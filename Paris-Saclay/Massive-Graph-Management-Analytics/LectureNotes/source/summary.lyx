#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage{footmisc}
\usepackage{listings}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{1,0.99,0.94}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,  
    frame=single,
    tabsize=2
}

\lstset{style=mystyle}
\end_preamble
\use_default_options true
\begin_modules
tcolorbox
customHeadersFooters
theorems-ams-bytype
theorems-sec-bytype
algorithm2e
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=blue, urlcolor=blue, citecolor=blue, pdfstartview={FitH}, unicode=true"
\papersize a4paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\boxbgcolor #62a0ea
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 3cm
\rightmargin 2cm
\bottommargin 3cm
\headheight 2cm
\headsep 1cm
\footskip 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
BDMA - Massive Graph Management and Analytics
\end_layout

\begin_layout Date
Fall 2023
\end_layout

\begin_layout Author
Jose Antonio Lorencio Abril
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename ../../../Decision-Modeling/LectureNotes/source/CS-logo.png
	scale 70

\end_inset


\end_layout

\begin_layout Standard
\align right
Professor: Nacéra Seghouani
\end_layout

\begin_layout Standard
\align right
Student e-mail: jose-antonio.lorencio-abril@student-cs.fr
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Address
This is a summary of the course 
\emph on
Massive Graph Management and Analytics
\emph default
 taught at the Université Paris Saclay - CentraleSupélec by Professor Nacéra
 Seghouani in the academic year 23/24.
 Most of the content of this document is adapted from the course notes by
 Seghouani, 
\begin_inset CommandInset citation
LatexCommand cite
key "Seghouani2023"
literal "false"

\end_inset

, so I won't be citing it all the time.
 Other references will be provided when used.
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Graph-structured data is at the heart of complex systems and plays a major
 role in our daily life, science and economy.
 Examples of this data are the cooperation between billions of individuals,
 or communication infraestructures with billions of cell phones, computers
 and satellites, the interactions between thousands of genes and metabolites
 within our cells, and so on.
\end_layout

\begin_layout Standard
Therefore, understanding its mathematical foundations, description, prediction,
 and eventually being able to control them is one of the major scientific
 challenges of the 21st century.
\end_layout

\begin_layout Section
Preliminaries
\end_layout

\begin_layout Subsection
Graph Theory Preliminaries
\end_layout

\begin_layout Standard
A graph is a pair 
\begin_inset Formula $G=\left(V,E\right)$
\end_inset

, where 
\begin_inset Formula $V$
\end_inset

 is the set of vertices and 
\begin_inset Formula $E\subset V\times V$
\end_inset

 is the set of edges.
 Usually, we denote 
\begin_inset Formula $\left|V\right|=n$
\end_inset

 and 
\begin_inset Formula $\left|E\right|=m$
\end_inset

.
\end_layout

\begin_layout Standard
There are different types of graphs:
\end_layout

\begin_layout Itemize

\series bold
Undirected
\series default
: 
\begin_inset Formula $\left(u,v\right)\in E\implies\left(v,u\right)\in E$
\end_inset

.
 That is, the edges goes in both directions.
\end_layout

\begin_layout Itemize

\series bold
Directed
\series default
: 
\begin_inset Formula $\left(u,v\right)\in E\not\implies\left(v,u\right)\in E$
\end_inset

.
 That is, the edges have direction, and it is possible that an edge goes
 from 
\begin_inset Formula $u$
\end_inset

 to 
\begin_inset Formula $v$
\end_inset

, but not the other way.
\end_layout

\begin_layout Itemize

\series bold
Weigthed vertices
\series default
: the vertices have a weight.
 That is, there is a function 
\begin_inset Formula $w_{v}:V\rightarrow\mathbb{R}$
\end_inset

.
\end_layout

\begin_layout Itemize

\series bold
Weigthed edges
\series default
: the edges have a weight.
 That is, there is a function 
\begin_inset Formula $w_{e}:E\rightarrow\mathbb{R}$
\end_inset

.
\end_layout

\begin_layout Itemize

\series bold
Labeled vertices
\series default
: the vertices have a label, 
\begin_inset Formula $L_{v}:V\rightarrow\mathcal{L}$
\end_inset

, where 
\begin_inset Formula $\mathcal{L}$
\end_inset

 is the set of labels.
\end_layout

\begin_layout Itemize

\series bold
Labeled edges
\series default
: the edges have a label, 
\begin_inset Formula $L_{e}:E\rightarrow\mathcal{L}$
\end_inset

.
\end_layout

\begin_layout Itemize

\series bold
Bipartite
\series default
: a graph 
\begin_inset Formula $G=\left(V,E\right)$
\end_inset

 is bipartite if there is a partition of the vertices, 
\begin_inset Formula $V=V_{1}\cup V_{2}$
\end_inset

, such that 
\begin_inset Formula $V_{1}\cap V_{2}=\emptyset$
\end_inset

 and 
\begin_inset Formula $E=\left\{ \left(v_{i},v_{j}\right)|v_{i}\in V_{1},v_{j}\in V_{j}\right\} $
\end_inset

.
 That is, the vertices in 
\begin_inset Formula $V_{1}$
\end_inset

 only connect to vertices in 
\begin_inset Formula $V_{2}$
\end_inset

, and viceversa.
\end_layout

\begin_layout Itemize

\series bold
\begin_inset Formula $k$
\end_inset

-Partite
\series default
: a graph 
\begin_inset Formula $G=\left(V,E\right)$
\end_inset

 is 
\begin_inset Formula $k$
\end_inset

-partite if there is a 
\begin_inset Formula $k$
\end_inset

-partition of the vertices, 
\begin_inset Formula $V=V_{1}\cup V_{2}\cup...\cup V_{k}$
\end_inset

, such that 
\begin_inset Formula $V_{i}\cap V_{j}=\emptyset,\forall i\neq j$
\end_inset

 and the is no edge 
\begin_inset Formula $e=\left(u,v\right)$
\end_inset

 such that 
\begin_inset Formula $u,v\in V_{i}$
\end_inset

, for the same 
\begin_inset Formula $i$
\end_inset

.
\end_layout

\begin_layout Itemize

\series bold
Multigraph 
\series default
or 
\series bold
multidigraph
\series default
: in this case, there can be several edges between two vertices.
 For this, we define the edges as a separate set 
\begin_inset Formula $E$
\end_inset

, and a function 
\begin_inset Formula $r:E\rightarrow V\times V$
\end_inset

, that assigns the vertices related by that edge.
\end_layout

\begin_layout Itemize

\series bold
Hypergraph
\series default
: in this case, 
\begin_inset Formula $E\subset2^{V}$
\end_inset

.
 That it, the edges can relate 0 or more vertices.
 In this case, it is more appropriate to interpret 
\begin_inset Formula $E$
\end_inset

 as a set of classes or hierarchies, rather than edges.
\end_layout

\begin_layout Itemize

\series bold
Complete
\series default
: a graph is complete if 
\begin_inset Formula $E=V\times V$
\end_inset

.
\end_layout

\begin_layout Standard
Some examples are:
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename pegado1.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
Continuing with definitions, let 
\begin_inset Formula $G=\left(V,E\right)$
\end_inset

 be a graph (directed or undirected).
 Let 
\begin_inset Formula $d_{i}^{+}$
\end_inset

 and 
\begin_inset Formula $d_{i}^{-}$
\end_inset

 denote the number of edges coming out and coming to 
\begin_inset Formula $v_{i}$
\end_inset

, respectively.
 The 
\series bold
degree
\series default
 of 
\begin_inset Formula $v_{i}$
\end_inset

 is
\begin_inset Formula 
\[
d_{i}=d_{i}^{+}+d_{i}^{-}.
\]

\end_inset

 Note that it counts double for undirected graphs.
\end_layout

\begin_layout Standard
Now, let 
\begin_inset Formula $N_{i}^{+}$
\end_inset

 and 
\begin_inset Formula $N_{i}^{-}$
\end_inset

 the set of successors and predecessors of 
\begin_inset Formula $v_{i}$
\end_inset

, respectively.
 Then, the set of 
\series bold
neighbors
\series default
 of 
\begin_inset Formula $v_{i}$
\end_inset

 is
\begin_inset Formula 
\[
N_{i}=N_{i}^{+}+N_{i}^{-}.
\]

\end_inset


\end_layout

\begin_layout Standard
A 
\series bold
path
\series default
 between two vertices, 
\begin_inset Formula $u,v\in V$
\end_inset

, denoted 
\begin_inset Formula $u\rightsquigarrow v$
\end_inset

, is a sequence of vertices 
\begin_inset Formula $\left(u=v_{0},v_{1},...,v_{k-1},v_{k}=v\right)$
\end_inset

, where 
\begin_inset Formula $\left(v_{i-1},v_{i}\right)\in E,\forall i=1,...,k$
\end_inset

.
 The length of a path, 
\begin_inset Formula $L\left(u\rightsquigarrow v\right)$
\end_inset

, is the number of edges in the cycle, that is, 
\begin_inset Formula $k$
\end_inset

.
\end_layout

\begin_layout Standard
A 
\series bold
cycle
\series default
 is a path from a vertex to itself, 
\begin_inset Formula $u\rightsquigarrow u$
\end_inset

.
\end_layout

\begin_layout Standard
The 
\series bold
distance
\series default
 between two nodes, 
\begin_inset Formula $d\left(u,v\right)$
\end_inset

, is the shortest path length between them:
\begin_inset Formula 
\[
d\left(u,v\right)=\min_{u\rightsquigarrow v}L\left(u\rightsquigarrow v\right).
\]

\end_inset


\end_layout

\begin_layout Standard
The 
\series bold
eccentricity
\series default
 of a node, 
\begin_inset Formula $ecc\left(u\right)$
\end_inset

, is the greatest distance between 
\begin_inset Formula $u$
\end_inset

 and any other vertex in the graph:
\begin_inset Formula 
\[
ecc\left(u\right)=\max_{v\in V}d\left(u,v\right).
\]

\end_inset


\end_layout

\begin_layout Standard
Note that this could be infinity if we cannot reach some node from 
\begin_inset Formula $u$
\end_inset

.
 Usually, we consider only reachable nodes, because this can give us information
 about the graph, but a value of infinity is not very informative.
\end_layout

\begin_layout Standard
The 
\series bold
diameter
\series default
 of a graph, 
\begin_inset Formula $diam\left(G\right)$
\end_inset

, is the greatest distance between two nodes in the graph:
\begin_inset Formula 
\[
diam\left(G\right)=\max_{u,v\in V}d\left(u,v\right)=\max_{u\in V}ecc\left(u\right).
\]

\end_inset

 The 
\series bold
radius
\series default
 of a graph, 
\begin_inset Formula $rad\left(G\right)$
\end_inset

, is the minimum eccentricity of any vertex in the graph:
\begin_inset Formula 
\[
rad\left(G\right)=\min_{u\in V}ecc\left(u\right).
\]

\end_inset


\end_layout

\begin_layout Standard
The 
\series bold
center
\series default
 of a graph, 
\begin_inset Formula $C\left(G\right)$
\end_inset

, is the set of all vertices of minimum eccentricity, i.e., the graph radius:
\begin_inset Formula 
\[
C\left(G\right)=\left\{ u:ecc\left(u\right)=rad\left(G\right)\right\} .
\]

\end_inset


\end_layout

\begin_layout Example
Compute the diameter, radius and center of the following graphs:
\end_layout

\begin_deeper
\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename pegado2.png
	scale 60

\end_inset


\end_layout

\end_deeper
\begin_layout Example
The solution is the following:
\end_layout

\begin_deeper
\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename graphs_examples.drawio (1).png
	scale 60

\end_inset


\end_layout

\end_deeper
\begin_layout Example
In each node, we show its eccentricity.
 The diameter is 6, the radius is 3 and the center is 
\begin_inset Formula $c$
\end_inset

 (in blue).
\end_layout

\begin_deeper
\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename pegado3.png
	scale 60

\end_inset


\end_layout

\end_deeper
\begin_layout Example
Solution:
\end_layout

\begin_deeper
\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename graphs_examples.drawio2.png
	scale 60

\end_inset


\end_layout

\end_deeper
\begin_layout Example
In this case, the diameter is 5, the radius is 3 and the center is 
\begin_inset Formula $\left\{ c,h\right\} $
\end_inset

.
\end_layout

\begin_layout Standard
A 
\series bold
partial graph
\series default
 of 
\begin_inset Formula $G=\left(V,E\right)$
\end_inset

 is a graph 
\begin_inset Formula $G'=\left(V,E'\right)$
\end_inset

, where 
\begin_inset Formula $E'\subset E$
\end_inset

.
\end_layout

\begin_layout Standard
A 
\series bold
subgraph
\series default
 of 
\begin_inset Formula $G=\left(V,E\right)$
\end_inset

 is a graph 
\begin_inset Formula $G'=\left(V',E'\right)$
\end_inset

 where 
\begin_inset Formula $V'\subset V$
\end_inset

 and 
\begin_inset Formula $E'\subset E$
\end_inset

.
 Note that partial graphs are also subgraphs.
\end_layout

\begin_layout Standard
A graph 
\begin_inset Formula $G=\left(V,E\right)$
\end_inset

 is said to be 
\series bold
connected
\series default
 if, and only if, 
\begin_inset Formula $\forall u,v\in V,\exists u\rightsquigarrow v$
\end_inset

.
\end_layout

\begin_layout Standard
A (strongly) 
\series bold
connected component
\series default
 of 
\begin_inset Formula $G=\left(V,E\right)$
\end_inset

 is a subgraph 
\begin_inset Formula $G_{cc}=\left(V_{cc},E_{cc}\right)$
\end_inset

, where 
\begin_inset Formula $\forall u,v\in V_{cc},\exists u\rightsquigarrow v\in V_{cc}$
\end_inset

.
 That it, a connected subgraph.
 It is called strongly when the paths are directed.
\end_layout

\begin_layout Standard
A graph 
\begin_inset Formula $G=\left(V,E\right)$
\end_inset

 is a 
\series bold
tree
\series default
 if, and only if, 
\begin_inset Formula $G$
\end_inset

 is a connected graph without cycles.
 In this case, the graph has 
\begin_inset Formula $m=n-1$
\end_inset

 edges.
\end_layout

\begin_layout Standard
A graph 
\begin_inset Formula $G=\left(V,E\right)$
\end_inset

 is a 
\series bold
forest
\series default
 if, and only if, all connected components of 
\begin_inset Formula $G$
\end_inset

 are trees.
\end_layout

\begin_layout Subsubsection
Breadth First Search (BFS)
\end_layout

\begin_layout Standard
BFS is a method to traverse the nodes of a graph, by starting at one node
 and traversing all its neighbours.
 Then, all neighbours of its neighbours, and so on.
\end_layout

\begin_layout Standard
For this, we use a FIFO queue.
 The algorithm is:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Python,morekeywords={end, do, procedure, <-}"
inline false
status open

\begin_layout Plain Layout

procedure BFS(G=(V,E), r)
\end_layout

\begin_layout Plain Layout

	Q <- emptyset
\end_layout

\begin_layout Plain Layout

	enqueue(Q,r)
\end_layout

\begin_layout Plain Layout

	r.label = True
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	while Q is not empty do
\end_layout

\begin_layout Plain Layout

		v <- dequeue(Q)
\end_layout

\begin_layout Plain Layout

		for neig in neighbours(v) do
\end_layout

\begin_layout Plain Layout

			if not neig.label then
\end_layout

\begin_layout Plain Layout

				enqueue(Q,neig)
\end_layout

\begin_layout Plain Layout

				neig.label = True
\end_layout

\begin_layout Plain Layout

			end if
\end_layout

\begin_layout Plain Layout

		end for
\end_layout

\begin_layout Plain Layout

	end while
\end_layout

\begin_layout Plain Layout

end procedure
\end_layout

\end_inset


\end_layout

\begin_layout Example
Apply BFS in the following graph, starting at node A.
\end_layout

\begin_deeper
\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename bfs_1.png
	scale 60

\end_inset


\end_layout

\end_deeper
\begin_layout Example
Q=[A].
 We visit A's neighbours:
\end_layout

\begin_deeper
\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename bfs_2.png
	scale 60

\end_inset


\end_layout

\end_deeper
\begin_layout Example
Q=[F,G].
 Now, by lexycographical order, we visit F's neighbours:
\end_layout

\begin_deeper
\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename bfs_3.png
	scale 60

\end_inset


\end_layout

\end_deeper
\begin_layout Example
Q=[G,B,E].
 Now, we visit G's neighbours.
 Since it has no new unvisited neighbours, there is no change.
\end_layout

\begin_layout Example
Q=[B,E].
 Now, we visit B's neighbours:
\end_layout

\begin_deeper
\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename bfs_4.png

\end_inset


\end_layout

\end_deeper
\begin_layout Example
Q=[E,C].
 Now, we visit E's neighbours:
\end_layout

\begin_deeper
\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename bfs_5.png
	scale 60

\end_inset


\end_layout

\end_deeper
\begin_layout Example
Q=[C,D].
 Everything is visited, so the queue will be slowly emptied!
\end_layout

\begin_layout Subsubsection
Depth First Search (DFS)
\end_layout

\begin_layout Standard
In the case of DFS, the objective is also to traverse the whole graph.
 The difference is that in this case we try to go as deep as we can in the
 graph before visiting more neighbours.
\end_layout

\begin_layout Standard
It can be implemented with a stack, let it be a explicit stack, or an implicit
 one.
\end_layout

\begin_layout Standard
The implementation with an explicit stack is the following:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Python,morekeywords={end, do, procedure, <-}"
inline false
status open

\begin_layout Plain Layout

procedure DFS(G=(V,E),r)
\end_layout

\begin_layout Plain Layout

	S <- emptyset
\end_layout

\begin_layout Plain Layout

	push(S,r)
\end_layout

\begin_layout Plain Layout

	while S is not empty do
\end_layout

\begin_layout Plain Layout

		v <- pop(S)
\end_layout

\begin_layout Plain Layout

		if not v.label then
\end_layout

\begin_layout Plain Layout

			v.label = true
\end_layout

\begin_layout Plain Layout

			for neig in neighbours(v) do
\end_layout

\begin_layout Plain Layout

				push(S, neig)
\end_layout

\begin_layout Plain Layout

			end for
\end_layout

\begin_layout Plain Layout

		end if
\end_layout

\begin_layout Plain Layout

	end while	
\end_layout

\begin_layout Plain Layout

end procedure
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The implementation with an implicit stack is recursive, and is as follows:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Python,morekeywords={end, do, procedure, <-}"
inline false
status open

\begin_layout Plain Layout

procedure BFS(G=(V,E), r)
\end_layout

\begin_layout Plain Layout

	Q <- emptyset
\end_layout

\begin_layout Plain Layout

	enqueue(Q,r)
\end_layout

\begin_layout Plain Layout

	r.label = True
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	while Q is not empty do
\end_layout

\begin_layout Plain Layout

		v <- dequeue(Q)
\end_layout

\begin_layout Plain Layout

		for neig in neighbours(v) do
\end_layout

\begin_layout Plain Layout

			if not neig.label then
\end_layout

\begin_layout Plain Layout

				enqueue(Q,neig)
\end_layout

\begin_layout Plain Layout

				neig.label = True
\end_layout

\begin_layout Plain Layout

			end if
\end_layout

\begin_layout Plain Layout

		end for
\end_layout

\begin_layout Plain Layout

	end whileDFS*(G=(V,E), r)
\end_layout

\begin_layout Plain Layout

	r.label = true
\end_layout

\begin_layout Plain Layout

	for neig in neighbours(r) do
\end_layout

\begin_layout Plain Layout

		if not neig.label then
\end_layout

\begin_layout Plain Layout

			DFS*(G, neig)
\end_layout

\begin_layout Plain Layout

		end if
\end_layout

\begin_layout Plain Layout

	end for
\end_layout

\begin_layout Plain Layout

end procedure
\end_layout

\end_inset


\end_layout

\begin_layout Example
Let's repeat the example, now using DFS:
\end_layout

\begin_deeper
\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename bfs_1.png
	scale 60

\end_inset


\begin_inset Graphics
	filename dfs_1.png
	scale 60

\end_inset


\begin_inset Graphics
	filename dfs_2.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename dfs_3.png
	scale 60

\end_inset


\begin_inset Graphics
	filename dfs_4.png
	scale 60

\end_inset


\begin_inset Graphics
	filename dfs_5.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename dfs_6.png
	scale 60

\end_inset


\end_layout

\end_deeper
\begin_layout Subsubsection
Greaph Representations
\end_layout

\begin_layout Standard
A graph, 
\begin_inset Formula $G=\left(V,E\right)$
\end_inset

, with 
\begin_inset Formula $n$
\end_inset

 vertices and 
\begin_inset Formula $m$
\end_inset

 edges can be encoded using different structures:
\end_layout

\begin_layout Itemize

\series bold
Adjacency matrix
\series default
: a matrix 
\begin_inset Formula $A\in\mathcal{M}_{n\times n}$
\end_inset

, defined by
\begin_inset Formula 
\[
A_{ij}=\begin{cases}
1 & if,\ \left(v_{i},v_{j}\right)\in E\\
0 & otherwise
\end{cases}.
\]

\end_inset

 The adjacency matrix is symmetric for undirected graphs.
\end_layout

\begin_layout Itemize

\series bold
Adjacency list
\series default
: a list 
\begin_inset Formula $L$
\end_inset

 of length 
\begin_inset Formula $n$
\end_inset

 in which each vertex holds a list of its neighbours:
\begin_inset Formula 
\[
\forall u\in V,L_{u}=\left\{ v|\left(u,v\right)\in E\right\} .
\]

\end_inset

 If 
\begin_inset Formula $G$
\end_inset

 is directed, the choice of the direction depends on the analytic needs.
\end_layout

\begin_layout Itemize

\series bold
Incidence matrix
\series default
: a matrix 
\begin_inset Formula $B\in\mathcal{M}_{n\times m}$
\end_inset

, defined by
\begin_inset Formula 
\[
B_{ij}=\begin{cases}
1 & if\ e_{j}=\left(v_{i},v_{k}\right)\in E\\
0 & otherwise
\end{cases}.
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Exercises
\end_layout

\begin_layout Enumerate
Using graph traversal algorithms, propose an algorithm that computes the
 number of edges between a given vertex and all other vertices.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=Python,morekeywords={end, do, procedure, <-}"
inline false
status open

\begin_layout Plain Layout

procedure n_edges(G=(V,E), r)
\end_layout

\begin_layout Plain Layout

	Q <- emptyset
\end_layout

\begin_layout Plain Layout

	enqueue(Q,r)
\end_layout

\begin_layout Plain Layout

	r.n_edges = 0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	while Q is not empty do
\end_layout

\begin_layout Plain Layout

		v <- dequeue(Q)
\end_layout

\begin_layout Plain Layout

		for neig in neighbours(v) do
\end_layout

\begin_layout Plain Layout

			if not neig.n_edges then
\end_layout

\begin_layout Plain Layout

				enqueue(Q,neig)
\end_layout

\begin_layout Plain Layout

				neig.n_edges = v.n_edges + 1
\end_layout

\begin_layout Plain Layout

			end if
\end_layout

\begin_layout Plain Layout

		end for
\end_layout

\begin_layout Plain Layout

	end while	
\end_layout

\begin_layout Plain Layout

end procedure
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Given the following cycles with even and odd lengths (with the distances
 or depths from the grey vertex), what do you think about the case of graphs
 with an odd cycle (in number of edges)? Is this a characteristic property?
 State the general case.
\end_layout

\begin_deeper
\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename pegado4.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard

\series bold
Proposition
\series default
: a graph contains a cycle 
\begin_inset Formula $C$
\end_inset

 with an odd number of edges if, and only if, 
\begin_inset Formula $\exists\left(x,y\right)\in E|depth\left(x\right)=depth\left(y\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\emph on
Proof
\emph default
: first, we know that all edges connect vertices of 'neighbouring' depths.
 That it, 
\begin_inset Formula $\forall\left(x,y\right)\in E,$
\end_inset

 it holds 
\begin_inset Formula $\left|depth\left(x\right)-depth\left(y\right)\right|\leq1$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $\left[\implies\right]$
\end_inset

 By reduction ad absurdum, seeking a contradiction, suppose that 
\begin_inset Formula $\forall\left(x,y\right)\in C$
\end_inset

, with 
\begin_inset Formula $depth\left(x\right)\neq depth\left(y\right)$
\end_inset

.
 This means that 
\begin_inset Formula $depth\left(x\right)=depth\left(y\right)\pm1$
\end_inset

.
 Therefore, there is, along the cycle, a node of even depth, followed by
 a node of odd lenght, and so on.
 When we close the cycle, the final node is the inicial one, so its depth
 is 0 (even).
 Therefore, we need an even number of edges, to conserve the parity.
\end_layout

\begin_layout Standard
\begin_inset Formula $\left[\impliedby\right]$
\end_inset

 If there is an edge 
\begin_inset Formula $\left(x,y\right)\in E$
\end_inset

 with 
\begin_inset Formula $depth\left(x\right)=depth\left(y\right)$
\end_inset

, then we can consider the path tree that was used to annotate the depths.
 In this tree, 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 have a first ancestor 
\begin_inset Formula $z$
\end_inset

 in common, from which we can form an odd cycle of size 
\begin_inset Formula $2\cdot\left(depth\left(x\right)-depth\left(z\right)\right)+1$
\end_inset

 by adding the edge 
\begin_inset Formula $\left(x,y\right)$
\end_inset

 to this subtree starting at 
\begin_inset Formula $z$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
Propose an algorithm that determines if a graph contains an odd cycle.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=Python,morekeywords={end, do, procedure, <-}"
inline false
status open

\begin_layout Plain Layout

procedure hasOddCycle(G=(V,E))
\end_layout

\begin_layout Plain Layout

	v <- a vertex from V
\end_layout

\begin_layout Plain Layout

	depths <- n_edges(G,v) #from the first exercise
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	for (u,v) in E do
\end_layout

\begin_layout Plain Layout

		if depth[u] == depth[v] then
\end_layout

\begin_layout Plain Layout

			return True
\end_layout

\begin_layout Plain Layout

		end if
\end_layout

\begin_layout Plain Layout

	end for	
\end_layout

\begin_layout Plain Layout

end procedure
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
In a bipartite graph, can there be a cycle with an odd number of edges?
 Is this a characteristic property?
\end_layout

\begin_deeper
\begin_layout Standard
No, it is not possible!
\end_layout

\begin_layout Standard

\series bold
Proposition
\series default
: A graph is bipartite if, and only if, all cycles are of even size.
\end_layout

\begin_layout Standard
\begin_inset Formula $\left[\implies\right]$
\end_inset

 If the graph is bipartite, any path alternates between each vertex of each
 partition to create a cycle ending by the initial vertex.
 Therefore, all cycles must be of even size.
\end_layout

\begin_layout Standard
\begin_inset Formula $\left[\impliedby\right]$
\end_inset

 Consider the partition of vertices with even depth 
\begin_inset Formula $V_{1}$
\end_inset

, and the partition of vertices with odd depth 
\begin_inset Formula $V_{2}$
\end_inset

.
 
\end_layout

\begin_layout Standard
Since there is no odd cycle, then, from question 2, we know that 
\begin_inset Formula $\forall\left(u,v\right)\in E$
\end_inset

 it is 
\begin_inset Formula $depth\left(u\right)=depth\left(v\right)\pm1$
\end_inset

.
 Therefore, the graph is bipartite.
\end_layout

\end_deeper
\begin_layout Enumerate
Propose an algorithm that allows to determine if a graph is bipartite.
 Test your algorithm in the following graph.
 Is it bipartite? Justify your answer.
\end_layout

\begin_deeper
\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename pegado5.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
The algorithm is the same as in exercise 3, because of exercise 4.
\end_layout

\begin_layout Standard
The proposed graph is clearly not bipartite, because there are several odd
 cycles.
\end_layout

\end_deeper
\begin_layout Enumerate
Graph coloring is a way of coloring the vertices of a graph in such a way
 that no two adjacent vertices share the same color.
 A 2-colorable graph is a graph that can be colored with only 2 colors.
\end_layout

\begin_deeper
\begin_layout Enumerate
What is the link with the previous exercise? Justify your answer.
\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Proposition
\series default
: a graph is 2-colorable if, and only if, it is bipartite.
\end_layout

\begin_layout Standard

\emph on
Proof
\emph default
: 
\begin_inset Formula $\left[\implies\right]$
\end_inset

 If it is 2-colorable, with colors red and blue.
 Then we take 
\begin_inset Formula $V_{1}=\left\{ u|color\left(u\right)=blue\right\} $
\end_inset

 and 
\begin_inset Formula $V_{2}=\left\{ u|color\left(u\right)=red\right\} $
\end_inset

.
 
\begin_inset Formula $G$
\end_inset

 is clearly bipartite with this partition.
\end_layout

\begin_layout Standard
\begin_inset Formula $\left[\impliedby\right]$
\end_inset

 If it is bipartite, with partition 
\begin_inset Formula $V_{1}$
\end_inset

 and 
\begin_inset Formula $V_{2}$
\end_inset

, then we can color all nodes in 
\begin_inset Formula $V_{1}$
\end_inset

 in blue, and all nodes in 
\begin_inset Formula $V_{2}$
\end_inset

 in red.
 The graph is 2-colorable.
\end_layout

\end_deeper
\begin_layout Enumerate
We want to write an algorithm, inspired by DFS search, which takes as input
 a graph, 
\begin_inset Formula $G=\left(V,E\right)$
\end_inset

, and which returns a pair 
\begin_inset Formula $\left(result,color\right)$
\end_inset

 where 
\begin_inset Formula $result$
\end_inset

 is True if the graph is colorable, False otherwise, and 
\begin_inset Formula $color$
\end_inset

 is a dictionary associating a color 0 or 1 to each vertex.
 This algorithm should stop as soon as possible when the graph is not 2-colorabl
e.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=Python,morekeywords={end, do, procedure, <-}"
inline false
status open

\begin_layout Plain Layout

procedure coloring(G=(V,E), r)
\end_layout

\begin_layout Plain Layout

	color <- {r: 0}
\end_layout

\begin_layout Plain Layout

	stack <- emptyset
\end_layout

\begin_layout Plain Layout

	push(stack, r)
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	while stack is not empty do
\end_layout

\begin_layout Plain Layout

		v <- pop(stack)
\end_layout

\begin_layout Plain Layout

		for neig in neighbours(v) do
\end_layout

\begin_layout Plain Layout

			if neigh is not in color.keys then
\end_layout

\begin_layout Plain Layout

				push(stack, neigh)
\end_layout

\begin_layout Plain Layout

				color[neig] = 1 - color[v]
\end_layout

\begin_layout Plain Layout

			elif color[neig] = color[v] then
\end_layout

\begin_layout Plain Layout

				return False, color
\end_layout

\begin_layout Plain Layout

			end if
\end_layout

\begin_layout Plain Layout

		end for
\end_layout

\begin_layout Plain Layout

	end while
\end_layout

\begin_layout Plain Layout

	return True, color
\end_layout

\begin_layout Plain Layout

end procedure
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
Compute the shortest path in the following graph using Dijkstra's algorithm,
 starting at A:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=Python,morekeywords={end, do, procedure, <-}"
inline false
status open

\begin_layout Plain Layout

procedure dijkstra(G=(V,E), r)
\end_layout

\begin_layout Plain Layout

	dist <- {r:0}
\end_layout

\begin_layout Plain Layout

	P <- emptyset
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	for v in V-{r} do
\end_layout

\begin_layout Plain Layout

		dist[v] = infinity
\end_layout

\begin_layout Plain Layout

	end for
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	while V-P is not empty do
\end_layout

\begin_layout Plain Layout

		w <- select(v in V-P and dist[v]=min_u dist[u])
\end_layout

\begin_layout Plain Layout

		P <- P union {w}
\end_layout

\begin_layout Plain Layout

		for neig in neighbours(w)-P do
\end_layout

\begin_layout Plain Layout

			if dist[w]+weight(neig,w) < dist[neig] then
\end_layout

\begin_layout Plain Layout

				dist[neig] <- dist[w]+wight(neig,w)
\end_layout

\begin_layout Plain Layout

			end if
\end_layout

\begin_layout Plain Layout

		end for
\end_layout

\begin_layout Plain Layout

	end while	
\end_layout

\begin_layout Plain Layout

end procedure
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename dijkstra_1.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
We start with: dist = 
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="7">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
D
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
F
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
G
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\infty$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\infty$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\infty$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\infty$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\infty$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\infty$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset

, and 
\begin_inset Formula $P=\emptyset$
\end_inset

.
\end_layout

\begin_layout Standard
Now, 
\begin_inset Formula $w=A$
\end_inset

 and 
\begin_inset Formula $P=\left\{ A\right\} $
\end_inset

.
 We update dist = 
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="7">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
D
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
F
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
G
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\infty$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\infty$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\infty$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\infty$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset

.
\end_layout

\begin_layout Standard
Now, 
\begin_inset Formula $w=G$
\end_inset

 and 
\begin_inset Formula $P=\left\{ A,G\right\} $
\end_inset

.
 We update dist = 
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="7">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
D
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
F
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
G
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\infty$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\infty$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\infty$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset

.
\end_layout

\begin_layout Standard
Now, 
\begin_inset Formula $w=F$
\end_inset

 and 
\begin_inset Formula $P=\left\{ A,F,G\right\} $
\end_inset

.
 We update dist = 
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="7">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
D
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
F
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
G
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\infty$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\infty$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset

.
\end_layout

\begin_layout Standard
Now, 
\begin_inset Formula $w=E$
\end_inset

 and 
\begin_inset Formula $P=\left\{ A,E,F,G\right\} $
\end_inset

.
 We update dist = 
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="7">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
D
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
F
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
G
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset

.
\end_layout

\begin_layout Standard
Now, 
\begin_inset Formula $w=C$
\end_inset

 and 
\begin_inset Formula $P=\left\{ A,C,E,F,G\right\} $
\end_inset

.
 We update dist = 
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="7">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
D
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
F
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
G
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset

.
\end_layout

\begin_layout Standard
Now, 
\begin_inset Formula $w=B$
\end_inset

 and 
\begin_inset Formula $P=\left\{ A,B,C,E,F,G\right\} $
\end_inset

.
 dist does not change.
\end_layout

\begin_layout Standard
Finally, 
\begin_inset Formula $w=D$
\end_inset

 and 
\begin_inset Formula $P=\left\{ A,B,C,D,E,F,G\right\} $
\end_inset

.
 dist does not change.
\end_layout

\end_deeper
\begin_layout Enumerate
Given the following graphs:
\end_layout

\begin_deeper
\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename pegado7.png
	scale 60

\end_inset


\end_layout

\begin_layout Enumerate
Give the different representations of these graphs.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula $A_{1}=\begin{array}{cc}
 & \begin{array}{cccccc}
0 & 1 & 2 & 3 & 4 & 5\end{array}\\
\begin{array}{c}
0\\
1\\
2\\
3\\
4\\
5
\end{array} & \left(\begin{array}{cccccc}
0 & 1 & 0 & 0 & 1 & 1\\
1 & 0 & 1 & 1 & 0 & 1\\
0 & 1 & 0 & 1 & 0 & 1\\
0 & 1 & 1 & 0 & 0 & 1\\
1 & 0 & 0 & 0 & 0 & 1\\
1 & 1 & 1 & 1 & 1 & 0
\end{array}\right)
\end{array},$
\end_inset


\begin_inset Formula $L_{1}=\begin{array}{c}
0:\left\{ 1,4,5\right\} \\
1:\left\{ 0,2,3,5\right\} \\
2:\left\{ 1,3,5\right\} \\
3:\left\{ 1,2,5\right\} \\
4:\left\{ 0,5\right\} \\
5:\left\{ 0,1,2,3,4\right\} 
\end{array}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $B_{1}=\begin{array}{cc}
 & \begin{array}{cccccccccc}
01 & 04 & 05 & 12 & 13 & 15 & 23 & 25 & 35 & 45\end{array}\\
\begin{array}{c}
0\\
1\\
2\\
3\\
4\\
5
\end{array} & \left(\begin{array}{cccccccccc}
1 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
1 & 0 & 0 & 1 & 1 & 1 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 1 & 0 & 0 & 1 & 1 & 0 & 0\\
0 & 0 & 0 & 0 & 1 & 0 & 1 & 0 & 1 & 0\\
0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1\\
0 & 0 & 1 & 0 & 0 & 1 & 0 & 1 & 1 & 1
\end{array}\right)
\end{array}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $A_{2}=\begin{array}{cc}
 & \begin{array}{cccccc}
0 & 1 & 2 & 3 & 4 & 5\end{array}\\
\begin{array}{c}
0\\
1\\
2\\
3\\
4\\
5
\end{array} & \left(\begin{array}{cccccc}
0 & 1 & 0 & 0 & 1 & 0\\
0 & 0 & 0 & 0 & 0 & 1\\
0 & 0 & 0 & 1 & 0 & 1\\
0 & 0 & 0 & 1 & 0 & 0\\
1 & 1 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 1 & 0
\end{array}\right)
\end{array}$
\end_inset

, 
\begin_inset Formula $L_{2}=\begin{array}{c}
0:\left\{ 1,4\right\} \\
1:\left\{ 5\right\} \\
2:\left\{ 3,5\right\} \\
3:\left\{ 3\right\} \\
4:\left\{ 0,1\right\} \\
5:\left\{ 4\right\} 
\end{array}$
\end_inset

,
\end_layout

\begin_layout Standard
\begin_inset Formula $B_{1}=\begin{array}{cc}
 & \begin{array}{ccccccccc}
01 & 04 & 15 & 23 & 25 & 33 & 40 & 41 & 54\end{array}\\
\begin{array}{c}
0\\
1\\
2\\
3\\
4\\
5
\end{array} & \left(\begin{array}{ccccccccc}
1 & 1 & 0 & 0 & 0 & 0 & 2 & 0 & 0\\
2 & 0 & 1 & 0 & 0 & 0 & 0 & 2 & 0\\
0 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 2 & 0 & 3 & 0 & 0 & 0\\
0 & 2 & 0 & 0 & 0 & 0 & 1 & 1 & 2\\
0 & 0 & 2 & 0 & 2 & 0 & 0 & 0 & 1
\end{array}\right)
\end{array}$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Compute 
\begin_inset Formula $A^{2},A^{3}$
\end_inset

.
 What does 
\begin_inset Formula $A_{ij}^{r}$
\end_inset

 represents?
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula $A_{ij}^{r}$
\end_inset

 represents the number of paths of length 
\begin_inset Formula $r$
\end_inset

 from node 
\begin_inset Formula $i$
\end_inset

 to node 
\begin_inset Formula $j$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
What is the complexity of 
\begin_inset Formula $A^{r}$
\end_inset

? Is it possible to reduce it?
\end_layout

\begin_deeper
\begin_layout Standard
Computing 
\begin_inset Formula $A^{r}$
\end_inset

 is 
\begin_inset Formula $O\left(rn^{3}\right)$
\end_inset

, since it requires 
\begin_inset Formula $r$
\end_inset

 products of complexity 
\begin_inset Formula $O\left(n^{3}\right)$
\end_inset

.
\end_layout

\begin_layout Standard
However, we can reuse some results to reduce the complexity:
\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $r$
\end_inset

 is even, we can do 
\begin_inset Formula $A^{r}=\left(A^{\frac{r}{2}}\right)^{2}.$
\end_inset


\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $r$
\end_inset

 is odd, we can do 
\begin_inset Formula $A^{r}=A\left(A^{\frac{r-1}{2}}\right)^{2}$
\end_inset

.
\end_layout

\begin_layout Standard
Therefore, we can obtain 
\begin_inset Formula $A^{r}$
\end_inset

 in 
\begin_inset Formula $O\left(\log r\cdot n^{3}\right)$
\end_inset

.
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsection
Linear Algebra Preliminaries
\end_layout

\begin_layout Standard
A 
\series bold
norm
\series default
 is a function 
\begin_inset Formula $f$
\end_inset

 that measures the size of a vector.
 It must satisfy the following properties:
\end_layout

\begin_layout Itemize
\begin_inset Formula $f\left(x\right)=0\iff x=0$
\end_inset

.
\end_layout

\begin_layout Itemize
Linear on scale factors: 
\begin_inset Formula 
\[
f\left(\alpha x\right)=\left|\alpha\right|f\left(x\right),\forall\alpha\in\mathbb{R}.
\]

\end_inset


\end_layout

\begin_layout Itemize
Triangle inequality:
\begin_inset Formula 
\[
f\left(x+y\right)\leq f\left(x\right)+f\left(y\right).
\]

\end_inset


\end_layout

\begin_layout Standard
A widely use family of norms are the 
\begin_inset Formula $p$
\end_inset

-norms:
\begin_inset Formula 
\[
\left\Vert x\right\Vert _{p}=\sqrt[p]{\sum_{i}\left|x_{i}\right|^{p}},
\]

\end_inset

 with the most common one being the Euclidean norm, for 
\begin_inset Formula $p=2$
\end_inset

:
\begin_inset Formula 
\[
\left\Vert x\right\Vert =\sqrt{\sum_{i}x_{i}^{2}}.
\]

\end_inset


\end_layout

\begin_layout Standard
The 
\series bold
determinant
\series default
 of a square matrix is equal to the hypervolume of the parallelotope defined
 by the vectors of the matrix.
 It is 0 if, and only if, the set of vectors is colinear.
\end_layout

\begin_layout Standard
The determinant can be used for many things:
\end_layout

\begin_layout Itemize
We can represents linear systems with matrices as 
\begin_inset Formula $Y=AX$
\end_inset

, and there are many methods to solve this efficiently.
\end_layout

\begin_layout Itemize
With the determinant we can compute the 
\series bold
characteristic polynomial
\series default
 of 
\begin_inset Formula $A$
\end_inset

, whose roots are the eigenvalues of 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\begin_layout Standard
Some properties of the determinant are:
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left|I\right|=1$
\end_inset

, where 
\begin_inset Formula $I$
\end_inset

 is the identity matrix.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left|A\right|=0$
\end_inset

 if 
\begin_inset Formula $A$
\end_inset

 is singular (not invertible).
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left|AB\right|=\left|A\right|\left|B\right|$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left|A^{T}\right|=\left|A\right|$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left|cA\right|=c^{n}\left|A\right|$
\end_inset

, where 
\begin_inset Formula $n$
\end_inset

 is the dimension of 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\begin_layout Standard
A square matrix, 
\begin_inset Formula $A$
\end_inset

, is 
\series bold
invertible
\series default
 (non-singular, non-degenerate), with inverse denoetd 
\begin_inset Formula $A^{-1}$
\end_inset

, if 
\begin_inset Formula $\exists B$
\end_inset

 such that
\begin_inset Formula 
\[
AB=BA=I,
\]

\end_inset

 in this case, 
\begin_inset Formula $A^{-1}=B$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Proposition
For a square matrix, A, the following properties are equivalent:
\end_layout

\begin_deeper
\begin_layout Itemize
A is invertible.
\end_layout

\begin_layout Itemize
All vectors in A are linearly independent.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left|A\right|\neq0$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $A^{T}$
\end_inset

 is invertible.
\end_layout

\begin_layout Itemize
0 is not an eigenvalue of 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Standard
Properties of the inverse:
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(A^{-1}\right)^{-1}=A$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(A^{T}\right)^{-1}=\left(A^{-1}\right)^{T}$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(AB\right)^{-1}=B^{-1}A^{-1}$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(cA\right)^{-1}=\frac{1}{c}A^{-1}$
\end_inset

 for 
\begin_inset Formula $c\neq0.$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left|A^{-1}\right|=\frac{1}{\left|A\right|}$
\end_inset

.
\end_layout

\begin_layout Standard
An 
\series bold
eigenvector
\series default
 or characteristic vector of a linear transformation, 
\begin_inset Formula $T$
\end_inset

, is a non-zero vector that changes by a escalar factor, 
\begin_inset Formula $\lambda$
\end_inset

, when transformed by 
\begin_inset Formula $T$
\end_inset

.
 That is, 
\begin_inset Formula $v$
\end_inset

 is an eigenvector of the linear transformation 
\begin_inset Formula $T$
\end_inset

 if
\begin_inset Formula 
\[
T\left(v\right)=\lambda v.
\]

\end_inset

 There is a direct correspondence between 
\begin_inset Formula $n\times n$
\end_inset

 matrices and linear transformation in the 
\begin_inset Formula $n$
\end_inset

-dimenstional vector space into itself.
 That is, every linear transformation 
\begin_inset Formula $T$
\end_inset

 can be represented as a matrix 
\begin_inset Formula $A_{T}$
\end_inset

 (the matrix depends on the chosen base).
 Therefore, we can say that 
\begin_inset Formula $A_{T}$
\end_inset

 has an eigenvector 
\begin_inset Formula $v$
\end_inset

 if
\begin_inset Formula 
\[
A_{T}v=\lambda v.
\]

\end_inset


\end_layout

\begin_layout Standard
The scale factors of the eigenvectors are called 
\series bold
eigenvalues
\series default
.
\end_layout

\begin_layout Standard
We can find the eigenvalues by solving a polynomial function on 
\begin_inset Formula $\lambda$
\end_inset

 called the 
\series bold
characteristic polynomial
\series default
 of 
\begin_inset Formula $A_{T}$
\end_inset

:
\begin_inset Formula 
\[
\left(A-\lambda I\right)v=0.
\]

\end_inset

 Now, this equation has non-zero solution if, and only if, 
\begin_inset Formula 
\[
\left|A-\lambda I\right|=0.
\]

\end_inset

 Therefore, we can compute 
\begin_inset Formula $\left|A-\lambda I\right|$
\end_inset

 and find all values of 
\begin_inset Formula $\lambda$
\end_inset

 that makes it equal to 0.
\end_layout

\begin_layout Standard
Once we have the eigenvalues, we can use them to find the corresponding
 eigenvectors.
\end_layout

\begin_layout Example
Compute the eigenvalues and eigenvectors of 
\begin_inset Formula $A=\left(\begin{array}{cc}
2 & 1\\
1 & 2
\end{array}\right)$
\end_inset

.
\end_layout

\begin_layout Example
\begin_inset Formula 
\[
\left|A-\lambda I\right|=\left|\begin{array}{cc}
2-\lambda & 1\\
1 & 2-\lambda
\end{array}\right|=\left(2-\lambda\right)^{2}-1=\lambda^{2}-4\lambda+3.
\]

\end_inset

 This has as solutions
\begin_inset Formula 
\[
\lambda=\frac{4\pm\sqrt{16-12}}{2}=\frac{4\pm2}{2}=2\pm1.
\]

\end_inset

 Therefore, we have 
\begin_inset Formula $\lambda_{1}=1,\lambda_{2}=3$
\end_inset

.
\end_layout

\begin_layout Example
To find the eigenvectors, we solve
\begin_inset Formula 
\[
Av=\lambda v\iff\begin{cases}
2x+y & =\lambda x\\
x+2y & =\lambda y
\end{cases}.
\]

\end_inset

 For 
\begin_inset Formula $\lambda_{1}=1$
\end_inset

, it is
\begin_inset Formula 
\[
\begin{cases}
2x+y & =x\\
x+2y & =y
\end{cases}\iff x=-y,
\]

\end_inset

 so the eigenvector associated to 
\begin_inset Formula $\lambda_{1}=1$
\end_inset

 is
\begin_inset Formula 
\[
v_{\lambda_{1}}=\left(\begin{array}{c}
t\\
-t
\end{array}\right).
\]

\end_inset


\end_layout

\begin_layout Example
For 
\begin_inset Formula $\lambda_{2}=3$
\end_inset

, it is
\begin_inset Formula 
\[
\begin{cases}
2x+y & =3x\\
x+2y & =3y
\end{cases}\iff x=y,
\]

\end_inset

 so the eigenvector associated to 
\begin_inset Formula $\lambda_{2}=3$
\end_inset

 is
\begin_inset Formula 
\[
v_{\lambda_{2}}=\left(\begin{array}{c}
t\\
t
\end{array}\right).
\]

\end_inset

 
\end_layout

\begin_layout Standard
We call the 
\series bold
algebraic multiplicity
\series default
, 
\begin_inset Formula $t_{i}$
\end_inset

, of the eigenvalue 
\begin_inset Formula $\lambda_{i}$
\end_inset

 to its multiplicity as root of the characteristic polynomial:
\begin_inset Formula 
\[
P\left(A\right)=\left|A-\lambda I\right|=\left(\lambda-\lambda_{1}\right)^{t_{1}}\left(\lambda-\lambda_{2}\right)^{t_{2}}\cdot...\cdot\left(\lambda-\lambda_{k}\right)^{t_{k}}.
\]

\end_inset

 Note that 
\begin_inset Formula $A$
\end_inset

 can have at most 
\begin_inset Formula $n$
\end_inset

 distinct eigenvalues, although some of them may be complex.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Proposition
If the eigenvalues of A are all different, then the corresponding eigenvectors
 are linearly independent.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\series bold
eigenspace
\series default
 of an eigenvalue, 
\begin_inset Formula $\lambda$
\end_inset

, is the spave generated by the eigenvectors associated to 
\begin_inset Formula $\lambda$
\end_inset

.
\end_layout

\begin_layout Standard
The dimension of the eigenspace of 
\begin_inset Formula $\lambda$
\end_inset

 is the 
\series bold
geometric multiplicity
\series default
 of 
\begin_inset Formula $\lambda$
\end_inset

.
 The geometric multiplicity of an eigenvalue is, at most, its algebraic
 multiplicity.
\end_layout

\begin_layout Example
Let's get some eigenspaces:
\end_layout

\begin_layout Example
\begin_inset Formula $A=\left(\begin{array}{ccc}
-1 & 1 & 0\\
-4 & 3 & 0\\
1 & 0 & 2
\end{array}\right),$
\end_inset

 so 
\begin_inset Formula 
\begin{align*}
\left|A-\lambda I\right|= & \left|\begin{array}{ccc}
-1-\lambda & 1 & 0\\
-4 & 3-\lambda & 0\\
1 & 0 & 2-\lambda
\end{array}\right|=\left(-1-\lambda\right)\left(3-\lambda\right)\left(2-\lambda\right)+4\left(2-\lambda\right)\\
= & \left(2-\lambda\right)\left[\left(-1-\lambda\right)\left(3-\lambda\right)+4\right]=\left(2-\lambda\right)\left(-3+\lambda-3\lambda+\lambda^{2}+4\right)\\
= & \left(2-\lambda\right)\left(\lambda^{2}-2\lambda+1\right)\\
= & \left(2-\lambda\right)\left(\lambda-1\right)^{2}.
\end{align*}

\end_inset

 This has roots 
\begin_inset Formula $\lambda_{1}=1$
\end_inset

, with algebraic multiplicity 2, and 
\begin_inset Formula $\lambda_{2}=2$
\end_inset

, with algebraic multiplicity 
\begin_inset Formula $1$
\end_inset

.
\end_layout

\begin_layout Example
Now, we get the eigenvectors associated to them:
\begin_inset Formula 
\[
Av=\lambda v\iff\begin{cases}
-x+y & =\lambda x\\
-4x+3y & =\lambda y\\
x+2z & =\lambda z
\end{cases}.
\]

\end_inset

 For 
\begin_inset Formula $\lambda_{1}$
\end_inset

 this is
\begin_inset Formula 
\[
\begin{cases}
-x+y & =x\\
-4x+3y & =y\\
x+2z & =z
\end{cases}\iff\begin{cases}
y & =2x\\
-4x+3y & =y\\
x & =-z
\end{cases},
\]

\end_inset

 so 
\begin_inset Formula $v_{\lambda_{1}}=\left(\begin{array}{c}
t\\
2t\\
-t
\end{array}\right)$
\end_inset

, with dimension 1 (it could be 2).
\end_layout

\begin_layout Example
For 
\begin_inset Formula $\lambda_{2}$
\end_inset

 this is
\begin_inset Formula 
\[
\begin{cases}
-x+y & =2x\\
-4x+3y & =2y\\
x+2z & =2z
\end{cases}\iff\begin{cases}
y & =3x\\
-4x & =-y\\
x+2z & =\lambda z
\end{cases}\iff\begin{cases}
x=0\\
y=0\\
2z & =2z
\end{cases},
\]

\end_inset

 so 
\begin_inset Formula $v_{\lambda_{2}}=\left(\begin{array}{c}
0\\
0\\
t
\end{array}\right)$
\end_inset

, with dimension 1 (it could not be differently).
\end_layout

\begin_layout Example
\begin_inset Formula $B=\left(\begin{array}{ccc}
4 & 6 & 0\\
-3 & -5 & 0\\
-3 & -6 & 1
\end{array}\right)$
\end_inset

, so
\begin_inset Formula 
\begin{align*}
\left|B-\lambda I\right|= & \left|\begin{array}{ccc}
4-\lambda & 6 & 0\\
-3 & -5-\lambda & 0\\
-3 & -6 & 1-\lambda
\end{array}\right|=\left(4-\lambda\right)\left(-5-\lambda\right)\left(1-\lambda\right)+18\left(1-\lambda\right)\\
= & \left(1-\lambda\right)\left[\left(4-\lambda\right)\left(-5-\lambda\right)+18\right]=\left(1-\lambda\right)\left(-20-4\lambda+5\lambda+\lambda^{2}+18\right)\\
= & \left(1-\lambda\right)\left(\lambda^{2}+\lambda-2\right)=\left(1-\lambda\right)^{2}\left(-2-\lambda\right).
\end{align*}

\end_inset


\end_layout

\begin_layout Example
This has roots 
\begin_inset Formula $\lambda_{1}=1$
\end_inset

, with algebraic multiplicity 2, and 
\begin_inset Formula $\lambda_{2}=-2$
\end_inset

, with algebraic multiplicity 
\begin_inset Formula $1$
\end_inset

.
\end_layout

\begin_layout Example
Now, we get the eigenvectors associated to them:
\begin_inset Formula 
\[
Av=\lambda v\iff\begin{cases}
4x+6y & =\lambda x\\
-3x-5y & =\lambda y\\
-3x-6y+z & =\lambda z
\end{cases}.
\]

\end_inset

 For 
\begin_inset Formula $\lambda_{1}=1$
\end_inset

, we have
\begin_inset Formula 
\[
\begin{cases}
4x+6y & =x\\
-3x-5y & =y\\
-3x-6y+z & =z
\end{cases}\iff\begin{cases}
x & =-2y\\
\\
z & =z
\end{cases}.
\]

\end_inset

 Therefore, the eigenspace associated to 
\begin_inset Formula $\lambda_{1}$
\end_inset

 is
\begin_inset Formula 
\[
E\left(\lambda_{1}\right)=\left\{ \left(\begin{array}{c}
-2t\\
t\\
0
\end{array}\right),\left(\begin{array}{c}
0\\
0\\
u
\end{array}\right)\right\} .
\]

\end_inset

 For 
\begin_inset Formula $\lambda_{2}=2$
\end_inset

, we have
\begin_inset Formula 
\[
\begin{cases}
4x+6y & =-2x\\
-3x-5y & =-2y\\
-3x-6y+z & =-2z
\end{cases}\iff\begin{cases}
x & =-y\\
\\
-3y+z & =-2z
\end{cases}\iff\begin{cases}
x & =-y\\
\\
y & =z
\end{cases}.
\]

\end_inset

 Thus, the eigenspace associated to 
\begin_inset Formula $\lambda_{2}$
\end_inset

is
\begin_inset Formula 
\[
E\left(\lambda_{2}\right)=\left(\begin{array}{c}
-t\\
t\\
t
\end{array}\right).
\]

\end_inset


\end_layout

\begin_layout Example
\begin_inset Formula $C=\left(\begin{array}{ccc}
1 & -1 & 0\\
-1 & 2 & 1\\
0 & 1 & 1
\end{array}\right),$
\end_inset


\begin_inset Formula 
\begin{align*}
\left|C-\lambda I\right|= & \left|\begin{array}{ccc}
1-\lambda & -1 & 0\\
-1 & 2-\lambda & 1\\
0 & 1 & 1-\lambda
\end{array}\right|=\left(1-\lambda\right)^{2}\left(2-\lambda\right)-2\left(1-\lambda\right)\\
= & \left(1-\lambda\right)\left[\left(1-\lambda\right)\left(2-\lambda\right)-2\right]\\
= & \left(1-\lambda\right)\left(2-\lambda-2\lambda+\lambda^{2}-2\right)\\
= & \left(1-\lambda\right)\left(\lambda^{2}-3\lambda\right)\\
= & \left(1-\lambda\right)\left(\lambda-3\right)\lambda.
\end{align*}

\end_inset


\end_layout

\begin_layout Example
\begin_inset Formula 
\[
Cv=\lambda v\iff\begin{cases}
x-y & =\lambda x\\
-x+2y+z & =\lambda y\\
y+z & =\lambda z
\end{cases}.
\]

\end_inset

 
\begin_inset Formula $\lambda_{1}=0$
\end_inset

:
\begin_inset Formula 
\[
\begin{cases}
x-y & =0\\
-x+2y+z & =0\\
y+z & =0
\end{cases}\iff\begin{cases}
x=y\\
y+z & =0
\end{cases}\iff\begin{cases}
x=y\\
y=-z
\end{cases},
\]

\end_inset

 so
\begin_inset Formula 
\[
E\left(\lambda_{1}\right)=\left(\begin{array}{c}
t\\
t\\
-t
\end{array}\right).
\]

\end_inset


\end_layout

\begin_layout Example
\begin_inset Formula $\lambda_{2}=1$
\end_inset

:
\begin_inset Formula 
\[
\begin{cases}
x-y & =x\\
-x+2y+z & =y\\
y+z & =z
\end{cases}\iff\begin{cases}
y=0\\
-x+z & =\\
z & =z
\end{cases}\iff\begin{cases}
y=0\\
x=z
\end{cases},
\]

\end_inset

 so
\begin_inset Formula 
\[
E\left(\lambda_{2}\right)=\left(\begin{array}{c}
t\\
0\\
t
\end{array}\right).
\]

\end_inset


\end_layout

\begin_layout Example
\begin_inset Formula $\lambda_{3}=3$
\end_inset

:
\begin_inset Formula 
\[
\begin{cases}
x-y & =3x\\
-x+2y+z & =3y\\
y+z & =3z
\end{cases}\iff\begin{cases}
y & =-2x\\
y & =2z
\end{cases},
\]

\end_inset

 so
\begin_inset Formula 
\[
E\left(\lambda_{3}\right)=\left(\begin{array}{c}
-t\\
2t\\
t
\end{array}\right).
\]

\end_inset


\end_layout

\begin_layout Example
\begin_inset Formula $D=\left(\begin{array}{ccc}
1 & -1 & 4\\
3 & 2 & -1\\
2 & 1 & -1
\end{array}\right),$
\end_inset


\begin_inset Formula 
\begin{align*}
\left|D-\lambda I\right|= & \left|\begin{array}{ccc}
1-\lambda & -1 & 4\\
3 & 2-\lambda & -1\\
2 & 1 & -1-\lambda
\end{array}\right|\\
= & \left(1-\lambda\right)\left(2-\lambda\right)\left(-1-\lambda\right)+12+2-8\left(2-\lambda\right)+1-\lambda+3\left(-1-\lambda\right)\\
= & \left(2-3\lambda+\lambda^{2}\right)\left(-1-\lambda\right)-4+4\lambda\\
= & -2-2\lambda+3\lambda+3\lambda^{2}-\lambda^{2}-\lambda^{3}-4+4\lambda\\
= & -\lambda^{3}+2\lambda^{2}+5\lambda-6
\end{align*}

\end_inset

 To obtain the roots, we can use Ruffini:
\end_layout

\begin_layout Example
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-6
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Example
So 
\begin_inset Formula $\lambda_{1}=1$
\end_inset

 is a root and we have now 
\begin_inset Formula $-\lambda^{2}+\lambda+6=0$
\end_inset

, obtaining
\begin_inset Formula 
\[
\lambda=\frac{-1\pm\sqrt{1+24}}{-2}=\frac{-1\pm5}{-2},
\]

\end_inset

 and we get 
\begin_inset Formula $\lambda_{2}=-2$
\end_inset

 and 
\begin_inset Formula $\lambda_{3}=3$
\end_inset

.
\end_layout

\begin_layout Example
\begin_inset Formula 
\[
Dv=\lambda v\iff\begin{cases}
x-y+4z & =\lambda x\\
3x+2y-z & =\lambda y\\
2x+y-z & =\lambda z
\end{cases}.
\]

\end_inset

 
\begin_inset Formula $\lambda_{1}=1$
\end_inset

:
\begin_inset Formula 
\[
\begin{cases}
x-y+4z & =x\\
3x+2y-z & =y\\
2x+y-z & =z
\end{cases}\iff\begin{cases}
y & =4z\\
3x+3z & =0\\
2x+2z & =0
\end{cases}\iff\begin{cases}
y=4z\\
x=-z
\end{cases}.
\]

\end_inset

 Then, 
\begin_inset Formula $E\left(\lambda_{1}\right)=\left(\begin{array}{c}
-t\\
4t\\
t
\end{array}\right).$
\end_inset


\end_layout

\begin_layout Example
\begin_inset Formula $\lambda_{2}=-2$
\end_inset

:
\begin_inset Formula 
\[
\begin{cases}
x-y+4z & =-2x\\
3x+2y-z & =-2y\\
2x+y-z & =-2z
\end{cases}\iff\begin{cases}
3x-y+4z & =0\\
3x+4y-z & =0\\
2x+y+z & =0
\end{cases}\iff\begin{cases}
5y-5z & =0\\
2x+y+z & =0
\end{cases}
\]

\end_inset


\begin_inset Formula 
\[
\iff\begin{cases}
y=z\\
2x+2y & =0
\end{cases}\iff\begin{cases}
y=z\\
x=-y
\end{cases}.
\]

\end_inset

 Then, 
\begin_inset Formula $E\left(\lambda_{2}\right)=\left(\begin{array}{c}
-t\\
t\\
t
\end{array}\right)$
\end_inset

.
\end_layout

\begin_layout Example
\begin_inset Formula $\lambda_{3}=3$
\end_inset

:
\begin_inset Formula 
\[
\begin{cases}
x-y+4z & =3x\\
3x+2y-z & =3y\\
2x+y-z & =3z
\end{cases}\iff\begin{cases}
-2x-y+4z & =0\\
3x-y-z & =0\\
2x+y-4z & =0
\end{cases}\iff\begin{cases}
-2x-y+4z & =0\\
5x-5z & =0
\end{cases}
\]

\end_inset


\begin_inset Formula 
\[
\begin{cases}
y=2z\\
x=z
\end{cases}.
\]

\end_inset


\end_layout

\begin_layout Example
Then, 
\begin_inset Formula $E\left(\lambda_{3}\right)=\left(\begin{array}{c}
t\\
2t\\
t
\end{array}\right)$
\end_inset

.
\end_layout

\begin_layout Example
\begin_inset Formula $E=\left(\begin{array}{ccc}
6 & -2 & 2\\
-2 & 3 & -1\\
2 & -1 & 3
\end{array}\right),$
\end_inset


\begin_inset Formula 
\begin{align*}
\left|E-\lambda I\right|= & \left|\begin{array}{ccc}
6-\lambda & -2 & 2\\
-2 & 3-\lambda & -1\\
2 & -1 & 3-\lambda
\end{array}\right|\\
= & \left(6-\lambda\right)\left(3-\lambda\right)^{2}+4+4-4\left(3-\lambda\right)-\left(6-\lambda\right)-4\left(3-\lambda\right)\\
= & \left(6-\lambda\right)\left(9-6\lambda+\lambda^{2}\right)+2-8\left(3-\lambda\right)+\lambda\\
= & 54-36\lambda+6\lambda^{2}-9\lambda+6\lambda^{2}-\lambda^{3}-22+8\lambda+\lambda\\
= & -\lambda^{3}+12\lambda^{2}-36\lambda+32.
\end{align*}

\end_inset


\end_layout

\begin_layout Example
Again, we can use the Ruffini rule:
\end_layout

\begin_layout Example
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-36
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-32
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Example
So 
\begin_inset Formula $\lambda_{1}=2$
\end_inset

 is a root, and we now have 
\begin_inset Formula $-\lambda^{2}+10\lambda-16=0$
\end_inset

, which gives us
\begin_inset Formula 
\[
\lambda=\frac{-10\pm\sqrt{100-64}}{-2}=\frac{-10\pm6}{-2}=5\pm3.
\]

\end_inset

 Therefore, 
\begin_inset Formula $\lambda_{1}$
\end_inset

 is a double root and the other root is 
\begin_inset Formula $\lambda_{2}=8$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula 
\[
Ev=\lambda v\iff\begin{cases}
6x-2y+2z & =\lambda x\\
-2x+3y-z & =\lambda y\\
2x-y+3z & =\lambda z
\end{cases}.
\]

\end_inset

 
\begin_inset Formula $\lambda_{1}=2$
\end_inset

:
\begin_inset Formula 
\[
\begin{cases}
6x-2y+2z & =2x\\
-2x+3y-z & =2y\\
2x-y+3z & =2z
\end{cases}\iff\begin{cases}
4x-2y+2z & =0\\
-2x+y-z & =0\\
2x-y+z & =0
\end{cases}\iff\begin{cases}
4x-2y+2z & =0\\
2x-y+z & =0
\end{cases}
\]

\end_inset


\begin_inset Formula 
\[
\iff2x-y+z=0
\]

\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Formula $x=0$
\end_inset

: 
\begin_inset Formula $y=z$
\end_inset

.
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $x=t\neq0$
\end_inset

: 
\begin_inset Formula $-y+z=-2t$
\end_inset

, working for 
\begin_inset Formula $y=t$
\end_inset

 and 
\begin_inset Formula $z=-t$
\end_inset

.
\end_layout

\begin_layout Standard
So
\begin_inset Formula 
\[
E\left(\lambda_{1}\right)=\left\{ \left(\begin{array}{c}
0\\
t\\
t
\end{array}\right),\left(\begin{array}{c}
t\\
t\\
-t
\end{array}\right)\right\} .
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\lambda_{2}=8$
\end_inset

:
\begin_inset Formula 
\[
\begin{cases}
6x-2y+2z & =8x\\
-2x+3y-z & =8y\\
2x-y+3z & =8z
\end{cases}\iff\begin{cases}
-2x-2y+2z & =0\\
-2x-5y-z & =0\\
2x-y-5z & =0
\end{cases}\iff\begin{cases}
-3y-3z & =0\\
2x-y-5z & =0
\end{cases}
\]

\end_inset


\begin_inset Formula 
\[
\iff\begin{cases}
y=-z\\
2x-4z & =0
\end{cases}\iff\begin{cases}
y=-z\\
x=2z
\end{cases}.
\]

\end_inset

 Therefore,
\begin_inset Formula 
\[
E\left(\lambda_{2}\right)=\left(\begin{array}{c}
2t\\
-t\\
t
\end{array}\right).
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $F=\left(\begin{array}{ccc}
0 & -1 & -1\\
1 & 2 & 1\\
1 & 1 & 2
\end{array}\right),$
\end_inset


\begin_inset Formula 
\begin{align*}
\left|F-\lambda I\right|= & \left|\begin{array}{ccc}
-\lambda & -1 & -1\\
1 & 2-\lambda & 1\\
1 & 1 & 2-\lambda
\end{array}\right|\\
= & -\lambda\left(2-\lambda\right)^{2}\cancel{-2+2}\cancel{-\lambda+\lambda}+2-\lambda\\
= & \left(2-\lambda\right)\left[-\lambda\left(2-\lambda\right)+1\right]\\
= & \left(2-\lambda\right)\left(-2\lambda+\lambda^{2}+1\right)\\
= & \left(2-\lambda\right)\left(1-\lambda\right)^{2}.
\end{align*}

\end_inset

 One root is 
\begin_inset Formula $\lambda_{1}=1$
\end_inset

 with algebraic dimension 2, and 
\begin_inset Formula $\lambda_{2}=2$
\end_inset

 with algebraic dimension 1.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
Fv=\lambda v\iff\begin{cases}
-y-z & =\lambda x\\
x+2y+z & =\lambda y\\
x+y+2z & =\lambda z
\end{cases}.
\]

\end_inset

 
\begin_inset Formula $\lambda_{1}=1$
\end_inset

:
\begin_inset Formula 
\[
\begin{cases}
-y-z & =x\\
x+2y+z & =y\\
x+y+2z & =z
\end{cases}\iff\begin{cases}
x+y+z & =0\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Formula $x=0$
\end_inset

: 
\begin_inset Formula $y=-z$
\end_inset

.
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $x=t\neq0$
\end_inset

: 
\begin_inset Formula $y+z=-t$
\end_inset

.
 This works for 
\begin_inset Formula $y=t,z=-2t$
\end_inset

.
\end_layout

\begin_layout Standard
Therefore,
\begin_inset Formula 
\[
E\left(\lambda_{1}\right)=\left\{ \left(\begin{array}{c}
0\\
t\\
-t
\end{array}\right),\left(\begin{array}{c}
t\\
t\\
-2t
\end{array}\right)\right\} .
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\lambda_{2}=2$
\end_inset

:
\begin_inset Formula 
\[
\begin{cases}
-y-z & =2x\\
x+2y+z & =2y\\
x+y+2z & =2z
\end{cases}\iff\begin{cases}
-y-z & =2x\\
x+z & =0\\
x+y & =0
\end{cases}\iff\begin{cases}
x=-z\\
x=-y
\end{cases}.
\]

\end_inset


\begin_inset Formula 
\[
\iff2x-y+z=0
\]

\end_inset

So
\begin_inset Formula 
\[
E\left(\lambda_{2}\right)=\left(\begin{array}{c}
t\\
-t\\
-t
\end{array}\right).
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Another way to represent eigenvalues and eigenvectors is
\begin_inset Formula 
\[
AV=V\Lambda,
\]

\end_inset

 where 
\begin_inset Formula $V=\left[v_{1},...,v_{n}\right]$
\end_inset

 is the matrix formed by putting each eigenvector as a column, and
\begin_inset Formula 
\[
\Lambda=\left(\begin{array}{cccc}
\lambda_{1}\\
 & \lambda_{2}\\
 &  & \ddots\\
 &  &  & \lambda_{n}
\end{array}\right)
\]

\end_inset

 is the diagonal matrix formed by all eigenvalues.
\end_layout

\begin_layout Standard
A matrix 
\begin_inset Formula $A$
\end_inset

 is 
\series bold
diagonalizable
\series default
 if there exist 
\begin_inset Formula $n$
\end_inset

 linearly independent eigenvectors.
 That is, if the matrix 
\begin_inset Formula $V$
\end_inset

 is invertible:
\begin_inset Formula 
\[
\Lambda=V^{-1}AV.
\]

\end_inset

 This leads naturally to the 
\series bold
eigen-decomposition
\series default
 of the matrix,
\begin_inset Formula 
\[
A=V\Lambda V^{-1}.
\]

\end_inset


\end_layout

\begin_layout Standard
A real matrix, 
\begin_inset Formula $U$
\end_inset

, is 
\series bold
orthogonal
\series default
 if 
\begin_inset Formula $U^{T}U=UU^{T}=I$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Proposition
The following statements are equivalent:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $U^{T}$
\end_inset

 is orthogonal.
\end_layout

\begin_layout Itemize
\begin_inset Formula $U^{T}=U^{-1}$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left|U\right|=1$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $U$
\end_inset

's eigenvectors are orthonormal (the pairwise dot product is 0 and the norm
 is 1).
\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Example
Some examples of orthogonal matrices:
\end_layout

\begin_deeper
\begin_layout Itemize
Identity: 
\begin_inset Formula $I$
\end_inset


\end_layout

\begin_layout Itemize
Permutation of coordinates: 
\begin_inset Formula $\left[\begin{array}{ccc}
0 & 1 & 0\\
1 & 0 & 0\\
0 & 0 & 1
\end{array}\right]$
\end_inset


\end_layout

\begin_layout Itemize
Rotation: 
\begin_inset Formula $\left(\begin{array}{cc}
\cos\theta & -\sin\theta\\
\sin\theta & \cos\theta
\end{array}\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
Reflection: 
\begin_inset Formula $\left(\begin{array}{cc}
\cos\theta & \sin\theta\\
\sin\theta & -\cos\theta
\end{array}\right)$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Standard
A matrix 
\begin_inset Formula $A$
\end_inset

 is said to be 
\series bold
positive semi-definite
\series default
 when it can be obtained as the product of a matrix by its transpose:
\begin_inset Formula 
\[
\exists X|A=XX^{T}.
\]

\end_inset

 Positive semi-definite matrices are always symmetric, because
\begin_inset Formula 
\[
A^{T}=\left(XX^{T}\right)^{T}=XX^{T}=A.
\]

\end_inset

 A symmetric matrix 
\begin_inset Formula $A$
\end_inset

 is positive semi-definite if all its eigenvalues are non-negative.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Proposition
Let 
\begin_inset Formula $A$
\end_inset

 be a positive semi-definite matrix.
 Then:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $0\leq\lambda_{1}\leq\lambda_{2}\leq...\leq\lambda_{n}$
\end_inset

 and its eigenvectors are pairwise orthogonal when their eigenvalues are
 different.
\end_layout

\begin_layout Itemize
The eigenvalues are composed of real values.
\end_layout

\begin_layout Itemize
The multiplicity of an eigenvalue is the dimension of its eigenspace.
\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Standard
In this case, since eigenvectors are orthogonal, it is possible to store
 all the eigenvectors in an orthogonal matrix.
 
\end_layout

\begin_layout Standard
Therefore, the eigen-decomposition of a positive semi-definite matrix, 
\begin_inset Formula $A$
\end_inset

, could be
\begin_inset Formula 
\[
A=U\Lambda U^{T},
\]

\end_inset

 with 
\begin_inset Formula $U$
\end_inset

 an orthogonal matrix.
\end_layout

\begin_layout Standard
As a consequence, the eigen-decomposition of a positive semi-definite matrix
 is often referred to as its diagonalization.
\end_layout

\begin_layout Standard
An alternative definition for positive semi-definite matrix is:
\end_layout

\begin_layout Standard
\begin_inset Formula $A$
\end_inset

 is positive semi-definite if 
\begin_inset Formula $x^{T}Ax\geq0,\forall x$
\end_inset

.
 
\end_layout

\begin_layout Standard
If it is 
\begin_inset Formula $x^{T}Ax>0,\forall x$
\end_inset

, then it is positive definite.
\end_layout

\begin_layout Standard
If it is 
\begin_inset Formula $x^{T}Ax\leq0,\forall x$
\end_inset

, then it is negative semi-definite.
\end_layout

\begin_layout Standard
If it is 
\begin_inset Formula $x^{T}Ax<0,\forall x$
\end_inset

, then it is negative definite.
\end_layout

\begin_layout Standard
The 
\series bold
rank
\series default
 of a matrix is the dimension of the vector space generated by its columns
 (or rows).
 This corresponds to the maximum number of linearly independent columns
 of 
\begin_inset Formula $A$
\end_inset

.
 A matrix whose rank is equal to its size is called a 
\series bold
full rank matrix
\series default
.
 Only full rank matrices have an inverse.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Proposition
The sum of the eigenvalues of a matrix is the sum of the elements of its
 main diagonal.
\end_layout

\begin_layout Proposition
The product of the eigenvalues is equal to the determinant of the matrix.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We can now define the 
\series bold
Laplacian matrix
\series default
 for undirected graphs, as
\begin_inset Formula 
\[
L_{ij}=\begin{cases}
-1 & ,\left(v_{i},v_{j}\right)\in E\\
0 & ,\left(v_{i},v_{j}\right)\notin E\\
d_{i} & ,i=j
\end{cases},
\]

\end_inset

 or, equivalently, 
\begin_inset Formula 
\[
L=D-A,
\]

\end_inset

 where 
\begin_inset Formula $A$
\end_inset

 is the degree is the matrix of 
\begin_inset Formula $G$
\end_inset

, and 
\begin_inset Formula $A$
\end_inset

 its adjacency matrix.
\end_layout

\begin_layout Subsubsection
Exercises
\end_layout

\begin_layout Enumerate
What could you say about these matrices?
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $A=\left(\begin{array}{cc}
-1 & \frac{3}{2}\\
1 & -1
\end{array}\right),$
\end_inset

 
\begin_inset Formula $det\left(A\right)=-\frac{1}{2}$
\end_inset

, 
\begin_inset Formula $A$
\end_inset

 is invertible.
 Its eigenvalues are 
\begin_inset Formula $\lambda_{1}=-1+\frac{\sqrt{6}}{2}$
\end_inset

 and 
\begin_inset Formula $\lambda_{2}=-1-\frac{\sqrt{6}}{2}$
\end_inset

, with 
\begin_inset Formula $v_{\lambda_{1}}=\left(\begin{array}{c}
\frac{\sqrt{6}}{2}t\\
t
\end{array}\right)$
\end_inset

 and 
\begin_inset Formula $v_{\lambda_{2}}=\left(\begin{array}{c}
-\frac{\sqrt{6}}{2}t\\
t
\end{array}\right)$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $B=\left(\begin{array}{cc}
-1 & \frac{3}{2}\\
\frac{2}{3} & -1
\end{array}\right)$
\end_inset

.
 The second row is equal to the first row multiplied by 
\begin_inset Formula $-\frac{2}{3}$
\end_inset

.
 Therefore, it is not invertible.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $I$
\end_inset

: its determinant is 1.
 It is symmetric, orthogonal, its own inverse.
 Triple eigenvalue 1, with eigenspace the whole space.
\end_layout

\end_deeper
\begin_layout Enumerate
Show that 
\begin_inset Formula $A^{n}=X\Lambda X^{-1}$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard
First, this is only true if 
\begin_inset Formula $A$
\end_inset

 is diagonalizable.
 If that is the case, then we can proceed by induction on 
\begin_inset Formula $n$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula $n=1$
\end_inset

: Obvious.
\end_layout

\begin_layout Standard
\begin_inset Formula $n=2$
\end_inset

:
\begin_inset Formula 
\[
A^{2}=\left(X\Lambda X^{-1}\right)^{2}=X\Lambda X^{-1}X\Lambda X^{-1}=X\Lambda^{2}X^{-1}.
\]

\end_inset

 Suppose it is true for 
\begin_inset Formula $n-1$
\end_inset

:
\begin_inset Formula 
\[
A^{n-1}=X\Lambda^{n-1}X^{-1}.
\]

\end_inset

 Then, for 
\begin_inset Formula $n$
\end_inset

, we have:
\begin_inset Formula 
\[
A^{n}=AA^{n-1}=X\Lambda X^{-1}X\Lambda^{n-1}X^{-1}=X\Lambda^{n}X^{-1}.
\]

\end_inset

 
\end_layout

\end_deeper
\begin_layout Enumerate
Find the eigenvalues and unit eigenvectors of 
\begin_inset Formula $A^{T}A$
\end_inset

 and 
\begin_inset Formula $AA^{T}$
\end_inset

 with 
\begin_inset Formula $A=\left(\begin{array}{cc}
1 & 1\\
1 & 0
\end{array}\right)$
\end_inset

 the Fibonnaci matrix.
\end_layout

\begin_deeper
\begin_layout Standard
First of all, notice that 
\begin_inset Formula $A$
\end_inset

 is symmetric, so 
\begin_inset Formula $A^{T}A=AA^{T}=A^{2}=\left(\begin{array}{cc}
2 & 1\\
1 & 1
\end{array}\right).$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left|\begin{array}{cc}
2-\lambda & 1\\
1 & 1-\lambda
\end{array}\right|=\left(2-\lambda\right)\left(1-\lambda\right)-1=2-3\lambda+\lambda^{2}-1=\lambda^{2}-3\lambda+1.$
\end_inset

 The roots of this polynomial are
\begin_inset Formula 
\[
\lambda=\frac{3\pm\sqrt{9-4}}{2}=\frac{3\pm\sqrt{5}}{2}.
\]

\end_inset


\end_layout

\begin_layout Standard
Now, 
\begin_inset Formula 
\[
A^{2}v=\lambda v\iff\begin{cases}
2x+y & =\lambda x\\
x+y & =\lambda y
\end{cases}\iff\begin{cases}
x=\left(\lambda-1\right)y\end{cases}
\]

\end_inset

 Therefore
\begin_inset Formula 
\[
E\left(\lambda_{1}\right)=\left(\begin{array}{c}
\frac{1+\sqrt{5}}{2}t\\
t
\end{array}\right)
\]

\end_inset

 with unit eigenvector 
\begin_inset Formula $v_{1}=\frac{1}{\sqrt{4-\sqrt{5}}}\left(\begin{array}{c}
\frac{1+\sqrt{5}}{2}\\
1
\end{array}\right).$
\end_inset


\end_layout

\begin_layout Standard
And
\begin_inset Formula 
\[
E\left(\lambda_{2}\right)=\left(\begin{array}{c}
\frac{1-\sqrt{5}}{2}t\\
t
\end{array}\right)
\]

\end_inset

 with unit eigenvector 
\begin_inset Formula $v_{2}=\frac{1}{\sqrt{4-\sqrt{5}}}\left(\begin{array}{c}
\frac{1-\sqrt{5}}{2}\\
1
\end{array}\right).$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Without multiplying
\begin_inset Formula 
\[
S=\left(\begin{array}{cc}
\cos\theta & -\sin\theta\\
\sin\theta & \cos\theta
\end{array}\right)\left(\begin{array}{cc}
2 & 0\\
0 & 5
\end{array}\right)\left(\begin{array}{cc}
\cos\theta & \sin\theta\\
-\sin\theta & \cos\theta
\end{array}\right),
\]

\end_inset

 find the determinant, the eigenvalues and eigenvectors.
 Why S is positive definite?
\end_layout

\begin_deeper
\begin_layout Standard
We have 
\begin_inset Formula $S=U\Lambda U^{T}$
\end_inset

 with 
\begin_inset Formula $U$
\end_inset

 orthogonal.
 Therefore, the eigenvalues of 
\begin_inset Formula $S$
\end_inset

 are 2 and 5.
 Its determinant is 10.
 The eigenvectors are the eigenvectors of 
\begin_inset Formula $\Lambda$
\end_inset

 rotated as well, that is:
\begin_inset Formula 
\[
V=\left(\begin{array}{cc}
\cos\theta & -\sin\theta\\
\sin\theta & \cos\theta
\end{array}\right)\left(\begin{array}{cc}
1 & 0\\
0 & 1
\end{array}\right)\left(\begin{array}{cc}
\cos\theta & \sin\theta\\
-\sin\theta & \cos\theta
\end{array}\right).
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $S$
\end_inset

 is positive definite because
\begin_inset Formula 
\[
xSx^{T}=x\left(\begin{array}{cc}
\cos\theta & -\sin\theta\\
\sin\theta & \cos\theta
\end{array}\right)\left(\begin{array}{cc}
2 & 0\\
0 & 5
\end{array}\right)\left(\begin{array}{cc}
\cos\theta & \sin\theta\\
-\sin\theta & \cos\theta
\end{array}\right)x^{T},
\]

\end_inset

 now note that
\begin_inset Formula 
\[
\left(x\left(\begin{array}{cc}
\cos\theta & -\sin\theta\\
\sin\theta & \cos\theta
\end{array}\right)\right)^{T}=\left(\begin{array}{cc}
\cos\theta & \sin\theta\\
-\sin\theta & \cos\theta
\end{array}\right)x^{T},
\]

\end_inset

 so
\begin_inset Formula 
\[
xSx^{T}=y\left(\begin{array}{cc}
2 & 0\\
0 & 5
\end{array}\right)y^{T}\geq0,
\]

\end_inset

 because 
\begin_inset Formula $\left(\begin{array}{cc}
2 & 0\\
0 & 5
\end{array}\right)$
\end_inset

 is positive semi-definite (symmetric with positive eigenvalues).
\end_layout

\end_deeper
\begin_layout Enumerate
For what numbers 
\begin_inset Formula $c$
\end_inset

 and 
\begin_inset Formula $d$
\end_inset

 are the following matrices positive definite?
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $A=\left(\begin{array}{ccc}
c & 1 & 1\\
1 & c & 1\\
1 & 1 & c
\end{array}\right)$
\end_inset

: all principal minors must be positive.
 That is:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $c>0$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left|\begin{array}{cc}
c & 1\\
1 & c
\end{array}\right|=c^{2}-1>0$
\end_inset

.
 Combined with the previous one, this is 
\begin_inset Formula $c>1$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left|\begin{array}{ccc}
c & 1 & 1\\
1 & c & 1\\
1 & 1 & c
\end{array}\right|=c^{3}+2-3c.$
\end_inset

 Roots: 1, 
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset

, and we have 
\begin_inset Formula $c^{2}+c-2$
\end_inset

, with roots 
\begin_inset Formula $c=\frac{-1\pm\sqrt{5}}{2}$
\end_inset

.
 We are only interested in the interval 
\begin_inset Formula $\left(1,\infty\right)$
\end_inset

, in which 
\begin_inset Formula $c^{3}-3c+2>0$
\end_inset

.
\end_layout

\begin_layout Standard
Therefore, it is 
\begin_inset Formula $c>1$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Formula $B=\left(\begin{array}{ccc}
1 & 2 & 3\\
2 & d & 4\\
3 & 4 & 5
\end{array}\right):$
\end_inset

 
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $1>0$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left|\begin{array}{cc}
1 & 2\\
2 & d
\end{array}\right|=d-4>0\iff d>4$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left|\begin{array}{ccc}
1 & 2 & 3\\
2 & d & 4\\
3 & 4 & 5
\end{array}\right|=5d+24+24-9d-16-20=-4d+12>0\iff-4d>-12\iff d<3.$
\end_inset

 
\end_layout

\begin_layout Standard
Therefore, there is no value for 
\begin_inset Formula $d$
\end_inset

 for which 
\begin_inset Formula $B$
\end_inset

 is positive.
\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
Show that if 
\begin_inset Formula $\lambda_{1},\lambda_{2},...,\lambda_{n}$
\end_inset

 are the eigenvalues of a matrix 
\begin_inset Formula $A$
\end_inset

, then 
\begin_inset Formula $A^{m}$
\end_inset

 has as eigenvalues 
\begin_inset Formula $\lambda_{1}^{m},\lambda_{2}^{m},...,\lambda_{n}^{m}$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard
Induction on 
\begin_inset Formula $m$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $m=1$
\end_inset

: Obvious.
\end_layout

\begin_layout Standard
\begin_inset Formula $m=2$
\end_inset

: Let 
\begin_inset Formula $v_{i}$
\end_inset

 be the eigenvector associated to 
\begin_inset Formula $\lambda_{i}$
\end_inset

, then
\begin_inset Formula 
\[
A^{2}v_{i}=A\left(Av_{i}\right)=A\left(\lambda_{i}v_{i}\right)=\lambda_{i}Av_{i}=\lambda_{i}^{2}v_{i},
\]

\end_inset

 so 
\begin_inset Formula $\lambda_{i}^{2}$
\end_inset

 is an eigenvalue of 
\begin_inset Formula $A^{2}$
\end_inset

, with associated eigenvector 
\begin_inset Formula $v_{i}$
\end_inset

.
\end_layout

\begin_layout Standard
Suppose it is true for 
\begin_inset Formula $m-1$
\end_inset

, then, for 
\begin_inset Formula $m$
\end_inset

:
\begin_inset Formula 
\[
A^{m}v_{i}=A\left(A^{m-1}v_{i}\right)=A\left(\lambda_{i}^{m-1}v_{i}\right)=\lambda_{i}^{m-1}Av_{i}=\lambda_{i}^{m}v_{i},
\]

\end_inset

 and we have the result.
\end_layout

\end_deeper
\begin_layout Enumerate
What is the determinant of any orthogonal matrix?
\end_layout

\begin_deeper
\begin_layout Standard
If 
\begin_inset Formula $U$
\end_inset

 is orthogonal, then 
\begin_inset Formula $UU^{T}=I$
\end_inset

.
 Then,
\begin_inset Formula 
\[
1=\left|I\right|=\left|UU^{T}\right|=\left|U\right|\left|U^{T}\right|=\left|U\right|^{2}.
\]

\end_inset

 Therefore, 
\begin_inset Formula $\left|U\right|=\pm1$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
For an undirected graph, both the adjacency matrix and the Laplacian matrix
 are symmetric.
 Show that the Laplacian matrix is positive semi-definite.
\end_layout

\begin_layout Section
Random Walks on Graphs
\end_layout

\begin_layout Subsection
First Perron-Frobenius Theorem
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
A matrix, 
\begin_inset Formula $A$
\end_inset

, is 
\series bold
positive
\series default
 if 
\begin_inset Formula $A_{ij}>0,\forall i,j$
\end_inset

.
 Similarly, it is 
\series bold
non-negative
\series default
 if 
\begin_inset Formula $A_{ij}\ge0,\forall i,j$
\end_inset

.
 Similar definitions apply for negative and non-positive matrices.
\end_layout

\end_inset


\end_layout

\begin_layout Remark
Observe that it is not the same for a matrix to be positive as to be positive
 semi-definite.
\end_layout

\begin_layout Standard
The Perron-Frobenius theorem for non-negative matrices leads to the characteriza
tion of non-negative primary eigenvectors.
 This is useful in stationary distributions, such as those of Markov chains
 and the famous Google's page rank algorithm.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Theorem

\series bold
Perron-Frobenius Theorem for positive matrices
\end_layout

\begin_layout Theorem
If 
\begin_inset Formula $A$
\end_inset

 is a positive matrix, then:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\exists\lambda^{*}>0,v^{*}>0,\left\Vert v^{*}\right\Vert _{2}=1$
\end_inset

 such that 
\begin_inset Formula $A\cdot v=\lambda^{*}v^{*}$
\end_inset

 (
\begin_inset Formula $v^{*}$
\end_inset

 is a right column eigenvector).
\end_layout

\begin_layout Itemize
\begin_inset Formula $\exists\lambda^{*}>0,w>0,\left\Vert w\right\Vert _{2}=1$
\end_inset

 such that 
\begin_inset Formula $w\cdot A=\lambda^{*}w$
\end_inset

 (
\begin_inset Formula $w$
\end_inset

 is a left row eigenvector).
\end_layout

\begin_layout Itemize
For any other eigenvalue, 
\begin_inset Formula $\lambda$
\end_inset

, it holds, 
\begin_inset Formula $\left|\lambda\right|<\lambda^{*}$
\end_inset

 (
\begin_inset Formula $\lambda^{*}$
\end_inset

 is a dominant eigenvalue, called the 
\series bold
\shape italic
Perron eigenvalue
\series default
\shape default
).
\end_layout

\begin_layout Itemize
\begin_inset Formula $\lambda^{*}$
\end_inset

 is unique and 
\begin_inset Formula $v^{*}$
\end_inset

 is unique (the only vector of unit length associated to 
\begin_inset Formula $\lambda^{*}$
\end_inset

).
\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
A non-negative matrix 
\begin_inset Formula $A$
\end_inset

 is:
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
Irreducible
\series default
 if, 
\begin_inset Formula $\forall i,j,\exists k\in\mathbb{N^{*}}$
\end_inset

 such that 
\begin_inset Formula $A_{i,j}^{k}>0$
\end_inset

.
\end_layout

\begin_layout Itemize

\series bold
Primitive
\series default
 if, 
\begin_inset Formula $\exists k\in\mathbb{N}^{*}$
\end_inset

 such that 
\begin_inset Formula $\forall i,j$
\end_inset

, 
\begin_inset Formula $A_{i,j}^{k}>0$
\end_inset

.
\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Theorem

\series bold
Perron-Frobenius Theorem for non-negative matrices
\end_layout

\begin_layout Theorem
If 
\begin_inset Formula $A$
\end_inset

 is a non-negative matrix, then:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\exists\lambda^{*}>0,v^{*}\ge0,\left\Vert v^{*}\right\Vert _{2}=1$
\end_inset

 such that 
\begin_inset Formula $A\cdot v=\lambda^{*}v^{*}$
\end_inset

 (
\begin_inset Formula $v^{*}$
\end_inset

 is a right column eigenvector).
\end_layout

\begin_layout Itemize
\begin_inset Formula $\exists\lambda^{*}>0,w\ge0,\left\Vert w\right\Vert _{2}=1$
\end_inset

 such that 
\begin_inset Formula $w\cdot A=\lambda^{*}w$
\end_inset

 (
\begin_inset Formula $w$
\end_inset

 is a left row eigenvector).
\end_layout

\begin_layout Itemize
For any other eigenvalue, 
\begin_inset Formula $\lambda$
\end_inset

, it holds, 
\begin_inset Formula $\left|\lambda\right|\le\lambda^{*}$
\end_inset

 (
\begin_inset Formula $\lambda^{*}$
\end_inset

 is a dominant eigenvalue, called the 
\series bold
\shape italic
Perron eigenvalue
\series default
\shape default
).
\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $A$
\end_inset

 is irreducible, then the vector 
\begin_inset Formula $v^{*}$
\end_inset

 is unique and it holds 
\begin_inset Formula $v^{*}>0$
\end_inset

.
\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $A$
\end_inset

 is primitive, then the eigenvalue 
\begin_inset Formula $\lambda^{*}$
\end_inset

 is unique.
 
\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Standard
Note now that a graph, 
\begin_inset Formula $G=\left(V,E\right)$
\end_inset

, with adjacency matrix 
\begin_inset Formula $A$
\end_inset

, then: 
\begin_inset Formula $G$
\end_inset

 is connected 
\begin_inset Formula $\iff$
\end_inset


\begin_inset Formula $\forall1\le i,j\le\left|V\right|,\exists k\in\mathbb{N}^{*}$
\end_inset

 such that 
\begin_inset Formula $A_{i,j}^{k}>0$
\end_inset

.
 This means that the adjacency matrix of connected graphs is irreducible.
\end_layout

\begin_layout Standard
Now, if a graph is 
\begin_inset Formula $k$
\end_inset

-connected, i.e., there is a 
\begin_inset Formula $k$
\end_inset

-path between all nodes, then its adjacency matrix is primitive.
 One sufficient condition for a graph to be 
\begin_inset Formula $k$
\end_inset

-connected is being connected and having 
\begin_inset Formula $A_{ii}>0$
\end_inset

 for some 
\begin_inset Formula $i$
\end_inset

.
\end_layout

\begin_layout Subsection
Random Walks on Graphs
\end_layout

\begin_layout Standard
A 
\series bold
random walk
\series default
 on a graph, 
\begin_inset Formula $G=\left(V,E\right)$
\end_inset

, is a random process that starts from some vertex 
\begin_inset Formula $v_{i}$
\end_inset

, and repeatedly moves to a neighbour 
\begin_inset Formula $v_{j}$
\end_inset

 chosen at random (for example with uniform distribution).
 The random walk, 
\begin_inset Formula $\xi_{t}$
\end_inset

, is therefore a random variable describing the position of a random walk
 after 
\begin_inset Formula $t$
\end_inset

 steps.
 The probability of going from node 
\begin_inset Formula $i$
\end_inset

 to node 
\begin_inset Formula $j$
\end_inset

 is the 
\series bold
transition probability
\series default
,
\begin_inset Formula 
\[
P_{ij}=P\left(\xi_{t+1}=j|\xi_{t}=i\right).
\]

\end_inset

 The sequence of nodes can be regarded as a Markov chain, i.e.
 a discrete time stochastic process, where the position 
\begin_inset Formula $\xi_{0}$
\end_inset

 is the initial state, according to the 
\series bold
init distribution
\series default
, 
\begin_inset Formula $P^{0}$
\end_inset

, and from this point the next state only depends on the current state.
 The 
\begin_inset Formula $t$
\end_inset


\series bold
-step transition probability
\series default
 is
\begin_inset Formula 
\[
P_{ij}^{t}=P\left(\xi_{t}=j|\xi_{0}=i\right).
\]

\end_inset

 Some examples are the path traced by a molecule in a liquid or a gas (Brownian
 motion), the price of a fluctuating stock, the financial status of a gambler,
 etc.
 The term random walk was first introduced by Karl Pearson in 1905.
\end_layout

\begin_layout Standard
The following is a basic visual example of a random walk on a graph:
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename pegado8.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
Note that we can express the transition probability 
\begin_inset Formula $P_{ij}$
\end_inset

 in a matrix 
\begin_inset Formula $P$
\end_inset

.
 This matrix is the 
\series bold
transition probabilities matrix
\series default
, and it is 
\series bold
row-stochastic
\series default
 or 
\series bold
row-Markov
\series default
, meaning, 
\begin_inset Formula 
\[
P_{ij}\ge0,\forall i,j,\text{ and }\sum_{j}P_{i,j}=1,\forall i.
\]

\end_inset

 This implies that
\begin_inset Formula 
\[
P\cdot1=P\cdot\left(\begin{array}{c}
1\\
\vdots\\
1
\end{array}\right)=\left(\begin{array}{c}
1\\
\vdots\\
1
\end{array}\right).
\]

\end_inset

 This means that 
\begin_inset Formula $\left(\begin{array}{c}
1\\
\vdots\\
1
\end{array}\right)$
\end_inset

 is an eigenvector and 
\begin_inset Formula $1$
\end_inset

 is an eigenvalue.
 1 is the largest eigenvalue because
\begin_inset Formula 
\[
\left\Vert Pv\right\Vert _{1}\leq\left\Vert v\right\Vert _{1},
\]

\end_inset

 so, for an eigenvalue 
\begin_inset Formula $\lambda$
\end_inset

,
\begin_inset Formula 
\[
\left|\lambda\right|\left\Vert v\right\Vert _{1}=\left\Vert \lambda v\right\Vert _{1}=\left\Vert Pv\right\Vert _{1}\leq\left\Vert v\right\Vert _{1},
\]

\end_inset

 so 
\begin_inset Formula $\left|\lambda\right|\leq1$
\end_inset

.
\end_layout

\begin_layout Standard
From the Perron-Frobenius theorem for non-negative matrices, we know that:
\end_layout

\begin_layout Itemize
\begin_inset Formula $v^{*}=\left(\begin{array}{c}
1\\
\vdots\\
1
\end{array}\right)$
\end_inset

 is a right Perron eigenvector for 
\begin_inset Formula $P$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left|\lambda\right|\leq\lambda^{*}=1$
\end_inset

 is a Perron eigenvalue.
\end_layout

\begin_layout Itemize
There exists a left Perron eigenvector 
\begin_inset Formula $\pi P=\pi$
\end_inset

.
\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $P$
\end_inset

 is irreducible, the vector 
\begin_inset Formula $\pi$
\end_inset

 is unique.
\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $P$
\end_inset

 is primitive, the eigenvalue 1 is unique (there are no complex eigenvalues
 with norm 1).
\end_layout

\begin_layout Subsubsection
The Stationary Distribution
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $\pi^{t}$
\end_inset

 be the row vector giving the probability distribution of 
\begin_inset Formula $\xi_{t}$
\end_inset

, that is, 
\begin_inset Formula $\pi_{i}^{t}$
\end_inset

 is the probability that the random walk is at node 
\begin_inset Formula $i$
\end_inset

 at time 
\begin_inset Formula $t$
\end_inset

.
 Therefore, we can write
\begin_inset Formula 
\[
\pi^{t+1}=\pi^{t}P,
\]

\end_inset

 which, applied recursively, leads to
\begin_inset Formula 
\[
\pi^{t+1}=\pi^{0}P^{t+1}.
\]

\end_inset

 Or, we can take limits
\begin_inset Formula 
\[
\lim_{t}\pi^{t+1}=\lim_{t}\pi^{t}P.
\]

\end_inset

 If this limit exists, 
\begin_inset Formula $\lim_{t}\pi^{t}=\pi$
\end_inset

, then
\begin_inset Formula 
\[
\pi=\pi P.
\]

\end_inset

 Convergence is ensured if 
\begin_inset Formula $P$
\end_inset

 is irreducible.
\end_layout

\begin_layout Example
The following example does not converge:
\end_layout

\begin_layout Example
\begin_inset Formula 
\[
P=\left(\begin{array}{cc}
0 & 1\\
1 & 0
\end{array}\right)
\]

\end_inset


\end_layout

\begin_layout Standard
A common way to perform random walks on graphs is with the uniform probability.
 That is,
\begin_inset Formula 
\[
P_{ij}=P\left(\xi_{t+1}=j|\xi_{t}=i\right)=\begin{cases}
\frac{1}{d_{i}} & if\ \left(i,j\right)\in E,\\
0 & otherwise,
\end{cases}
\]

\end_inset

 where 
\begin_inset Formula $d_{i}$
\end_inset

 is the degree of node 
\begin_inset Formula $i$
\end_inset

.
 Equivalently,
\begin_inset Formula 
\[
P_{ij}=\frac{A_{ij}}{\sum_{j\in V}A_{ij}}=\frac{A_{ij}}{d_{i}}=D_{ii}^{-1}A_{ij}.
\]

\end_inset

 The random sequence of vertices 
\begin_inset Formula $\xi_{0},\xi_{1},...,\xi_{t},\xi_{t+1},...$
\end_inset

 visited on 
\begin_inset Formula $G$
\end_inset

 is a Markov Chain with state space 
\begin_inset Formula $V$
\end_inset

 and matrix transition probabilite 
\begin_inset Formula $P=D^{-1}A$
\end_inset

.
\end_layout

\begin_layout Example
Given the graph:
\end_layout

\begin_deeper
\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename pegado9.png
	scale 60

\end_inset


\end_layout

\end_deeper
\begin_layout Example
The transition matrix for the uniform distribution is:
\begin_inset Formula 
\[
P=\left(\begin{array}{cccccc}
0 & 0 & 1 & 0 & 0 & 0\\
0 & 0 & \frac{1}{3} & \frac{1}{3} & \frac{1}{3} & 0\\
\frac{1}{4} & \frac{1}{4} & 0 & \frac{1}{4} & \frac{1}{4} & 0\\
0 & \frac{1}{4} & \frac{1}{4} & 0 & \frac{1}{4} & \frac{1}{4}\\
0 & \frac{1}{4} & \frac{1}{4} & \frac{1}{4} & 0 & \frac{1}{4}\\
0 & 0 & 0 & \frac{1}{2} & \frac{1}{2} & 0
\end{array}\right)
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Balance Condition
\end_layout

\begin_layout Standard
A probability distribution 
\begin_inset Formula $\pi$
\end_inset

 satisfies the 
\series bold
balance condition
\series default
 if 
\begin_inset Formula 
\[
\pi_{i}P_{ij}=\pi_{j}P_{ji},\forall i,j\in V.
\]

\end_inset

 If 
\begin_inset Formula $\pi$
\end_inset

 satisfies the balance condition, then it is the stationary distribution
 for the undirected graph.
 To see this, notice that the balance condition can be rewritten as
\begin_inset Formula 
\[
\pi_{i}\frac{A_{ij}}{d_{i}}=\pi_{j}\frac{A_{ji}}{d_{j}}.
\]

\end_inset

 Since the graph is considered without direction, 
\begin_inset Formula $A_{ij}=A_{ji}$
\end_inset

, and then
\begin_inset Formula 
\[
\frac{\pi_{i}}{d_{i}}=\frac{\pi_{j}}{d_{j}}=c,
\]

\end_inset

 where 
\begin_inset Formula $c$
\end_inset

 is a constant, for all 
\begin_inset Formula $i,j$
\end_inset

.
 Now, we know that 
\begin_inset Formula $\sum_{i}\pi_{i}=1$
\end_inset

, so
\begin_inset Formula 
\[
1=\sum_{i}\pi_{i}=\sum_{i}\frac{\pi_{j}}{d_{i}}d_{i}=\sum_{i}cd_{i}=c\sum_{i}d_{i}.
\]

\end_inset

 Therefore
\begin_inset Formula 
\[
\sum_{i}d_{i}=\frac{1}{c}.
\]

\end_inset

 Finally, it must be
\begin_inset Formula 
\[
\pi_{i}=d_{i}c=\frac{d_{i}}{\sum_{j}d_{j}}=\frac{d_{i}}{2\left|E\right|}.
\]

\end_inset

 In this case:
\begin_inset Formula 
\[
\left(\pi P\right)_{i}=\sum_{j}\pi_{j}P_{ji}=\sum_{j}\pi_{j}\frac{1}{d_{j}}A_{ji}=\sum_{j}cA_{ji}=c\sum_{j}A_{ji}=c\sum_{j}A_{ij}=cd_{i}=\frac{d_{i}}{\sum_{j}d_{j}}=\pi_{i}.
\]

\end_inset

 Therefore, we have seen that the stationary probabilities are proportional
 to the degrees of the vertices.
\end_layout

\begin_layout Standard
In particular, if 
\begin_inset Formula $G$
\end_inset

 is 
\begin_inset Formula $d$
\end_inset

-regular, i.e., all nodes have degree 
\begin_inset Formula $d$
\end_inset

, then
\begin_inset Formula 
\[
\pi=\frac{d}{2\left|E\right|}=\frac{d}{d\cdot n}=\frac{1}{n}
\]

\end_inset

 is the uniform distribution.
 With this setup, a random walk moves along every edge with the same frequence.
\end_layout

\begin_layout Standard
The balance condition implies time-reversibility: the reversed walk is also
 a Markov chain.
\end_layout

\begin_layout Subsubsection
Hitting Time
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
The 
\series bold
expected hitting time
\series default
, 
\begin_inset Formula $H_{ij}$
\end_inset

, is the expected number of steps before node 
\begin_inset Formula $j$
\end_inset

 is reached in a random walk starting at node 
\begin_inset Formula $i$
\end_inset

:
\begin_inset Formula 
\[
H_{ij}=\begin{cases}
1+\sum_{k}P_{ik}H_{kj} & if\ i\neq j,\\
0 & otherwise.
\end{cases}
\]

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Remark*
In general, 
\begin_inset Formula $H_{ij}\neq H_{ji},$
\end_inset

 so 
\begin_inset Formula $H$
\end_inset

 is not symmetric.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
\begin_inset Formula $H$
\end_inset

 follows the triangle inequality
\begin_inset Formula 
\[
H_{ij}\leq H_{ik}+H_{kj}.
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
The 
\series bold
commute time
\series default
, 
\begin_inset Formula $C_{ij}$
\end_inset

, is the expected number of steps in a random walk starting at node 
\begin_inset Formula $i$
\end_inset

, reaching node 
\begin_inset Formula $j$
\end_inset

 and coming back to 
\begin_inset Formula $i$
\end_inset

 again:
\begin_inset Formula 
\[
C_{ij}=H_{ij}+H_{ji}.
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Lazy Random Walk
\end_layout

\begin_layout Standard
The lazy random walk is a variation of the random walk, in which the walk
 stays at the current node with probability 
\begin_inset Formula $\frac{1}{2}$
\end_inset

, and continue with the walk with the rest of the probability.
\end_layout

\begin_layout Standard
In this case, the transition matrix is
\begin_inset Formula 
\[
P_{ij}=\begin{cases}
\frac{1}{2} & if\ i=j,\\
\frac{1}{2d_{i}} & if\ \left(i,j\right)\in E,\\
0 & otherwise.
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Formula $Q$
\end_inset

 is the transition matrix for the uniform random walk, then
\begin_inset Formula 
\[
\pi^{t+1}=\pi^{t}P=\frac{1}{2}\pi^{t}+\frac{1}{2}\pi^{t}Q.
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Proposition
If the lazy random walk converges and the uniform random walk is irreducible,
 then it converges to the same stationary distribution as the uniform random
 walk.
\end_layout

\end_inset


\end_layout

\begin_layout Proof
Let 
\begin_inset Formula $Q$
\end_inset

 be the transition matrix for the uniform random walk, then, the stationary
 distribution is
\begin_inset Formula 
\[
\pi=\pi Q.
\]

\end_inset

 For lazy random walk, say the stationary distribution is 
\begin_inset Formula $\pi'$
\end_inset

.
 Then:
\begin_inset Formula 
\[
\pi'=\frac{1}{2}\pi'+\frac{1}{2}\pi'Q\iff\frac{1}{2}\pi'=\frac{1}{2}\pi'Q\iff\pi'=\pi'Q.
\]

\end_inset

 Therefore, since 
\begin_inset Formula $Q$
\end_inset

 is irreducible, the uniqueness of 
\begin_inset Formula $\pi$
\end_inset

 implies 
\begin_inset Formula $\pi'=\pi$
\end_inset

.
\end_layout

\begin_layout Subsection
PageRank
\end_layout

\begin_layout Standard
The web is very heterogeneous bu nature, and certainly huge.
 We cannot expect the web graph to be connected.
 Page and Brin proposed a way to overcome this problem, by ensuring the
 convergence of random walks on the web graph.
\end_layout

\begin_layout Standard
The idea is to fix a positive constant, 
\begin_inset Formula $p$
\end_inset

, between 0 and 1, called the 
\series bold
damping factor
\series default
, and which represents the probability that a user leaves the current page
 and goes to a random web.
\end_layout

\begin_layout Standard
Therefore, the 
\series bold
page rank transition matrix
\series default
 is
\begin_inset Formula 
\[
P_{g}=\left(1-p\right)P+pB,
\]

\end_inset

 where 
\begin_inset Formula $B=\frac{1}{n}\left(\begin{array}{cccc}
1 & 1 & \dots & 1\\
1 & 1 & \dots & 1\\
\vdots & \vdots & \ddots & \vdots\\
1 & 1 & \dots & 1
\end{array}\right).$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $p$
\end_inset

 is usually chosen small, like 0.15, modelling a situation in which a surfer
 will, most of the time, follow the outgoing links and move on to one of
 the neighbours.
 A smaller percentage of time, the surfer will dump the current page and
 choose arbritrarily a different page from the web.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Proposition
\begin_inset Formula $P_{g}$
\end_inset

 is stochastic.
\end_layout

\end_inset


\end_layout

\begin_layout Proof
We need to proof that, for all 
\begin_inset Formula $i$
\end_inset

, it holds 
\begin_inset Formula $\sum_{j}P_{g_{i,j}}=1$
\end_inset

.
\begin_inset Formula 
\begin{align*}
\sum_{j}P_{g_{i,j}}= & \sum_{j}\left(1-p\right)P_{ij}+pB_{ij}\\
= & \left(1-p\right)\sum_{j}P_{ij}+p\sum_{j}B_{ij}\\
= & \left(1-p\right)\cdot1+p\sum_{j}\frac{1}{n}\\
= & 1-p+p\cdot n\frac{1}{n}\\
= & 1-p+p\\
= & 1.
\end{align*}

\end_inset


\end_layout

\begin_layout Section
Centrality Measures
\end_layout

\begin_layout Standard
Centrality Measures try to answer the question 
\emph on
'What characterizes an important vertex?'
\emph default
.
 They define a real-valued function on the vertices of the graph, 
\begin_inset Formula $m:V\rightarrow\mathbb{R}$
\end_inset

, that serves to rank the vertices.
 However, there are many different ways to define such function, leading
 to different definitions of centrality, such as cohesiveness, ability to
 transfer information across the network, to influence other nodes, to control
 information flow, etc.
\end_layout

\begin_layout Standard
There are many centrality measures that count the number of paths through
 a given vertex.
 These differ in how relevant walks are defined and counted.
 For example, if we only consider paths of length one, we would be computing
 degree centrality, while if we allow paths of arbitrary length, we would
 be computing eigenvalue centrality.
\end_layout

\begin_layout Subsection
Degree Centrality
\end_layout

\begin_layout Standard
The more neighbours a vertex has, the higher its communication ability is,
 increasing its importance.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
Given the graph 
\begin_inset Formula $G=\left(V,E\right)$
\end_inset

, with adjacency matrix 
\begin_inset Formula $A$
\end_inset

, the 
\series bold
degree centrality
\series default
 is computed as
\begin_inset Formula 
\[
D=Au,
\]

\end_inset

 where 
\begin_inset Formula $u=\boldsymbol{1}\in\mathbb{R}^{n}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Example
Consider the following graph:
\end_layout

\begin_deeper
\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename centrality0.png
	scale 60

\end_inset


\end_layout

\end_deeper
\begin_layout Example
The degree centrality is
\begin_inset Formula 
\[
D=Au=\left(\begin{array}{cccccc}
0 & 1 & 0 & 0 & 1 & 0\\
1 & 0 & 1 & 0 & 1 & 0\\
0 & 1 & 0 & 1 & 0 & 0\\
0 & 0 & 1 & 0 & 1 & 1\\
1 & 1 & 0 & 1 & 0 & 0\\
0 & 0 & 0 & 1 & 0 & 0
\end{array}\right)\left(\begin{array}{c}
1\\
1\\
1\\
1\\
1\\
1
\end{array}\right)=\left(\begin{array}{c}
2\\
3\\
2\\
3\\
3\\
1
\end{array}\right),
\]

\end_inset

 so the nodes with highest value are nodes 
\begin_inset Formula $\left(2,4,5\right)$
\end_inset

.
\end_layout

\begin_layout Standard
One drawback of this measure, is that it is very likely that several nodes
 present the same exact value, difficulting an unique ranking of vertices.
\end_layout

\begin_layout Subsection
Neighbourhood centrality
\end_layout

\begin_layout Standard
This measure correspond to the average degree of each vertex neighbours.
 We could understand this measure as measuring how much a vertex is related
 to influencial vertices.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
Given the graph 
\begin_inset Formula $G=\left(V,E\right)$
\end_inset

, with adjacency matrix 
\begin_inset Formula $A$
\end_inset

, the 
\series bold
neighbourhood centrality
\series default
 is computed as
\begin_inset Formula 
\[
N=\mathcal{D}^{-1}AD,
\]

\end_inset

 where 
\begin_inset Formula $\mathcal{D}$
\end_inset

 is the diagonal matrix where 
\begin_inset Formula $\mathcal{D}_{ii}=d_{i}$
\end_inset

 is the degree of vertex 
\begin_inset Formula $i$
\end_inset

 and 
\begin_inset Formula $D$
\end_inset

 is the degree centrality.
 Each vertex' measure is
\begin_inset Formula 
\[
N_{v}=\frac{\sum_{u\in\mathcal{N}_{v}}d_{u}}{d_{v}}.
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Example
The neighbourhood centrality of the previous example graph is
\begin_inset Formula 
\[
N=\mathcal{D}^{-1}Au=\left(\begin{array}{cccccc}
\frac{1}{2}\\
 & \frac{1}{3}\\
 &  & \frac{1}{2}\\
 &  &  & \frac{1}{3}\\
 &  &  &  & \frac{1}{3}\\
 &  &  &  &  & 1
\end{array}\right)\left(\begin{array}{cccccc}
0 & 1 & 0 & 0 & 1 & 0\\
1 & 0 & 1 & 0 & 1 & 0\\
0 & 1 & 0 & 1 & 0 & 0\\
0 & 0 & 1 & 0 & 1 & 1\\
1 & 1 & 0 & 1 & 0 & 0\\
0 & 0 & 0 & 1 & 0 & 0
\end{array}\right)\left(\begin{array}{c}
2\\
3\\
2\\
3\\
3\\
1
\end{array}\right)=\left(\begin{array}{c}
\frac{3+3}{2}\\
\frac{2+2+3}{3}\\
\frac{3+3}{2}\\
\frac{2+3+1}{3}\\
\frac{2+3+3}{3}\\
\frac{3}{1}
\end{array}\right)=\left(\begin{array}{c}
3\\
2.33\\
3\\
2\\
2.66\\
3
\end{array}\right),
\]

\end_inset

 so the nodes with highest value are nodes 
\begin_inset Formula $\left(1,3,6\right)$
\end_inset

.
\end_layout

\begin_layout Subsection
Eigenvector Centrality
\end_layout

\begin_layout Standard
A natural extension of degree centrality is to consider all reachable nodes,
 not just neighbours.
 Eigenvector centrality measures a node's importance while considering the
 importance of its neighbours.
 A high eigenvector centrality means that a node is connected to many nodes
 that have high scores themselves.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
Given the graph 
\begin_inset Formula $G=\left(V,E\right)$
\end_inset

, with adjacency matrix 
\begin_inset Formula $A$
\end_inset

, the 
\series bold
eigenvector centrality
\series default
 of node 
\begin_inset Formula $v$
\end_inset

 is
\begin_inset Formula 
\[
E_{v}=\frac{1}{\lambda}\sum_{u\in\mathcal{N}_{v}}A_{vu}E_{u},
\]

\end_inset

 where 
\begin_inset Formula $\lambda$
\end_inset

 is a parameter.
 Note that this can be written as
\begin_inset Formula 
\[
E=\frac{1}{\lambda}AE,
\]

\end_inset

 or
\begin_inset Formula 
\[
AE=\lambda E.
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This means that 
\begin_inset Formula $E$
\end_inset

 is an eigenvector of 
\begin_inset Formula $A$
\end_inset

, for the eigenvalue 
\begin_inset Formula $\lambda$
\end_inset

.
\end_layout

\begin_layout Standard
Bonacich suggested that the eigenvector of the largest eigenvalue of 
\begin_inset Formula $A$
\end_inset

 could make a good network centrality measure.
\end_layout

\begin_layout Standard
The eigenvector 
\begin_inset Formula $E$
\end_inset

 must be non-negative and according to the Perron-Frobenius theorem, the
 largest 
\begin_inset Formula $\lambda$
\end_inset

 enforces this property, making it a suitable value.
\end_layout

\begin_layout Example
Let's compute 
\begin_inset Formula $E$
\end_inset

 for the previous example graph.
 The matrix 
\begin_inset Formula $A$
\end_inset

 has as largest eigenvalue 
\begin_inset Formula $\lambda=2.54$
\end_inset

, and the corresponding eigenvector is
\begin_inset Formula 
\[
E=\left(\begin{array}{c}
2.5\\
3.1\\
2.2\\
2.5\\
3.2\\
1
\end{array}\right).
\]

\end_inset


\end_layout

\begin_layout Standard
Note that it is usually unfeasible to compute the eigenvalues and eigenvectors.
 It is more usual to get the vector iteratively as
\begin_inset Formula 
\[
E_{k}=A\frac{E_{k-1}}{\left\Vert E_{k-1}\right\Vert }.
\]

\end_inset


\end_layout

\begin_layout Subsection
PageRank Centrality
\end_layout

\begin_layout Standard
Google's PageRank is a variant of the eigenvector centrality, which uses
 in-degree to award one centrality point for every link a node receives.
 As we saw, the algorithm is based on a web surfer who is randomly clicking
 on links, with a certain probability to go to a different place of the
 web (the damping factor).
\end_layout

\begin_layout Standard
Therefore, we define the matrix 
\begin_inset Formula 
\[
P_{g}=\left(1-p\right)P+pB,
\]

\end_inset

 where 
\begin_inset Formula $P_{ij}=\begin{cases}
\frac{1}{d_{i}} & if\ j\in\mathcal{N}_{i}\\
0 & otherwise
\end{cases},$
\end_inset

 and 
\begin_inset Formula $B_{ij}=\frac{1}{n}$
\end_inset

.
\end_layout

\begin_layout Standard
Now, we apply the eigenvector centrality to this modified matrix, as
\begin_inset Formula 
\[
P_{g}E_{g}=\lambda E_{g}=E_{g},
\]

\end_inset

 with 
\begin_inset Formula $\lambda=1$
\end_inset

 because 
\begin_inset Formula $P_{g}$
\end_inset

 is stochastic.
\end_layout

\begin_layout Standard
Or, iteratively as
\begin_inset Formula 
\[
E_{g_{k}}=P_{g}E_{g_{k-1}}.
\]

\end_inset

 Note that in this case it is not necessary to normalize the vector at each
 step, because 
\begin_inset Formula $P_{g}$
\end_inset

 is stochastic.
 A good 
\begin_inset Formula $E_{g_{0}}$
\end_inset

 is 
\begin_inset Formula $E_{g_{0}}=\left(\begin{array}{c}
\frac{1}{n}\\
\vdots\\
\frac{1}{n}
\end{array}\right).$
\end_inset


\end_layout

\begin_layout Subsection
Katz (or alpha) centrality
\end_layout

\begin_layout Standard
The main problem with eigenvector centrality is that it only works well
 when the graph is strongly connected (so Perron-Frobenius is applicable
 in its stronger form).
 Real networks do not usually have this property, specially if they are
 directed.
 The vertices that are not in strongly connected components will have value
 0.
\end_layout

\begin_layout Standard
A way to work around this problem was proposed by Leo Katz.
 The idea is to give each node a minimum, positive amount of centrality,
 that it can transfer to other nodes, so:
\begin_inset Formula 
\[
K_{v}=\alpha\sum_{u}A_{vu}K_{u}+\beta,
\]

\end_inset

 where 
\begin_inset Formula $K_{v}$
\end_inset

 is the Katz centrality of node 
\begin_inset Formula $v$
\end_inset

, 
\begin_inset Formula $\beta$
\end_inset

 is a vector whose elements are all equal to a given positive constant and
 
\begin_inset Formula $\alpha\in\left(0,1\right)$
\end_inset

 is a parameter.
 Equivalently, this is
\begin_inset Formula 
\[
K=\alpha AK+\beta,
\]

\end_inset

 so
\begin_inset Formula 
\[
\left(I-\alpha A\right)K=\beta,
\]

\end_inset

 and
\begin_inset Formula 
\[
K=\left(I-\alpha A\right)^{-1}\beta.
\]

\end_inset


\end_layout

\begin_layout Standard
For this to work, 
\begin_inset Formula $I-\alpha A$
\end_inset

 must be invertible, which happens if and only if 
\begin_inset Formula $\left|I-\alpha A\right|\neq0\iff\left|\frac{1}{\alpha}I-A\right|\neq0$
\end_inset

, so 
\begin_inset Formula $\frac{1}{\alpha}$
\end_inset

 must not be an eigenvalue of 
\begin_inset Formula $A$
\end_inset

.
 This is ensured if we take 
\begin_inset Formula $\frac{1}{\alpha}>\lambda_{max}$
\end_inset

, or 
\begin_inset Formula $0<\alpha<\frac{1}{\lambda_{max}}$
\end_inset

.
\end_layout

\begin_layout Standard
An iterative way to compute 
\begin_inset Formula $K$
\end_inset

 is
\begin_inset Formula 
\[
K=\left(\sum_{k=1}^{\infty}\alpha^{k}A^{k}\right)u.
\]

\end_inset

 The strength of 
\begin_inset Formula $\alpha$
\end_inset

 decreases at each iteration, acting as attenuation factor.
\end_layout

\begin_layout Subsection
Clustering Coefficient Centrality
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Plain Layout

\series bold
Triadic closure
\series default
 is the property among three nodes A, B, and C (representing people, for
 instance), that if the connections A-B and A-C exist, there is a tendency
 for the new connection B-C to be formed.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The clustering coefficient measures the proportion of neighbours of each
 node, that connected to each other.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
Given a graph 
\begin_inset Formula $G=\left(V,E\right)$
\end_inset

, with adjacency matrix 
\begin_inset Formula $A$
\end_inset

, the 
\series bold
clustering coefficient
\series default
 of node 
\begin_inset Formula $v$
\end_inset

 is
\begin_inset Formula 
\[
CC_{v}=\frac{\left|\left\{ \left\{ u,v,w\right\} :\left(u,v\right),\left(v,w\right),\left(u,w\right)\in E\right\} \right|}{\binom{d_{v}}{2}},
\]

\end_inset

 where the numerator is the number of triangles involving 
\begin_inset Formula $v$
\end_inset

 and its neighbours, and the denominator is the total number of possible
 links between 
\begin_inset Formula $v$
\end_inset

's neighbours.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The more densely connected the neighbourhood of 
\begin_inset Formula $v$
\end_inset

 is, the higher is its clustering coefficient.
\end_layout

\begin_layout Example
The clustering coefficient of the graph example that we've been working
 with is
\begin_inset Formula 
\[
CC=\left(\begin{array}{c}
\frac{1}{1}\\
\frac{1}{3}\\
\frac{0}{1}\\
\frac{0}{3}\\
\frac{1}{3}\\
0
\end{array}\right)=\left(\begin{array}{c}
1\\
\frac{1}{3}\\
0\\
0\\
\frac{1}{3}\\
0
\end{array}\right).
\]

\end_inset


\end_layout

\begin_layout Subsection
Closeness Centrality
\end_layout

\begin_layout Standard
Closeness centrality is a measure of how close a node is, on average, to
 the rest of the nodes, in terms of shortest paths.
 It measures the average distance between a node 
\begin_inset Formula $v$
\end_inset

 and all other nodes in the network.
 Thus, the more central a node is, the closer it is to all other nodes.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
Given a graph 
\begin_inset Formula $G=\left(V,E\right)$
\end_inset

, the 
\series bold
closeness centrality
\series default
 of node 
\begin_inset Formula $v$
\end_inset

 is
\begin_inset Formula 
\[
CL_{v}=\frac{1}{\sum_{r\neq v}dist\left(v,r\right)}.
\]

\end_inset

 It can be normalized by the factor 
\begin_inset Formula 
\[
CL_{v}=\frac{N-1}{\sum_{r\neq v}dist\left(v,r\right)}.
\]

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
An alternative is the 
\series bold
harmonic centrality
\series default
, obtained as
\begin_inset Formula 
\[
H_{v}=\sum_{r\neq v}\frac{1}{dist\left(v,r\right)},
\]

\end_inset

 with 
\begin_inset Formula $dist\left(v,r\right)=0$
\end_inset

 if there is no path from 
\begin_inset Formula $v$
\end_inset

 to 
\begin_inset Formula $r$
\end_inset

.
\end_layout

\begin_layout Subsection
Betweenness Centrality
\end_layout

\begin_layout Standard
A family of betweenness measures are defined to capture a node's importance
 as a conduct of information flow in the network.
 This has wide applications in network theory, because in a telecommunications
 network, a node with higher betweenness centrality would have more control
 over the network, since more information will pass through that node.
\end_layout

\begin_layout Standard
The most well-known betweenness metric measures the number of times a node
 is on a shortest path between two nodes.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
Given a graph 
\begin_inset Formula $G=\left(V,E\right)$
\end_inset

, the 
\series bold
betweenness centrality
\series default
 of node 
\begin_inset Formula $v$
\end_inset

 is
\begin_inset Formula 
\[
B_{v}=\sum_{s\neq v\neq t}\frac{\sigma_{s,t}\left(v\right)}{\sigma_{s,t}},
\]

\end_inset

 where 
\begin_inset Formula $\sigma_{s,t}$
\end_inset

 is the number of shortest path from source node 
\begin_inset Formula $s$
\end_inset

 to target node 
\begin_inset Formula $t$
\end_inset

, and 
\begin_inset Formula $\sigma_{s,t}\left(v\right)$
\end_inset

 is the number of shortest path between these two nodes going through 
\begin_inset Formula $v$
\end_inset

.
\end_layout

\begin_layout Definition
This measure can be normalized by the number of ordered pairs not including
 
\begin_inset Formula $v$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Itemize
For directed graphs
\begin_inset Formula 
\[
B_{v}=\frac{1}{\left(n-1\right)\left(n-2\right)}\sum_{s\neq v\neq t}\frac{\sigma_{s,t}\left(v\right)}{\sigma_{s,t}}.
\]

\end_inset


\end_layout

\begin_layout Itemize
For undirected graphs
\begin_inset Formula 
\[
B_{v}=\frac{2}{\left(n-1\right)\left(n-2\right)}\sum_{s\neq v\neq t}\frac{\sigma_{s,t}\left(v\right)}{\sigma_{s,t}}.
\]

\end_inset


\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Example
For the undirected star graph:
\end_layout

\begin_deeper
\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename centrality1.png
	scale 60

\end_inset


\end_layout

\end_deeper
\begin_layout Example
The center vertex has a betweenness of 
\begin_inset Formula $\frac{\left(n-1\right)\left(n-2\right)}{2}$
\end_inset

 (or 1, if we normalize it), while the leaves have a betweenness of 0.
\end_layout

\begin_layout Exercise
What about the following graphs?
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Graphics
	filename centrality2.png
	scale 60

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula 
\[
B=\left(\begin{array}{c}
\frac{0}{6}\\
\frac{3}{6}\\
\frac{4}{6}\\
\frac{3}{4}\\
\frac{0}{6}
\end{array}\right)=\left(\begin{array}{c}
0\\
0.5\\
0.67\\
0.5\\
0
\end{array}\right).
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Graphics
	filename centrality3.png
	scale 60

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula 
\[
B=\left(\begin{array}{c}
\frac{1}{6}\\
\frac{1}{6}\\
\frac{1}{6}\\
\frac{1}{6}\\
\frac{1}{6}
\end{array}\right).
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Graphics
	filename centrality4.png
	scale 60

\end_inset


\begin_inset Formula 
\[
B=\left(\begin{array}{c}
\frac{0}{6}\\
\frac{3}{6}\\
\frac{5}{6}\\
\frac{0}{6}\\
\frac{0}{6}
\end{array}\right)=\left(\begin{array}{c}
0\\
0.5\\
0.83\\
0\\
0
\end{array}\right).
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Section
MapReduce Computation Model
\end_layout

\begin_layout Standard
The advent of big data and the increasing analysis needs favorised the design
 of parallel algorithms, specially in the realm of big data processing pipelines
, with a tradeoff between communication costs and degree of parallelism.
\end_layout

\begin_layout Standard
MapReduce is a processing paradigm that works on top of distributed environments.
 More precisely, it was built on top of Google File System (GFS) and Hadoop
 Distributed File System (HDFS), used to manage large-scale data and to
 be tolerant to hardware and networks faults.
 To do this, HDFS splits files into large blocks and distributes thema cross
 nodes in a cluster, and MapReduce is the programming model used to manage
 many large-scale parallel computations.
\end_layout

\begin_layout Standard
Basically, the idea is that the data is first splitted, then some operation
 is done to it, and then it's merged to produce the final results.
 For this, we will just need to define the 
\series bold
Map
\series default
 and 
\series bold
Reduce
\series default
 functions, while the system manages the parallel execution on distributed
 data and the coordination between them, leading with the possibility that
 one of the tasks may fail.
\end_layout

\begin_layout Example
Word Counter
\end_layout

\begin_layout Example
Consider a text file splitted into partitions 
\begin_inset Formula $A,B,C,D$
\end_inset

, across different nodes.
 We want to count how many times each word appears in the whole document.
 For this, we can use MapReduce as follows:
\end_layout

\begin_deeper
\begin_layout Enumerate
Map: for each word, 
\begin_inset Formula $w$
\end_inset

, in each partition, generate the pair 
\begin_inset Formula $\left(w,1\right)$
\end_inset

.
\end_layout

\begin_layout Enumerate
Shuffle/sort: collects and groups the pairs by key (word), in order to guarantee
 that the same key will be processed by the same reduce task.
 
\series bold
Shuffling
\series default
 is the process of redistributing data from Map nodes to Reduce nodes.
\end_layout

\begin_deeper
\begin_layout Standard
In our example, we would have, for each word 
\begin_inset Formula $w$
\end_inset

, the pairs 
\begin_inset Formula $\left(w,\left[1,...,1\right]\right)$
\end_inset

, with as many 1s as 
\begin_inset Formula $w$
\end_inset

 appearances.
\end_layout

\end_deeper
\begin_layout Enumerate
Reduce: for each input 
\begin_inset Formula $\left(w,\left[1,...,1\right]\right)$
\end_inset

, output 
\begin_inset Formula $\left(w,N_{w}\right)$
\end_inset

, where 
\begin_inset Formula $N_{w}$
\end_inset

 is the amount of 1s.
 
\end_layout

\end_deeper
\begin_layout Example
The Map task will typically process many words in one or more chunks.
 If a word, 
\begin_inset Formula $w$
\end_inset

, appears 
\begin_inset Formula $m$
\end_inset

 times among all chunks assigned to that process, there will be 
\begin_inset Formula $m$
\end_inset

 key-value pairs 
\begin_inset Formula $\left(w,1\right)$
\end_inset

 among its output.
\end_layout

\begin_layout Example
To perform the grouping and distribution to the Reduce task, the master
 controller merges the pairs by key and produces a sequence of 
\begin_inset Formula $\left(w,\left[1,...,1\right]\right)$
\end_inset

.
 Since it knows how many reduce tasks there will be, 
\begin_inset Formula $r$
\end_inset

, it will produce 
\begin_inset Formula $r$
\end_inset

 lists, putting a list in one of 
\begin_inset Formula $r$
\end_inset

 local files destined to one of the Reduce tasks.
 Each key is assigned as input to one, and only one, Reduce task.
\end_layout

\begin_layout Example
The Reduce task executes one or more reducers, one per key.
 The outputs from all reducers are merges into a single final file.
\end_layout

\begin_layout Subsection
The Map Function
\end_layout

\begin_layout Standard
In general, a map function can be defined as a function, 
\begin_inset Formula $m_{f}:\mathbb{E}_{1}^{n}\rightarrow\mathbb{E}_{2}^{n}$
\end_inset

, where 
\begin_inset Formula $\mathbb{E}_{i}$
\end_inset

 is the domain of the input (1) or output (2) and 
\begin_inset Formula $f:\mathbb{R}\rightarrow\mathbb{R}$
\end_inset

, that applies 
\begin_inset Formula $f$
\end_inset

 to each coordinate.
 That is:
\begin_inset Formula 
\[
m_{f}\left(\left[e_{1},...,e_{n}\right]\right)=\left[f\left(e_{1}\right),...,f\left(e_{n}\right)\right].
\]

\end_inset

For example:
\begin_inset Formula 
\[
m_{\cdot2}\left(\left[2,3,6\right]\right)=\left[4,6,12\right].
\]

\end_inset


\end_layout

\begin_layout Standard
In the MapReduce scheme, map is more restrictive, as the function 
\begin_inset Formula $f$
\end_inset

 must produce a key-value pair.
 That is, for all 
\begin_inset Formula $i=1,...,n$
\end_inset

, it is
\begin_inset Formula 
\[
f\left(e_{i}\right)=\left(k_{i},v_{i}\right).
\]

\end_inset


\end_layout

\begin_layout Standard
For example, in the word counter example:
\begin_inset Formula 
\[
m_{f}\left(\left["a","b","a"\right]\right)=\left[\left("a",1\right),\left("b",1\right),\left("a",1\right)\right].
\]

\end_inset


\end_layout

\begin_layout Subsection
Shuflling/Grouping Function
\end_layout

\begin_layout Standard
The shuffle function consists in grouping the outputs of the map function
 by key, so
\begin_inset Formula 
\[
s\left(\left[\left(k_{1},v_{1}\right),...,\left(k_{n},v_{n}\right)\right]\right)=\left[\left(k_{1},\left(v_{j}:k_{j}=k_{1},\forall j=1,...,n\right)\right),...\right].
\]

\end_inset

 Following the previous example:
\begin_inset Formula 
\[
s\left(\left[\left("a",1\right),\left("b",1\right),\left("a",1\right)\right]\right)=\left[\left("a",\left[1,1\right]\right),\left("b",\left[1\right]\right)\right].
\]

\end_inset


\end_layout

\begin_layout Subsection
Reduce Function
\end_layout

\begin_layout Standard
Generally, a reduce function applies to a vector/row, and outputs a single
 value, applying the aggregation function 
\begin_inset Formula $f$
\end_inset

:
\begin_inset Formula 
\[
r_{f}\left(\left[v_{1},...,v_{n}\right]\right)=f\left(v_{1},...,v_{n}\right).
\]

\end_inset

 In MapReduce, reduce applies to each output of the shuffle function with
 the same key:
\begin_inset Formula 
\[
r_{f}\left(\left(k,\left[v_{1},...,v_{n}\right]\right)\right)=\left[\left(k_{1}',f\left(v_{1},...,v_{n}\right)\right),...,\left(k_{m}',f\left(v_{1},...,v_{n}\right)\right)\right].
\]

\end_inset

 Following the previous example:
\begin_inset Formula 
\[
r_{sum}\left(\left[\left("a",\left[1,1\right]\right),\left("b",\left[1\right]\right)\right]\right)=\left[\left("a",2\right),\left("b",1\right)\right].
\]

\end_inset


\end_layout

\begin_layout Standard
A 
\series bold
MapReduce pipeline
\series default
 can be a composition of different 
\begin_inset Formula $r_{f_{r}}\circ s\circ m_{f_{m}}.$
\end_inset


\end_layout

\begin_layout Standard
The process is illustrated below:
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename pegado10.png
	scale 60

\end_inset


\end_layout

\begin_layout Subsection
MapReduce Execution Model
\end_layout

\begin_layout Standard
Whenever we launch the execution of a MapReduce pipeline, the following
 happens:
\end_layout

\begin_layout Itemize
The user program forks a master controller process and some number of worker
 processes at different computer nodes.
\end_layout

\begin_layout Itemize
The amster creates some number of map tasks and some number of reduce tasks.
 It assigns the tasks to worker processes by taking into account the co-location.
\end_layout

\begin_layout Itemize
A worker handles either map tasks (a 
\series bold
map worker
\series default
) or reduce tasks (a 
\series bold
reduce worker
\series default
), but not both.
\end_layout

\begin_layout Itemize
A worker process reports to the amster when it finishes a task, and a new
 task is scheduled by the master for that worker process.
\end_layout

\begin_layout Itemize
The master keeps track of the status of each map and reduce task (idle,
 executing, or completed).
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename pegado11.png
	scale 60

\end_inset


\end_layout

\begin_layout Subsubsection
Coping with Node Failures
\end_layout

\begin_layout Standard
If the master node fails, the entire MapReduce job must be restarted.
\end_layout

\begin_layout Standard
If a worker node fails, it would be detected and managed by the master,
 since it periodically pings the worker processes.
 All the map tasks assigned to this worker have to be redone in this case.
\end_layout

\begin_layout Subsubsection
Algorithms by MapReduce
\end_layout

\begin_layout Standard
This paradigm is not a solution to every problem, and in fact it only makes
 sense when files are very large, and rarely outdated.
 Its original purpose was to execute very large matrix-vector multiplications.
\end_layout

\begin_layout Subsection
Use-Case: Matrix-Vector Multiplication by MapReduce
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $M$
\end_inset

 be a 
\begin_inset Formula $n\times n$
\end_inset

 squared matrix and 
\begin_inset Formula $V$
\end_inset

 a vector of size 
\begin_inset Formula $n$
\end_inset

.
 Their product, 
\begin_inset Formula 
\[
W=MV,
\]

\end_inset

 is defined by
\begin_inset Formula 
\[
w_{i}=\sum_{j=1}^{n}m_{ij}v_{j}.
\]

\end_inset

 We can store 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $V$
\end_inset

 in a file in 
\begin_inset Formula $HDFS$
\end_inset

 as triples 
\begin_inset Formula $\left(\left(i,j\right),m_{ij}\right)$
\end_inset

 for 
\begin_inset Formula $M$
\end_inset

 and pairs 
\begin_inset Formula $\left(j,v_{j}\right)$
\end_inset

 for 
\begin_inset Formula $V$
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
This way is very efficient for sparse matrices.
\end_layout

\end_inset

.
 Now we can compute the computation by MapReduce as:
\end_layout

\begin_layout Itemize
Map: for each 
\begin_inset Formula $\left(\left(i,j\right),m_{ij}\right)$
\end_inset

 and 
\begin_inset Formula $\left(j,v_{j}\right)$
\end_inset

, it returns 
\begin_inset Formula $\left(i,m_{ij}v_{j}\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
Reduce: simply sums all the values for each key 
\begin_inset Formula $i$
\end_inset

, producing the pair 
\begin_inset Formula $\left(i,w_{i}\right)$
\end_inset

.
\end_layout

\begin_layout Standard
For this to work, all the pairs from 
\begin_inset Formula $V$
\end_inset

 must be available in all chunks (
\begin_inset Formula $V$
\end_inset

 cannot be stored distributely).
\end_layout

\begin_layout Standard
More concretely, we can define the functions:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

map(key,val):
\end_layout

\begin_layout Plain Layout

	i = key(1)
\end_layout

\begin_layout Plain Layout

	j = key(2)
\end_layout

\begin_layout Plain Layout

	for (j2, v) in V:
\end_layout

\begin_layout Plain Layout

		if j == j2:
\end_layout

\begin_layout Plain Layout

			emit(i, val*v)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

reduce(key, val):
\end_layout

\begin_layout Plain Layout

	sum = 0
\end_layout

\begin_layout Plain Layout

	for v in val
\end_layout

\begin_layout Plain Layout

		sum += v
\end_layout

\begin_layout Plain Layout

	emit(key, sum)		
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename pegado12.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
Now, if 
\begin_inset Formula $n$
\end_inset

 is large, 
\begin_inset Formula $V$
\end_inset

 might not fit in main memory of a worker node, and a large number of disk
 accesses may be required.
 We can improve the approach by distributing 
\begin_inset Formula $V$
\end_inset

 and refining the algorithm as follows:
\end_layout

\begin_layout Itemize
We devide the matrix into vertical stripes of equal width, and the vector
 in strips of the same size:
\end_layout

\begin_deeper
\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename pegado13.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
Here, the size of 
\begin_inset Formula $M_{k}$
\end_inset

 is 
\begin_inset Formula $n\times n_{k}$
\end_inset

 and the size of 
\begin_inset Formula $V_{k}$
\end_inset

 is 
\begin_inset Formula $n_{k}$
\end_inset

, so that the product 
\begin_inset Formula $M_{k}\cdot V_{k}$
\end_inset

 can be performed, outputing a vector of size 
\begin_inset Formula $n$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize
Each map task is assigned a chunk from one of the matrix stripes and gets
 the entire corresponding stripe of the vector.
\end_layout

\begin_layout Itemize
The final result would be
\begin_inset Formula 
\[
W=MV=\sum_{k=1}^{K}M_{k}\cdot V_{k},
\]

\end_inset

 where we apply the previously explained algorithm to each sub-multiplication
 step.
\end_layout

\begin_layout Subsubsection
Matrix Multiplication
\end_layout

\begin_layout Standard
This approach can be extended to matrix multiplication.
 Now, let 
\begin_inset Formula $M$
\end_inset

 be a matrix of size 
\begin_inset Formula $n_{1}\times n_{2}$
\end_inset

 and 
\begin_inset Formula $N$
\end_inset

 a matrix of size 
\begin_inset Formula $n_{2}\times n_{3}$
\end_inset

, the product 
\begin_inset Formula $P=MN$
\end_inset

 is a matrix of size 
\begin_inset Formula $n_{1}\times n_{3}$
\end_inset

, where
\begin_inset Formula 
\[
p_{ik}=\sum_{j=1}^{n_{2}}M_{ij}N_{jk}.
\]

\end_inset

 The matrices are stored as 
\begin_inset Formula $\left(M,\left(i,j\right),m_{ij}\right)$
\end_inset

 and 
\begin_inset Formula $\left(N,\left(j,k\right),n_{jk}\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
Map 1: transform 
\begin_inset Formula $\left(M,\left(i,j\right),m_{ij}\right)$
\end_inset

 into 
\begin_inset Formula $\left(j,\left(M,i,m_{ij}\right)\right)$
\end_inset

 and 
\begin_inset Formula $\left(N,\left(j,k\right),n_{jk}\right)$
\end_inset

 into 
\begin_inset Formula $\left(j,\left(N,k,n_{jk}\right)\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
Reduce 1: for each key, 
\begin_inset Formula $j$
\end_inset

, produces the key-value pair 
\begin_inset Formula $\left(\left(i,k\right),m_{ij}n_{jk}\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
Map 2: the identity.
\end_layout

\begin_layout Itemize
Reduce 2: for each key, 
\begin_inset Formula $\left(i,k\right)$
\end_inset

, produce the sum of the list of values associated to this key, 
\begin_inset Formula $\left(\left(i,k\right),\sum_{j}m_{ij}n_{jk}\right).$
\end_inset

 
\end_layout

\begin_layout Standard
In addition, 
\begin_inset Formula $M$
\end_inset

 could be divided into 
\begin_inset Formula $K$
\end_inset

 vertical stripes of size 
\begin_inset Formula $\left(n_{1},n_{k}\right)$
\end_inset

 and 
\begin_inset Formula $N$
\end_inset

 into 
\begin_inset Formula $K$
\end_inset

 horizontal stripes of size 
\begin_inset Formula $\left(n_{k},n_{3}\right)$
\end_inset

, where 
\begin_inset Formula $\sum_{k}n_{k}=n_{2}$
\end_inset

.
 In this setup, we can apply the algorithm to compute each 
\begin_inset Formula $M_{k}\cdot N_{k}$
\end_inset

 and then sum them all.
\end_layout

\begin_layout Standard
The functions can be defined more precisely as:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

map_1(T,(i,j),T_ij):
\end_layout

\begin_layout Plain Layout

	emit(j , (T,i,T_ij))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

reduce_1(key, val):
\end_layout

\begin_layout Plain Layout

	for v in val:
\end_layout

\begin_layout Plain Layout

		for w in val:
\end_layout

\begin_layout Plain Layout

			if v(1) == M and w(1) == N:
\end_layout

\begin_layout Plain Layout

				i = v(2)
\end_layout

\begin_layout Plain Layout

				M_ij = v(3)
\end_layout

\begin_layout Plain Layout

				k = w(2)
\end_layout

\begin_layout Plain Layout

				N_jk = w(3)
\end_layout

\begin_layout Plain Layout

				emit((i, k), M_ij*N_jk)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

map_2(key, val):
\end_layout

\begin_layout Plain Layout

	emit(key, val)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

reduce_2(key, val):
\end_layout

\begin_layout Plain Layout

	sum = 0
\end_layout

\begin_layout Plain Layout

	for v in val:
\end_layout

\begin_layout Plain Layout

		sum += v
\end_layout

\begin_layout Plain Layout

	emit(key, sum)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Relational Algebra by MapReduce
\end_layout

\begin_layout Subsubsection
Selection
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $R\left(A_{1},...,A_{n}\right)$
\end_inset

 be a relation stored as a file in HDFS.
 The elements of this file are the tuples of 
\begin_inset Formula $R$
\end_inset

.
 The selection operator, 
\begin_inset Formula $\sigma_{C}\left(R\right)$
\end_inset

 can be defined using MapReduce as:
\end_layout

\begin_layout Itemize
Map: for each tuple in 
\begin_inset Formula $R$
\end_inset

, 
\begin_inset Formula $t$
\end_inset

, test if 
\begin_inset Formula $t$
\end_inset

 satisfies 
\begin_inset Formula $C$
\end_inset

.
 If it does, produce the key-value pair 
\begin_inset Formula $\left(t,t\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
Reduce: the identity.
\end_layout

\begin_layout Subsubsection
Projection
\end_layout

\begin_layout Standard
For the projection, 
\begin_inset Formula $\pi_{A}\left(R\right)$
\end_inset

, we can do:
\end_layout

\begin_layout Itemize
Map: for each tuple in 
\begin_inset Formula $R$
\end_inset

, 
\begin_inset Formula $t$
\end_inset

, construct a tuple 
\begin_inset Formula $t'$
\end_inset

 by removing the attributes that are not in 
\begin_inset Formula $A$
\end_inset

.
 Output 
\begin_inset Formula $\left(t',t'\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
Reduce: for each key, 
\begin_inset Formula $t'$
\end_inset

, produced by the map tasks, there will be one or more key-value pairs 
\begin_inset Formula $\left(t',t'\right)$
\end_inset

.
 The reduce function turns 
\begin_inset Formula $\left(t',\left[t',t',...,t'\right]\right)$
\end_inset

 into 
\begin_inset Formula $\left(t',t'\right)$
\end_inset

 so it produces exactly one pair.
\end_layout

\begin_layout Subsubsection
Join
\end_layout

\begin_layout Standard
\begin_inset Formula $R\left(A\right)\bowtie_{B}S\left(C\right)$
\end_inset

 with 
\begin_inset Formula $A,B,C$
\end_inset

 sets of attributes satisfying 
\begin_inset Formula $B\subset A,B\subset C$
\end_inset

, can be implemented with MapReduce as:
\end_layout

\begin_layout Itemize
Map: for each tuple 
\begin_inset Formula $\left(a,b\right)\in R$
\end_inset

, produce the key-value pair 
\begin_inset Formula $\left(b,\left(R,a\right)\right)$
\end_inset

.
 For each tuple 
\begin_inset Formula $\left(c,b\right)\in S$
\end_inset

, produce the key-value pair 
\begin_inset Formula $\left(b,\left(S,c\right)\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
Reduce: for each key, 
\begin_inset Formula $b$
\end_inset

, output as many pairs as needed, 
\begin_inset Formula $\left(b,\left[\left(R,a\right),\left(S,c\right)\right]\right)$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Aggregation
\end_layout

\begin_layout Standard
The aggregation operator, 
\begin_inset Formula $\gamma_{A,\theta\left(B\right)}\left(R\right)$
\end_inset

, where 
\begin_inset Formula $A\cup B$
\end_inset

 is the set of attributes of 
\begin_inset Formula $R$
\end_inset

, and 
\begin_inset Formula $A\cap B=\emptyset$
\end_inset

, can be defined with MapReduce as:
\end_layout

\begin_layout Itemize
Map: for each tuple, 
\begin_inset Formula $t$
\end_inset

, produce 
\begin_inset Formula $\left(a,b\right)$
\end_inset

, where 
\begin_inset Formula $a$
\end_inset

 is the 
\begin_inset Formula $A$
\end_inset

 part of 
\begin_inset Formula $t$
\end_inset

, and 
\begin_inset Formula $b$
\end_inset

 is the 
\begin_inset Formula $B$
\end_inset

 part.
\end_layout

\begin_layout Itemize
Reduce: each key represents a group, so we apply 
\begin_inset Formula $\theta$
\end_inset

 to the list 
\begin_inset Formula $\left[b_{1},...,b_{n}\right]$
\end_inset

 associated to each value 
\begin_inset Formula $a$
\end_inset

.
 We output 
\begin_inset Formula $\left(a,x\right)$
\end_inset

, where 
\begin_inset Formula $x=\theta\left(b_{1},...,b_{n}\right)$
\end_inset

.
\end_layout

\begin_layout Subsection
Some Issues of MapReduce
\end_layout

\begin_layout Itemize

\series bold
Locality
\series default
: input data is stored on local disks of machines in the cluster.
 Each file is divided into blocks of 64MB, each of which is stored several
 times, as replicas, on different machines.
 MapReduce master node takes the location information of the input files
 into account, and attempts to schedule a map task on a machine that contains
 the needed replica.
 If this fails, it tries to schedule a map task in a machine that is near
 to one that has a replica.
\end_layout

\begin_layout Itemize

\series bold
Granularity
\series default
: the amp and reduce steps are divided into 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $R$
\end_inset

 pieces.
 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $R$
\end_inset

 should be much larger than the number of workers.
 Each worker can perform different tasks, improving dynamic load balancing
 and speeding up recovery when a worker fails.
 Some practical bounds on how large these values should be say that the
 master should take 
\begin_inset Formula $M+R$
\end_inset

 scheduling decisions and keep 
\begin_inset Formula $M\times R$
\end_inset

 states in memory.
\end_layout

\begin_layout Itemize

\series bold
Refinements
\series default
: partitioning input data using different functions according to the problem
 to be solved.
\end_layout

\begin_layout Itemize

\series bold
Ordering guarantees
\series default
: the intermediate key-value pairs are generally processed in increasing
 key order, to make it easy to generate a sorted output file per partition.
 However, this is not guaranteed.
\end_layout

\begin_layout Section
Spark Parallel Computing Framework
\end_layout

\begin_layout Standard
Nowadays, data is growing faster than processing speeds, and so the only
 possible solution is to parallelize on large clusters.
\end_layout

\begin_layout Standard

\series bold
Apache Spark
\series default
 is an open source implementation of a framework for large-scale data processing
, providing an interface for programming clusters with implicit data parallelism
 and fault tolerance.
 It extends a programming language with read-only data structure distributed
 over a cluster of machines, the 
\series bold
Resilient Distributed Datasets (RDDs)
\series default
, maintained in a fault-tolerant way.
 RDDs were developed in 2012 in response to limitations in Hadoop's MapReduce,
 which forces a particular linear dataflow as a sequence of HDFS reads and
 writes.
 
\end_layout

\begin_layout Standard
Spark is up to 100 times faster than traditional Hadoop thanks to its in-memory
 data processing:
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename pegado14.png
	scale 60

\end_inset


\end_layout

\begin_layout Subsection
Spark's Engine Properties and Components
\end_layout

\begin_layout Standard
Spark was originally written in Scala, a high level language for JVM.
 There are APIs for Java, Scala, Python, R,...
 
\end_layout

\begin_layout Standard
The Dataframe API was released as an abstraction on top of the RDD, as well
 as packages like MLlib or GraphX, that can be used for machine learning
 and graph analytics.
 These APIs facilitate the implementation of both iterative algorithms and
 interactive or exploratory data analysis.
\end_layout

\begin_layout Standard
Spark requires a cluster manager and a distributed storage system:
\end_layout

\begin_layout Itemize
Cluster management: Spark supports standalone, native Spark clusters, where
 we can launch a cluster either manually or using scripts, or we can use
 Hadoop YARN, Apache Mesos, or Kubernetes.
\end_layout

\begin_layout Itemize
Distributed storage: Spark cna interface with a wide variety of distributed
 databases, like Alluxio, HDFS, MapR-FS, Cassandra,...
\end_layout

\begin_layout Standard
Spark also supports different sources of data, in different formats and
 from different databases.
 All these relationships are shown below:
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename pegado15.png
	scale 60

\end_inset


\end_layout

\begin_layout Subsection
Spark's Execution Architecture
\end_layout

\begin_layout Standard
Data is splitted into partitions or blocks, and the driver assigns tasks
 to each worker, which reads a HDFS block, and has a cache.
 Each worker process and cache data, if necessary, sending the results to
 the driver when done.
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename pegado16.png
	scale 40

\end_inset


\begin_inset Graphics
	filename pegado17.png
	scale 40

\end_inset


\begin_inset Graphics
	filename pegado18.png
	scale 40

\end_inset


\begin_inset Graphics
	filename pegado19.png
	scale 40

\end_inset


\end_layout

\begin_layout Subsection
Resilient Distributed Datasets (RDDs)
\end_layout

\begin_layout Standard
RDDs are immutable and distributed collections of objects, spread across
 a cluster, and stored in RAM or disk (when they are persistent).
 They are statically typed, i.e., RDD[T] has objects of type T.
 The types can be of any type of Python, Java, or Scala objects, including
 user-defined classes.
\end_layout

\begin_layout Standard
RDDs are built via parallel 
\series bold
transformations
\series default
 and computed via parallel 
\series bold
actions
\series default
 on distributed datasets, executed lazily.
 For instnace, RDDs are splitted into multiple partitions, which may be
 computed on different nodes of a cluster.
\end_layout

\begin_layout Itemize

\series bold
Transformation
\series default
: operation on an RDD that returns a new RDD.
 They are computed lazily, only after an action is called.
\end_layout

\begin_layout Itemize

\series bold
Action
\series default
: operation on an RDD that returns a final result which is not another RDD.
 When an action is called, all the transformations prior to it are executed
 in the same order they were defined.
 Each time a new action is called, the entire RDD must be computed from
 scratch, but the user can deide to persist intermediate result (caching).
\end_layout

\begin_layout Standard
Inside Apache Spark, the workflow is managed as a directed acyclic graph
 (DAG).
 Nodes represents RDDs while edges represent the operations executed on
 the RDDs.
 Spark keeps track of the set of dependencies between different RDDs.
 This is called the 
\series bold
lineage graph
\series default
.
\end_layout

\begin_layout Example
Python Example: first line mentioning Python
\end_layout

\begin_layout Example
\begin_inset listings
lstparams "language=Python"
inline false
status open

\begin_layout Plain Layout

# spark context creation
\end_layout

\begin_layout Plain Layout

sc = pyspark.SparkContext(...)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# creating an RDD of strings with textFile()
\end_layout

\begin_layout Plain Layout

lines = sc.textFile(
\begin_inset Quotes eld
\end_inset

README.txt
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Transformations:
\end_layout

\begin_layout Plain Layout

# 	Construct a new RDD from a previous one, one common transformation is
 filtering data that matches a predicate
\end_layout

\begin_layout Plain Layout

pythonLines = lines.filter(lambda line: 
\begin_inset Quotes eld
\end_inset

Python
\begin_inset Quotes erd
\end_inset

 in line)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Actions:
\end_layout

\begin_layout Plain Layout

# 	Compute a result based on an RDD, and either return it to the driver
 program or save it to an external sotrage system
\end_layout

\begin_layout Plain Layout

pythonLines.first()
\end_layout

\end_inset


\end_layout

\begin_layout Example
Some notes:
\end_layout

\begin_deeper
\begin_layout Itemize
Once a SparkContext, 
\begin_inset Formula $sc$
\end_inset

, is set, it is used to build RDDs.
 The driver program manages a number of workers, and different workers on
 different machines might count lines in different ranges of the file.
 
\end_layout

\begin_layout Itemize
\begin_inset Formula $filter\left(\right)$
\end_inset

 does not mutate the existing input RDD.
 Instead, it returns a pointer to a new RDD.
\end_layout

\begin_layout Itemize
Many transformations work on one element at a time, but this is not true
 for all transformation, like 
\begin_inset Formula $union$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Subsubsection
RDDs Operations
\end_layout

\begin_layout Itemize
\begin_inset Formula $map\left(\right)$
\end_inset

 is used from different purposes, from fetching a large collection to just
 squaring numbers.
 It transforms an RDD of length 
\begin_inset Formula $N$
\end_inset

 into another RDD of length 
\begin_inset Formula $N$
\end_inset

, applying a function to each element in the RDD.
 For example:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=Python"
inline false
status open

\begin_layout Plain Layout

nums = sc.parallelize([1,2,3,4])
\end_layout

\begin_layout Plain Layout

squared = nums.map(lambda x: x*x).collect()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

for num in squared:
\end_layout

\begin_layout Plain Layout

	print(num)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# 1 4 9 16
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $flatMap\left(\right)$
\end_inset

 transforms an RDD of length 
\begin_inset Formula $N$
\end_inset

 into a collection of 
\begin_inset Formula $N$
\end_inset

 collection, then flatterns these into a single RDD of results, applying
 a function to each collection.
 For example:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=Python"
inline false
status open

\begin_layout Plain Layout

def tokenize(sentence):
\end_layout

\begin_layout Plain Layout

	return [word for word in sentence]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

rdd = sc.parallelize([
\begin_inset Quotes eld
\end_inset

coffee panda
\begin_inset Quotes erd
\end_inset

])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Using map
\end_layout

\begin_layout Plain Layout

map_result = rdd1.map(tokenize).collect()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

for token in map_result:
\end_layout

\begin_layout Plain Layout

	print(token)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Output: [
\begin_inset Quotes eld
\end_inset

coffee
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

panda
\begin_inset Quotes erd
\end_inset

]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Using flatMap
\end_layout

\begin_layout Plain Layout

flatmap_result = rdd1.flatMap(tokenize).collect()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

for token in flatmap_result:
\end_layout

\begin_layout Plain Layout

	print(token)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Output: 
\begin_inset Quotes eld
\end_inset

coffee
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

panda
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $reduce\left(\right)$
\end_inset

 is the most common action on basic RDDs.
 It operates on two elements of the type of the RDD and returns a new element
 of the same type.
 For example:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

data = sc.parallelize([1,2,3])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

data.reduce(lambda x, y: x+y) # Result is 6
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $reduceByKey\left(\right)$
\end_inset

 operates on RDD of key-value pairs.
 It runs several parallel reduce operations, for each key, where each operations
 combines values that have the same key.
 It returns a new RDD consisting of each key and the reduced value for that
 key.
 For example:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=Python"
inline false
status open

\begin_layout Plain Layout

pets = sc.parallelize([(
\begin_inset Quotes eld
\end_inset

cat
\begin_inset Quotes erd
\end_inset

, 3), (
\begin_inset Quotes eld
\end_inset

dog
\begin_inset Quotes erd
\end_inset

, 2), (
\begin_inset Quotes eld
\end_inset

cat
\begin_inset Quotes erd
\end_inset

, 1)])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

pets.reduceByKey(lambda x, y: x+y)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Result: {(
\begin_inset Quotes eld
\end_inset

cat
\begin_inset Quotes erd
\end_inset

, 4),(
\begin_inset Quotes eld
\end_inset

dog
\begin_inset Quotes erd
\end_inset

, 2)}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $groupByKey\left(\right)$
\end_inset

 and 
\begin_inset Formula $sortByKey\left(\right)$
\end_inset

 return the RDD with the values grouped or sorted by the keys.
 For example:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=Python"
inline false
status open

\begin_layout Plain Layout

pets = sc.parallelize([(
\begin_inset Quotes eld
\end_inset

cat
\begin_inset Quotes erd
\end_inset

, 3), (
\begin_inset Quotes eld
\end_inset

dog
\begin_inset Quotes erd
\end_inset

, 2), (
\begin_inset Quotes eld
\end_inset

cat
\begin_inset Quotes erd
\end_inset

, 1)])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

pets.groupsByKey() # Result: {(
\begin_inset Quotes eld
\end_inset

cat
\begin_inset Quotes erd
\end_inset

, [3, 1]),(
\begin_inset Quotes eld
\end_inset

dog
\begin_inset Quotes erd
\end_inset

, [2])}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

pets.sortByKey() # Result: {(
\begin_inset Quotes eld
\end_inset

cat
\begin_inset Quotes erd
\end_inset

, 3),(
\begin_inset Quotes eld
\end_inset

cat
\begin_inset Quotes erd
\end_inset

, 1),(
\begin_inset Quotes eld
\end_inset

dog
\begin_inset Quotes erd
\end_inset

, 2)}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $distinct\left(\right)$
\end_inset

 produces a new RDD with only distinct items.
\end_layout

\begin_layout Itemize
\begin_inset Formula $union\left(otherRDD\right)$
\end_inset

 produces a new RDD consisting of the data from both sources, removing duplicate
s.
\end_layout

\begin_layout Itemize
\begin_inset Formula $RDD.subtract\left(otherRDD\right)$
\end_inset

 produces a new RDD consisting in all values present in 
\begin_inset Formula $RDD$
\end_inset

 but not in 
\begin_inset Formula $otherRDD$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $RDD.cartesian\left(otherRDD\right)$
\end_inset

 returns of possible pairs 
\begin_inset Formula $\left(a,b\right)$
\end_inset

 where 
\begin_inset Formula $a\in RDD$
\end_inset

 and 
\begin_inset Formula $b\in otherRDD$
\end_inset

.
 Note that this operation is very costly.
\end_layout

\begin_layout Itemize
\begin_inset Formula $RDD.innerJoin(otherRDD)$
\end_inset

 returns only keys that are present in both pairs to the output RDD.
\end_layout

\begin_layout Itemize
\begin_inset Formula $RDD.leftOuterJoin\left(otherRDD\right)$
\end_inset

 and 
\begin_inset Formula $RDD.rightOuterJoin\left(otherRDD\right)$
\end_inset

 join the two RDDs together by key, allowing one of them to miss the key
 (left or right).
 For example:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=Python"
inline false
status open

\begin_layout Plain Layout

rdd = sc.parallelize([(1,2),(3,4),(3,6)])
\end_layout

\begin_layout Plain Layout

other = sc.parallelzie([3, 9])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

rdd.join(other) # result: {(3, (4,9)), (3, (6,9))}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

rdd.leftOuterJoin(other) # result: {(1, (2, None)), (3, (4,9)), (3, (6,9))}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Subsubsection
RDDs Actions
\end_layout

\begin_layout Itemize
\begin_inset Formula $collect\left(\right)$
\end_inset

 is used to retrieve the entire RDD.
 It is useful if it filters RDDs down to a very small size to deal with
 it locally at the driver.
 The retrieved dataset must fit in memory in a single machine.
\end_layout

\begin_layout Itemize
\begin_inset Formula $take\left(N\right)$
\end_inset

 is used to retrieve a small number of elements in the RDD at the driver
 program and then iterate them over them locally.
\end_layout

\begin_layout Itemize
\begin_inset Formula $top\left(N\right)$
\end_inset

 is used to extract the top elements.
\end_layout

\begin_layout Itemize
\begin_inset Formula $takeSample\left(withReplacement,N,seed\right)$
\end_inset

 allows to take a sample of the data either with out without replacement.
\end_layout

\begin_layout Itemize
\begin_inset Formula $foreach\left(\right)$
\end_inset

 performs computations on each element in the RDD without bringing it back
 locally.
\end_layout

\begin_layout Itemize
\begin_inset Formula $count\left(\right)$
\end_inset

 returns a count of the elements.
\end_layout

\begin_layout Itemize
\begin_inset Formula $countByValue\left(\right)$
\end_inset

 returns a map of each unique value and its count.
\end_layout

\begin_layout Subsubsection
Caching
\end_layout

\begin_layout Standard
Spark RDDs are lazily evaluated, and sometimes we use the same RDD multiple
 times.
 Naively, Spark will recompute the RDD and all of tis dependencies each
 time we call an action on the RDD.
 To avoid this, we can ask Spark to persist data using 
\begin_inset Formula $persist\left(\right)$
\end_inset

.
\end_layout

\begin_layout Standard
Notice that calling 
\begin_inset Formula $persist\left(\right)$
\end_inset

 does not force the evaluation of the RDD.
\end_layout

\begin_layout Standard
If we cache too much data, Spark will automatically delete old partitions.
 For the memory-only storage levels, it will recompute these partitions
 the next time they are accessed.
 This means that caching unnecessary data can lead to eviction and increased
 re-computation time.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintCited"
bibfiles "ps-cs"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
