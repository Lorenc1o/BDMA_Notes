#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage{footmisc}
\usepackage{listings}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{1,0.99,0.94}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,  
    frame=single,
    tabsize=2
}

\lstset{style=mystyle}
\end_preamble
\use_default_options true
\begin_modules
tcolorbox
customHeadersFooters
theorems-ams-bytype
theorems-sec-bytype
algorithm2e
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=blue, urlcolor=blue, citecolor=blue, pdfstartview={FitH}, unicode=true"
\papersize a4paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\boxbgcolor #62a0ea
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 3cm
\rightmargin 2cm
\bottommargin 3cm
\headheight 2cm
\headsep 1cm
\footskip 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Exam 2019
\end_layout

\begin_layout Exercise
In the framework of the RUM conjecture, name six data structures we saw
 in the course (not concrete tool implementations) and place them in the
 corresponding category: 
\end_layout

\begin_layout Itemize
Read optimized: BTree, Hash Index
\end_layout

\begin_layout Itemize
Write optimized: LSMTree, Hash Map
\end_layout

\begin_layout Itemize
Memory optimized: Bitmap Index, run-length encoded columns
\end_layout

\begin_layout Exercise
Which is the main problem in having replicas, and which is the innovation
 introduced by some NOSQL tools to solve it.
 
\end_layout

\begin_layout Itemize
Problem: the problem is maintaining consistency between different replicas,
 i.e., reflecting updates in the system correctly in all replicas.
 All this without hindering the performance of the system (for example if
 we need to block the whole system for every update, the cost would be very
 high, and scalability would decrease).
\end_layout

\begin_layout Itemize
Solution: eventual consistency is presented by NOSQL system as the solution
 to this problem, by enabling updates to be transmitted at different paces
 through the system, asynchronously.
 This is usually achieved by voting mechanisms.
\end_layout

\begin_layout Exercise
Suppose you have a hash function whose range has size 100 (i.e., D=100), and
 a Consistent Hash structure with 5 machines (M1..5) whose identifiers map
 to values h(M1)=0, h(M2)=20, h(M3)=40, h(M4)=60, h(M5)=80.
 What happens if you have an object mapped to value h(O)=90? 
\end_layout

\begin_layout Exercise
A consistent hash structure is circular, and each object is stored in the
 next machine in this circular structure.
 Since 90>80, it would go to the next machine in the circule, i.e., the first
 machine, M1.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Exercise
Suppose you implement a system to store images in hundreds of machines with
 thousands of users using HBase with a single column‐family.
 These images taken at time VT belong to a person P who tags each with a
 single subject S (e.g., family, friends, etc.) and are concurrently uploaded
 into the system at time TT in personal batches containing multiple pictures
 of different subjects taken at different times.
 Each person can then retrieve all his/her pictures of one single subject
 that were taken after a given time.
 Precisely define the key you would use if you exclusively prioritize (i.e.,
 do not consider any other criteria) … 
\end_layout

\begin_layout Itemize
Load balancing on ingestion: VT,S,P
\end_layout

\begin_deeper
\begin_layout Itemize
Assumptions: VT is going to be different for every picture, S will coincide
 for some picture, P and TT will coincide for all pictures in each, but
 we need P to retrieve the user fast.
\end_layout

\end_deeper
\begin_layout Itemize
Load balancing on querying: VT,S,P
\end_layout

\begin_deeper
\begin_layout Itemize
Assumptions: again, we want the leftmost part of the key to be as unique
 as possible, this is the best option.
\end_layout

\end_deeper
\begin_layout Itemize
I/O on ingestion: P,S,VT
\end_layout

\begin_deeper
\begin_layout Itemize
Assumptions: grouping by users would make ingestion very localized.
 S cannot go first because it is likely that many many users would use the
 same subject a lot.
\end_layout

\end_deeper
\begin_layout Itemize
I/O on querying: P,S,VT
\end_layout

\begin_deeper
\begin_layout Itemize
the user's pictures and subjects would be very close to one another.
\end_layout

\end_deeper
\begin_layout Exercise
Consider two files containing the following kinds of data: 
\end_layout

\begin_layout Exercise
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Employees.txt 
\end_layout

\begin_layout Plain Layout

EMP1;RICARDO;250000€;MADRID;SITE2 
\end_layout

\begin_layout Plain Layout

EMP2;EULALIA;150000€;BARCELONA;SITE1 
\end_layout

\begin_layout Plain Layout

EMP3;MIQUEL;125000€;BADALONA;SITE3 
\end_layout

\begin_layout Plain Layout

EMP4;MARIA;175000€;MADRID;SITE2 
\end_layout

\begin_layout Plain Layout

EMP5;ESTEBAN;150000€;MADRID;SITE4 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Departments.txt 
\end_layout

\begin_layout Plain Layout

SITE1;DPT.MANAGEMENT;FLOOR10;ST.PAU CLARIS;BARCELONA 
\end_layout

\begin_layout Plain Layout

SITE2;DPT.MANAGEMENT;FLOOR8;ST.RIOS ROSAS;MADRID 
\end_layout

\begin_layout Plain Layout

SITE3;DPT.MARKETING;FLOOR1;ST.PAU CLARIS;BARCELONA 
\end_layout

\begin_layout Plain Layout

SITE4;DPT.MARKETING;FLOOR1;ST.RIOS ROSAS;MADRID 
\end_layout

\begin_layout Plain Layout

SITE5;DPT.MARKETING;FLOOR5;ST.MARTI PUJOL;BADALONA 
\end_layout

\end_inset


\end_layout

\begin_layout Exercise
Provide the ordered list of Spark operations (no need to follow the exact
 syntax, but just the kind of operation and main parameters) you’d need
 to retrieve the list of department IDs for those departments with sites
 in all cities where employees live (these employees can be even from other
 departments).
 Save the results in “output.txt”.
 In the previous example, the result should be “DPT.MARKETING”, because it
 has sites in all the three cities where there are employees (i.e., MADRID,
 BARCELONA and BADALONA).
 However, “DPT.MANAGEMENT” should not be in the result, because it does not
 have any site in BADALONA, where EMP3 lives.
 
\end_layout

\begin_layout Enumerate
emp = spark.read.csv('Employees.txt').delimiter=';',header='false').toDF().columns(['e
ID',''eName','eSalary','eCity','eSite'])
\end_layout

\begin_layout Enumerate
dept = spark.read.csv(Departments.txt').delimiter=';',header='false').toDF().columns([
'dSite','dName','dFloor','dStreet','dCity'])
\end_layout

\begin_layout Enumerate
emp_cities = emp.select('eCity').distinct().groupBy().agg(collect_list('dCity')).as('
eCities')
\end_layout

\begin_layout Enumerate
dept_cities = dept.select('dName','dCity').groupBy('dName').agg(collect_list('dCity
')).as('dCities')
\end_layout

\begin_layout Enumerate
result = dept_cities.filter(size(array_except(emp_cities['eCities'],dept_cities['
dCities']))==0).select('dName')
\end_layout

\begin_layout Enumerate
result.write.save('./output.txt', format='csv', header='false')
\end_layout

\begin_layout Standard
Another solution:
\end_layout

\begin_layout Enumerate
emp = spark.read.csv('Employees.txt').delimiter=';',header='false').toDF().columns(['e
ID',''eName','eSalary','eCity','eSite'])
\end_layout

\begin_layout Enumerate
dept = spark.read.csv(Departments.txt').delimiter=';',header='false').toDF().columns([
'dSite','dName','dFloor','dStreet','dCity'])
\end_layout

\begin_layout Enumerate
dept__cities = dept.join(emp, dept.dCity = emp.eCity, 'inner').select('dName',
 'eCity').distinct().groupBy('dName').agg(count('dCity')).as('nCities') #Note
 that these cities are shared with employees! This is important because
 else this approach would not work
\end_layout

\begin_layout Enumerate
eCities_count = emp.select('eCity).distinct().count()
\end_layout

\begin_layout Enumerate
result = dept.filter(dept.nCities == eCities_count).select('dName')
\end_layout

\begin_layout Enumerate
result.write.save('./output.txt',format='csv',header='false')
\end_layout

\end_body
\end_document
