#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage{footmisc}
\usepackage{listings}
\usepackage{ifsym}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{1,0.99,0.94}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,  
    frame=single,
    tabsize=2
}

\lstset{style=mystyle}

\newcommand{\ljoin}{\footnotesize \textifsym{|><} \normalsize}
\end_preamble
\use_default_options true
\begin_modules
tcolorbox
customHeadersFooters
theorems-ams-bytype
theorems-sec-bytype
algorithm2e
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=blue, urlcolor=blue, citecolor=blue, pdfstartview={FitH}, unicode=true"
\papersize a4paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\boxbgcolor #62a0ea
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 3cm
\rightmargin 2cm
\bottommargin 3cm
\headheight 2cm
\headsep 1cm
\footskip 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
BDM-MIRI - Big Data Management - Exercises
\end_layout

\begin_layout Date
Spring 2023
\end_layout

\begin_layout Author
Jose Antonio Lorencio Abril
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename ../../LectureNotes/source/upc-logo.png
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\align right
Professor: Alberto Abelló
\end_layout

\begin_layout Standard
\align right
Student e-mail: jose.antonio.lorencio@estudiantat..upc.edu
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Address
This are the exercises of the course 
\emph on
Big Data Management
\emph default
 taught at the Universitat Politècnica de Catalunya by Professor Alberto
 Abelló in the academic year 22/23.
 Some exercises have been solved in class (marked with 
\color red
*
\color inherit
).
\end_layout

\begin_layout Address
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Big Data Design
\end_layout

\begin_layout Subsection
Theoretical questions
\end_layout

\begin_layout Subsubsection
Briefly explain what 'physical independence' is, which is the general position
 of NOSQL systems on this, and why they take this position.
\end_layout

\begin_layout Subsubsection
In the framework of the RUM conjecture, name six data structures we saw
 in the course (not concrete tool implementations) and place them in the
 corresponding category:
\end_layout

\begin_layout Itemize

\series bold
Read optimized:
\end_layout

\begin_layout Itemize

\series bold
Write optimized:
\end_layout

\begin_layout Itemize

\series bold
Space optimized:
\end_layout

\begin_layout Subsubsection
Compare a B-tree and a LSM-tree in the context of the RUM conjectura (i.e.
 as an answer to this question, three brief explanations of the form 'From
 the perspective of X, Y-tree is better than Z-tree, because of this and
 that' are expected).
\end_layout

\begin_layout Itemize

\series bold
R:
\end_layout

\begin_layout Itemize

\series bold
U:
\end_layout

\begin_layout Itemize

\series bold
M:
\end_layout

\begin_layout Subsection
Problems
\end_layout

\begin_layout Subsubsection
Consider
\end_layout

\begin_layout Enumerate

\series bold
['BCN', POPULATION:{VALUE:'2 000 000'}, REGION{VALUE:'CAT'}]
\end_layout

\begin_layout Enumerate

\series bold
['BCN', ALL:{VALUE:'2 000 000;CAT'}]
\end_layout

\begin_layout Enumerate

\series bold
['BCN', ALL:{POPULATION:'2 000 000'; REGION:'CAT'}]
\end_layout

\begin_layout Standard

\series bold
Place {1,2,3} in the table:
\end_layout

\begin_layout Standard
\align center

\series bold
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Less variable schema
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\begin_inset Formula $\rightarrow$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
More variable schema
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Less explicit schema
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\begin_inset Formula $\downarrow$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
More explicit schema
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection*
Name two criteria you would use to choose among them.
\end_layout

\begin_layout Subsubsection
Consider the following conceptual schema and propose several design alternatives
 to translate it to a logical representation(e.g.
 using JSON notation).
 Then, explain which is the best alternative and why.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado1.png
	scale 60

\end_inset


\end_layout

\begin_layout Section
Distributed Data
\end_layout

\begin_layout Subsection
Theoretical questions
\end_layout

\begin_layout Subsubsection
Which kind of database is this according to the distribution of data?
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado2.png
	scale 60

\end_inset


\end_layout

\begin_layout Subsubsection
Explain what is (a) a distributed system, and (b) a parallel system.
 Compare both of them (i.e.
 what has one and not the other and vice-versa).
\end_layout

\begin_layout Subsubsection
Which two kinds of schema information contains the Global Conceptual Schema
 that does not contain the Local Conceptual Schema in the Extended ANSI-SPARC
 Architecture for DDBMS? 
\color red
*
\end_layout

\begin_layout Enumerate
Fragmentation
\end_layout

\begin_layout Enumerate
Allocation
\end_layout

\begin_layout Subsubsection
In the context of distributed data management, name the four big challenges
 that need to be carefully considered in the presence of distribution from
 the tenant/user point of view.
 
\color red
*
\end_layout

\begin_layout Enumerate
Data design.
\end_layout

\begin_layout Enumerate
Catalog management.
\end_layout

\begin_layout Enumerate
Transaction management.
\end_layout

\begin_layout Enumerate
Query processing.
\end_layout

\begin_layout Subsubsection
Name the three characteristics of fragmentation that make it correct.
 
\color red
*
\end_layout

\begin_layout Enumerate
Disjoint.
\end_layout

\begin_layout Enumerate
Complete.
\end_layout

\begin_layout Enumerate
Reconstructible.
\end_layout

\begin_layout Subsubsection
Which is the main problem in having replicas, and which is the innovation
 introduced by some NOSQL tools to solve it? 
\color red
*
\end_layout

\begin_layout Itemize

\series bold
Problem:
\series default
 Consistency.
\end_layout

\begin_layout Itemize

\series bold
Innovation: 
\series default
Eventual consistency.
\end_layout

\begin_layout Subsubsection
Given 
\begin_inset Formula $N$
\end_inset

 replicas, let's call 
\begin_inset Formula $R$
\end_inset

 the ReadConcern parameter of MongoDB and 
\begin_inset Formula $W$
\end_inset

 the WriteConcert (which indicate, respectively, the number of copies it
 reads and writes before confirming the operation to the user).
 Give the equation involving those variables that corresponds to the eventually
 consistent configuration.
 
\color red
*
\end_layout

\begin_layout Standard
The formula is:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
W+R<N.
\]

\end_inset


\end_layout

\begin_layout Subsubsection
What is the difference between query cost and query response time...
\end_layout

\begin_layout Enumerate

\series bold
In centralized systems?
\end_layout

\begin_layout Enumerate

\series bold
In distributed systems?
\end_layout

\begin_layout Subsubsection
Name the two factors that make it impossible to have linear scalability
 according to the Universal Scalability Law.
 
\color red
*
\end_layout

\begin_layout Enumerate
Programs are not fully parallelizable.
\end_layout

\begin_layout Enumerate
There are communication costs.
\end_layout

\begin_layout Subsection
Problems
\end_layout

\begin_layout Subsubsection
Briefly explain (a) which fragmentation strategy has been applied for the
 tables below and whether this fragmentation strategy is (b) complete, (c)
 disjoint and (d) allows to reconstruct the global relations (if so, (e)
 indicate the operation).
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Plain Layout

\series bold
Global Relations
\end_layout

\begin_layout Plain Layout
——————————————————
\end_layout

\begin_layout Plain Layout

\family typewriter
Kids(
\bar under
kidId
\bar default
, name, address, age)
\end_layout

\begin_layout Plain Layout

\family typewriter
Toys(
\bar under
toyId
\bar default
, name, price)
\end_layout

\begin_layout Plain Layout

\family typewriter
Request(
\bar under
kidId, toyId
\bar default
, willingness)
\end_layout

\begin_layout Plain Layout
——————————————————
\end_layout

\begin_layout Plain Layout
Note that 
\family typewriter
requests(kidId)
\family default
 is a FK to 
\family typewriter
kids(kidId)
\family default
 and 
\family typewriter
requests(toyId)
\family default
 is a FK to 
\family typewriter
toys(toyId)
\family default
.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Plain Layout

\series bold
Fragments
\end_layout

\begin_layout Plain Layout
——————————————————
\end_layout

\begin_layout Plain Layout
K1 = Kids[kidId, name]
\end_layout

\begin_layout Plain Layout
K2 = Kids[kidId, address, age]
\end_layout

\begin_layout Plain Layout
——————————————————
\end_layout

\begin_layout Plain Layout
T1 = Toys(price 
\begin_inset Formula $\geq$
\end_inset

 150)
\end_layout

\begin_layout Plain Layout
T2 = toys(price 
\begin_inset Formula $<$
\end_inset

 150)
\end_layout

\begin_layout Plain Layout
——————————————————
\end_layout

\begin_layout Plain Layout
R1 = Requests 
\begin_inset Formula $\ltimes$
\end_inset

 T1 
\end_layout

\begin_layout Plain Layout
R2 = Requests 
\begin_inset Formula $\ltimes$
\end_inset

 T2
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
You are a customer using an e-commerce based on heavy replication (e.g.
 Amazon):
\end_layout

\begin_layout Enumerate

\series bold
Show a database replication strategy (e.g.
 sketch it) where:
\end_layout

\begin_deeper
\begin_layout Enumerate

\series bold
You buy an item, but this item does not appear in your basket.
\end_layout

\begin_layout Enumerate

\series bold
You reload the page: the item appears.
\end_layout

\begin_layout Standard

\series bold
What happened?
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Show a database replication strategy (e.g.
 sketch it) where:
\end_layout

\begin_deeper
\begin_layout Enumerate

\series bold
You delete an item from your command, and add another one: the basket shows
 both items.
\end_layout

\begin_layout Standard

\series bold
What happened? Will the situation change if you reload the page?
\end_layout

\end_deeper
\begin_layout Subsubsection
Consider the following architecture and answer the questions
\begin_inset Foot
status open

\begin_layout Plain Layout
From S.
 Abiteboul et al.
 
\emph on
Web Data Management
\emph default
.
 Cambridge Press, 2011.
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pegado3.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Centralized architecture.
\begin_inset CommandInset label
LatexCommand label
name "fig:Centralized-architecture."

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Latency
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Bandwidth
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Disk
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\approx5\times10^{-3}s\left(5\ millisec.\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
At best 100 MB/s
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Enumerate

\series bold
How long would it take (i.e.
 response time) to read 1TB with sequential access (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Centralized-architecture."
plural "false"
caps "false"
noprefix "false"

\end_inset

)? (in secs)
\end_layout

\begin_layout Enumerate

\series bold
How long would a single random access (i.e.
 reading one tuple, of for example 100 B, through an index) take (i.e.
 response time), assuming we already have the physical address? (in secs)
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pegado4.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Shared-memory architecture.
\begin_inset CommandInset label
LatexCommand label
name "fig:Shared-memory-architecture."

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Latency
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Bandwidth
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Disk
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\approx5\times10^{-3}s\left(5\ millisec.\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
At best 100 MB/s
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
3.
 
\end_layout

\end_inset


\series bold
How long would it take (i.e.
 response time) to read 1TB with parallel access (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Shared-memory-architecture."
plural "false"
caps "false"
noprefix "false"

\end_inset

)? Assume 100 disks (i.e.
 100 replicas of the whole data) on the same machine with shared-memory
 and infinite CPU capacity.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
4.
 
\end_layout

\end_inset


\series bold
How long would a single ranodm access (i.e.
 reading one tuple, of 100 B, through an index) take (i.e.
 response time), assuming we already have the physical address? (in secs)
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pegado5.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Shared-nothing architecture.
\begin_inset CommandInset label
LatexCommand label
name "fig:Shared-nothing-architecture."

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Latency
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Bandwidth
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Disk
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\approx5\times10^{-3}s\left(5\ millisec.\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
At best 100 MB/s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LAN
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\approx1/2\ \times10^{-2}s\left(1-2\ millisec.\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\approx1\ GB/s\left(single\ rack\right)\approx10\ MB/s\left(switched\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Internet
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Highly variable (10-100ms)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Highly variable (few MB/s, 10MB/s)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Remark
It is approximately one order of magnitude to exchange main memory data
 between 2 machines in a data center, that to read on the disk.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
Exchanging through the Internet is slow and unreliable with respect to LANs.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
5.
 
\end_layout

\end_inset


\series bold
How long would it take (i.e.
 response time) to read 1TB with distributed access (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Shared-nothing-architecture."
plural "false"
caps "false"
noprefix "false"

\end_inset

)? Assume 100 shared-nothing machines (with all data replicated in each
 of them) in a star-shape LAN in a single rack where all data is sent to
 the center of the star in only one network hop.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
6.
 
\end_layout

\end_inset


\series bold
How long would it take (i.e.
 response time) to read 1TB with distributed access (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Shared-nothing-architecture."
plural "false"
caps "false"
noprefix "false"

\end_inset

)? Assume 100 shared-nothing machines (with all data replicated in each
 of them) in a star-shape cluster of machines connected through the Internet
 where all data is sent ot the center of the star in only one network hop.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
7.
 
\end_layout

\end_inset


\series bold
How long would a single random access (i.e.
 reading one tuple, of 100 B, through an index) take (i.e.
 response time), assuming we already have the physical address? (in secs)
\end_layout

\begin_layout Subsubsection
What are the main differences between these two distributed access plans?
 Under which assumptions is one or the other better?
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT *
\end_layout

\begin_layout Plain Layout

FROM employee e, assignedTo a
\end_layout

\begin_layout Plain Layout

WHERE e.#emp = a.#emp AND a.responsability = 'manager'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Plain Layout
The database is:
\end_layout

\begin_layout Plain Layout
——————————————————
\end_layout

\begin_layout Plain Layout

\family typewriter
Employee(
\bar under
#emp
\bar default
, empName, degree)
\end_layout

\begin_layout Plain Layout

\family typewriter
S4: E1 = Employee(#emp 
\begin_inset Formula $\leq$
\end_inset

 'E3')
\end_layout

\begin_layout Plain Layout

\family typewriter
S3: E2 = Employee(#emp 
\begin_inset Formula $>$
\end_inset

 'E3')
\end_layout

\begin_layout Plain Layout
——————————————————
\end_layout

\begin_layout Plain Layout

\family typewriter
AssignedTo(
\bar under
#emp, #proj
\bar default
, responsability, fullTime)
\end_layout

\begin_layout Plain Layout

\family typewriter
FK: #emp references Employee
\end_layout

\begin_layout Plain Layout

\family typewriter
S1: A1 = AssignedTo(#emp 
\begin_inset Formula $\leq$
\end_inset

 'E3')
\end_layout

\begin_layout Plain Layout

\family typewriter
S2: A2 = AssignedTo(#emp 
\begin_inset Formula $>$
\end_inset

 'E3')
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pegado6.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Distributed Access Plans
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Compute the fragment query (data location stage) for the database setting
 and query below and find in how many ways we can assign the operations
 to the different sites.
\end_layout

\begin_layout Standard

\series bold
The database setting is:
\end_layout

\begin_layout Itemize

\series bold
A distributed database with 5 sites (i.e.
 database nodes): 
\begin_inset Formula $S_{1},S_{2},S_{3},S_{4}$
\end_inset

 and 
\begin_inset Formula $S_{5}$
\end_inset

.
\end_layout

\begin_layout Itemize

\series bold
3 relations in the databaset: 
\begin_inset Formula $R,S$
\end_inset

 and 
\begin_inset Formula $T$
\end_inset

.
\end_layout

\begin_layout Itemize

\series bold
Each relation is horizontally fragmented in two fragments (we refer to them
 by the name of the relation and a subindex, for example: 
\begin_inset Formula $R_{1},R_{2}$
\end_inset

).
 You can consider them to be correct (i.e.
 complete, disjoint and reconstructible).
\end_layout

\begin_layout Itemize

\series bold
Each fragment is replicated at all sites.
\end_layout

\begin_layout Itemize

\series bold
We have the following query
\begin_inset Formula 
\[
Q_{1}=\sigma\left(R\right)\Join\sigma\left(S\right)\Join T.
\]

\end_inset


\end_layout

\begin_layout Standard

\series bold
The process tree of the query is:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado7.png
	scale 60

\end_inset


\end_layout

\begin_layout Subsubsection
Consider a left-deep process tree corresponding to a query, where each internal
 node is a join, and every leaf a data source (e.g.
 relational table).
 Knowing that the tree contains 9 nodes (including leaves), the system has
 as much parallelism capacity as needed to run all the joins in pipelining
 mode (no other kind of parallelism is available), which is the occupancy
 if the overall cost of the serial query is 4 seconds? Explicit any assumption
 you need to make.
\end_layout

\begin_layout Subsection
Extra
\end_layout

\begin_layout Subsubsection
Give five types of data or software resourcea that can be usefully shared.
 Give examples of their sharing as it occurs in practice in distributed
 systems.
\end_layout

\begin_layout Subsubsection
How might the clocks in two computers that are linked by a local network
 by synchronized without reference to an external time source? What factors
 limit the accuracy of the procedure you have described? How could the clocks
 in a large number of computers connected by the Internet be synchronized?
 Discuss the accuracy of that procedure.
\end_layout

\begin_layout Subsubsection
Consider the implementation strategies for massively multiplayer online.
 In particular, what advantages do you see in adopting a single server approach
 for representing the state of the multiplayer game? What problems can you
 identify and how might they be resolved?
\end_layout

\begin_layout Subsubsection
A server program wirtten in one language (for example, C++) provides the
 implementation of a BLOB object that is intended to be accessed by clients
 that may be written in a different language (for example, Java).
 The client and server computers may have different harware, but all of
 them are attached to the Internet.
 Describe the problems due to each of the aspects of heterogeneity that
 need to be solved to make it possible for a client object to invoke a method
 on the server object.
\end_layout

\begin_layout Itemize

\series bold
Programming languages:
\end_layout

\begin_layout Itemize

\series bold
Implementations by different developers:
\end_layout

\begin_layout Subsubsection
The INFO service manages a potentially very large set of resources, each
 of which can be accessed by users throughout the Internet by means of a
 key (a string name).
 Discuss an approach to the design of the names of the resources that achieves
 the minimum loss of performance as the number of resources in the service
 increases.
 Suggest how the INFO service can be implemented so as to avoid performance
 bottlenecks when the number of users becomes very large.
\end_layout

\begin_layout Subsubsection
A server process maintains a shared information object such as the BLOB
 object of exercise 2.3.4.
 Give arguments for and against allowing the client requests to be executed
 concurrently by the server.
 In thec ase that they are executed concurrently, give an example of possible
 'interference' that can occur between the operations of different clients.
 Suggest how such interference may be prevented.
\end_layout

\begin_layout Subsubsection
A service is implemented by several servers.
 Explain why resources might be transferred between them.
 Would it be satisfactory for clients to multicast all requests to the group
 of servers as a way of achieving mobility transparency for clients?
\end_layout

\begin_layout Section
Distributed File System
\end_layout

\begin_layout Subsection
Theoretical questions
\end_layout

\begin_layout Subsubsection
How does HDFS decide where to place the different chunks of a file?
\end_layout

\begin_layout Subsection
Problems
\end_layout

\begin_layout Subsubsection
Given a table with ten blocks (
\begin_inset Formula $B=10$
\end_inset

) and 17 tuples per block (
\begin_inset Formula $R=17$
\end_inset

) for a total of 170 tuples, compare the cost of reading the whole table
 sequentially, against the cost of accessing seven random (potentially repeated)
 tuples in an unknown order.
 Assume that seek time is 
\begin_inset Formula $12ms$
\end_inset

, average rotation time is 
\begin_inset Formula $3ms$
\end_inset

 and transferring one block is 
\begin_inset Formula $0.03ms$
\end_inset

.
 You should consider which is the probability that two tuples accessed consecuti
vely are actually in the same block, but ignore the presence of any cache
 or buffer pool mechanism.
\end_layout

\begin_layout Subsubsection
Consider a table stored in HDFS with the following characteristics:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $size\left(T\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
256 MB
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left|T\right|$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
64
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $size\left(row\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 MB
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $cols\left(T\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $size\left(cell\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 MB
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $size\left(Header\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $size\left(Footer\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Enumerate

\series bold
Given the configuration parameters, how much space would you need to store
 it in a horizontal layout (i.e.
 Avro)?
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $size\left(MetaRow\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.1 MB
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $size\left(MetaBody\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.1 MB
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Given the configuration parameters, how much space would you need to store
 it in a hybrid layout (i.e.
 Parquet)?
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $size\left(MetaCol\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.2 MB
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $size\left(MetaRowGroup\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.5 MB
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $size\left(RowGroup\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8 MB
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Given the configuration parameters, how much data would you need to retrieve
 it in a hybrid layout (i.e.
 Parquet) to select one row (e.g.
 given its key) if the table is not sorted?
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $size\left(MetaCol\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.2 MB
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $size\left(MetaRowGroup\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.5 MB
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $size\left(RowGroup\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8 MB
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Subsubsection
Given a file with 
\begin_inset Formula $C$
\end_inset

 chunks and 
\begin_inset Formula $N$
\end_inset

 nodes in the cluster, find the probability that HDFS uses all the nodes
 in case 
\begin_inset Formula $C\geq N$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Consider an HDFS cluster with 100 data nodes, without replication.
 If I upload a file with 10 chunks and 10 disk blocks each, answer the following
 questions and briefly justify your answer.
\end_layout

\begin_layout Enumerate

\series bold
Which is the maximum number of machines actually contain data?
\end_layout

\begin_layout Enumerate

\series bold
Which is the probability of the maximum number of machines actually contain
 data?
\end_layout

\begin_layout Subsubsection
Given a file of 3.2 GB stored in an HDFS cluster of 50 machines, and containing
 
\begin_inset Formula $16\times10^{5}$
\end_inset

 key-value pairs in a SequenceFile, estimate the execution time of a Spark
 job containing a single map transformation and an action storing the result
 in a file.
 Explicit any assumption you make and consider also the following parameters:
\end_layout

\begin_layout Itemize

\series bold
Chunk size: 128 MB (default)
\end_layout

\begin_layout Itemize

\series bold
Replication factor: 3 (default)
\end_layout

\begin_layout Itemize

\series bold
Map function (i.e.
 the parameter of the transformation) execution time: 
\begin_inset Formula $10^{-3}$
\end_inset

 sec/call (this is the only cost you have to consider)
\end_layout

\begin_layout Itemize

\series bold
Save action execution time: 0 sec (do not consider this cost)
\end_layout

\begin_layout Subsubsection
Given a file with 3.2 GB of raw data stored in an HDFS cluster of 50 machines,
 and containing 
\begin_inset Formula $16\times10^{5}$
\end_inset

 rows in a Parquet file; consider you have a query over an attribute 'A=constant
' and this attribute contains only 100 different and equiprobable velues.
 Assuming any kind of compression has been disabled, explicit any assumption
 you need to make and give the amount of raw data (i.e.
 do not count metadata) it would need to fetch from disk.
\end_layout

\begin_layout Itemize

\series bold
Replication factor: 3 (default)
\end_layout

\begin_layout Itemize

\series bold
Chunk size: 128 MB (default)
\end_layout

\begin_layout Itemize

\series bold
RowGroup size: 32 MB
\end_layout

\begin_layout Subsubsection
Consider a cluster of ten worker machines and a single coordinator, which
 contains a sequence file of 128 MB stored in HDFS with an OS block size
 of 32 KB in all machines and a chunk size of 64 MB.
 On the event of a client retrieving that file, give the number of control
 messages (do not consider data messages) that will travel the network in
 the case of (a) a client cache miss and in the case of (b) a client cache
 hit.
 Briefly justigy both numbers.
\end_layout

\begin_layout Section
Key-Value Stores
\end_layout

\begin_layout Subsection
Theoretical questions
\end_layout

\begin_layout Subsubsection
Which is the main difference between the hash functions used in the linear
 hash and consistent hash algorithms?
\end_layout

\begin_layout Subsubsection
With respect to distributed systems, explain what is a distributed hash
 table (DHT), and provide a brief description of how consistent hashing
 guarantees balancing keys when adding new servers.
\end_layout

\begin_layout Subsection
Exercises
\end_layout

\begin_layout Subsubsection
Let's assume we have a Consistent hash with D = 16, and the hash function
 is simply the module of the IP address or the key, and suppose the current
 state of the consistent hash is (position in the ring:key|key|...):
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado8.png
	scale 60

\end_inset


\end_layout

\begin_layout Enumerate

\series bold
What happens when we insert objects 30 and 58? Draw the result.
\end_layout

\begin_layout Enumerate

\series bold
What happens in the structure when we register a new server with IP address
 37? Draw the result.
\end_layout

\begin_layout Subsubsection
Let's suppose we have a Linear Hash and the hash function is simply the
 module of the key, the capacity of a bucket is only four entries, and curent
 state of the linear hash is (bucketID: key|key|...):
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado9.png
	scale 60

\end_inset


\end_layout

\begin_layout Enumerate

\series bold
What happens in the structure when we insert keys 14, 27, 37 and 44? Draw
 the result.
\end_layout

\begin_layout Subsubsection
Let's suppose that we have an LSM Tree that reached the threshold to consider
 the MemStore is full, and it contains four entries with format 
\begin_inset Formula $\left[key,value,timestamp\right]$
\end_inset

 needing 10 characters each.
 the content of the different structures is:
\end_layout

\begin_layout Itemize

\series bold
MemStore: 
\begin_inset Formula $\left[1,v,t50\right],\left[15,v,t49\right],\left[17,v,t47\right],\left[29,v,t48\right]$
\end_inset


\end_layout

\begin_layout Itemize

\series bold
Commit Log: 
\begin_inset Formula $\left[17,v,t47\right],\left[29,v,t48\right],\left[15,v,t49\right],\left[1,v,t50\right]$
\end_inset


\end_layout

\begin_layout Itemize

\series bold
SSTable: 
\begin_inset Formula $\left[13,v,t23\right],\left[25,v,t17\right],\left[35,v,t40\right],\left[59,v,t38\right]$
\end_inset


\end_layout

\begin_layout Itemize

\series bold
Index: 
\begin_inset Formula $\left[13,0\right],\left[25,30\right],\left[35,60\right],\left[59,90\right]$
\end_inset


\end_layout

\begin_layout Standard

\series bold
Assuming that the minimum size of an SSTable is 120 characters and on having
 two SSTables, a minor compactation is automatically triggered.
 Explicit the content of all structures once the compactation is done.
\end_layout

\begin_layout Itemize

\series bold
MemStore:
\end_layout

\begin_layout Itemize

\series bold
Commit Log:
\end_layout

\begin_layout Itemize

\series bold
SSTable:
\end_layout

\begin_layout Itemize

\series bold
Index:
\end_layout

\begin_layout Subsubsection
Briefly explain what is wrong in this linear hash structure, or if you think
 it is right, explicitly say so:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado10.png
	scale 60

\end_inset


\end_layout

\begin_layout Subsubsection
Suppose you have a hash function whose range has size 100 (i.e., D=100), and
 a Consistent Hash structure with 5 machines (M1,...,M5) whose identifiers
 map to values 
\begin_inset Formula $h\left(M1\right)=0,h\left(M2\right)=20,h\left(M3\right)=40,h\left(M4\right)=60$
\end_inset

 and 
\begin_inset Formula $h\left(M5\right)=80$
\end_inset

.
 What happens if you have an object mapped to value 
\begin_inset Formula $h\left(O\right)=90$
\end_inset

?
\end_layout

\begin_layout Subsubsection
Given an empty consistent hash with 
\begin_inset Formula $h\left(x\right)=x\%32$
\end_inset

 (i.e., we directly take module 32 to both the keys and the bucket IDs), and
 unlimited capacity in each bucket, consider you have a cluster of four
 machines with IDs 19,22,75,92 and draw the result of inserting the following
 keys in the given order: 12, 4, 10, 49, 42, 60, 53, 47, 27, 26, 28, 13,
 52.
\end_layout

\begin_layout Subsubsection
Suppose you implement a system to store images in hundreds of machines with
 thousands of users using HBase with a single column-family.
 These images taken at time VT belong to a person P who tags each with a
 single subject S (e.g.
 family, friends, etc.) and are concurrently uploaded into the system at
 time TT in personal batches containing multiple pictures of different subjects
 taken at different times.
 Each person can then retrieve all his/her pictures of one single subject
 taken that were taken after a given time.
 Precisely define the key you would use if you exclusively prioritize (i.e.,
 do not consider any other criteria):
\end_layout

\begin_layout Itemize

\series bold
Load balancing on ingestion:
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
Assumptions made:
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Load balancing on querying:
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
Assumptions made:
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
I/O cost (i.e., minimum blocks retrieved) on ingestion:
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
Assumptions made:
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
I/O cost (i.e., minimum blocks retrieved) on querying:
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
Assumptions made:
\end_layout

\end_deeper
\begin_layout Subsubsection
Given an empty linear hash with 
\begin_inset Formula $f\left(x\right)=x$
\end_inset

 (i.e., we directly apply the module to the keys), and a capacity of four
 keys per bucket, draw the result of inserting the following keys in the
 given order: 12, 4, 10, 49, 42, 60, 63, 53, 47, 27, 26, 28, 13, 52.
\end_layout

\begin_layout Section
Document Stores
\end_layout

\begin_layout Subsection
Problems
\end_layout

\begin_layout Subsubsection
Optimize the performance of the following document design:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

{"_id": 123,
\end_layout

\begin_layout Plain Layout

"name": "Alberto"
\end_layout

\begin_layout Plain Layout

"address": {
\end_layout

\begin_layout Plain Layout

"street": "Jordi Girona",
\end_layout

\begin_layout Plain Layout

"city": "Barcelona",
\end_layout

\begin_layout Plain Layout

"zip_code": "08034"},
\end_layout

\begin_layout Plain Layout

"telephone1": "93 4137889",
\end_layout

\begin_layout Plain Layout

"telephone2": "93 4137840",
\end_layout

\begin_layout Plain Layout

"telephone3": "123456789"
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Optimize the performance of the following pipe:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

db.partsupp.aggregate([
\end_layout

\begin_layout Plain Layout

{"$sort": {"n_name": 1, "s_name": 1, "p_partkey": 1}},
\end_layout

\begin_layout Plain Layout

{"$match": {"part.p_size": 5},
\end_layout

\begin_layout Plain Layout

{"$project": {
\end_layout

\begin_layout Plain Layout

"supplier.s_name": 1,
\end_layout

\begin_layout Plain Layout

"supplier.s_phone": 1,
\end_layout

\begin_layout Plain Layout

"supplier.s_comment": 1,
\end_layout

\begin_layout Plain Layout

"_id": 0
\end_layout

\begin_layout Plain Layout

}}
\end_layout

\begin_layout Plain Layout

])
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Assume you have a MongoDB collection which occupies 6 chunks evenly distributed
 in 3 shards (i.e., 2 chunks per shard).
 Being the document ID also the shard key, the chunk of a document is determined
 by means of a hash function.
 Assuming that accessing one document takes one time unit (existing indexes
 are used at no cost) and we have 6000 documents in the collection, 
\begin_inset Formula $k$
\end_inset

 of which have value 'YYY' for attribute 'other', how many units would take
 the following operations
\begin_inset Foot
status open

\begin_layout Plain Layout
As typically in RDBMS optimizers, assume uniform distribution of values
 and statistical independence between pairs of attributes.
\end_layout

\end_inset

:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $FindOne\left(\left\{ \_id:"XXX"\right\} \right)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $Find\left(\left\{ \_id:\left\{ \$in:\left[1,...,3000\right]\right\} \right\} \right)$
\end_inset

, being 
\begin_inset Formula $\left[1,6000\right]$
\end_inset

 the range of existing IDs.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $Find\left(\left\{ other:"YYY"\right\} \right)$
\end_inset

, being the attribute indexed.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $Find\left(\left\{ other:"YYY\right\} \right)$
\end_inset

, being the attribute not indexed.
\end_layout

\begin_layout Subsubsection
Assume you have a MongoDB collection which occupies 6 chunks unevenly distribute
d in 3 shards (i.e., 1, 2 and 3 chunks per shard, respectively).
 Being the document Id also the shard key, the chunk of a document is determined
 by means of a hash function.
 Assuming that accessing one document takes one time unit (existing indexes
 are used at no cost) and we have 6000 documents in the collection, 
\begin_inset Formula $k$
\end_inset

 of which have value 'YYY' for attribute 'other', how many times units would
 take the following operations
\begin_inset Foot
status open

\begin_layout Plain Layout
As typically in RDBMS optimizers, assume uniform distribution of values
 and statistical independence between pairs of attributes.
\end_layout

\end_inset

:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $FindOne\left(\left\{ \_id:"XXX"\right\} \right)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $Find\left(\left\{ \_id:\left\{ \$in:\left[1,...,3000\right]\right\} \right\} \right)$
\end_inset

, being 
\begin_inset Formula $\left[1,6000\right]$
\end_inset

 the range of existing IDs.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $Find\left(\left\{ other:"YYY"\right\} \right)$
\end_inset

, being the attribute indexed.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $Find\left(\left\{ other:"YYY\right\} \right)$
\end_inset

, being the attribute not indexed.
\end_layout

\begin_layout Subsubsection
Assume you have a MongoDB collection which occupies 6 chunks evenly distributed
 in 3 shards (i.e., 2 chunks per shard).
 Being the document Id also the shard key, the chunk of a document is determined
 by range.
 Assuming that accessing one document takes one time unit (existing indexes
 are used at no cost) and we have 6000 documents in the collection, 
\begin_inset Formula $k$
\end_inset

 of which have value 'YYY' for attribute 'other', how many times units would
 take the following operations
\begin_inset Foot
status open

\begin_layout Plain Layout
As typically in RDBMS optimizers, assume uniform distribution of values
 and statistical independence between pairs of attributes.
\end_layout

\end_inset

:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $FindOne\left(\left\{ \_id:"XXX"\right\} \right)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $Find\left(\left\{ \_id:\left\{ \$in:\left[1,...,3000\right]\right\} \right\} \right)$
\end_inset

, being 
\begin_inset Formula $\left[1,6000\right]$
\end_inset

 the range of existing IDs.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $Find\left(\left\{ other:"YYY"\right\} \right)$
\end_inset

, being the attribute indexed.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $Find\left(\left\{ other:"YYY\right\} \right)$
\end_inset

, being the attribute not indexed.
\end_layout

\begin_layout Subsubsection
Assume a MongoDB collection of JSON documents following the structure shown
 below.
 Indicate a sequence of stage operators that can be used in a pipeline to
 compute the top five departments in terms of number of employees such that
 its location has at least one performance_review greater than 7.
 In the example below, since both locations have performance reviewss greater
 than 7, manufacturing has a total of 90 employees, while billing and sales
 have 80 and 40 employees, respectively.
 You need only to provide the names of the stage operators and the sequence
 in which they are applied.
 You should not use the mapreduce feature of MongoDB, but rather the specific
 stage operators provided by MongoDB.
 You do not need to explicitly handle the case of ties (i.e., in the case
 of ties, you may return any of the tied documents to complete the top five).
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

{ "location": "Barcelona",
\end_layout

\begin_layout Plain Layout

"budget": 3.000.000,
\end_layout

\begin_layout Plain Layout

"departments": [ { "name": "sales", "employees": 40 }, { "name": "manufacturing"
,
\end_layout

\begin_layout Plain Layout

"employees": 75 } ],
\end_layout

\begin_layout Plain Layout

"performance_reviews": [ 7, 6, 3 ]
\end_layout

\begin_layout Plain Layout

},
\end_layout

\begin_layout Plain Layout

{ "location": "Brussels",
\end_layout

\begin_layout Plain Layout

"budget": 5.000.000,
\end_layout

\begin_layout Plain Layout

"departments": [ { "name": "manufacturing", "employees": 15 }, { "name":
 "billing
\end_layout

\begin_layout Plain Layout

", "employees": 80 } ],
\end_layout

\begin_layout Plain Layout

"performance_reviews": [ 6, 8, 7 ]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Imagine you want to design a system to maintain data about citizens and
 doubt whether to use HBase or MongoDB.
 Precisely, for each citizen, it will store: their personal data (with pID),
 their city data (with cID) and their employment data.
 We also know the workload (i.e., queries and frequency of execution) is as
 follows:
\end_layout

\begin_layout Itemize

\series bold
\begin_inset Formula $Q_{1}$
\end_inset

: average salary in Barcelona (50% frequency) - information obtained from
 the set of city and employment data.
\end_layout

\begin_layout Itemize

\series bold
\begin_inset Formula $Q_{2}$
\end_inset

: average weight for you people (less than 18 years old) (45% frequency)
 - information obtained from the set of personal data.
\end_layout

\begin_layout Itemize

\series bold
\begin_inset Formula $Q_{3}$
\end_inset

: number of VIPs (5% frequency) - information obtained from the set of personal
 data.
\end_layout

\begin_layout Standard

\series bold
Discuss your choice of technology and data model, without pre-computing
 the results of the queries.
 Clearly specify the structure of the data (i.e., tables/collections, keys,
 values, etc.), trade-offs, and assumptions made.
\end_layout

\begin_layout Subsubsection
Analyze (i.e., briefly give pros and cons) the following JSON design compared
 to other equivalent JSON designs from the three perspectives:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

"BID-PRODUCT":{
\end_layout

\begin_layout Plain Layout

"B_ID": int(4), "B_PRICE": int(4), "U_ID": int(4),
\end_layout

\begin_layout Plain Layout

"PRODUCT": {
\end_layout

\begin_layout Plain Layout

"P_ID": int(4), "P_INFO": varchar(100)
\end_layout

\begin_layout Plain Layout

}}
\end_layout

\begin_layout Plain Layout

"PRODUCT-SELLER-REGION": {
\end_layout

\begin_layout Plain Layout

"P_ID": int(4), "P_INFO": varchar(100),
\end_layout

\begin_layout Plain Layout

"USER": {
\end_layout

\begin_layout Plain Layout

"U_ID": int(4), "U_F_NAME": varchar(20),
\end_layout

\begin_layout Plain Layout

"REGION": {
\end_layout

\begin_layout Plain Layout

"R_ID": int(4), "R_NAME": varchar(10)
\end_layout

\begin_layout Plain Layout

}}}
\end_layout

\begin_layout Plain Layout

"PRODUCT-COMMENTS": {
\end_layout

\begin_layout Plain Layout

"P_ID": int(4), "P_INFO": varchar(100),
\end_layout

\begin_layout Plain Layout

"COMMENTS": [{
\end_layout

\begin_layout Plain Layout

"C_ID": int(4), "C_TITLE": varchar(20), "U_ID": int(4)
\end_layout

\begin_layout Plain Layout

}]}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate

\series bold
Read (a.k.a Query)
\end_layout

\begin_deeper
\begin_layout Enumerate

\series bold
Pros:
\end_layout

\begin_layout Enumerate

\series bold
Cons:
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Update
\end_layout

\begin_deeper
\begin_layout Enumerate

\series bold
Pros:
\end_layout

\begin_layout Enumerate

\series bold
Cons:
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Memory (a.k.a.
 Space)
\end_layout

\begin_deeper
\begin_layout Enumerate

\series bold
Pros:
\end_layout

\begin_layout Enumerate

\series bold
Cons:
\end_layout

\end_deeper
\begin_layout Section
New Relational Architecture
\end_layout

\begin_layout Subsection
Theoretical questions
\end_layout

\begin_layout Subsubsection
Briefly explain the concept of associativity in the context of memory usage.
 Identify the benefit of high (respectively low) associativity.
\end_layout

\begin_layout Subsection
Problems
\end_layout

\begin_layout Subsubsection
Assume you have a SanssouciuDB table T stored row-wise, which ocupies 300
 blocks and contains tuples with three variable length attributes [
\bar under
A
\bar default
,B,C] (underlined attribute is declared to be the primary key of the table).
 Assume there is no index and give the average cost of each query assuming
 accessing one block is one second.
\end_layout

\begin_layout Itemize

\series bold
SELECT A,B,C FROM T WHERE A=x; (being x a constant)
\end_layout

\begin_layout Itemize

\series bold
SELECT SUM(B) FROM T;
\end_layout

\begin_layout Subsubsection
Assume you have a SanssouciuDB table T stored column-wise, which ocupies
 300 blocks and contains tuples with three variable length attributes [
\bar under
A
\bar default
,B,C] (underlined attribute is declared to be the primary key of the table).
 Assume there is no index, storage of each attribute uses exactly the same
 space after compression (i.e., 100 blocks), and run length encoding has been
 applied for non-key attributes storing ending row position per run.
 Give the average cost of each query assuming accessing one block is one
 second and explicit any other assumption you make.
\end_layout

\begin_layout Itemize

\series bold
SELECT A,B,C FROM T WHERE A=x; (being x a constant)
\end_layout

\begin_layout Itemize

\series bold
SELECT SUM(B) FROM T;
\end_layout

\begin_layout Subsubsection
Assume that there is a table T with attributes [
\bar under
A
\bar default
,B,C] (the underlined attribute is the primary key of the table), which
 occupies 300 disk blocks of 8 KB each, with 100 B per row.
 All three attributes require the same space (even in case of compression).
 Supposing that there is not any index, which would be the minimum amount
 of memory required to process (do not consider the memory required to store
 the final output of the query) the following query in either row storage
 or column storage (briefly justify your answer and explicit any assumption
 you make).
\end_layout

\begin_layout Standard

\series bold
SELECT A FROM T WHERE B='x' and C='y';
\end_layout

\begin_layout Itemize

\series bold
Row storage:
\end_layout

\begin_layout Itemize

\series bold
Column storage:
\end_layout

\begin_layout Subsubsection
Without considering compression and assuming a disk block size of 8 KB,
 is there any case where a query retrieving all tuples, but only half of
 the equally-sized attributes of a relaitonal table performs better in row
 storage without any kind of vertical partitioning than in columnar storage?
 Numerically justify your answer.
\end_layout

\begin_layout Subsubsection
Represent the given column with dictionary and run-length encoding storing
 and row position.
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Table
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Dictionary
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
End Row
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Code
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection
Given the two columns of a table represented with run-length encoding using
 dictionary, give the position of the row(s) that fulfill the predicate
 
\begin_inset Quotes eld
\end_inset

Charlie AND Beta
\begin_inset Quotes erd
\end_inset

.
 Briefly explain how a column store would obtain them.
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="8cm">
<column alignment="center" valignment="top" width="8cm">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Dictionary
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bravo
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Charlie
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Values
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Dictionary Positions
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Dictionary
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Alpha
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Beta
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Values
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Dictionary Positions
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Section
Distributed Processing Frameworks
\end_layout

\begin_layout Subsection
MapReduce in use: Theoretical questions
\end_layout

\begin_layout Subsubsection
Classify a MapReduce system as either query-shipping (i.e., the evaluation
 of the query is delegated to the site where the data is stored), data-shipping
 (i.e., the data is moved from the stored site to the site executing the query)
 or hybrid (i.e., both query and data shipping).
 Clearly justify your answer.
\end_layout

\begin_layout Subsection
MapReduce in use: Problems
\end_layout

\begin_layout Subsubsection
Consider the following implementation of the Cartesian Product with MapReduce
 (
\begin_inset Formula $\oplus$
\end_inset

 stands for concatenation) and answer the questions accordingly:
\begin_inset Formula 
\[
T\times S\implies\begin{cases}
map\left(key\ k,value\ v\right)\mapsto\\
\left[\left(h_{T}\left(k\right)\ \mod D,k\oplus v\right)\right] & if\ input\left(k\oplus v\right)=T\\
\left[\left(0,k\oplus v,...,\left(D-1,k\oplus v\right)\right)\right] & if\ input\left(k\oplus v\right)=S\\
reduce\left(key\ ik,vset\ ivs\right)\mapsto\\
\left[\begin{array}{c}
crossproduct\left(T_{ik},S\right)|\\
T_{ik}=\left\{ iv|iv\in ivs\land input\left(iv\right)T\right\} ,\\
S=\left\{ iv|iv\in ivs\land input\left(iv\right)S\right\} 
\end{array}\right]
\end{cases}.
\]

\end_inset


\end_layout

\begin_layout Enumerate

\series bold
Which is the relationship of 
\begin_inset Formula $D$
\end_inset

 with parallelism and scalability, if any?
\end_layout

\begin_layout Enumerate

\series bold
Which is the optimal value for 
\begin_inset Formula $D$
\end_inset

?
\end_layout

\begin_layout Subsubsection
Provide the MapReduce pseudo-code implementation of the following relational
 operators.
 You can use 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\oplus$
\end_inset


\begin_inset Quotes erd
\end_inset

 symbol for concatenation, 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $prj_{a_{i_{1}}...a_{i_{n}}}\left(t\right)$
\end_inset


\begin_inset Quotes erd
\end_inset

 to get attributes 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $a_{i_{1}}...a_{i_{n}}$
\end_inset


\begin_inset Quotes erd
\end_inset

 in 
\begin_inset Formula $t$
\end_inset

, 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $crossproduct\left(S_{1},S_{2}\right)$
\end_inset


\begin_inset Quotes erd
\end_inset

 to perform the cross product of two sets of rows, and assume the 
\begin_inset Quotes eld
\end_inset

key
\begin_inset Quotes erd
\end_inset

 parameter contains the PL of the table and the 
\begin_inset Quotes eld
\end_inset

value
\begin_inset Quotes erd
\end_inset

 one all the others.
\end_layout

\begin_layout Itemize

\series bold
Aggregation (
\begin_inset Formula $\gamma_{A,f\left(B\right)}\left(T\right)$
\end_inset

)
\end_layout

\begin_layout Itemize

\series bold
Selection (
\begin_inset Formula $\sigma_{P}\left(T\right)$
\end_inset

)
\end_layout

\begin_layout Itemize

\series bold
Join (
\begin_inset Formula $T\bowtie_{T.A=S.B}S$
\end_inset

)
\end_layout

\begin_layout Itemize

\series bold
Union (
\begin_inset Formula $T\cup S$
\end_inset

)
\end_layout

\begin_layout Itemize

\series bold
Difference (
\begin_inset Formula $T\setminus S$
\end_inset

)
\end_layout

\begin_layout Itemize

\series bold
Intersection (
\begin_inset Formula $T\cap S$
\end_inset

)
\end_layout

\begin_layout Subsubsection
In relational algebra, the antijoin operator (
\begin_inset Formula $\triangleright$
\end_inset

) is defined as the complement of the semijoin on the primary keys (PKs).
 Formally, assuming 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 are the PLs of 
\begin_inset Formula $R$
\end_inset

 and 
\begin_inset Formula $S$
\end_inset

, respectively, then
\begin_inset Formula 
\[
R\triangleright S=R\setminus R\ltimes{}_{A=B}S
\]

\end_inset

 Provide the MapReduce pseudo-code implementation of the antijoin operator.
 Assume the existence of the operator 
\begin_inset Formula $\oplus$
\end_inset

 to concatenate strings, 
\begin_inset Formula $prj_{att}\left(s\right)$
\end_inset

 to project attribute 
\begin_inset Formula $att$
\end_inset

 from the tuple 
\begin_inset Formula $s$
\end_inset

, and 
\begin_inset Formula $input\left(s\right)$
\end_inset

 to decide the origin (i.e., 
\begin_inset Formula $R$
\end_inset

 or 
\begin_inset Formula $S$
\end_inset

) from a tuple 
\begin_inset Formula $s$
\end_inset

.
\end_layout

\begin_layout Subsection
MapReduce internals: Problems
\end_layout

\begin_layout Subsubsection
Assume the following MapReduce program:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++}"
inline false
status open

\begin_layout Plain Layout

public void map(LongWritable key, Text value) {
\end_layout

\begin_layout Plain Layout

String line = value.toString();
\end_layout

\begin_layout Plain Layout

StringTokenizer tokenizer = new StringTokenizer(line);
\end_layout

\begin_layout Plain Layout

while (tokenizer.hasMoreTokens()) {
\end_layout

\begin_layout Plain Layout

write(new Text(tokenizer.nextToken()), new IntWritable(1));
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

public void reduce(Text key, Iterable<IntWritable> values) {
\end_layout

\begin_layout Plain Layout

int sum = 0;
\end_layout

\begin_layout Plain Layout

for (IntWritable val : values) {
\end_layout

\begin_layout Plain Layout

sum += val.get();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

write(key, new IntWritable(sum));
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Consider the following dataset:
\end_layout

\begin_layout Itemize

\series bold
Block0: 
\begin_inset Quotes eld
\end_inset

a b b a c | c d c e a
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize

\series bold
Block1: 
\begin_inset Quotes eld
\end_inset

a b d d a | b b c c d
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Subsubsection*
Simulate the execution of the MapReduce code given the following configuration:
\end_layout

\begin_layout Itemize

\series bold
The map and reduce functions are those of the wordcount.
 The combine function shares the implementation of the reduce.
\end_layout

\begin_layout Itemize

\series bold
One Split is one block.
\end_layout

\begin_layout Itemize

\series bold
The 
\begin_inset Quotes eld
\end_inset

|
\begin_inset Quotes erd
\end_inset

 divides the records inside each block.
 We have two records per block.
\end_layout

\begin_layout Itemize

\series bold
Hadoop is configured with the parameter 
\begin_inset Formula $dfs.replication=1$
\end_inset

.
\end_layout

\begin_layout Itemize

\series bold
We can keep four pairs [key, value] per spill
\end_layout

\begin_layout Itemize

\series bold
We have two mappers and two reducers:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $Machine0$
\end_inset

 
\series bold
contains block0, runs mapper0 and reducer0
\end_layout

\begin_layout Itemize
\begin_inset Formula $Machine1$
\end_inset

 
\series bold
contains block1, runs mapper1 and reducer1
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
The hash functions used to shuffle data to the reducers uses the correspondence:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\left\{ b,d,f\right\} \rightarrow0$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left\{ a,c,e\right\} \rightarrow1$
\end_inset


\end_layout

\end_deeper
\begin_layout Subsubsection*
Fill the gaps in each step (numbers correspond to the phase in the MapReduce
 algorithm):
\end_layout

\begin_layout Enumerate
\begin_inset Formula $Machine0$
\end_inset

 
\series bold
contains
\series default
 
\series bold
...
 block(s).
 
\begin_inset Formula $Machine1$
\end_inset

 contains ...
 block(s).
\end_layout

\begin_layout Enumerate

\series bold
We keep ...
 replica(s) (including the master copy) per block.
\end_layout

\begin_layout Enumerate

\series bold
We have ...
 split(s) per machine.
\end_layout

\begin_layout Enumerate

\series bold
Mapper0 reads ...
 records.
 Mapper1 reads ...
 records.
\end_layout

\begin_layout Enumerate

\series bold
Memory content during each spill in 
\begin_inset Formula $Machine0$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Spill1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Spill2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Spill3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Spill4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[][][][]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[][][][]
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard

\series bold
Spills in 
\begin_inset Formula $Machine1$
\end_inset

:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Spill1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Spill2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Spill3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Spill4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[][][][]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[][][][]
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Three substeps:
\end_layout

\begin_deeper
\begin_layout Enumerate

\series bold
Partitions in 
\begin_inset Formula $Machine0$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="6">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Spill1
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Spill2
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Spill3
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Partition0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Partition1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Partition0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Partition1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Partition0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Partition1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard

\series bold
Partitions in 
\begin_inset Formula $Machine1$
\end_inset

:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="6">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Spill1
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Spill2
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Spill3
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Partition0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Partition1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Partition0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Partition1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Partition0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Partition1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Partitions in 
\begin_inset Formula $Machine0$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="6">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Spill1
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Spill2
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Spill3
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Partition0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Partition1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Partition0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Partition1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Partition0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Partition1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard

\series bold
Partitions in 
\begin_inset Formula $Machine1$
\end_inset

:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="6">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Spill1
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Spill2
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Spill3
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Partition0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Partition1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Partition0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Partition1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Partition0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Partition1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Files in 
\begin_inset Formula $Machine0$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File0.0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File0.1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File0.2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File0.3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File0.4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File0.5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard

\series bold
Files in 
\begin_inset Formula $Machine1$
\end_inset

:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File1.0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File1.1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File1.2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File1.3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File1.4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File1.5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate

\series bold
Merges in 
\begin_inset Formula $Machine0$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Merge0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Merge1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] [] []
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard

\series bold
Merges in 
\begin_inset Formula $Machine1$
\end_inset

:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Merge0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Merge1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] [] []
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Files in 
\begin_inset Formula $Machine0$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File0.0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File0.1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] [] []
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard

\series bold
Files in 
\begin_inset Formula $Machine1$
\end_inset

:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File1.0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File1.1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] [] []
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Reducer0 reads ...
 from 
\begin_inset Formula $Machine0$
\end_inset

 and ...
 from 
\begin_inset Formula $Machine1$
\end_inset

.
 Reducer1 reads ...
 from 
\begin_inset Formula $Machine0$
\end_inset

 and ...
 from 
\begin_inset Formula $Machine1$
\end_inset

.
\end_layout

\begin_layout Enumerate

\series bold
Merges in 
\begin_inset Formula $Machine0$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Merge0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Merge1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] [] []
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard

\series bold
Merges in 
\begin_inset Formula $Machine1$
\end_inset

:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Merge0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Merge1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] [] []
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Reduce function is executed ...
 times in 
\begin_inset Formula $Machine0$
\end_inset

.
 Reduce function is executed ...
 times in 
\begin_inset Formula $Machine1$
\end_inset

.
\end_layout

\begin_layout Enumerate

\series bold
Files in 
\begin_inset Formula $Machine0$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Output0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] [] []
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard

\series bold
Files in 
\begin_inset Formula $Machine1$
\end_inset

:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Output1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] [] []
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Subsubsection
Let's suppose that we have a cluster of 100 machines and a MapReduce job
 with 1 000 000 key-value pairs in the input that generate 100 000 pairs
 in the output.
 Assume that both map and reduce functions generate one pair in the output
 per call.
 Assuming the reduce function is commutative and associative, is it worth
 to use the combine function? Briefly justify your answer.
\end_layout

\begin_layout Subsection
Spark in use: Problems
\end_layout

\begin_layout Subsubsection
Consider a file (
\begin_inset Formula $wines.txt$
\end_inset

) containing the following data:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

wines.txt
\end_layout

\begin_layout Plain Layout

type 1,2.064254
\end_layout

\begin_layout Plain Layout

type 3,2.925376
\end_layout

\begin_layout Plain Layout

type 2,2.683955
\end_layout

\begin_layout Plain Layout

type 1,2.991452
\end_layout

\begin_layout Plain Layout

type 2,2.861996
\end_layout

\begin_layout Plain Layout

type 1,2.727688
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Provide the ordered list of Spark operations (no need to follow the exact
 syntax, just the kind of operation and main parameters) you'd need to retrieve
 the minimum value per type.
 Do not use SQL and minimize the use of other Python libraries or code.
 Save the results in 
\begin_inset Formula $output.txt$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Consider two files containing the following data:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Employees.txt
\end_layout

\begin_layout Plain Layout

EMP1;CARME;400000;MATARO;DPT1
\end_layout

\begin_layout Plain Layout

EMP2;EUGENIA;350000;TOLEDO;DPT2
\end_layout

\begin_layout Plain Layout

EMP3;JOSEP;250000;SITGES;DPT3
\end_layout

\begin_layout Plain Layout

EMP4;RICARDO;250000;MADRID;DPT4
\end_layout

\begin_layout Plain Layout

EMP5;EULALIA;150000;BARCELONA;DPT5
\end_layout

\begin_layout Plain Layout

EMP6;MIQUEL;125000;BADALONA;DPT5
\end_layout

\begin_layout Plain Layout

EMP7;MARIA;175000;MADRID;DPT6
\end_layout

\begin_layout Plain Layout

EMP8;ESTEBAN;150000;MADRID;DPT6
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Departments.txt
\end_layout

\begin_layout Plain Layout

DPT1;DIRECCIO;10;PAU CLARIS;BARCELONA
\end_layout

\begin_layout Plain Layout

DPT2;DIRECCIO;8;RIOS ROSAS;MADRID
\end_layout

\begin_layout Plain Layout

DPT3;MARKETING;1;PAU CLARIS;BARCELONA
\end_layout

\begin_layout Plain Layout

DPT4;MARKETING;3;RIOS ROSAS;MADRID
\end_layout

\begin_layout Plain Layout

DPT5;VENDES;1;MUNTANER;BARCELONA
\end_layout

\begin_layout Plain Layout

DPT6;VENDES;1;CASTELLANA;MADRID
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Provide the ordered list of Spark operations (no need to follow the exact
 syntax, just the kind of operation and main parameters) you'd need to retrieve
 for each employee his/her department information.
 Do not use SQL and minimize the use of other Python libraries or code.
 Save the results in 
\begin_inset Formula $output.txt$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Consider an error log file (
\begin_inset Formula $log.txt$
\end_inset

) like the one below:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

log.txt
\end_layout

\begin_layout Plain Layout

20150323;0833;ERROR;Oracle
\end_layout

\begin_layout Plain Layout

20150323;0835;WARNING;MySQL
\end_layout

\begin_layout Plain Layout

20150323;0839;WARNING;MySQL
\end_layout

\begin_layout Plain Layout

20150323;0900;WARNING;Oracle
\end_layout

\begin_layout Plain Layout

20150323;0905;ERROR;MySQL
\end_layout

\begin_layout Plain Layout

20150323;1013;OK;Oracle
\end_layout

\begin_layout Plain Layout

20150323;1014;OK;MySQL
\end_layout

\begin_layout Plain Layout

20150323;1055;ERROR;Oracle
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Provide the ordered list of Spark operations (no need to follow the exact
 syntax, just the kind of operation and main parameters) you'd need to retrieve
 the lines corresponding to both 
\begin_inset Formula $errors$
\end_inset

 and 
\begin_inset Formula $warnings$
\end_inset

, but adding 
\begin_inset Formula $Important:$
\end_inset

 at the begginning of those of 
\begin_inset Formula $errors$
\end_inset

 (i.e., only 
\begin_inset Formula $errors$
\end_inset

).
 Do not use SQL and minimize the use of other Python libraries or code.
 Save the results in 
\begin_inset Formula $output.txt$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Given two files contianing the following kinds of data:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Employees.txt with fields: 
\end_layout

\begin_layout Plain Layout

	EmployeeID; EmployeeName; YearlySalary; CityOfResidence; SiteOfWork
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	EMP4;RICARDO;250000;MADRID;DPT4
\end_layout

\begin_layout Plain Layout

	EMP5;EULALIA;150000;BARCELONA;DPT5
\end_layout

\begin_layout Plain Layout

	EMP6;MIQUEL;125000;BADALONA;DPT5
\end_layout

\begin_layout Plain Layout

	EMP7;MARIA;175000;MADRID;DPT6
\end_layout

\begin_layout Plain Layout

	EMP8;ESTEBAN;150000;MADRID;DPT6
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Departments.txt with fields: 
\end_layout

\begin_layout Plain Layout

	SiteID; DepartmentName; StreetNumber; StreetName; City
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	DPT1;DIRECCIO;10;PAU CLARIS;BARCELONA
\end_layout

\begin_layout Plain Layout

	DPT2;DIRECCIO;8;RIOS ROSAS;MADRID
\end_layout

\begin_layout Plain Layout

	DPT3;MARKETING;1;PAU CLARIS;BARCELONA
\end_layout

\begin_layout Plain Layout

	DPT4;MARKETING;3;RIOS ROSAS;MADRID
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Consider the following PySpark code and answer the questions below:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Python"
inline false
status open

\begin_layout Plain Layout

source1 = spark.read.format("csv").load("employees.txt", header='false', inferSchema
='true', sep=";")
\end_layout

\begin_layout Plain Layout

source2 = spark.read.format("csv").load("departments.txt", header='false', inferSche
ma='true', sep=";")
\end_layout

\begin_layout Plain Layout

A = source1.toDF("eID","eName","eSalary","eCity","eDpt","eProj")
\end_layout

\begin_layout Plain Layout

B = source2.toDF("dID","dArea","dNumber","dStreet","dCity")
\end_layout

\begin_layout Plain Layout

C = A.select(A.eCity.alias("city"))
\end_layout

\begin_layout Plain Layout

D = B.select("dArea")
\end_layout

\begin_layout Plain Layout

E = D.crossJoin(C)
\end_layout

\begin_layout Plain Layout

F = B.select("dArea",B.dCity.alias("city"))
\end_layout

\begin_layout Plain Layout

G = E.subtract(F)
\end_layout

\begin_layout Plain Layout

H = G.select("dArea")
\end_layout

\begin_layout Plain Layout

result = D.subtract(H)
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate

\series bold
State in natural language the corresponding query it would answer.
\end_layout

\begin_layout Enumerate

\series bold
Clearly indicate any mistake or improvement you can fix/make in the code.
 For each of them give (1) the line number, (2) pseudo-code to implement
 the fix, and (3) brief rationale.
\end_layout

\begin_layout Subsubsection
Given two files containing the following kinds of data:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Employees.txt with fields: 
\end_layout

\begin_layout Plain Layout

	EmployeeID; EmployeeName; YearlySalary; CityOfResidence; SiteOfWork
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	EMP1;RICARDO;250000;MADRID;DPT1
\end_layout

\begin_layout Plain Layout

	EMP2;EULALIA;150000;BARCELONA;DPT2
\end_layout

\begin_layout Plain Layout

	EMP3;MIQUEL;125000;BADALONA;DPT3
\end_layout

\begin_layout Plain Layout

	EMP4;MARIA;175000;MADRID;DPT4
\end_layout

\begin_layout Plain Layout

	EMP5;ESTEBAN;150000;MADRID;DPT3
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

Departments.txt with fields: 
\end_layout

\begin_layout Plain Layout

	SiteID; DepartmentName; StreetNumber; StreetName; City
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	DPT1;DIRECCIO;10;PAU CLARIS;BARCELONA
\end_layout

\begin_layout Plain Layout

	DPT2;DIRECCIO;8;RIOS ROSAS;MADRID
\end_layout

\begin_layout Plain Layout

	DPT3;MARKETING;1;PAU CLARIS;BARCELONA
\end_layout

\begin_layout Plain Layout

	DPT4;MARKETING;3;RIOS ROSAS;MADRID
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Give a sequence of Spark operations in pseudo-code (resembling PySpark)
 to obtain for each city where employees that work in a site of a department
 in Barcelona live, the sum of the salaries of those employees.
 The result for the exemplary data would be:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MADRID;400000
\end_layout

\begin_layout Plain Layout

BARCELONA;125000
\end_layout

\begin_layout Plain Layout

...
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Conider three files containing the following kinds of data:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Employees.txt
\end_layout

\begin_layout Plain Layout

	EMP1,CARME,400000,MATARO,DEPT1,PROJ1
\end_layout

\begin_layout Plain Layout

	EMP2,EULALIA,150000,BARCELONA,DEPT2,PROJ1
\end_layout

\begin_layout Plain Layout

	EMP3,MIQUEL,125000,BADALONA,DEPT1,PROJ3
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Projects.txt
\end_layout

\begin_layout Plain Layout

	PROJ1,IBDTEL,TV,1000000
\end_layout

\begin_layout Plain Layout

	PROJ2,IBDVID,VIDEO,500000
\end_layout

\begin_layout Plain Layout

	PROJ3,IBDTEF,TELEPHONE,200000
\end_layout

\begin_layout Plain Layout

	PROJ4,IBDCOM,COMMUNICATIONS,2000000
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Departments.txt
\end_layout

\begin_layout Plain Layout

	DEPT1,MANAGEMENT,10,PAU CLARIS,BARCELONA
\end_layout

\begin_layout Plain Layout

	DEPT2,MANAGEMENT,8,RIOS ROSAS,MADRID
\end_layout

\begin_layout Plain Layout

	DEPT4,MARKETING,3,RIOS ROSAS,MADRID
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Provide the ordered list of Spark operations (no need to follow the exact
 syntax, but just the kind of operation and main parameters) you would need
 to obtain the departments with all employees assigned to the same prooject.
 The result must include department number.
 Save the results in 
\begin_inset Formula $output.txt$
\end_inset

.
 In the previous example, the result should be 
\begin_inset Formula $DEPT2$
\end_inset

 and 
\begin_inset Formula $DEPT4$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Consider two files containing the following kinds of data:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Employees.txt
\end_layout

\begin_layout Plain Layout

	EMP4;RICARDO;250000;MADRID;DPT4
\end_layout

\begin_layout Plain Layout

	EMP5;EULALIA;150000;BARCELONA;DPT5
\end_layout

\begin_layout Plain Layout

	EMP6;MIQUEL;125000;BADALONA;DPT5
\end_layout

\begin_layout Plain Layout

	EMP7;MARIA;175000;MADRID;DPT6
\end_layout

\begin_layout Plain Layout

	EMP8;ESTEBAN;150000;MADRID;DPT6
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Departments.txt
\end_layout

\begin_layout Plain Layout

	DPT1;DIRECCIO;10;PAU CLARIS;BARCELONA
\end_layout

\begin_layout Plain Layout

	DPT2;DIRECCIO;8;RIOS ROSAS;MADRID
\end_layout

\begin_layout Plain Layout

	DPT3;MARKETING;1;PAU CLARIS;BARCELONA
\end_layout

\begin_layout Plain Layout

	DPT4;MARKETING;3;RIOS ROSAS;MADRID
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Provide the ordered list of Spark operations (no need to follow the exact
 syntax, but just the kind of operation and main parameters) you'd need
 to retrieve the list of department IDs for those departments with workers
 from all cities where there are employees.
 Save the results in 
\begin_inset Formula $output.txt$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Consider two files containing the following kinds of data:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Employees.txt
\end_layout

\begin_layout Plain Layout

	EMP1;RICARDO;250000C;MADRID;SITE2
\end_layout

\begin_layout Plain Layout

	EMP2;EULALIA;150000C;BARCELONA;SITE1
\end_layout

\begin_layout Plain Layout

	EMP3;MIQUEL;125000C;BADALONA;SITE3
\end_layout

\begin_layout Plain Layout

	EMP4;MARIA;175000C;MADRID;SITE2
\end_layout

\begin_layout Plain Layout

	EMP5;ESTEBAN;150000C;MADRID;SITE4
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Departments.txt
\end_layout

\begin_layout Plain Layout

	SITE1;DPT.MANAGEMENT;FLOOR10;ST.PAU CLARIS;BARCELONA
\end_layout

\begin_layout Plain Layout

	SITE2;DPT.MANAGEMENT;FLOOR8;ST.RIOS ROSAS;MADRID
\end_layout

\begin_layout Plain Layout

	SITE3;DPT.MARKETING;FLOOR1;ST.PAU CLARIS;BARCELONA
\end_layout

\begin_layout Plain Layout

	SITE4;DPT.MARKETING;FLOOR1;ST.RIOS ROSAS;MADRID
\end_layout

\begin_layout Plain Layout

	SITE5;DPT.MARKETING;FLOOR5;ST.MARTI PUJOL;BADALONA
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Provide the ordered list of Spark operations (no need to follow the exact
 syntax, but just the kind of operation and main parameters) you'd need
 to retrieve the list of department IDs for those departments with sites
 in all cities where employees live (these employees can be even from other
 departments).
 Save the results in 
\begin_inset Formula $output.txt$
\end_inset

.
 In the previous example, the result should be 
\begin_inset Formula $DPT.MARKETING$
\end_inset

, because it has sites in all the three cities where there are employees
 (i.e., MADRID, BARCELONA and BADALONA).
 However, 
\begin_inset Formula $DPT.MANAGEMENT$
\end_inset

 should not be in the result, because it does not have any site in BADALONA,
 where EMP3 lives.
\end_layout

\begin_layout Subsubsection
Consider three files relating to a bibliographic database: 
\begin_inset Formula $author.csv$
\end_inset

 relates authors with papers (you may assume that author names are unique,
 that authors have one or more papers, and that papers have one or more
 authors); 
\begin_inset Formula $title.csv$
\end_inset

 gives the title of a paper (you may assume a paper has one title, but one
 title may be shared by many papers); and 
\begin_inset Formula $citation.csv$
\end_inset

 indicates which papers cite which other papers (you may assume that each
 paper cites at least one other paper, that a paper may be cited or more
 times, and that a paper cannot cite itself).
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

author.csv
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

AUTHOR			PAPERID
\end_layout

\begin_layout Plain Layout

...
   			...
\end_layout

\begin_layout Plain Layout

C.
 Gutierrez		GP2014
\end_layout

\begin_layout Plain Layout

C.
 Gutierrez		AGP2013
\end_layout

\begin_layout Plain Layout

C.
 Gutierrez		GZ2011
\end_layout

\begin_layout Plain Layout

...				...
\end_layout

\begin_layout Plain Layout

J.
 Perez			GP2014
\end_layout

\begin_layout Plain Layout

J.
 Perez			AGP2013
\end_layout

\begin_layout Plain Layout

J.
 Perez			P2017
\end_layout

\begin_layout Plain Layout

...				...
\end_layout

\begin_layout Plain Layout

R.
 Angles			AGP2013
\end_layout

\begin_layout Plain Layout

R.
 Angles			AKK2016
\end_layout

\begin_layout Plain Layout

...				...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

title.csv
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

PAPERID			TITLE
\end_layout

\begin_layout Plain Layout

...
 				...
\end_layout

\begin_layout Plain Layout

GP2014 			Semantics of SPARQL
\end_layout

\begin_layout Plain Layout

AGP2013 			Deduction for RDF
\end_layout

\begin_layout Plain Layout

GZ2011 			Graph databases
\end_layout

\begin_layout Plain Layout

...
 				...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

citation.csv
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

PAPER 			CITES
\end_layout

\begin_layout Plain Layout

...
 			...
\end_layout

\begin_layout Plain Layout

GP2014 			AGP2013
\end_layout

\begin_layout Plain Layout

AGP2013 			GZ2011
\end_layout

\begin_layout Plain Layout

P2017 			AKK2016
\end_layout

\begin_layout Plain Layout

...
 			...
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
The count of self-citations for an author 
\begin_inset Formula $A$
\end_inset

, denoted 
\begin_inset Formula $self\left(A\right)$
\end_inset

, is defined as the number of citation pairs 
\begin_inset Formula $\left(P_{1},P_{2}\right)$
\end_inset

 where 
\begin_inset Formula $A$
\end_inset

 is the author of both.
 The count of citations given by an author 
\begin_inset Formula $A$
\end_inset

, denoted 
\begin_inset Formula $give\left(A\right)$
\end_inset

, is the count of citation pairs 
\begin_inset Formula $\left(P_{1},P_{2}\right)$
\end_inset

 such that 
\begin_inset Formula $A$
\end_inset

 is an author of 
\begin_inset Formula $P_{1}$
\end_inset

.
 The count of citations received by 
\begin_inset Formula $A$
\end_inset

, denoted 
\begin_inset Formula $receive\left(A\right)$
\end_inset

, is the count of citation pairs 
\begin_inset Formula $\left(P_{1},P_{2}\right)$
\end_inset

 where 
\begin_inset Formula $A$
\end_inset

 is an author of 
\begin_inset Formula $P_{2}$
\end_inset

.
 The ratio of self-citations to all citations given and received are then
 defined, respectively, as 
\begin_inset Formula $\frac{self\left(A\right)}{give\left(A\right)}$
\end_inset

 and 
\begin_inset Formula $\frac{self\left(A\right)}{receive\left(A\right)}$
\end_inset

.
 In case that 
\begin_inset Formula $receive\left(A\right)=0$
\end_inset

, you should omit the author 
\begin_inset Formula $A$
\end_inset

 from the results (note that 
\begin_inset Formula $give\left(A\right)$
\end_inset

 cannot be 0, as an author must have at least one paper, and a paper must
 have at least one citation).
 We provide an example output for the input data:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
AUTHOR
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SELFGIVERATIO
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SELFRECEIVERATIO
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C.
 Gutierrez
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1.000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1.000
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
J.
 Perez
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.333
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1.000
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
R.
 Angles
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.000
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard

\series bold
We will use Apache Spark to perform the analysis and compute the output.
 You should not assume any ordering of the input files.
 You do not need to order the output file in any particular way.
\end_layout

\begin_layout Standard

\series bold
Given this input and desired output, design a Spark process to complete
 the required processing.
 In particular, you should draw the high-level DAG of operations that the
 Spark process will perform, detailing the sequence of transformations and
 actions.
 You should briefly describe what each step does, clearly indicating which
 steps are transformations and which are actions.
 You should also indicate which RDDs are cirtual and which will be materialized.
 You should use caching if appropriate.
 You should provide details on any functions passed as arguments to the
 transformations/actions you use.
\end_layout

\begin_layout Subsection
Spark internals: Theoretical questions
\end_layout

\begin_layout Subsubsection
What indicates to Spark query optimizer the end of a stage and the beginning
 of the next one?
\end_layout

\begin_layout Subsection
Spark internals: Problems
\end_layout

\begin_layout Subsubsection
Considering the file and result example, briefly indicate the problems you
 find in the Spark code below (if any), and modify the code to fix them
 (if needed).
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Employees.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	EMP1;CARME;40000;MATARO;DPT1;PROJ1
\end_layout

\begin_layout Plain Layout

	EMP2;EUGENIA;35000;TOLEDO;DPT2;PROJ1
\end_layout

\begin_layout Plain Layout

	EMP3;JOSEP;25000;SITGES;DPT3;PROJ2
\end_layout

\begin_layout Plain Layout

	EMP4;RICARDO;25000;MADRID;DPT4;PROJ2
\end_layout

\begin_layout Plain Layout

	EMP5;EULALIA;15000;BARCELONA;DPT5;PROJ2
\end_layout

\begin_layout Plain Layout

	EMP6;MIQUEL;12500;BADALONA;DPT5;PROJ3
\end_layout

\begin_layout Plain Layout

	EMP7;MARIA;17500;MADRID;DPT6;PROJ3
\end_layout

\begin_layout Plain Layout

	EMP8;ESTEBAN;15000;MADRID;DPT6;PROJ3
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Expected result
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[ PROJ1,[ EUGENIA, 35000, 37500.0 ] ]
\end_layout

\begin_layout Plain Layout

[ PROJ2,[ EULALIA, 15000, 21666.6 ] ]
\end_layout

\begin_layout Plain Layout

[ PROJ3,[ MIQUEL, 12500, 15000.0 ] ]
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

rawEmps = sc.textFile(r"Employees.txt")
\end_layout

\begin_layout Plain Layout

emps = rawEmps.map(lambda l: tuple(l.split(";"))).cache()
\end_layout

\begin_layout Plain Layout

RDD1 = emps.map(lambda t: (t[5], (int(t[2]), 1)))
\end_layout

\begin_layout Plain Layout

RDD2 = RDD1.reduceByKey(lambda t1, t2: (t1[0] + t2[0])/(t1[1] + t2[1]))
\end_layout

\begin_layout Plain Layout

RDD3 = emps.map(lambda t: (t[5], t))
\end_layout

\begin_layout Plain Layout

RDD4 = RDD3.join(RDD2)
\end_layout

\begin_layout Plain Layout

RDD5 = RDD4.filter(lambda t: int(t[1][0][2])<t[1][1])
\end_layout

\begin_layout Plain Layout

RDD6 = RDD5.map(lambda t: (t[0],(t[1][0][1],t[1][0][2],t[1][1])))
\end_layout

\begin_layout Plain Layout

Result = RDD6.sortByKey()
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Consider the following pipeline.
 This pipeline runs in a 4-machine cluster with HDFS to store the files
 and Spark to execute it.
 
\begin_inset Formula $File1$
\end_inset

 and 
\begin_inset Formula $File2$
\end_inset

 are distributed in the cluster in 6 chunks each.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

RddF1 := sc.textFile(”...file1.txt”)
\end_layout

\begin_layout Plain Layout

RddF2 := sc.textFile(”...file2.txt”)
\end_layout

\begin_layout Plain Layout

Rdd2 := RddF1.mapToPair(s.split(”;”)[0],s.split(”;”)[1−2])
\end_layout

\begin_layout Plain Layout

Rdd3 := Rdd2.GroupByKey()
\end_layout

\begin_layout Plain Layout

Rdd4 := Rdd3.MapValues(f1)
\end_layout

\begin_layout Plain Layout

Rdd5 := RddF2.mapToPair(s.split(”;”)[0],s.split(”;”)[1−2])
\end_layout

\begin_layout Plain Layout

Rdd6 := Rdd5.GroupByKey()
\end_layout

\begin_layout Plain Layout

Rdd7 := Rdd6.MapValues(f2)
\end_layout

\begin_layout Plain Layout

Rdd8 := Rdd4.join(Rdd7)
\end_layout

\begin_layout Plain Layout

Rdd8.save(”...file3.txt”)
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate

\series bold
How many stages will the scheduler generate for this pipeline? (Justify
 your answer)
\end_layout

\begin_layout Enumerate

\series bold
How many tasks will be generated within each stage? (Justify your answer)
\end_layout

\begin_layout Subsubsection
Consider the legacy code written in MapReduce that specifies a 
\begin_inset Formula $map\left(\right),combine\left(\right)$
\end_inset

 and 
\begin_inset Formula $reduce\left(\right)$
\end_inset

 operations.
 This job reads from a text file 
\begin_inset Formula $f_{1}$
\end_inset

.
 The combine and reduce operations coincide and you can assume all functions
 are correct.
 Write a Spark pipeline equivalent to the MapReduce job.
 Use 
\begin_inset Formula $fmap$
\end_inset

 and 
\begin_inset Formula $freduce$
\end_inset

 to refer to the code executed inside the map and combine/reduce operations.
 You can parameterize the 
\begin_inset Formula $fmap$
\end_inset

 and 
\begin_inset Formula $freduce$
\end_inset

 functions but resulting in minimal code adaptation.
\end_layout

\begin_layout Subsubsection
Assume we have a MongoDB collection in a distributed cluster, which contains
 prices of apartments without any secondary index.
 Such collection is big enough not to completely fit in memory.
 We want to use Spark to compute the standard deviation per neighbourhood.
 Clearly identify the most efficient option and briefly justify the choice
 (it is not necessary to provide the Spark code).
\end_layout

\begin_layout Enumerate

\series bold
Use Spark only to push the query to MongoDB aggregation framework and simply
 get the result.
\end_layout

\begin_layout Enumerate

\series bold
Push only some of the operations to MongoDB aggregation framework and then
 run the rest in Spark.
\end_layout

\begin_layout Enumerate

\series bold
Load the whole collection to an RDD and perform all computations in Spark.
\end_layout

\begin_layout Section
Streams
\end_layout

\begin_layout Subsection
Problems
\end_layout

\begin_layout Subsubsection
Let's suppose an arrival rate 
\begin_inset Formula $\lambda=50\ msg/sec$
\end_inset

 and a service rate 
\begin_inset Formula $\mu=50\ msg/sec$
\end_inset

.
 Given the message arrivals in the table below and a size of 
\begin_inset Formula $100B$
\end_inset

 per message, which is the minimum buffer size needed to guarantee that
 no message is lost?
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="11">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Time
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
#Messages
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
50
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
75
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
150
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
40
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection
Let's suppose a stationary situation in the processing of a stream, where
 the whole memory available is occupied by messages.
 Assume also the existence of a separated buffer big enough to allow us
 the complete processing of these messages already in memory without being
 concerned with new arrivals.
 Assume we have 
\begin_inset Formula $M=10$
\end_inset

 memory pages with 
\begin_inset Formula $R_{S}=10$
\end_inset

 messages per page.
 If the processing of these messages consists only of a lookup and in-memory
 processing/comparison of a message and a tuple is thousand times smaller
 than a disk access, give the cost in these two situations considering that
 every disk block of the table contains also 
\begin_inset Formula $R_{T}=10$
\end_inset

 tuples:
\end_layout

\begin_layout Enumerate

\series bold
Going through an index for each message with cost 
\begin_inset Formula $h=3$
\end_inset

 for the index and one more disk access to the lookup table per message.
\end_layout

\begin_layout Enumerate

\series bold
Bringing each block of the lookup table (whose size is 
\begin_inset Formula $B=100$
\end_inset

) into memory one by one and checking all messages in memory against all
 its tuples.
\end_layout

\begin_layout Subsubsection
Let's suppose that setting the execution environment for the processing
 of messages in a stream is 
\begin_inset Formula $S=100$
\end_inset

 (e.g., placing & retrieving all the information to/from the stack), independently
 of their number.
 Both packing and unpacking the messages in a batch (i.e., a list of elements)
 have the same cost of 
\begin_inset Formula $Pk=1$
\end_inset

 per message, and processing each message is 
\begin_inset Formula $Ps=10$
\end_inset

.
\end_layout

\begin_layout Enumerate

\series bold
Which is the cost of truly streaming 10 messages one at a time?
\end_layout

\begin_layout Enumerate

\series bold
Which is the cost of processing one packed micro-batch of 10 messages at
 once?
\end_layout

\begin_layout Subsubsection
Let's suppose we have a log file recording the events coming from different
 machines.
 Thus, for each event we have the following information:
\begin_inset Formula 
\[
\left(logID,traceID,eventID,duration\right)
\]

\end_inset

 The 
\begin_inset Formula $logID$
\end_inset

 corresponds to the IP of the machine; the 
\begin_inset Formula $traceID$
\end_inset

 identifies the transaction inside the machine (i.e., two traceIDs can coincide
 in different machines); the 
\begin_inset Formula $eventID$
\end_inset

 identifies the kind of action performed by the machine; finally, the 
\begin_inset Formula $duration$
\end_inset

 is the number of milliseconds taken to implement the action.
 Assuming that we cannot keep all log entries in memory, and we decide to
 randomly sample them, give the attributes (up to three) you would use as
 parameters of the hash function implementing such sampling, so that each
 of the following queries gives a result as accurate as possible.
\end_layout

\begin_layout Enumerate

\series bold
Estimate the fraction of transactions where the same kind of action appears
 more than once.
\end_layout

\begin_layout Enumerate

\series bold
For each machine, estimate the average number of actions per transaction.
\end_layout

\begin_layout Enumerate

\series bold
Estimate the number of transactions with more than two actions taking more
 than 100ms.
\end_layout

\begin_layout Enumerate

\series bold
Estimate the average sum of the duration per transaction.
\end_layout

\begin_layout Subsubsection
Let's suppose we have a black-list of IP addresses (whose packages we do
 not want to cross our firewall), which it too long to be kept in memory
 (
\begin_inset Formula $10^{7}$
\end_inset

 elements).
 Thus, we decide to implement a Bloom filter (to avoid further processing
 of black-listed addresses), with only 
\begin_inset Formula $10^{8}$
\end_inset

 bits.
\end_layout

\begin_layout Enumerate

\series bold
How many hash functions would you use?
\end_layout

\begin_layout Enumerate

\series bold
What's the probability of a false positive in that case?
\end_layout

\begin_layout Enumerate

\series bold
Briefly explain what is the consequence of a false positive in this concrete
 case.
\end_layout

\begin_layout Subsubsection
Let's suppose we have a log file recording the events coming from different
 machines.
 Thus, for each event we have the following information:
\begin_inset Formula 
\[
\left(logID,traceID,eventID,duration\right).
\]

\end_inset

 The 
\begin_inset Formula $logID$
\end_inset

 corresponds to the IP of the machine; the 
\begin_inset Formula $traceID$
\end_inset

 identifies the transaction inside the machine; the 
\begin_inset Formula $eventID$
\end_inset

 identifies the kind of action performed by the machine; finally, the 
\begin_inset Formula $duration$
\end_inset

 is the number of milliseconds taken to implement the action.
 Consider the following table and assume that each machine generates the
 same number of events and at the same pace, and use an exponentially decaying
 window model with a constant 
\begin_inset Formula $c=0.5$
\end_inset

.
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Time
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
logID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
traceID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
eventID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
duration
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
D
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Enumerate

\series bold
Give the milliseconds (and details of calculation) used per machine (i.e.
 for Machine 1 and Machine 2) when the last event arrives, provided that
 the current milliseconds are more valuable than the oldest ones.
\end_layout

\begin_layout Subsubsection
Assume we ingest a stream with an event every time a ticket is sold at a
 theater.
 Precisely, the stream has the following structure:
\begin_inset Formula 
\[
\left(movieID,theaterID,timestamps,price\right).
\]

\end_inset

 Next, we ingest the following ordered set of events:
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(m1,t1,12h,10\text{€}\right)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(m2,t1,14h,12\text{€}\right)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(m2,t2,15h,18\text{€}\right)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(m1,t3,18h,6\text{€}\right)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(m3,t2,19:15h,13\text{€}\right)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(m1,t3,19:30h,10\text{€}\right)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(m2,t3,19:45h,25\text{€}\right)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(m3,t1,20h,17\text{€}\right)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(m1,t3,20:30h,10\text{€}\right)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(m2,t2,21h,8\text{€}\right)$
\end_inset


\end_layout

\begin_layout Standard

\series bold
Provide a detailed answer (i.e., describe the process) for the following questions
:
\end_layout

\begin_layout Enumerate

\series bold
Which theaters would be considered heavy hitters by the algorithm, given
 a required frequency of 50%?
\end_layout

\begin_layout Enumerate

\series bold
Under the exponentially-decaying window model, using an aging constant of
 
\begin_inset Formula $c=0.1$
\end_inset

 and a purging threshold of 
\begin_inset Formula $0.6$
\end_inset

 (i.e., we'll remove movies as soon as their popularity falls strictly below
 
\begin_inset Formula $0.6$
\end_inset

).
 What would be the most popular movies at 21h, considering an aging tick
 every 15 minutes? Give the value corresponding for each of the movies in
 that moment.
\end_layout

\begin_layout Subsubsection
If you have a stream of messages that arrive at a rate of 10 000 per second
 accounting for 512 MB per hour, how many RDDs will process your Spark Streaming
 process in one hour? Explicit all the assumptions you make.
\end_layout

\begin_layout Subsubsection
Assume we ingest a stream with an event every time a ticket is sold at a
 theater.
 Precisely, the stream has the structure 
\begin_inset Formula $\left(movieID,theaterID,timestamp,price\right)$
\end_inset

.
 Nest, we ingest the following ordered set of events:
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(m3,t4,12h,10\text{€}\right)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(m1,t2,13h,17\text{€}\right)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(m2,t4,14h,11\text{€}\right)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(m4,t1,15h,8\text{€}\right)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(m1,t3,16h,9\text{€}\right)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(m3,t4,17h,5\text{€}\right)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(m6,t1,18h,15\text{€}\right)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(m5,t2,19h,12\text{€}\right)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(m7,t5,20h,17\text{€}\right)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(m1,t1,21h,11\text{€}\right)$
\end_inset


\end_layout

\begin_layout Standard

\series bold
Which theaters would be considered heavy hitters (using the approximate
 method) considering a required frequency of 33%? Provide a det
\end_layout

\end_body
\end_document
