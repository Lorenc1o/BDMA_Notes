#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage{footmisc}
\usepackage{listings}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{1,0.99,0.94}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,  
    frame=single,
    tabsize=2
}

\lstset{style=mystyle}
\end_preamble
\use_default_options true
\begin_modules
tcolorbox
customHeadersFooters
theorems-ams-bytype
theorems-sec-bytype
algorithm2e
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=blue, urlcolor=blue, citecolor=blue, pdfstartview={FitH}, unicode=true"
\papersize a4paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\boxbgcolor #62a0ea
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 3cm
\rightmargin 2cm
\bottommargin 3cm
\headheight 2cm
\headsep 1cm
\footskip 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Exam 2021
\end_layout

\begin_layout Exercise
Given N replicas, letâ€™s call R the ReadConcern parameter of MongoDB and
 W the WriteConcern (which indicate respectively the number of copies it
 reads and writes, before confirming the operation to the user); give the
 equation involving those variables that corresponds to the eventually consisten
t configuration.
\end_layout

\begin_layout Exercise
Eventual consistency is achieved when
\begin_inset Formula 
\[
W+R\leq N.
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Exercise
Given an empty linear hash with f(x) = x (i.e., we directly apply the module
 to the keys), and a capacity of four keys per bucket, draw the result of
 inserting the following keys in the given order: 12, 4, 10, 49, 42, 60,
 63, 53, 47, 27, 26, 28, 13, 52.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename bdm_2021_2.png
	scale 60

\end_inset


\end_layout

\begin_layout Exercise
Given a file of 3.2GB stored in an HDFS cluster of 50 machines, and containing
 
\begin_inset Formula $16\cdot10^{5}$
\end_inset

 key-value pairs in a SequenceFile; estimate the execution time of a Spark
 job containing a single map transformation and an action storing the results
 in a file.
 Explicit any assumption you make and consider also the following parameters:
 
\end_layout

\begin_layout Itemize
Chunk size: 128MB (default) 
\end_layout

\begin_layout Itemize
Replication factor: 3 (default) 
\end_layout

\begin_layout Itemize
Map function (i.e., the parameter of the transformation) execution time: 
\begin_inset Formula $10^{-3}$
\end_inset

 sec/call (this is the only cost you have to consider) 
\end_layout

\begin_layout Itemize
Save action execution time: 0sec (do not consider its cost at all)
\end_layout

\begin_layout Standard
The number of chunks is
\begin_inset Formula 
\[
N=\frac{3.2GB}{128MB}=25.
\]

\end_inset

 Therefore, there are
\begin_inset Formula 
\[
N_{kv}=\frac{16\cdot10^{5}}{25}=64000
\]

\end_inset

 key-value pairs per chunk.
 Since there are 50 machines, all chunks can be processed in parallel, accountin
g for a total execution time of
\begin_inset Formula 
\[
T=t\cdot N_{kv}=10^{-3}\cdot64000=64s.
\]

\end_inset


\end_layout

\begin_layout Exercise
Analyze (i.e., briefly give pros and cons) the following JSON design compared
 to other equivalent JSON designs from the three perspectives:
\end_layout

\begin_layout Exercise
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

" BID - PRODUCT ":{
\end_layout

\begin_layout Plain Layout

	" B_ID ": int (4), " B_PRICE ": int (4), " U_ID ": int (4),
\end_layout

\begin_layout Plain Layout

	" PRODUCT ": {
\end_layout

\begin_layout Plain Layout

		" P_ID ": int (4), " P_INFO ": varchar (100)
\end_layout

\begin_layout Plain Layout

}}
\end_layout

\begin_layout Plain Layout

	" PRODUCT - SELLER - REGION ": {
\end_layout

\begin_layout Plain Layout

	" P_ID ": int (4), " P_INFO ": varchar (100),
\end_layout

\begin_layout Plain Layout

	" USER ": {
\end_layout

\begin_layout Plain Layout

		" U_ID ": int (4), " U_F_NAME ": varchar (20),
\end_layout

\begin_layout Plain Layout

		" REGION ": {
\end_layout

\begin_layout Plain Layout

			" R_ID ": int (4), " R_NAME ": varchar (10)
\end_layout

\begin_layout Plain Layout

}}}
\end_layout

\begin_layout Plain Layout

" PRODUCT - COMMENTS ": {
\end_layout

\begin_layout Plain Layout

	" P_ID ": int (4), " P_INFO ": varchar (100),
\end_layout

\begin_layout Plain Layout

	" COMMENTS ": [{
\end_layout

\begin_layout Plain Layout

		" C_ID ": int (4), " C_TITLE ": varchar (20), " U_ID ": int (4)
\end_layout

\begin_layout Plain Layout

}]}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Read (a.k.a.
 Query):
\end_layout

\begin_deeper
\begin_layout Itemize
Pros: retrieving the information regarding a product is very easy, like
 the sellers of a product.
 Also, retrieving all the comments of a product is easy.
\end_layout

\begin_layout Itemize
Cons: retrieving all products that a seller offers requires many joins,
 as well as obtaining all bids to a product and even worse is to find all
 products sold in a given region.
\end_layout

\end_deeper
\begin_layout Itemize
Update:
\end_layout

\begin_deeper
\begin_layout Itemize
Pros: if we want to update the sellers of a particular product, it is fast
 and easy.
 Same if we want to update the comments of a particular product or the product
 of a bid.
\end_layout

\begin_layout Itemize
Cons: if we want to update the region of a seller, we would need to traverse
 all product to see if the seller sells that product, and then update the
 region.
 This is very costly and inefficient.
 Also, if we want to update a product description, we would need to change
 it in the three places that it appears.
\end_layout

\end_deeper
\begin_layout Itemize
Memory:
\end_layout

\begin_deeper
\begin_layout Itemize
Pros: Having product as a central concept makes BID-PRODUCT and PRODUCT-COMMENTS
 able to be stored efficiently, since we just need to provide the ID of
 the related product.
\end_layout

\begin_layout Itemize
Cons: P_INFO is stored repeatedly.
 Not only this, but we are storing the USERS many times, and the REGIONS
 even more times.
\end_layout

\end_deeper
\begin_layout Exercise
Assume we have a MongoDB collection in a distributed cluster, which contains
 prices of apartments without any secondary index.
 Such collection is big enough not to completely fit in memory.
 We want to use Spark to compute the standard deviation per neighbourhood.
 Clearly identify the most efficient option and briefly justify the choice
 (it is not necessary to provide the Spark code).
 
\end_layout

\begin_layout Exercise
A.
 Use Spark only to push the query to MongoDB aggregation framework and simply
 get the result.
 No, because we would need the mongo router to perform all the work, losing
 the power of parallelism.
\end_layout

\begin_layout Exercise
B.
 Push only some of the operations to MongoDB aggregation framework and the
 run the rest in Spark.
 Yes, but we need specific drivers for Spark to be able to push operations
 to the storage engine.
 For MongoDB these exist.
\end_layout

\begin_layout Exercise
C.
 Load the whole collection to an RDD and perform all computations in Spark.
 No, because we would need to transfer everything to Spark, implying a huge
 data transfer overload.
\end_layout

\end_body
\end_document
