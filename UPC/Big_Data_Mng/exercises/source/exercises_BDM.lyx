#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage{footmisc}
\usepackage{listings}
\usepackage{ifsym}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{1,0.99,0.94}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,  
    frame=single,
    tabsize=2
}

\lstset{style=mystyle}

\newcommand{\ljoin}{\footnotesize \textifsym{|><} \normalsize}
\end_preamble
\use_default_options true
\begin_modules
tcolorbox
customHeadersFooters
theorems-ams-bytype
theorems-sec-bytype
algorithm2e
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=blue, urlcolor=blue, citecolor=blue, pdfstartview={FitH}, unicode=true"
\papersize a4paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\boxbgcolor #62a0ea
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 3cm
\rightmargin 2cm
\bottommargin 3cm
\headheight 2cm
\headsep 1cm
\footskip 2cm
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
BDM-MIRI - Big Data Management - Exercises
\end_layout

\begin_layout Date
Spring 2023
\end_layout

\begin_layout Author
Jose Antonio Lorencio Abril
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename ../../LectureNotes/source/upc-logo.png
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\align right
Professor: Alberto Abelló
\end_layout

\begin_layout Standard
\align right
Student e-mail: jose.antonio.lorencio@estudiantat..upc.edu
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Address
This are the exercises of the course 
\emph on
Big Data Management
\emph default
 taught at the Universitat Politècnica de Catalunya by Professor Alberto
 Abelló in the academic year 22/23.
 Some exercises have been solved in class (marked with 
\color red
*
\color inherit
).
\end_layout

\begin_layout Address
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Big Data Design
\end_layout

\begin_layout Subsection
Theoretical questions
\end_layout

\begin_layout Subsubsection
Briefly explain what 'physical independence' is, which is the general position
 of NOSQL systems on this, and why they take this position.
\end_layout

\begin_layout Standard
'Physical independence' in the context of databases refers to the ability
 to modify the physical storage of data (like its distribution across disks
 or its indexing strategy) without affecting the conceptual view of the
 data.
 NoSQL systems generally advocate for physical independence, mainly because
 they are designed to work with massive volumes of data which can be distributed
 across multiple nodes.
 Physical independence facilitates horizontal scaling (adding more machines)
 to handle larger datasets and workload, which is a core feature of NoSQL
 databases.
\end_layout

\begin_layout Subsubsection
In the framework of the RUM conjecture, name six data structures we saw
 in the course (not concrete tool implementations) and place them in the
 corresponding category:
\end_layout

\begin_layout Itemize

\series bold
Read optimized: 
\series default
B-Trees, Hash Indexes
\end_layout

\begin_layout Itemize

\series bold
Write optimized: 
\series default
Log-structured merge-trees (LSM trees), Hash Map
\end_layout

\begin_layout Itemize

\series bold
Space optimized: 
\series default
Bitmap Indexes, Trie
\end_layout

\begin_layout Standard
Remember that the RUM (Read, Update, Memory) conjecture is a framework that
 stipulates a trade-off between read efficiency, write (update) efficiency,
 and memory efficiency.
 
\end_layout

\begin_layout Subsubsection
Compare a B-tree and a LSM-tree in the context of the RUM conjectura (i.e.
 as an answer to this question, three brief explanations of the form 'From
 the perspective of X, Y-tree is better than Z-tree, because of this and
 that' are expected).
\end_layout

\begin_layout Itemize

\series bold
R: 
\series default
A B-Tree is generally better than an LSM-Tree, as B-Trees provide faster
 read operations due to the hierarchical nature and sorted order of their
 data.
\end_layout

\begin_layout Itemize

\series bold
U: 
\series default
An LSM-Tree is generally better than a B-Tree in terms of updates.
 LSM-Trees are write-optimized and handle write operations better because
 they buffer changes in memory and then write large blocks to disk.
\end_layout

\begin_layout Itemize

\series bold
M: 
\series default
An LSM-Tree is more memory-optimized than a B-Tree.
 LSM-Trees use less memory because they compact and compress old data, thus
 reducing storage footprint.
\end_layout

\begin_layout Subsection
Problems
\end_layout

\begin_layout Subsubsection
Consider
\end_layout

\begin_layout Enumerate

\series bold
['BCN', POPULATION:{VALUE:'2 000 000'}, REGION{VALUE:'CAT'}]
\end_layout

\begin_layout Enumerate

\series bold
['BCN', ALL:{VALUE:'2 000 000;CAT'}]
\end_layout

\begin_layout Enumerate

\series bold
['BCN', ALL:{POPULATION:'2 000 000'; REGION:'CAT'}]
\end_layout

\begin_layout Standard

\series bold
Place {1,2,3} in the table 
\series default
\color red
*
\series bold
\color inherit
:
\end_layout

\begin_layout Standard
\align center

\series bold
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Less variable schema
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\begin_inset Formula $\rightarrow$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
More variable schema
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Less explicit schema
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\begin_inset Formula $\downarrow$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
More explicit schema
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection*
Name two criteria you would use to choose among them.
\end_layout

\begin_layout Itemize
Variety of data.
\end_layout

\begin_layout Itemize
Variability of the data.
\end_layout

\begin_layout Subsubsection
Consider the following conceptual schema and propose several design alternatives
 to translate it to a logical representation(e.g.
 using JSON notation).
 Then, explain which is the best alternative and why.
 
\color red
*
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado1.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Author: {A_ID, A_NAME}
\end_layout

\begin_layout Plain Layout

Book: {B_ID, B_NAME}
\end_layout

\begin_layout Plain Layout

AuthorBooks: {A_ID, B_ID}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Author: {A_ID, A_NAME, 
\end_layout

\begin_layout Plain Layout

				Books: {
\end_layout

\begin_layout Plain Layout

							Book1: {B_ID, B_NAME},
\end_layout

\begin_layout Plain Layout

							...
\end_layout

\begin_layout Plain Layout

							BookN: {B_ID, B_NAME}
\end_layout

\begin_layout Plain Layout

						}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Book: {B_ID, B_NAME,
\end_layout

\begin_layout Plain Layout

				Authors: {
\end_layout

\begin_layout Plain Layout

							Author1: {A_ID, A_NAME},
\end_layout

\begin_layout Plain Layout

							...
\end_layout

\begin_layout Plain Layout

							AuthorN: {A_ID, A_NAME}
\end_layout

\begin_layout Plain Layout

						}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Author: {A_ID, A_NAME, Book1:{B_ID,B_NAME},..., BookN:{B_ID,B_NAME}}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
And many more...
\end_layout

\begin_layout Section
Distributed Data
\end_layout

\begin_layout Subsection
Theoretical questions
\end_layout

\begin_layout Subsubsection
Which kind of database is this according to the distribution of data?
\color red
*
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado2.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
This is a centralized system with respect to the data, because the database
 is completely handled in Node 2.
\end_layout

\begin_layout Subsubsection
Explain what is (a) a distributed system, and (b) a parallel system.
 Compare both of them (i.e.
 what has one and not the other and vice-versa).
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
a)
\end_layout

\end_inset

 A 
\series bold
distributed system
\series default
 is a system where components located on networked computers communicate
 and coordinate their actions by passing messages.
 The components interact with each other to appear as a single coherent
 system to the end user.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
b)
\end_layout

\end_inset

 A 
\series bold
parallel system
\series default
, on the other hand, is a type of computational system that performs many
 operations or processes simultaneously.
 Parallel systems can be a single computer with multiple processors or an
 array of computers working together to achieve a common goal.
\end_layout

\begin_layout Standard
While both systems process tasks concurrently, a distributed system spreads
 the tasks across different networked machines that may be geographically
 dispersed.
 In contrast, a parallel system typically uses multiple processors within
 a single machine or across a tightly coupled cluster of machines to perform
 tasks simultaneously.
\end_layout

\begin_layout Subsubsection
Which two kinds of schema information contains the Global Conceptual Schema
 that does not contain the Local Conceptual Schema in the Extended ANSI-SPARC
 Architecture for DDBMS? 
\color red
*
\end_layout

\begin_layout Enumerate
Fragmentation
\end_layout

\begin_layout Enumerate
Allocation
\end_layout

\begin_layout Subsubsection
In the context of distributed data management, name the four big challenges
 that need to be carefully considered in the presence of distribution from
 the tenant/user point of view.
 
\color red
*
\end_layout

\begin_layout Enumerate
Data design.
\end_layout

\begin_layout Enumerate
Catalog management.
\end_layout

\begin_layout Enumerate
Transaction management.
\end_layout

\begin_layout Enumerate
Query processing.
\end_layout

\begin_layout Subsubsection
Name the three characteristics of fragmentation that make it correct.
 
\color red
*
\end_layout

\begin_layout Enumerate
Disjoint.
\end_layout

\begin_layout Enumerate
Complete.
\end_layout

\begin_layout Enumerate
Reconstructible.
\end_layout

\begin_layout Subsubsection
Which is the main problem in having replicas, and which is the innovation
 introduced by some NOSQL tools to solve it? 
\color red
*
\end_layout

\begin_layout Itemize

\series bold
Problem:
\series default
 Consistency.
\end_layout

\begin_layout Itemize

\series bold
Innovation: 
\series default
Eventual consistency.
\end_layout

\begin_layout Subsubsection
Given 
\begin_inset Formula $N$
\end_inset

 replicas, let's call 
\begin_inset Formula $R$
\end_inset

 the ReadConcern parameter of MongoDB and 
\begin_inset Formula $W$
\end_inset

 the WriteConcert (which indicate, respectively, the number of copies it
 reads and writes before confirming the operation to the user).
 Give the equation involving those variables that corresponds to the eventually
 consistent configuration.
 
\color red
*
\end_layout

\begin_layout Standard
The formula is:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
W+R\le N.
\]

\end_inset


\end_layout

\begin_layout Subsubsection
What is the difference between query cost and query response time...
 
\color red
*
\end_layout

\begin_layout Enumerate

\series bold
In centralized systems?
\end_layout

\begin_layout Enumerate

\series bold
In distributed systems?
\end_layout

\begin_layout Standard
Query cost refers to the total amount of resources (such as CPU, memory,
 disk I/O, network I/O) consumed to execute a query, whereas query response
 time is the time taken to execute a query and return a result.
\end_layout

\begin_layout Itemize
In 
\series bold
centralized systems
\series default
, query cost and query response time are tightly correlated.
 As the system is centralized, resource allocation and scheduling are predictabl
e and straightforward, hence the cost directly impacts the response time.
 Roughly, 
\begin_inset Formula $RT\propto C$
\end_inset

.
\end_layout

\begin_layout Itemize
In 
\series bold
distributed systems
\series default
, the correlation is more complex.
 Query cost is not the only factor impacting query response time.
 Network latency, load balancing, data locality, and the consistency model
 also significantly affect the response time.
 Thus, a query may have a low cost in terms of resources but may still experienc
e high response time due to network delays or synchronization overhead.
 In this case, 
\begin_inset Formula $RT\propto USL\left(C\right)$
\end_inset

 (the universal scalability law).
\end_layout

\begin_layout Subsubsection
Name the two factors that make it impossible to have linear scalability
 according to the Universal Scalability Law.
 
\color red
*
\end_layout

\begin_layout Enumerate
Programs are not fully parallelizable.
\end_layout

\begin_layout Enumerate
There are communication costs.
\end_layout

\begin_layout Subsection
Problems
\end_layout

\begin_layout Subsubsection
Briefly explain (a) which fragmentation strategy has been applied for the
 tables below and whether this fragmentation strategy is (b) complete, (c)
 disjoint and (d) allows to reconstruct the global relations (if so, (e)
 indicate the operation).
 
\color red
*
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Plain Layout

\series bold
Global Relations
\end_layout

\begin_layout Plain Layout
——————————————————
\end_layout

\begin_layout Plain Layout

\family typewriter
Kids(
\bar under
kidId
\bar default
, name, address, age)
\end_layout

\begin_layout Plain Layout

\family typewriter
Toys(
\bar under
toyId
\bar default
, name, price)
\end_layout

\begin_layout Plain Layout

\family typewriter
Request(
\bar under
kidId, toyId
\bar default
, willingness)
\end_layout

\begin_layout Plain Layout
——————————————————
\end_layout

\begin_layout Plain Layout
Note that 
\family typewriter
requests(kidId)
\family default
 is a FK to 
\family typewriter
kids(kidId)
\family default
 and 
\family typewriter
requests(toyId)
\family default
 is a FK to 
\family typewriter
toys(toyId)
\family default
.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Plain Layout

\series bold
Fragments
\end_layout

\begin_layout Plain Layout
——————————————————
\end_layout

\begin_layout Plain Layout
K1 = Kids[kidId, name]
\end_layout

\begin_layout Plain Layout
K2 = Kids[kidId, address, age]
\end_layout

\begin_layout Plain Layout
——————————————————
\end_layout

\begin_layout Plain Layout
T1 = Toys(price 
\begin_inset Formula $\geq$
\end_inset

 150)
\end_layout

\begin_layout Plain Layout
T2 = toys(price 
\begin_inset Formula $<$
\end_inset

 150)
\end_layout

\begin_layout Plain Layout
——————————————————
\end_layout

\begin_layout Plain Layout
R1 = Requests 
\begin_inset Formula $\ltimes$
\end_inset

 T1 
\end_layout

\begin_layout Plain Layout
R2 = Requests 
\begin_inset Formula $\ltimes$
\end_inset

 T2
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="6">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top" width="5cm">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top" width="5cm">
<column alignment="center" valignment="top" width="5cm">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Fragment
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
c)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
d)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
e)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
K1-K2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Vertical
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Complete
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Disjoint
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Reconstructible
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Join
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T1-T2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Horizontal
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Complete (if there are no NULLs)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Disjoint
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Reconstructible (if complete)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Union (if complete)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
R1-R2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Derived Horizontal
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Complete (if no NULLs)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Disjoint
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Reconstructible (if complete)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Projection on T + Union (if complete)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection
You are a customer using an e-commerce based on heavy replication (e.g.
 Amazon): 
\color red
*
\end_layout

\begin_layout Enumerate

\series bold
Show a database replication strategy (e.g.
 sketch it) where:
\end_layout

\begin_deeper
\begin_layout Enumerate

\series bold
You buy an item, but this item does not appear in your basket.
\end_layout

\begin_layout Enumerate

\series bold
You reload the page: the item appears.
\end_layout

\begin_layout Standard

\series bold
What happened?
\end_layout

\begin_layout Standard
This can happen in a Primary/Lazy setup, as the following sketch (the number
 indicate the order of each action):
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename bdm_2_2_2_a.png
	scale 60

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Show a database replication strategy (e.g.
 sketch it) where:
\end_layout

\begin_deeper
\begin_layout Enumerate

\series bold
You delete an item from your command, and add another one: the basket shows
 both items.
\end_layout

\begin_layout Standard

\series bold
What happened? Will the situation change if you reload the page?
\end_layout

\begin_layout Standard
This can happen in a Secondary/Lazy setup, in which different replicas are
 used for each of these purposes, as the following sketch:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename bdm_2_2_2_b.png
	scale 60

\end_inset


\end_layout

\end_deeper
\begin_layout Subsubsection
Consider the following architecture and answer the questions
\begin_inset Foot
status open

\begin_layout Plain Layout
From S.
 Abiteboul et al.
 
\emph on
Web Data Management
\emph default
.
 Cambridge Press, 2011.
\end_layout

\end_inset

: 
\color red
*
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pegado3.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Centralized architecture.
\begin_inset CommandInset label
LatexCommand label
name "fig:Centralized-architecture."

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Latency
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Bandwidth
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Disk
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\approx5\times10^{-3}s\left(5\ millisec.\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
At best 100 MB/s
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Enumerate

\series bold
How long would it take (i.e.
 response time) to read 1TB with sequential access (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Centralized-architecture."
plural "false"
caps "false"
noprefix "false"

\end_inset

)? (in secs)
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula 
\[
T_{transfer}=\frac{1TB}{100MB/s}=10^{4}s=10000s
\]

\end_inset

 Therefore,
\begin_inset Formula 
\[
T_{total}=T_{transfer}+T_{latency}=10000.005s.
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
How long would a single random access (i.e.
 reading one tuple, of for example 100 B, through an index) take (i.e.
 response time), assuming we already have the physical address? (in secs)
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula 
\[
T_{total}=\frac{100B}{100MB/s}+0.005=0.005001s.
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pegado4.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Shared-memory architecture.
\begin_inset CommandInset label
LatexCommand label
name "fig:Shared-memory-architecture."

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Latency
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Bandwidth
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Disk
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\approx5\times10^{-3}s\left(5\ millisec.\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
At best 100 MB/s
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
3.
 
\end_layout

\end_inset


\series bold
How long would it take (i.e.
 response time) to read 1TB with parallel access (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Shared-memory-architecture."
plural "false"
caps "false"
noprefix "false"

\end_inset

)? Assume 100 disks (i.e.
 100 replicas of the whole data) on the same machine with shared-memory
 and infinite CPU capacity.
\end_layout

\begin_deeper
\begin_layout Standard
In this case, we can read a portion of data from each machine.
 The latency remains still for all machines, therefore:
\begin_inset Formula 
\[
T_{total}=\frac{S_{data}}{N_{machines}\cdot B}+T_{latency}=\frac{1TB}{100\cdot100MB/s}+0.005=100,005s.
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
4.
 
\end_layout

\end_inset


\series bold
How long would a single random access (i.e.
 reading one tuple, of 100 B, through an index) take (i.e.
 response time), assuming we already have the physical address? (in secs)
\end_layout

\begin_deeper
\begin_layout Standard
We would know the machine in which the tuple is.
 Therefore, the situation would be the same as doing it in one machine_
\begin_inset Formula 
\[
T_{total}=0.005001s.
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pegado5.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Shared-nothing architecture.
\begin_inset CommandInset label
LatexCommand label
name "fig:Shared-nothing-architecture."

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Latency
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Bandwidth
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Disk
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\approx5\times10^{-3}s\left(5\ millisec.\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
At best 100 MB/s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LAN
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\approx1/2\ \times10^{-2}s\left(1-2\ millisec.\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\approx1\ GB/s\left(single\ rack\right)\approx10\ MB/s\left(switched\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Internet
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Highly variable (10-100ms)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Highly variable (few MB/s, 10MB/s)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Remark
It is approximately one order of magnitude to exchange main memory data
 between 2 machines in a data center, that to read on the disk.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
Exchanging through the Internet is slow and unreliable with respect to LANs.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
5.
 
\end_layout

\end_inset


\series bold
How long would it take (i.e.
 response time) to read 1TB with distributed access (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Shared-nothing-architecture."
plural "false"
caps "false"
noprefix "false"

\end_inset

)? Assume 100 shared-nothing machines (with all data replicated in each
 of them) in a star-shape LAN in a single rack where all data is sent to
 the center of the star in only one network hop.
\end_layout

\begin_deeper
\begin_layout Standard
In this case, the network is very fast, and the bottleneck is on the disk.
 The time is
\begin_inset Formula 
\[
T_{total}=\max\left(T_{disk},T_{LAN}\right)+T_{latency,disk}+T_{latency,LAN}=100+0.005+0.002=100.007s.
\]

\end_inset

 The reason we take the max is because once we have data in the memory taken
 from disk, we can send it through the LAN.
 Therefore, we can consider that both processes are done simoultaneously.
 
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
6.
 
\end_layout

\end_inset


\series bold
How long would it take (i.e.
 response time) to read 1TB with distributed access (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Shared-nothing-architecture."
plural "false"
caps "false"
noprefix "false"

\end_inset

)? Assume 100 shared-nothing machines (with all data replicated in each
 of them) in a star-shape cluster of machines connected through the Internet
 where all data is sent ot the center of the star in only one network hop.
\end_layout

\begin_deeper
\begin_layout Standard
In this case, the network is the bottleneck, so
\begin_inset Formula 
\[
T_{total}=T_{internet}+T_{latency,disk}+T_{latency,internet}=\frac{1TB}{100\cdot10MB/s}+0.005+0.1=1000.05s.
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
7.
 
\end_layout

\end_inset


\series bold
How long would a single random access (i.e.
 reading one tuple, of 100 B, through an index) take (i.e.
 response time), assuming we already have the physical address? (in secs)
 In the LAN (switched) scenario.
\end_layout

\begin_deeper
\begin_layout Standard
In this case, we cannot take advantage of the paralelization, because only
 one tuple is sent.
 Therefore, we need to take the time for all sequential steps into account:
\begin_inset Formula 
\[
T_{total}=T_{disk}+T_{latency,disk}+T_{LAN}+T_{latency,LAN}=0.000001+0.005+0.00001+0.002=0.007011s.
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Subsubsection
What are the main differences between these two distributed access plans?
 Under which assumptions is one or the other better? 
\color red
*
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT *
\end_layout

\begin_layout Plain Layout

FROM employee e, assignedTo a
\end_layout

\begin_layout Plain Layout

WHERE e.#emp = a.#emp AND a.responsability = 'manager'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Plain Layout
The database is:
\end_layout

\begin_layout Plain Layout
——————————————————
\end_layout

\begin_layout Plain Layout

\family typewriter
Employee(
\bar under
#emp
\bar default
, empName, degree)
\end_layout

\begin_layout Plain Layout

\family typewriter
S4: E1 = Employee(#emp 
\begin_inset Formula $\leq$
\end_inset

 'E3')
\end_layout

\begin_layout Plain Layout

\family typewriter
S3: E2 = Employee(#emp 
\begin_inset Formula $>$
\end_inset

 'E3')
\end_layout

\begin_layout Plain Layout
——————————————————
\end_layout

\begin_layout Plain Layout

\family typewriter
AssignedTo(
\bar under
#emp, #proj
\bar default
, responsability, fullTime)
\end_layout

\begin_layout Plain Layout

\family typewriter
FK: #emp references Employee
\end_layout

\begin_layout Plain Layout

\family typewriter
S1: A1 = AssignedTo(#emp 
\begin_inset Formula $\leq$
\end_inset

 'E3')
\end_layout

\begin_layout Plain Layout

\family typewriter
S2: A2 = AssignedTo(#emp 
\begin_inset Formula $>$
\end_inset

 'E3')
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pegado6.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Distributed Access Plans
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
In plan A, firstly, the data is reduced by means of selections.
 Then, they are joined, increasing the data.
 Finally, these joined tables are transferred through the network.
\end_layout

\begin_layout Enumerate
In plan B, the plain tables are transferred to one node, and then they are
 combined, selected and joined.
 All in one machine.
\end_layout

\begin_layout Standard
There are several considerations that need to be taken into account to decide
 between these two approaches:
\end_layout

\begin_layout Itemize
In plan B, if the individual tables are large, it is possible that one node
 does not have enough capacity to store them.
 In these cases, we can only go for A.
\end_layout

\begin_layout Itemize
If that's not the case, everything would depend on how big the joined tables
 in plan A are compared to the raw tables, since the transfer cost is probably
 the dominating cost here.
 If the joined tables are smaller than the individual tables, then plan
 A would be better, else B.
 
\end_layout

\begin_layout Standard
Therefore, we need statistics to be able to decide which option is better
 in the context of the execution.
\end_layout

\begin_layout Subsubsection
Compute the fragment query (data location stage) for the database setting
 and query below and find in how many ways we can assign the operations
 to the different sites.
\end_layout

\begin_layout Standard

\series bold
The database setting is:
\end_layout

\begin_layout Itemize

\series bold
A distributed database with 5 sites (i.e.
 database nodes): 
\begin_inset Formula $S_{1},S_{2},S_{3},S_{4}$
\end_inset

 and 
\begin_inset Formula $S_{5}$
\end_inset

.
\end_layout

\begin_layout Itemize

\series bold
3 relations in the databaset: 
\begin_inset Formula $R,S$
\end_inset

 and 
\begin_inset Formula $T$
\end_inset

.
\end_layout

\begin_layout Itemize

\series bold
Each relation is horizontally fragmented in two fragments (we refer to them
 by the name of the relation and a subindex, for example: 
\begin_inset Formula $R_{1},R_{2}$
\end_inset

).
 You can consider them to be correct (i.e.
 complete, disjoint and reconstructible).
\end_layout

\begin_layout Itemize

\series bold
Each fragment is replicated at all sites.
\end_layout

\begin_layout Itemize

\series bold
We have the following query
\begin_inset Formula 
\[
Q_{1}=\sigma\left(R\right)\Join\sigma\left(S\right)\Join T.
\]

\end_inset


\end_layout

\begin_layout Standard

\series bold
The process tree of the query is: 
\series default
\color red
*
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado7.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
Notice that since each relation is horizontally fragmented into two fragments,
 we need to perform the union between those to get the relations.
 For example, 
\begin_inset Formula $R=R_{1}\cup R_{2}$
\end_inset

.
 Therefore, the tree has 3 more nodes for each relation (one for each segment,
 and one for the union).
\end_layout

\begin_layout Standard
Thus, the tree is formed of 13 nodes, and there are 5 posible sites in which
 each node can execute.
 This means that there is a total of 
\begin_inset Formula $5^{13}$
\end_inset

 possible arrangements.
\end_layout

\begin_layout Subsubsection
Consider a left-deep process tree corresponding to a query, where each internal
 node is a join, and every leaf a data source (e.g.
 relational table).
 Knowing that the tree contains 9 nodes (including leaves), the system has
 as much parallelism capacity as needed to run all the joins in pipelining
 mode (no other kind of parallelism is available), which is the occupancy
 if the overall cost of the serial query is 4 seconds? Explicit any assumption
 you need to make.
\end_layout

\begin_layout Standard
The tree is the following:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename bdm_2_2_6.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
Then, there are 4 operators, so the occupancy is
\begin_inset Formula 
\[
O=\frac{T}{N}=\frac{4s}{4op}=1s/op.
\]

\end_inset


\end_layout

\begin_layout Standard
There are no stalls since we assumed an infinite parallelism capacity for
 pipelining.
\end_layout

\begin_layout Subsection
Extra
\end_layout

\begin_layout Subsubsection
Give five types of data or software resources that can be usefully shared.
 Give examples of their sharing as it occurs in practice in distributed
 systems.
\color red
*
\end_layout

\begin_layout Itemize
Data: a distributed database.
\end_layout

\begin_layout Itemize
Information: Internet.
\end_layout

\begin_layout Itemize
Query: a distributed database.
\end_layout

\begin_layout Itemize
Processing: edge computing.
\end_layout

\begin_layout Itemize
RAM: supercomputers.
\end_layout

\begin_layout Subsubsection
How might the clocks in two computers that are linked by a local network
 by synchronized without reference to an external time source? What factors
 limit the accuracy of the procedure you have described? How could the clocks
 in a large number of computers connected by the Internet be synchronized?
 Discuss the accuracy of that procedure.
 
\color red
* (kinda)
\end_layout

\begin_layout Standard
Two computers linked by a local network can synchronize their clocks using
 a protocol like the 
\series bold
Network Time Protocol (NTP)
\series default
, even without reference to an external time source.
 One of the computers is selected as the master clock, and it periodically
 sends the current time to the other computer, which then adjusts its clock
 accordingly.
\end_layout

\begin_layout Standard
The accuracy of this procedure can be limited by network latency and clock
 drift.
 
\series bold
Network latency
\series default
 causes a delay between when the time message is sent and when it is received.
 
\series bold
Clock drift
\series default
 can cause the clock to speed up or slow down slightly, introducing a discrepanc
y over time.
\end_layout

\begin_layout Standard
To synchronize clocks in a large number of computers connected by the Internet,
 a 
\series bold
hierarchical time distribution method
\series default
 can be used.
 At the top of the hierarchy is a primary server synchronized to an atomic
 clock or GPS.
 The primary server synchronizes time with secondary servers, which in turn
 synchronize with tertiary servers, and so on.
 Each layer of servers synchronizes with a large number of clients.
\end_layout

\begin_layout Standard
This procedure's accuracy can be affected by network latency and jitter,
 especially over long distances on the internet.
 However, protocols like NTP have built-in mechanisms to estimate and correct
 these errors.
\end_layout

\begin_layout Subsubsection
Consider the implementation strategies for massively multiplayer online.
 In particular, what advantages do you see in adopting a single server approach
 for representing the state of the multiplayer game? What problems can you
 identify and how might they be resolved?
\end_layout

\begin_layout Standard
Advantages:
\end_layout

\begin_layout Itemize
Simplified state management: The game's state is stored and processed centrally,
 simplifying the logic needed to manage and update it.
 
\end_layout

\begin_layout Itemize
Consistent game state: Since there's only one source of truth, all players
 can see the same game state, reducing the chances of discrepancies and
 conflicts.
\end_layout

\begin_layout Standard
Disadvantages:
\end_layout

\begin_layout Itemize
Scalability issues: A single server may struggle to handle a large number
 of players, affecting game performance.
 
\end_layout

\begin_layout Itemize
Single point of failure: If the server fails, the game becomes inaccessible
 for all players.
 
\end_layout

\begin_layout Standard
To address these issues, techniques like server sharding (splitting the
 game world into different sections, each managed by a separate server)
 or using a distributed server architecture can be used.
\end_layout

\begin_layout Subsubsection
A server program written in one language (for example, C++) provides the
 implementation of a BLOB object that is intended to be accessed by clients
 that may be written in a different language (for example, Java).
 The client and server computers may have different hardware, but all of
 them are attached to the Internet.
 Describe the problems due to each of the aspects of heterogeneity that
 need to be solved to make it possible for a client object to invoke a method
 on the server object.
\end_layout

\begin_layout Itemize

\series bold
Programming languages: 
\series default
Due to the language differences, a common protocol like HTTP or a language-indep
endent data format like JSON or XML might be necessary for communication.
 A method invocation from the Java client to the C++ server will have to
 be serialized into a standard format that both can understand.
\end_layout

\begin_layout Itemize

\series bold
Implementations by different developers: 
\series default
Different developers might have different programming styles, conventions,
 and assumptions which could introduce bugs and incompatibilities.
 Standardized interfaces, thorough documentation, and stringent testing
 practices can help mitigate these issues.
\end_layout

\begin_layout Subsubsection
The INFO service manages a potentially very large set of resources, each
 of which can be accessed by users throughout the Internet by means of a
 key (a string name).
 Discuss an approach to the design of the names of the resources that achieves
 the minimum loss of performance as the number of resources in the service
 increases.
 Suggest how the INFO service can be implemented so as to avoid performance
 bottlenecks when the number of users becomes very large.
 
\color red
* (kinda)
\end_layout

\begin_layout Standard

\series bold
Approach A: Hash Table
\end_layout

\begin_layout Standard
An efficient naming scheme could be a distributed hash table (DHT), where
 resource names (keys) are hashed to unique identifiers.
 This ensures a roughly uniform distribution of resources, allowing for
 efficient lookup even as the number of resources increases.
\end_layout

\begin_layout Standard
To avoid performance bottlenecks with a large number of users, the INFO
 service could be implemented in a distributed manner, where requests are
 load balanced across multiple servers.
 Each server would be responsible for a subset of the resources, reducing
 the load on any one server.
\end_layout

\begin_layout Standard

\series bold
Approach B: Prefix Tree
\end_layout

\begin_layout Standard
If we want to accommodate a potentially infinite amount of users, then we
 can make use of a prefix tree, like the one used by Internet, in which
 each resource is positioned in a leave of the subtree that can be accessed
 very fast thanks to the prefixed structure.
\end_layout

\begin_layout Subsubsection
A server process maintains a shared information object such as the BLOB
 object of exercise 2.3.4.
 Give arguments for and against allowing the client requests to be executed
 concurrently by the server.
 In the case that they are executed concurrently, give an example of possible
 'interference' that can occur between the operations of different clients.
 Suggest how such interference may be prevented.
 
\color red
*
\end_layout

\begin_layout Standard
Allowing concurrent client requests can increase the system's throughput
 but can also lead to data inconsistencies or conflicts if not properly
 managed.
 For example, if two clients try to modify the same data at the same time,
 one client's changes could overwrite the other's.
\end_layout

\begin_layout Standard
This interference can be prevented using concurrency control techniques
 such as locking (where a resource is locked when a client is modifying
 it and other clients have to wait), or optimistic concurrency control (where
 changes are checked for conflicts before being committed).
\end_layout

\begin_layout Subsubsection
A service is implemented by several servers.
 Explain why resources might be transferred between them.
 Would it be satisfactory for clients to multicast all requests to the group
 of servers as a way of achieving mobility transparency for clients?
\end_layout

\begin_layout Standard
Resources might be transferred between servers for load balancing, fault
 tolerance, or data locality purposes.
\end_layout

\begin_layout Standard
While multicasting all requests to all servers might seem like a way to
 achieve mobility transparency, it would lead to significant overhead and
 could result in conflicts if multiple servers try to respond to the same
 request.
 Instead, a more efficient approach might be to use a load balancer or a
 similar mechanism to distribute requests among the servers.
\end_layout

\begin_layout Section
Distributed File System
\end_layout

\begin_layout Subsection
Theoretical questions
\end_layout

\begin_layout Subsubsection
How does HDFS decide where to place the different chunks of a file? 
\color red
*
\end_layout

\begin_layout Standard
Randomly.
\end_layout

\begin_layout Subsection
Problems
\end_layout

\begin_layout Subsubsection
Given a table with ten blocks (
\begin_inset Formula $B=10$
\end_inset

) and 17 tuples per block (
\begin_inset Formula $R=17$
\end_inset

) for a total of 170 tuples, compare the cost of reading the whole table
 sequentially, against the cost of accessing seven random (potentially repeated)
 tuples in an unknown order.
 Assume that seek time is 
\begin_inset Formula $12ms$
\end_inset

, average rotation time is 
\begin_inset Formula $3ms$
\end_inset

 and transferring one block is 
\begin_inset Formula $0.03ms$
\end_inset

.
 You should consider which is the probability that two tuples accessed consecuti
vely are actually in the same block, but ignore the presence of any cache
 or buffer pool mechanism.
 
\color red
*
\end_layout

\begin_layout Standard
Sequentially:
\begin_inset Formula 
\[
T_{seq}=T_{seek}+T_{rot}+B\cdot T_{block}=12+3+10\cdot0.03=15.3ms.
\]

\end_inset


\end_layout

\begin_layout Standard
Seven random accesses:
\end_layout

\begin_layout Standard
First, we compute the probability that the tuple is in the same block as
 the previous one:
\begin_inset Formula 
\[
P_{i}=P\left(B_{i}=B_{i-1}\right)=\frac{1}{10}.
\]

\end_inset

 Then, the first block needs to be read for sure, the followings 6 will
 depend if they coincide or not:
\begin_inset Formula 
\[
T_{random}=\left[12+3+1\cdot0.03\right]+6\cdot\left[\left(1-P_{i}\right)\cdot{\color{red}3.03}+P_{i}\cdot0\right]=15.03+6\cdot\frac{9}{10}\cdot3.03=31.392ms.
\]

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset Formula ${\color{red}3.03}$
\end_inset

 is not a 15.03 because 10 blocks fit in one cylinder, so seek only happens
 the first time.
\end_layout

\begin_layout Subsubsection
Consider a table stored in HDFS with the following characteristics:
\color red
*
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $size\left(T\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
256 MB
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left|T\right|$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
64
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $size\left(row\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 MB
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $cols\left(T\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $size\left(cell\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 MB
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $size\left(Header\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $size\left(Footer\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Enumerate

\series bold
Given the configuration parameters, how much space would you need to store
 it in a horizontal layout (i.e.
 Avro)?
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $size\left(MetaRow\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.1 MB
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $size\left(MetaBody\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.1 MB
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
S\left(Body_{Hor}\right)=S\left(metaBody\right)+\left|T\right|\cdot\left[S\left(metaRow\right)+S\left(dataRow\right)\right]=0.1+64\cdot\left[0.1+4\right]=262.5\ MB.
\]

\end_inset


\begin_inset Formula 
\[
N_{chunks}=\left\lceil \frac{262.5}{128}\right\rceil =3\ chunks.
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Given the configuration parameters, how much space would you need to store
 it in a hybrid layout (i.e.
 Parquet)?
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $size\left(MetaCol\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.2 MB
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $size\left(MetaRowGroup\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.5 MB
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $size\left(RowGroup\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8 MB
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
UsedRowGroups=\frac{Cols\left(T\right)\cdot\left|T\right|\cdot S\left(cell\right)}{S\left(RowGroup\right)-S\left(metaRowGroup\right)-Cols\left(T\right)\cdot S\left(metaCol\right)}=\frac{4\cdot64\cdot1}{8-0.5-4\cdot0.2}=38.209.
\]

\end_inset


\begin_inset Formula 
\begin{align*}
S\left(Body_{Hyb}\right)= & \left\lceil UsedRowGroups\right\rceil \cdot\left[S\left(metaRowGroup\right)+Cols\left(T\right)\cdot S\left(metaCol\right)\right]+Cols\left(T\right)\cdot\left|T\right|\cdot S\left(cell\right)\\
= & 39\cdot\left[0.5+4\cdot0.2\right]+4\cdot64\cdot1=306.7\ MB.
\end{align*}

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Given the configuration parameters, how much data would you need to retrieve
 it in a hybrid layout (i.e.
 Parquet) to project two columns?
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $size\left(MetaCol\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.2 MB
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $size\left(MetaRowGroup\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.5 MB
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $size\left(RowGroup\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8 MB
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
S\left(projCols\right)=Proj\left(T\right)\cdot\frac{\left|T\right|}{UsedRowGroups\left(Hyb\right)}\cdot S\left(cell\right)=2\frac{64}{38.21}1
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
S\left(Project_{Hyb}\right)= & S\left(Header_{Hyb}\right)+S\left(Footer_{Hyb}\right)+\\
 & \left\lceil UsedRowGroups\left(Hyb\right)\right\rceil \cdot\left(S\left(metaRowGroup\right)+proj\left(T\right)+S\left(metaCol\right)\right)\\
 & +UsedRowGroups\left(Hyb\right)\cdot S\left(projCols\right)\\
= & 0+0+39\cdot\left(0.5+2\cdot0.2\right)+38.21\cdot\left[2\frac{64}{38.21}1\right]=163.1\ MB.
\end{align*}

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Given the configuration parameters, how much data would you need to retrieve
 it in a hybrid layout (i.e.
 Parquet) to select one row (e.g.
 given its key) if the table is not sorted?
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $size\left(MetaCol\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.2 MB
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $size\left(MetaRowGroup\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.5 MB
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $size\left(RowGroup\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8 MB
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula 
\[
P\left(RGSelected\right)=1-\left(1-SF\right)^{UsedRows\left(RG\right)}=1-\left(1-\frac{1}{64}\right)^{\frac{64}{38.21}}=0.026
\]

\end_inset


\begin_inset Formula 
\[
UsedRowGroups\left(Select_{Hyb}\right)=UsedRowGroups\left(Hyb\right)\cdot P\left(RGSelected\right)=0.993
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
S\left(Select_{Hyb}\right)= & S\left(Header_{Hyb}\right)+S\left(Footer_{Hyb}\right)+UsedRowGroups\left(Select_{Hyb}\right)\cdot S\left(RowGroup\right)\\
= & 0+0+0.993\cdot8=7.94\ MB.
\end{align*}

\end_inset


\end_layout

\end_deeper
\begin_layout Subsubsection
Given a file with 
\begin_inset Formula $C$
\end_inset

 chunks and 
\begin_inset Formula $N$
\end_inset

 nodes in the cluster, find the probability that HDFS uses all the nodes
 in case 
\begin_inset Formula $C\geq N$
\end_inset

.
\end_layout

\begin_layout Standard
There are
\begin_inset Formula 
\[
N^{C}
\]

\end_inset

 ways that the chunks can be distributed into the nodes.
 
\end_layout

\begin_layout Standard
Among this, the Stirling numbers of the second kind
\begin_inset Foot
status open

\begin_layout Plain Layout
Visit https://en.wikipedia.org/wiki/Stirling_numbers_of_the_second_kind
\begin_inset CommandInset href
LatexCommand href
name "Stirling  Numbers of the second kind in Wikipedia"
target "https://en.wikipedia.org/wiki/Stirling_numbers_of_the_second_kind"
literal "false"

\end_inset

 for more information.
\end_layout

\end_inset

 give us the number of possibilities in which all nodes contain at least
 one chunk, therefore, it is
\begin_inset Formula 
\[
P=\frac{S\left(N,C\right)N!}{N^{C}},
\]

\end_inset

 here, the 
\begin_inset Formula $N!$
\end_inset

 comes because the stirling number does not take into account that the nodes
 are different, i.e., for the Stirling number, it is the same to store two
 chunks in node 1 and one in node 2, as to store one chunk in node 1 and
 two in node 2.
 Therefore, we need to take all possible arrangements into consideration.
 More explicitly, this formula ends up being
\begin_inset Formula 
\[
P=\frac{N!\sum_{i=1}^{C}\frac{\left(-1\right)^{C-i}i^{n}}{\left(C-i\right)!i!}}{N^{C}}.
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Consider an HDFS cluster with 100 data nodes, without replication.
 If I upload a file with 10 chunks and 10 disk blocks each, answer the following
 questions and briefly justify your answer.
\end_layout

\begin_layout Enumerate

\series bold
Which is the maximum number of machines actually contain data?
\end_layout

\begin_deeper
\begin_layout Standard
Since there is no replication, and the unit of distribution is the chunk,
 then at most 10 nodes can contain data.
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Which is the probability of the maximum number of machines actually contain
 data?
\end_layout

\begin_deeper
\begin_layout Standard
According to the formula obtained in the previous exercise, with 
\begin_inset Formula $C=N=10$
\end_inset

, it is
\begin_inset Formula 
\[
P=\frac{10!\sum_{i=1}^{10}\frac{\left(-1\right)^{10-i}i^{10}}{\left(10-i\right)!i!}}{10^{10}}=\frac{567}{1562500}=0.00036288.
\]

\end_inset

 It is very unlikely.
\end_layout

\end_deeper
\begin_layout Subsubsection
Given a file of 3.2 GB stored in an HDFS cluster of 50 machines, and containing
 
\begin_inset Formula $16\times10^{5}$
\end_inset

 key-value pairs in a SequenceFile, estimate the execution time of a Spark
 job containing a single map transformation and an action storing the result
 in a file.
 Explicit any assumption you make and consider also the following parameters:
\end_layout

\begin_layout Itemize

\series bold
Chunk size: 128 MB (default)
\end_layout

\begin_layout Itemize

\series bold
Replication factor: 3 (default)
\end_layout

\begin_layout Itemize

\series bold
Map function (i.e.
 the parameter of the transformation) execution time: 
\begin_inset Formula $10^{-3}$
\end_inset

 sec/call (this is the only cost you have to consider)
\end_layout

\begin_layout Itemize

\series bold
Save action execution time: 0 sec (do not consider this cost)
\end_layout

\begin_layout Standard
There are
\begin_inset Formula 
\[
\frac{3.2GB}{128MB}=25\ chunks
\]

\end_inset

 in the cluster.
 These chunks are replicated three times each, accounting for a total of
 75 chunks in the system.
 However, replicated chunks are not processed unless some error occurs.
 Therefore, we consider only 25 chunks for execution.
\end_layout

\begin_layout Standard
There are
\begin_inset Formula 
\[
\frac{16\cdot10^{5}}{25}=64000\ kv/chunk
\]

\end_inset

 and since there are more machines than chunks, we can execute all chunks
 in parallel.
 Therefore, since the time to execute one chunk is
\begin_inset Formula 
\[
T=T_{call}\cdot N_{kv}=0.001\cdot64000=64s,
\]

\end_inset

 this is also the time to execute the whole job.
\end_layout

\begin_layout Subsubsection
Given a file with 3.2 GB of raw data stored in an HDFS cluster of 50 machines,
 and containing 
\begin_inset Formula $16\times10^{5}$
\end_inset

 rows in a Parquet file; consider you have a query over an attribute 'A=constant
' and this attribute contains only 100 different and equiprobable values.
 Assuming any kind of compression has been disabled, explicit any assumption
 you need to make and give the amount of raw data (i.e.
 do not count metadata) it would need to fetch from disk.
\end_layout

\begin_layout Itemize

\series bold
Replication factor: 3 (default)
\end_layout

\begin_layout Itemize

\series bold
Chunk size: 128 MB (default)
\end_layout

\begin_layout Itemize

\series bold
RowGroup size: 32 MB
\end_layout

\begin_layout Standard
There are
\begin_inset Formula 
\[
\frac{3.2GB}{32MB}=100\ RowGroups
\]

\end_inset

 in the cluster.
 Since the file contains 
\begin_inset Formula $16\times10^{5}$
\end_inset

 rows, each rowgroup contains
\begin_inset Formula 
\[
\frac{16\times10^{5}}{100}=1600\ rows.
\]

\end_inset

 Since attribute 
\begin_inset Formula $A$
\end_inset

 contains 100 different and equiprobable values, then we can consider that
 16 rows will be fetched from each rowgroup.
\end_layout

\begin_layout Standard
In a chunk, there are 4 rowgroups
\end_layout

\begin_layout Subsubsection
Consider a cluster of ten worker machines and a single coordinator, which
 contains a sequence file of 128 MB stored in HDFS with an OS block size
 of 32 KB in all machines and a chunk size of 64 MB.
 On the event of a client retrieving that file, give the number of control
 messages (do not consider data messages) that will travel the network in
 the case of (a) a client cache miss and in the case of (b) a client cache
 hit.
 Briefly justify both numbers.
\end_layout

\begin_layout Itemize
Client cache miss: In this case, when a client requests a file, the client
 first contacts the NameNode to get the location of the first block.
 The NameNode contacts the nodes in which each chunk is located, and then
 they answer the client.
 Therefore, there are 3 control messages, one from client to namenode, and
 two from namenode to datanodes.
\end_layout

\begin_layout Itemize
Client cache hit: In this case, the client knows the locations of the servers,
 so it asks directly them, accounting for just two control messages.
\end_layout

\begin_layout Section
Key-Value Stores
\end_layout

\begin_layout Subsection
Theoretical questions
\end_layout

\begin_layout Subsubsection
Which is the main difference between the hash functions used in the linear
 hash and consistent hash algorithms?
\color red
*
\end_layout

\begin_layout Standard
Linear hash adapts as the system grows, and there are two functions at once.
\end_layout

\begin_layout Standard
Consistent hash consists of a predefined static hash function.
\end_layout

\begin_layout Subsubsection
With respect to distributed systems, explain what is a distributed hash
 table (DHT), and provide a brief description of how consistent hashing
 guarantees balancing keys when adding new servers.
 
\color red
*
\end_layout

\begin_layout Standard
A DHT is a hash table that is divided into buckets, having these buckets
 distributed.
\end_layout

\begin_layout Standard
Consistent hashing guarantees balancing by redistributing the keys at the
 moment of adding new servers, and relies on the big numbers and the assumption
 of well-constructed hash functions.
\end_layout

\begin_layout Subsection
Exercises
\end_layout

\begin_layout Subsubsection
Let's assume we have a Consistent hash with D = 16, and the hash function
 is simply the module of the IP address or the key, and suppose the current
 state of the consistent hash is (position in the ring:key|key|...):
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado8.png
	scale 60

\end_inset


\end_layout

\begin_layout Enumerate

\series bold
What happens when we insert objects 30 and 58? Draw the result.
 
\series default
\color red
*
\end_layout

\begin_deeper
\begin_layout Standard
We have 
\begin_inset Formula 
\[
30\mod16=14,
\]

\end_inset

 so 30 goes to server with IP 14.
 Also,
\begin_inset Formula 
\[
58\mod16=10,
\]

\end_inset

 so 58 goes to server with IP 12:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename bdm_4_2_1.png
	scale 60

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
What happens in the structure when we register a new server with IP address
 37? Draw the result.
 
\series default
\color red
*
\end_layout

\begin_deeper
\begin_layout Standard
It is
\begin_inset Formula 
\[
37\mod16=5,
\]

\end_inset

 so the server is placed between servers 4 and 7.
 Now, we have to replace some elements from server 7:
\begin_inset Formula 
\begin{align*}
21\mod16=5 & \implies Replaced\\
38\mod16=6 & \implies NotReplaced\\
5\mod16=5 & \implies Replaced\\
23\mod16=7 & \implies NotReplaced
\end{align*}

\end_inset

 Therefore, the final result is
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename bdm_4_2_1_b.png
	scale 60

\end_inset


\end_layout

\end_deeper
\begin_layout Subsubsection
Let's suppose we have a Linear Hash and the hash function is simply the
 module of the key, the capacity of a bucket is only four entries, and curent
 state of the linear hash is (bucketID: key|key|...):
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado9.png
	scale 60

\end_inset


\end_layout

\begin_layout Enumerate

\series bold
What happens in the structure when we insert keys 14, 27, 37 and 44? Draw
 the result.
 
\series default
\color red
*
\end_layout

\begin_layout Standard
We have 
\begin_inset Formula $n=2$
\end_inset

, so
\begin_inset Formula 
\[
14\mod2^{2}=2,
\]

\end_inset

 and the first insertion ends up as
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename bdm_4_2_2_1.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
Then, 
\begin_inset Formula 
\[
27\mod2^{2}=3,
\]

\end_inset

 so
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename bdm_4_2_2_2.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
Then, 
\begin_inset Formula 
\[
37\mod2^{2}=1,
\]

\end_inset

 since this is before the pointer, we compute also the next hash
\begin_inset Formula 
\[
37\mod2^{3}=5,
\]

\end_inset

 therefore
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename bdm_4_2_2_3.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
Then, 
\begin_inset Formula 
\[
44\mod2^{2}=0,
\]

\end_inset

 since this is before the pointer, we compute also the next hash
\begin_inset Formula 
\[
44\mod2^{3}=4,
\]

\end_inset

 therefore it goes to 4.
 Since 4 is full, there is an overflow.
 We have to increase the pointer and recompute the values from the affected
 bucket (2):
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename bdm_4_2_2_4.png
	scale 60

\end_inset


\end_layout

\begin_layout Subsubsection
Let's suppose that we have an LSM Tree that reached the threshold to consider
 the MemStore is full, and it contains four entries with format 
\begin_inset Formula $\left[key,value,timestamp\right]$
\end_inset

 needing 10 characters each.
 the content of the different structures is:
\end_layout

\begin_layout Itemize

\series bold
MemStore: 
\begin_inset Formula $\left[1,v,t50\right],\left[15,v,t49\right],\left[17,v,t47\right],\left[29,v,t48\right]$
\end_inset


\end_layout

\begin_layout Itemize

\series bold
Commit Log: 
\begin_inset Formula $\left[17,v,t47\right],\left[29,v,t48\right],\left[15,v,t49\right],\left[1,v,t50\right]$
\end_inset


\end_layout

\begin_layout Itemize

\series bold
SSTable: 
\begin_inset Formula $\left[13,v,t23\right],\left[25,v,t17\right],\left[35,v,t40\right],\left[59,v,t38\right]$
\end_inset


\end_layout

\begin_layout Itemize

\series bold
Index: 
\begin_inset Formula $\left[13,0\right],\left[25,30\right],\left[35,60\right],\left[59,90\right]$
\end_inset


\end_layout

\begin_layout Standard

\series bold
Assuming that the minimum size of an SSTable is 120 characters and on having
 two SSTables, a minor compactation is automatically triggered.
 Explicit the content of all structures once the compactation is done.
 
\series default
\color red
*
\end_layout

\begin_layout Itemize

\series bold
MemStore: 
\begin_inset Formula $\emptyset$
\end_inset


\end_layout

\begin_layout Itemize

\series bold
Commit Log: 
\begin_inset Formula $\emptyset$
\end_inset


\end_layout

\begin_layout Itemize

\series bold
SSTable: 
\begin_inset Formula $\left[13,v,t23\right],\left[25,v,t17\right],\left[35,v,t40\right],\left[59,v,t38\right]$
\end_inset


\series default
,
\begin_inset Formula ${\color{blue}\left[1,v,t50\right],\left[15,v,t49\right],\left[17,v,t47\right],\left[29,v,t48\right]}$
\end_inset


\end_layout

\begin_layout Itemize

\series bold
Index: 
\begin_inset Formula $\left[13,0\right],\left[25,30\right],\left[35,60\right],\left[59,90\right]$
\end_inset


\series default
,
\begin_inset Formula ${\color{blue}\left[1,0\right],\left[15,30\right],\left[17,60\right],\left[29,90\right]}$
\end_inset


\end_layout

\begin_layout Standard
Then, they are merged and ordered by key:
\end_layout

\begin_layout Itemize

\series bold
MemStore: 
\begin_inset Formula $\emptyset$
\end_inset


\end_layout

\begin_layout Itemize

\series bold
Commit Log: 
\begin_inset Formula $\emptyset$
\end_inset


\end_layout

\begin_layout Itemize

\series bold
SSTable: 
\begin_inset Formula $\left[1,v,t50\right],\left[13,v,t23\right],\left[15,v,t49\right],\left[17,v,t47\right],\left[25,v,t17\right],\left[29,v,t48\right],\left[35,v,t40\right],\left[59,v,t38\right]$
\end_inset


\end_layout

\begin_layout Itemize

\series bold
Index: 
\begin_inset Formula $\left[1,0\right],\left[13,30\right],\left[15,60\right],\left[17,90\right],\left[25,120\right],\left[29,150\right],\left[35,180\right],\left[59,210\right]$
\end_inset


\end_layout

\begin_layout Subsubsection
Briefly explain what is wrong in this linear hash structure, or if you think
 it is right, explicitly say so:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado10.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
In this case, 
\begin_inset Formula $n=2$
\end_inset

, and it is not possible to have the pointer pointing to a bucket between
 
\begin_inset Formula $2^{n}$
\end_inset

 and 
\begin_inset Formula $2^{n+1}$
\end_inset

, because the design of the algorithm makes this impossible.
 When 
\begin_inset Formula $2^{n}+1$
\end_inset

 is reached, the pointer goes back to the first bucket and the process starts
 all over.
\end_layout

\begin_layout Subsubsection
Suppose you have a hash function whose range has size 100 (i.e., D=100), and
 a Consistent Hash structure with 5 machines (M1,...,M5) whose identifiers
 map to values 
\begin_inset Formula $h\left(M1\right)=0,h\left(M2\right)=20,h\left(M3\right)=40,h\left(M4\right)=60$
\end_inset

 and 
\begin_inset Formula $h\left(M5\right)=80$
\end_inset

.
 What happens if you have an object mapped to value 
\begin_inset Formula $h\left(O\right)=90$
\end_inset

?
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename bdm_4_2_5.png
	scale 60

\end_inset


\end_layout

\begin_layout Subsubsection
Given an empty consistent hash with 
\begin_inset Formula $h\left(x\right)=x\%32$
\end_inset

 (i.e., we directly take module 32 to both the keys and the bucket IDs), and
 unlimited capacity in each bucket, consider you have a cluster of four
 machines with IDs 19,22,75,92 and draw the result of inserting the following
 keys in the given order: 12, 4, 10, 49, 42, 60, 53, 47, 27, 26, 28, 13,
 52.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename bdm_4_2_6.png
	scale 60

\end_inset


\end_layout

\begin_layout Subsubsection
Suppose you implement a system to store images in hundreds of machines with
 thousands of users using HBase with a single column-family.
 These images taken at time VT belong to a person P who tags each with a
 single subject S (e.g.
 family, friends, etc.) and are concurrently uploaded into the system at
 time TT in personal batches containing multiple pictures of different subjects
 taken at different times.
 Each person can then retrieve all his/her pictures of one single subject
 taken that were taken after a given time.
 Precisely define the key you would use if you exclusively prioritize (i.e.,
 do not consider any other criteria): 
\color red
*
\end_layout

\begin_layout Itemize

\series bold
Load balancing on ingestion: 
\series default
VT, S, P
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
Assumptions made: 
\series default
We want to distribute the data as much as possible.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Load balancing on querying: 
\series default
TT, S, VT
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
Assumptions made: 
\series default
We want to distribute the queries as much as possible.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
I/O cost (i.e., minimum blocks retrieved) on ingestion: 
\series default
P, S, TT, VT
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
Assumptions made: 
\series default
We want to centralize data as much as possible
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
I/O cost (i.e., minimum blocks retrieved) on querying: 
\series default
P, S, VT
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
Assumptions made: 
\series default
We want to centralize the queries as much as possible.
\end_layout

\end_deeper
\begin_layout Subsubsection
Given an empty linear hash with 
\begin_inset Formula $f\left(x\right)=x$
\end_inset

 (i.e., we directly apply the module to the keys), and a capacity of four
 keys per bucket, draw the result of inserting the following keys in the
 given order: 12, 4, 10, 49, 42, 60, 63, 53, 47, 27, 26, 28, 13, 52.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename bdm_4_2_7_1.png
	scale 40

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename bdm_4_2_7_2.png
	scale 40

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename bdm_4_2_7_3.png
	scale 40

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename bdm_4_2_7_4.png
	scale 40

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename bdm_4_2_7_5.png
	scale 40

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename bdm_4_2_7_6.png
	scale 60

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename bdm_4_2_7_7.png
	scale 40

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename bdm_4_2_7_8.png
	scale 40

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename bdm_4_2_7_9.png
	scale 40

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename bdm_4_2_7_10.png
	scale 40

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename bdm_4_2_7_11.png
	scale 40

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename bdm_4_2_7_12.png
	scale 40

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename bdm_4_2_7_13.png
	scale 40

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename bdm_4_2_7_14.png
	scale 40

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Notice that in the last step, when moving objects from 0 to 4, 4 becomes
 full, and it also overflows, so another bucket is created and the pertinent
 moves are done.
\end_layout

\begin_layout Section
Document Stores
\end_layout

\begin_layout Subsection
Problems
\end_layout

\begin_layout Subsubsection
Optimize the performance of the following document design:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

{"_id": 123,
\end_layout

\begin_layout Plain Layout

"name": "Alberto"
\end_layout

\begin_layout Plain Layout

"address": {
\end_layout

\begin_layout Plain Layout

"street": "Jordi Girona",
\end_layout

\begin_layout Plain Layout

"city": "Barcelona",
\end_layout

\begin_layout Plain Layout

"zip_code": "08034"},
\end_layout

\begin_layout Plain Layout

"telephone1": "93 4137889",
\end_layout

\begin_layout Plain Layout

"telephone2": "93 4137840",
\end_layout

\begin_layout Plain Layout

"telephone3": "123456789"
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Optimize the performance of the following pipe:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

db.partsupp.aggregate([
\end_layout

\begin_layout Plain Layout

{"$sort": {"n_name": 1, "s_name": 1, "p_partkey": 1}},
\end_layout

\begin_layout Plain Layout

{"$match": {"part.p_size": 5},
\end_layout

\begin_layout Plain Layout

{"$project": {
\end_layout

\begin_layout Plain Layout

"supplier.s_name": 1,
\end_layout

\begin_layout Plain Layout

"supplier.s_phone": 1,
\end_layout

\begin_layout Plain Layout

"supplier.s_comment": 1,
\end_layout

\begin_layout Plain Layout

"_id": 0
\end_layout

\begin_layout Plain Layout

}}
\end_layout

\begin_layout Plain Layout

])
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Assume you have a MongoDB collection which occupies 6 chunks evenly distributed
 in 3 shards (i.e., 2 chunks per shard).
 Being the document ID also the shard key, the chunk of a document is determined
 by means of a hash function.
 Assuming that accessing one document takes one time unit (existing indexes
 are used at no cost) and we have 6000 documents in the collection, 
\begin_inset Formula $k$
\end_inset

 of which have value 'YYY' for attribute 'other', how many units would take
 the following operations
\begin_inset Foot
status open

\begin_layout Plain Layout
As typically in RDBMS optimizers, assume uniform distribution of values
 and statistical independence between pairs of attributes.
\end_layout

\end_inset

:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $FindOne\left(\left\{ \_id:"XXX"\right\} \right)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $Find\left(\left\{ \_id:\left\{ \$in:\left[1,...,3000\right]\right\} \right\} \right)$
\end_inset

, being 
\begin_inset Formula $\left[1,6000\right]$
\end_inset

 the range of existing IDs.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $Find\left(\left\{ other:"YYY"\right\} \right)$
\end_inset

, being the attribute indexed.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $Find\left(\left\{ other:"YYY\right\} \right)$
\end_inset

, being the attribute not indexed.
\end_layout

\begin_layout Subsubsection
Assume you have a MongoDB collection which occupies 6 chunks unevenly distribute
d in 3 shards (i.e., 1, 2 and 3 chunks per shard, respectively).
 Being the document Id also the shard key, the chunk of a document is determined
 by means of a hash function.
 Assuming that accessing one document takes one time unit (existing indexes
 are used at no cost) and we have 6000 documents in the collection, 
\begin_inset Formula $k$
\end_inset

 of which have value 'YYY' for attribute 'other', how many times units would
 take the following operations
\begin_inset Foot
status open

\begin_layout Plain Layout
As typically in RDBMS optimizers, assume uniform distribution of values
 and statistical independence between pairs of attributes.
\end_layout

\end_inset

:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $FindOne\left(\left\{ \_id:"XXX"\right\} \right)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $Find\left(\left\{ \_id:\left\{ \$in:\left[1,...,3000\right]\right\} \right\} \right)$
\end_inset

, being 
\begin_inset Formula $\left[1,6000\right]$
\end_inset

 the range of existing IDs.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $Find\left(\left\{ other:"YYY"\right\} \right)$
\end_inset

, being the attribute indexed.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $Find\left(\left\{ other:"YYY\right\} \right)$
\end_inset

, being the attribute not indexed.
\end_layout

\begin_layout Subsubsection
Assume you have a MongoDB collection which occupies 6 chunks evenly distributed
 in 3 shards (i.e., 2 chunks per shard).
 Being the document Id also the shard key, the chunk of a document is determined
 by range.
 Assuming that accessing one document takes one time unit (existing indexes
 are used at no cost) and we have 6000 documents in the collection, 
\begin_inset Formula $k$
\end_inset

 of which have value 'YYY' for attribute 'other', how many times units would
 take the following operations
\begin_inset Foot
status open

\begin_layout Plain Layout
As typically in RDBMS optimizers, assume uniform distribution of values
 and statistical independence between pairs of attributes.
\end_layout

\end_inset

:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $FindOne\left(\left\{ \_id:"XXX"\right\} \right)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $Find\left(\left\{ \_id:\left\{ \$in:\left[1,...,3000\right]\right\} \right\} \right)$
\end_inset

, being 
\begin_inset Formula $\left[1,6000\right]$
\end_inset

 the range of existing IDs.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $Find\left(\left\{ other:"YYY"\right\} \right)$
\end_inset

, being the attribute indexed.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $Find\left(\left\{ other:"YYY\right\} \right)$
\end_inset

, being the attribute not indexed.
\end_layout

\begin_layout Subsubsection
Assume a MongoDB collection of JSON documents following the structure shown
 below.
 Indicate a sequence of stage operators that can be used in a pipeline to
 compute the top five departments in terms of number of employees such that
 its location has at least one performance_review greater than 7.
 In the example below, since both locations have performance reviewss greater
 than 7, manufacturing has a total of 90 employees, while billing and sales
 have 80 and 40 employees, respectively.
 You need only to provide the names of the stage operators and the sequence
 in which they are applied.
 You should not use the mapreduce feature of MongoDB, but rather the specific
 stage operators provided by MongoDB.
 You do not need to explicitly handle the case of ties (i.e., in the case
 of ties, you may return any of the tied documents to complete the top five).
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

{ "location": "Barcelona",
\end_layout

\begin_layout Plain Layout

"budget": 3.000.000,
\end_layout

\begin_layout Plain Layout

"departments": [ { "name": "sales", "employees": 40 }, { "name": "manufacturing"
,
\end_layout

\begin_layout Plain Layout

"employees": 75 } ],
\end_layout

\begin_layout Plain Layout

"performance_reviews": [ 7, 6, 3 ]
\end_layout

\begin_layout Plain Layout

},
\end_layout

\begin_layout Plain Layout

{ "location": "Brussels",
\end_layout

\begin_layout Plain Layout

"budget": 5.000.000,
\end_layout

\begin_layout Plain Layout

"departments": [ { "name": "manufacturing", "employees": 15 }, { "name":
 "billing
\end_layout

\begin_layout Plain Layout

", "employees": 80 } ],
\end_layout

\begin_layout Plain Layout

"performance_reviews": [ 6, 8, 7 ]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Imagine you want to design a system to maintain data about citizens and
 doubt whether to use HBase or MongoDB.
 Precisely, for each citizen, it will store: their personal data (with pID),
 their city data (with cID) and their employment data.
 We also know the workload (i.e., queries and frequency of execution) is as
 follows:
\end_layout

\begin_layout Itemize

\series bold
\begin_inset Formula $Q_{1}$
\end_inset

: average salary in Barcelona (50% frequency) - information obtained from
 the set of city and employment data.
\end_layout

\begin_layout Itemize

\series bold
\begin_inset Formula $Q_{2}$
\end_inset

: average weight for you people (less than 18 years old) (45% frequency)
 - information obtained from the set of personal data.
\end_layout

\begin_layout Itemize

\series bold
\begin_inset Formula $Q_{3}$
\end_inset

: number of VIPs (5% frequency) - information obtained from the set of personal
 data.
\end_layout

\begin_layout Standard

\series bold
Discuss your choice of technology and data model, without pre-computing
 the results of the queries.
 Clearly specify the structure of the data (i.e., tables/collections, keys,
 values, etc.), trade-offs, and assumptions made.
\end_layout

\begin_layout Subsubsection
Analyze (i.e., briefly give pros and cons) the following JSON design compared
 to other equivalent JSON designs from the three perspectives:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

"BID-PRODUCT":{
\end_layout

\begin_layout Plain Layout

"B_ID": int(4), "B_PRICE": int(4), "U_ID": int(4),
\end_layout

\begin_layout Plain Layout

"PRODUCT": {
\end_layout

\begin_layout Plain Layout

"P_ID": int(4), "P_INFO": varchar(100)
\end_layout

\begin_layout Plain Layout

}}
\end_layout

\begin_layout Plain Layout

"PRODUCT-SELLER-REGION": {
\end_layout

\begin_layout Plain Layout

"P_ID": int(4), "P_INFO": varchar(100),
\end_layout

\begin_layout Plain Layout

"USER": {
\end_layout

\begin_layout Plain Layout

"U_ID": int(4), "U_F_NAME": varchar(20),
\end_layout

\begin_layout Plain Layout

"REGION": {
\end_layout

\begin_layout Plain Layout

"R_ID": int(4), "R_NAME": varchar(10)
\end_layout

\begin_layout Plain Layout

}}}
\end_layout

\begin_layout Plain Layout

"PRODUCT-COMMENTS": {
\end_layout

\begin_layout Plain Layout

"P_ID": int(4), "P_INFO": varchar(100),
\end_layout

\begin_layout Plain Layout

"COMMENTS": [{
\end_layout

\begin_layout Plain Layout

"C_ID": int(4), "C_TITLE": varchar(20), "U_ID": int(4)
\end_layout

\begin_layout Plain Layout

}]}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate

\series bold
Read (a.k.a Query)
\end_layout

\begin_deeper
\begin_layout Enumerate

\series bold
Pros:
\end_layout

\begin_layout Enumerate

\series bold
Cons:
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Update
\end_layout

\begin_deeper
\begin_layout Enumerate

\series bold
Pros:
\end_layout

\begin_layout Enumerate

\series bold
Cons:
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Memory (a.k.a.
 Space)
\end_layout

\begin_deeper
\begin_layout Enumerate

\series bold
Pros:
\end_layout

\begin_layout Enumerate

\series bold
Cons:
\end_layout

\end_deeper
\begin_layout Section
New Relational Architecture
\end_layout

\begin_layout Subsection
Theoretical questions
\end_layout

\begin_layout Subsubsection
Briefly explain the concept of associativity in the context of memory usage.
 Identify the benefit of high (respectively low) associativity.
 
\end_layout

\begin_layout Subsection
Problems
\end_layout

\begin_layout Subsubsection
Assume you have a SanssouciuDB table T stored row-wise, which ocupies 300
 blocks and contains tuples with three variable length attributes [
\bar under
A
\bar default
,B,C] (underlined attribute is declared to be the primary key of the table).
 Assume there is no index and give the average cost of each query assuming
 accessing one block is one second.
 
\color red
*
\end_layout

\begin_layout Itemize

\series bold
SELECT A,B,C FROM T WHERE A=x; (being x a constant)
\end_layout

\begin_deeper
\begin_layout Standard
The probability of 
\begin_inset Formula $A=x$
\end_inset

 in block 
\begin_inset Formula $k$
\end_inset

 is 
\begin_inset Formula $\frac{1}{300}$
\end_inset

.
 Therefore, the average cost is
\begin_inset Formula 
\[
C=\sum_{k=1}^{300}\left(\sum_{j=1}^{k}c\left(j\right)\cdot P\left(A=x|j\right)\right)=\sum_{k=1}^{300}\left(\sum_{j=1}^{k}1\frac{1}{300}\right)=\frac{1}{300}\sum_{k=1}^{300}k=\frac{1}{300}\frac{300\cdot301}{2}=150.5s.
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
SELECT SUM(B) FROM T;
\end_layout

\begin_deeper
\begin_layout Standard
In this case, we have to access all of them:
\begin_inset Formula 
\[
C=300s.
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Subsubsection
Assume you have a SanssouciuDB table T stored column-wise, which ocupies
 300 blocks and contains tuples with three variable length attributes [
\bar under
A
\bar default
,B,C] (underlined attribute is declared to be the primary key of the table).
 Assume there is no index, storage of each attribute uses exactly the same
 space after compression (i.e., 100 blocks), and run length encoding has been
 applied for non-key attributes storing ending row position per run.
 Give the average cost of each query assuming accessing one block is one
 second and explicit any other assumption you make.
 
\color red
*
\end_layout

\begin_layout Itemize

\series bold
SELECT A,B,C FROM T WHERE A=x; (being x a constant)
\end_layout

\begin_deeper
\begin_layout Standard
Find 
\begin_inset Formula $x$
\end_inset

 in 
\begin_inset Formula $A$
\end_inset

 is
\begin_inset Formula 
\[
C_{A}=\frac{101}{2}=50.5s.
\]

\end_inset

 Now, we know the position, and since the encoding is done with ending row
 position, we can access it directly.
 Therefore, 
\begin_inset Formula $C_{B}=C_{C}=1s$
\end_inset

 and the total cost is
\begin_inset Formula 
\[
C=52.5s.
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
SELECT SUM(B) FROM T;
\end_layout

\begin_deeper
\begin_layout Standard
We need to traverse all of 
\begin_inset Formula $B$
\end_inset

, so 
\begin_inset Formula $C=100s$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Subsubsection
Assume that there is a table T with attributes [
\bar under
A
\bar default
,B,C] (the underlined attribute is the primary key of the table), which
 occupies 300 disk blocks of 8 KB each, with 100 B per row.
 All three attributes require the same space (even in case of compression).
 Supposing that there is not any index, which would be the minimum amount
 of memory required to process (do not consider the memory required to store
 the final output of the query) the following query in either row storage
 or column storage (briefly justify your answer and explicit any assumption
 you make).
\end_layout

\begin_layout Standard

\series bold
SELECT A FROM T WHERE B='x' and C='y'; 
\series default
\color red
*
\end_layout

\begin_layout Itemize

\series bold
Row storage:
\series default
 1 Block.
 We can have just one block in memory at a time, an check the conditions
 inside each block, storing the wanted results accordingly.
\end_layout

\begin_layout Itemize

\series bold
Column storage:
\series default
 3 Blocks.
 In this case, we need to store a block in memory for each column, to be
 able to make the three comparisons for each row.
\end_layout

\begin_layout Subsubsection
Without considering compression and assuming a disk block size of 8 KB,
 is there any case where a query retrieving all tuples, but only half of
 the equally-sized attributes of a relaitonal table performs better in row
 storage without any kind of vertical partitioning than in columnar storage?
 Numerically justify your answer.
\end_layout

\begin_layout Subsubsection
Represent the given column with dictionary and run-length encoding storing
 and row position.
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Table
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
A
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
A
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
B
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
B
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
B
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
C
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
A
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
A
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Dictionary
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
End Row
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Code
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection
Given the two columns of a table represented with run-length encoding using
 dictionary, give the position of the row(s) that fulfill the predicate
 
\begin_inset Quotes eld
\end_inset

Charlie AND Beta
\begin_inset Quotes erd
\end_inset

.
 Briefly explain how a column store would obtain them.
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="8cm">
<column alignment="center" valignment="top" width="8cm">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Dictionary
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bravo
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Charlie
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Values
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Dictionary Positions
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Dictionary
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Alpha
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Beta
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Values
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Dictionary Positions
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Section
Distributed Processing Frameworks
\end_layout

\begin_layout Subsection
MapReduce in use: Theoretical questions
\end_layout

\begin_layout Subsubsection
Classify a MapReduce system as either query-shipping (i.e., the evaluation
 of the query is delegated to the site where the data is stored), data-shipping
 (i.e., the data is moved from the stored site to the site executing the query)
 or hybrid (i.e., both query and data shipping).
 Clearly justify your answer.
\end_layout

\begin_layout Subsection
MapReduce in use: Problems
\end_layout

\begin_layout Subsubsection
Consider the following implementation of the Cartesian Product with MapReduce
 (
\begin_inset Formula $\oplus$
\end_inset

 stands for concatenation) and answer the questions accordingly:
\begin_inset Formula 
\[
T\times S\implies\begin{cases}
map\left(key\ k,value\ v\right)\mapsto\\
\left[\left(h_{T}\left(k\right)\ \mod D,k\oplus v\right)\right] & if\ input\left(k\oplus v\right)=T\\
\left[\left(0,k\oplus v,...,\left(D-1,k\oplus v\right)\right)\right] & if\ input\left(k\oplus v\right)=S\\
reduce\left(key\ ik,vset\ ivs\right)\mapsto\\
\left[\begin{array}{c}
crossproduct\left(T_{ik},S\right)|\\
T_{ik}=\left\{ iv|iv\in ivs\land input\left(iv\right)T\right\} ,\\
S=\left\{ iv|iv\in ivs\land input\left(iv\right)S\right\} 
\end{array}\right]
\end{cases}.
\]

\end_inset


\end_layout

\begin_layout Enumerate

\series bold
Which is the relationship of 
\begin_inset Formula $D$
\end_inset

 with parallelism and scalability, if any?
\end_layout

\begin_layout Enumerate

\series bold
Which is the optimal value for 
\begin_inset Formula $D$
\end_inset

?
\end_layout

\begin_layout Subsubsection
Provide the MapReduce pseudo-code implementation of the following relational
 operators.
 You can use 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\oplus$
\end_inset


\begin_inset Quotes erd
\end_inset

 symbol for concatenation, 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $prj_{a_{i_{1}}...a_{i_{n}}}\left(t\right)$
\end_inset


\begin_inset Quotes erd
\end_inset

 to get attributes 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $a_{i_{1}}...a_{i_{n}}$
\end_inset


\begin_inset Quotes erd
\end_inset

 in 
\begin_inset Formula $t$
\end_inset

, 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $crossproduct\left(S_{1},S_{2}\right)$
\end_inset


\begin_inset Quotes erd
\end_inset

 to perform the cross product of two sets of rows, and assume the 
\begin_inset Quotes eld
\end_inset

key
\begin_inset Quotes erd
\end_inset

 parameter contains the PL of the table and the 
\begin_inset Quotes eld
\end_inset

value
\begin_inset Quotes erd
\end_inset

 one all the others.
\end_layout

\begin_layout Itemize

\series bold
Aggregation (
\begin_inset Formula $\gamma_{A,f\left(B\right)}\left(T\right)$
\end_inset

)
\end_layout

\begin_layout Itemize

\series bold
Selection (
\begin_inset Formula $\sigma_{P}\left(T\right)$
\end_inset

)
\end_layout

\begin_layout Itemize

\series bold
Join (
\begin_inset Formula $T\bowtie_{T.A=S.B}S$
\end_inset

)
\end_layout

\begin_layout Itemize

\series bold
Union (
\begin_inset Formula $T\cup S$
\end_inset

)
\end_layout

\begin_layout Itemize

\series bold
Difference (
\begin_inset Formula $T\setminus S$
\end_inset

)
\end_layout

\begin_layout Itemize

\series bold
Intersection (
\begin_inset Formula $T\cap S$
\end_inset

)
\end_layout

\begin_layout Subsubsection
In relational algebra, the antijoin operator (
\begin_inset Formula $\triangleright$
\end_inset

) is defined as the complement of the semijoin on the primary keys (PKs).
 Formally, assuming 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 are the PLs of 
\begin_inset Formula $R$
\end_inset

 and 
\begin_inset Formula $S$
\end_inset

, respectively, then
\begin_inset Formula 
\[
R\triangleright S=R\setminus R\ltimes{}_{A=B}S
\]

\end_inset

 Provide the MapReduce pseudo-code implementation of the antijoin operator.
 Assume the existence of the operator 
\begin_inset Formula $\oplus$
\end_inset

 to concatenate strings, 
\begin_inset Formula $prj_{att}\left(s\right)$
\end_inset

 to project attribute 
\begin_inset Formula $att$
\end_inset

 from the tuple 
\begin_inset Formula $s$
\end_inset

, and 
\begin_inset Formula $input\left(s\right)$
\end_inset

 to decide the origin (i.e., 
\begin_inset Formula $R$
\end_inset

 or 
\begin_inset Formula $S$
\end_inset

) from a tuple 
\begin_inset Formula $s$
\end_inset

.
\end_layout

\begin_layout Subsection
MapReduce internals: Problems
\end_layout

\begin_layout Subsubsection
Assume the following MapReduce program:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++}"
inline false
status open

\begin_layout Plain Layout

public void map(LongWritable key, Text value) {
\end_layout

\begin_layout Plain Layout

String line = value.toString();
\end_layout

\begin_layout Plain Layout

StringTokenizer tokenizer = new StringTokenizer(line);
\end_layout

\begin_layout Plain Layout

while (tokenizer.hasMoreTokens()) {
\end_layout

\begin_layout Plain Layout

write(new Text(tokenizer.nextToken()), new IntWritable(1));
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

public void reduce(Text key, Iterable<IntWritable> values) {
\end_layout

\begin_layout Plain Layout

int sum = 0;
\end_layout

\begin_layout Plain Layout

for (IntWritable val : values) {
\end_layout

\begin_layout Plain Layout

sum += val.get();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

write(key, new IntWritable(sum));
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Consider the following dataset:
\end_layout

\begin_layout Itemize

\series bold
Block0: 
\begin_inset Quotes eld
\end_inset

a b b a c | c d c e a
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize

\series bold
Block1: 
\begin_inset Quotes eld
\end_inset

a b d d a | b b c c d
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Subsubsection*
Simulate the execution of the MapReduce code given the following configuration:
\end_layout

\begin_layout Itemize

\series bold
The map and reduce functions are those of the wordcount.
 The combine function shares the implementation of the reduce.
\end_layout

\begin_layout Itemize

\series bold
One Split is one block.
\end_layout

\begin_layout Itemize

\series bold
The 
\begin_inset Quotes eld
\end_inset

|
\begin_inset Quotes erd
\end_inset

 divides the records inside each block.
 We have two records per block.
\end_layout

\begin_layout Itemize

\series bold
Hadoop is configured with the parameter 
\begin_inset Formula $dfs.replication=1$
\end_inset

.
\end_layout

\begin_layout Itemize

\series bold
We can keep four pairs [key, value] per spill
\end_layout

\begin_layout Itemize

\series bold
We have two mappers and two reducers:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $Machine0$
\end_inset

 
\series bold
contains block0, runs mapper0 and reducer0
\end_layout

\begin_layout Itemize
\begin_inset Formula $Machine1$
\end_inset

 
\series bold
contains block1, runs mapper1 and reducer1
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
The hash functions used to shuffle data to the reducers uses the correspondence:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\left\{ b,d,f\right\} \rightarrow0$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left\{ a,c,e\right\} \rightarrow1$
\end_inset


\end_layout

\end_deeper
\begin_layout Subsubsection*
Fill the gaps in each step (numbers correspond to the phase in the MapReduce
 algorithm):
\end_layout

\begin_layout Enumerate
\begin_inset Formula $Machine0$
\end_inset

 
\series bold
contains
\series default
 
\series bold
...
 block(s).
 
\begin_inset Formula $Machine1$
\end_inset

 contains ...
 block(s).
\end_layout

\begin_layout Enumerate

\series bold
We keep ...
 replica(s) (including the master copy) per block.
\end_layout

\begin_layout Enumerate

\series bold
We have ...
 split(s) per machine.
\end_layout

\begin_layout Enumerate

\series bold
Mapper0 reads ...
 records.
 Mapper1 reads ...
 records.
\end_layout

\begin_layout Enumerate

\series bold
Memory content during each spill in 
\begin_inset Formula $Machine0$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Spill1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Spill2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Spill3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Spill4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[][][][]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[][][][]
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard

\series bold
Spills in 
\begin_inset Formula $Machine1$
\end_inset

:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Spill1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Spill2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Spill3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Spill4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[][][][]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[][][][]
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Three substeps:
\end_layout

\begin_deeper
\begin_layout Enumerate

\series bold
Partitions in 
\begin_inset Formula $Machine0$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="6">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Spill1
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Spill2
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Spill3
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Partition0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Partition1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Partition0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Partition1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Partition0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Partition1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard

\series bold
Partitions in 
\begin_inset Formula $Machine1$
\end_inset

:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="6">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Spill1
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Spill2
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Spill3
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Partition0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Partition1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Partition0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Partition1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Partition0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Partition1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Partitions in 
\begin_inset Formula $Machine0$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="6">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Spill1
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Spill2
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Spill3
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Partition0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Partition1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Partition0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Partition1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Partition0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Partition1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard

\series bold
Partitions in 
\begin_inset Formula $Machine1$
\end_inset

:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="6">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Spill1
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Spill2
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Spill3
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Partition0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Partition1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Partition0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Partition1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Partition0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Partition1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Files in 
\begin_inset Formula $Machine0$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File0.0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File0.1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File0.2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File0.3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File0.4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File0.5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard

\series bold
Files in 
\begin_inset Formula $Machine1$
\end_inset

:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File1.0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File1.1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File1.2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File1.3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File1.4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File1.5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] []
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate

\series bold
Merges in 
\begin_inset Formula $Machine0$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Merge0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Merge1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] [] []
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard

\series bold
Merges in 
\begin_inset Formula $Machine1$
\end_inset

:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Merge0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Merge1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] [] []
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Files in 
\begin_inset Formula $Machine0$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File0.0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File0.1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] [] []
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard

\series bold
Files in 
\begin_inset Formula $Machine1$
\end_inset

:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File1.0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File1.1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] [] []
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Reducer0 reads ...
 from 
\begin_inset Formula $Machine0$
\end_inset

 and ...
 from 
\begin_inset Formula $Machine1$
\end_inset

.
 Reducer1 reads ...
 from 
\begin_inset Formula $Machine0$
\end_inset

 and ...
 from 
\begin_inset Formula $Machine1$
\end_inset

.
\end_layout

\begin_layout Enumerate

\series bold
Merges in 
\begin_inset Formula $Machine0$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Merge0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Merge1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] [] []
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard

\series bold
Merges in 
\begin_inset Formula $Machine1$
\end_inset

:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Merge0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Merge1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] [] []
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] [] []
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Reduce function is executed ...
 times in 
\begin_inset Formula $Machine0$
\end_inset

.
 Reduce function is executed ...
 times in 
\begin_inset Formula $Machine1$
\end_inset

.
\end_layout

\begin_layout Enumerate

\series bold
Files in 
\begin_inset Formula $Machine0$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Output0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] [] []
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard

\series bold
Files in 
\begin_inset Formula $Machine1$
\end_inset

:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Output1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[] [] [] [] []
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Subsubsection
Let's suppose that we have a cluster of 100 machines and a MapReduce job
 with 1 000 000 key-value pairs in the input that generate 100 000 pairs
 in the output.
 Assume that both map and reduce functions generate one pair in the output
 per call.
 Assuming the reduce function is commutative and associative, is it worth
 to use the combine function? Briefly justify your answer.
\end_layout

\begin_layout Subsection
Spark in use: Problems
\end_layout

\begin_layout Subsubsection
Consider a file (
\begin_inset Formula $wines.txt$
\end_inset

) containing the following data:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

wines.txt
\end_layout

\begin_layout Plain Layout

type 1,2.064254
\end_layout

\begin_layout Plain Layout

type 3,2.925376
\end_layout

\begin_layout Plain Layout

type 2,2.683955
\end_layout

\begin_layout Plain Layout

type 1,2.991452
\end_layout

\begin_layout Plain Layout

type 2,2.861996
\end_layout

\begin_layout Plain Layout

type 1,2.727688
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Provide the ordered list of Spark operations (no need to follow the exact
 syntax, just the kind of operation and main parameters) you'd need to retrieve
 the minimum value per type.
 Do not use SQL and minimize the use of other Python libraries or code.
 Save the results in 
\begin_inset Formula $output.txt$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Consider two files containing the following data:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Employees.txt
\end_layout

\begin_layout Plain Layout

EMP1;CARME;400000;MATARO;DPT1
\end_layout

\begin_layout Plain Layout

EMP2;EUGENIA;350000;TOLEDO;DPT2
\end_layout

\begin_layout Plain Layout

EMP3;JOSEP;250000;SITGES;DPT3
\end_layout

\begin_layout Plain Layout

EMP4;RICARDO;250000;MADRID;DPT4
\end_layout

\begin_layout Plain Layout

EMP5;EULALIA;150000;BARCELONA;DPT5
\end_layout

\begin_layout Plain Layout

EMP6;MIQUEL;125000;BADALONA;DPT5
\end_layout

\begin_layout Plain Layout

EMP7;MARIA;175000;MADRID;DPT6
\end_layout

\begin_layout Plain Layout

EMP8;ESTEBAN;150000;MADRID;DPT6
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Departments.txt
\end_layout

\begin_layout Plain Layout

DPT1;DIRECCIO;10;PAU CLARIS;BARCELONA
\end_layout

\begin_layout Plain Layout

DPT2;DIRECCIO;8;RIOS ROSAS;MADRID
\end_layout

\begin_layout Plain Layout

DPT3;MARKETING;1;PAU CLARIS;BARCELONA
\end_layout

\begin_layout Plain Layout

DPT4;MARKETING;3;RIOS ROSAS;MADRID
\end_layout

\begin_layout Plain Layout

DPT5;VENDES;1;MUNTANER;BARCELONA
\end_layout

\begin_layout Plain Layout

DPT6;VENDES;1;CASTELLANA;MADRID
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Provide the ordered list of Spark operations (no need to follow the exact
 syntax, just the kind of operation and main parameters) you'd need to retrieve
 for each employee his/her department information.
 Do not use SQL and minimize the use of other Python libraries or code.
 Save the results in 
\begin_inset Formula $output.txt$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Consider an error log file (
\begin_inset Formula $log.txt$
\end_inset

) like the one below:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

log.txt
\end_layout

\begin_layout Plain Layout

20150323;0833;ERROR;Oracle
\end_layout

\begin_layout Plain Layout

20150323;0835;WARNING;MySQL
\end_layout

\begin_layout Plain Layout

20150323;0839;WARNING;MySQL
\end_layout

\begin_layout Plain Layout

20150323;0900;WARNING;Oracle
\end_layout

\begin_layout Plain Layout

20150323;0905;ERROR;MySQL
\end_layout

\begin_layout Plain Layout

20150323;1013;OK;Oracle
\end_layout

\begin_layout Plain Layout

20150323;1014;OK;MySQL
\end_layout

\begin_layout Plain Layout

20150323;1055;ERROR;Oracle
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Provide the ordered list of Spark operations (no need to follow the exact
 syntax, just the kind of operation and main parameters) you'd need to retrieve
 the lines corresponding to both 
\begin_inset Formula $errors$
\end_inset

 and 
\begin_inset Formula $warnings$
\end_inset

, but adding 
\begin_inset Formula $Important:$
\end_inset

 at the begginning of those of 
\begin_inset Formula $errors$
\end_inset

 (i.e., only 
\begin_inset Formula $errors$
\end_inset

).
 Do not use SQL and minimize the use of other Python libraries or code.
 Save the results in 
\begin_inset Formula $output.txt$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Given two files contianing the following kinds of data:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Employees.txt with fields: 
\end_layout

\begin_layout Plain Layout

	EmployeeID; EmployeeName; YearlySalary; CityOfResidence; SiteOfWork
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	EMP4;RICARDO;250000;MADRID;DPT4
\end_layout

\begin_layout Plain Layout

	EMP5;EULALIA;150000;BARCELONA;DPT5
\end_layout

\begin_layout Plain Layout

	EMP6;MIQUEL;125000;BADALONA;DPT5
\end_layout

\begin_layout Plain Layout

	EMP7;MARIA;175000;MADRID;DPT6
\end_layout

\begin_layout Plain Layout

	EMP8;ESTEBAN;150000;MADRID;DPT6
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Departments.txt with fields: 
\end_layout

\begin_layout Plain Layout

	SiteID; DepartmentName; StreetNumber; StreetName; City
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	DPT1;DIRECCIO;10;PAU CLARIS;BARCELONA
\end_layout

\begin_layout Plain Layout

	DPT2;DIRECCIO;8;RIOS ROSAS;MADRID
\end_layout

\begin_layout Plain Layout

	DPT3;MARKETING;1;PAU CLARIS;BARCELONA
\end_layout

\begin_layout Plain Layout

	DPT4;MARKETING;3;RIOS ROSAS;MADRID
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Consider the following PySpark code and answer the questions below:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Python"
inline false
status open

\begin_layout Plain Layout

source1 = spark.read.format("csv").load("employees.txt", header='false', inferSchema
='true', sep=";")
\end_layout

\begin_layout Plain Layout

source2 = spark.read.format("csv").load("departments.txt", header='false', inferSche
ma='true', sep=";")
\end_layout

\begin_layout Plain Layout

A = source1.toDF("eID","eName","eSalary","eCity","eDpt","eProj")
\end_layout

\begin_layout Plain Layout

B = source2.toDF("dID","dArea","dNumber","dStreet","dCity")
\end_layout

\begin_layout Plain Layout

C = A.select(A.eCity.alias("city"))
\end_layout

\begin_layout Plain Layout

D = B.select("dArea")
\end_layout

\begin_layout Plain Layout

E = D.crossJoin(C)
\end_layout

\begin_layout Plain Layout

F = B.select("dArea",B.dCity.alias("city"))
\end_layout

\begin_layout Plain Layout

G = E.subtract(F)
\end_layout

\begin_layout Plain Layout

H = G.select("dArea")
\end_layout

\begin_layout Plain Layout

result = D.subtract(H)
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate

\series bold
State in natural language the corresponding query it would answer.
\end_layout

\begin_layout Enumerate

\series bold
Clearly indicate any mistake or improvement you can fix/make in the code.
 For each of them give (1) the line number, (2) pseudo-code to implement
 the fix, and (3) brief rationale.
\end_layout

\begin_layout Subsubsection
Given two files containing the following kinds of data:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Employees.txt with fields: 
\end_layout

\begin_layout Plain Layout

	EmployeeID; EmployeeName; YearlySalary; CityOfResidence; SiteOfWork
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	EMP1;RICARDO;250000;MADRID;DPT1
\end_layout

\begin_layout Plain Layout

	EMP2;EULALIA;150000;BARCELONA;DPT2
\end_layout

\begin_layout Plain Layout

	EMP3;MIQUEL;125000;BADALONA;DPT3
\end_layout

\begin_layout Plain Layout

	EMP4;MARIA;175000;MADRID;DPT4
\end_layout

\begin_layout Plain Layout

	EMP5;ESTEBAN;150000;MADRID;DPT3
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

Departments.txt with fields: 
\end_layout

\begin_layout Plain Layout

	SiteID; DepartmentName; StreetNumber; StreetName; City
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	DPT1;DIRECCIO;10;PAU CLARIS;BARCELONA
\end_layout

\begin_layout Plain Layout

	DPT2;DIRECCIO;8;RIOS ROSAS;MADRID
\end_layout

\begin_layout Plain Layout

	DPT3;MARKETING;1;PAU CLARIS;BARCELONA
\end_layout

\begin_layout Plain Layout

	DPT4;MARKETING;3;RIOS ROSAS;MADRID
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Give a sequence of Spark operations in pseudo-code (resembling PySpark)
 to obtain for each city where employees that work in a site of a department
 in Barcelona live, the sum of the salaries of those employees.
 The result for the exemplary data would be:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MADRID;400000
\end_layout

\begin_layout Plain Layout

BARCELONA;125000
\end_layout

\begin_layout Plain Layout

...
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Conider three files containing the following kinds of data:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Employees.txt
\end_layout

\begin_layout Plain Layout

	EMP1,CARME,400000,MATARO,DEPT1,PROJ1
\end_layout

\begin_layout Plain Layout

	EMP2,EULALIA,150000,BARCELONA,DEPT2,PROJ1
\end_layout

\begin_layout Plain Layout

	EMP3,MIQUEL,125000,BADALONA,DEPT1,PROJ3
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Projects.txt
\end_layout

\begin_layout Plain Layout

	PROJ1,IBDTEL,TV,1000000
\end_layout

\begin_layout Plain Layout

	PROJ2,IBDVID,VIDEO,500000
\end_layout

\begin_layout Plain Layout

	PROJ3,IBDTEF,TELEPHONE,200000
\end_layout

\begin_layout Plain Layout

	PROJ4,IBDCOM,COMMUNICATIONS,2000000
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Departments.txt
\end_layout

\begin_layout Plain Layout

	DEPT1,MANAGEMENT,10,PAU CLARIS,BARCELONA
\end_layout

\begin_layout Plain Layout

	DEPT2,MANAGEMENT,8,RIOS ROSAS,MADRID
\end_layout

\begin_layout Plain Layout

	DEPT4,MARKETING,3,RIOS ROSAS,MADRID
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Provide the ordered list of Spark operations (no need to follow the exact
 syntax, but just the kind of operation and main parameters) you would need
 to obtain the departments with all employees assigned to the same prooject.
 The result must include department number.
 Save the results in 
\begin_inset Formula $output.txt$
\end_inset

.
 In the previous example, the result should be 
\begin_inset Formula $DEPT2$
\end_inset

 and 
\begin_inset Formula $DEPT4$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Consider two files containing the following kinds of data:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Employees.txt
\end_layout

\begin_layout Plain Layout

	EMP4;RICARDO;250000;MADRID;DPT4
\end_layout

\begin_layout Plain Layout

	EMP5;EULALIA;150000;BARCELONA;DPT5
\end_layout

\begin_layout Plain Layout

	EMP6;MIQUEL;125000;BADALONA;DPT5
\end_layout

\begin_layout Plain Layout

	EMP7;MARIA;175000;MADRID;DPT6
\end_layout

\begin_layout Plain Layout

	EMP8;ESTEBAN;150000;MADRID;DPT6
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Departments.txt
\end_layout

\begin_layout Plain Layout

	DPT1;DIRECCIO;10;PAU CLARIS;BARCELONA
\end_layout

\begin_layout Plain Layout

	DPT2;DIRECCIO;8;RIOS ROSAS;MADRID
\end_layout

\begin_layout Plain Layout

	DPT3;MARKETING;1;PAU CLARIS;BARCELONA
\end_layout

\begin_layout Plain Layout

	DPT4;MARKETING;3;RIOS ROSAS;MADRID
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Provide the ordered list of Spark operations (no need to follow the exact
 syntax, but just the kind of operation and main parameters) you'd need
 to retrieve the list of department IDs for those departments with workers
 from all cities where there are employees.
 Save the results in 
\begin_inset Formula $output.txt$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Consider two files containing the following kinds of data:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Employees.txt
\end_layout

\begin_layout Plain Layout

	EMP1;RICARDO;250000C;MADRID;SITE2
\end_layout

\begin_layout Plain Layout

	EMP2;EULALIA;150000C;BARCELONA;SITE1
\end_layout

\begin_layout Plain Layout

	EMP3;MIQUEL;125000C;BADALONA;SITE3
\end_layout

\begin_layout Plain Layout

	EMP4;MARIA;175000C;MADRID;SITE2
\end_layout

\begin_layout Plain Layout

	EMP5;ESTEBAN;150000C;MADRID;SITE4
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Departments.txt
\end_layout

\begin_layout Plain Layout

	SITE1;DPT.MANAGEMENT;FLOOR10;ST.PAU CLARIS;BARCELONA
\end_layout

\begin_layout Plain Layout

	SITE2;DPT.MANAGEMENT;FLOOR8;ST.RIOS ROSAS;MADRID
\end_layout

\begin_layout Plain Layout

	SITE3;DPT.MARKETING;FLOOR1;ST.PAU CLARIS;BARCELONA
\end_layout

\begin_layout Plain Layout

	SITE4;DPT.MARKETING;FLOOR1;ST.RIOS ROSAS;MADRID
\end_layout

\begin_layout Plain Layout

	SITE5;DPT.MARKETING;FLOOR5;ST.MARTI PUJOL;BADALONA
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Provide the ordered list of Spark operations (no need to follow the exact
 syntax, but just the kind of operation and main parameters) you'd need
 to retrieve the list of department IDs for those departments with sites
 in all cities where employees live (these employees can be even from other
 departments).
 Save the results in 
\begin_inset Formula $output.txt$
\end_inset

.
 In the previous example, the result should be 
\begin_inset Formula $DPT.MARKETING$
\end_inset

, because it has sites in all the three cities where there are employees
 (i.e., MADRID, BARCELONA and BADALONA).
 However, 
\begin_inset Formula $DPT.MANAGEMENT$
\end_inset

 should not be in the result, because it does not have any site in BADALONA,
 where EMP3 lives.
\end_layout

\begin_layout Subsubsection
Consider three files relating to a bibliographic database: 
\begin_inset Formula $author.csv$
\end_inset

 relates authors with papers (you may assume that author names are unique,
 that authors have one or more papers, and that papers have one or more
 authors); 
\begin_inset Formula $title.csv$
\end_inset

 gives the title of a paper (you may assume a paper has one title, but one
 title may be shared by many papers); and 
\begin_inset Formula $citation.csv$
\end_inset

 indicates which papers cite which other papers (you may assume that each
 paper cites at least one other paper, that a paper may be cited or more
 times, and that a paper cannot cite itself).
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

author.csv
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

AUTHOR			PAPERID
\end_layout

\begin_layout Plain Layout

...
   			...
\end_layout

\begin_layout Plain Layout

C.
 Gutierrez		GP2014
\end_layout

\begin_layout Plain Layout

C.
 Gutierrez		AGP2013
\end_layout

\begin_layout Plain Layout

C.
 Gutierrez		GZ2011
\end_layout

\begin_layout Plain Layout

...				...
\end_layout

\begin_layout Plain Layout

J.
 Perez			GP2014
\end_layout

\begin_layout Plain Layout

J.
 Perez			AGP2013
\end_layout

\begin_layout Plain Layout

J.
 Perez			P2017
\end_layout

\begin_layout Plain Layout

...				...
\end_layout

\begin_layout Plain Layout

R.
 Angles			AGP2013
\end_layout

\begin_layout Plain Layout

R.
 Angles			AKK2016
\end_layout

\begin_layout Plain Layout

...				...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

title.csv
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

PAPERID			TITLE
\end_layout

\begin_layout Plain Layout

...
 				...
\end_layout

\begin_layout Plain Layout

GP2014 			Semantics of SPARQL
\end_layout

\begin_layout Plain Layout

AGP2013 			Deduction for RDF
\end_layout

\begin_layout Plain Layout

GZ2011 			Graph databases
\end_layout

\begin_layout Plain Layout

...
 				...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

citation.csv
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

PAPER 			CITES
\end_layout

\begin_layout Plain Layout

...
 			...
\end_layout

\begin_layout Plain Layout

GP2014 			AGP2013
\end_layout

\begin_layout Plain Layout

AGP2013 			GZ2011
\end_layout

\begin_layout Plain Layout

P2017 			AKK2016
\end_layout

\begin_layout Plain Layout

...
 			...
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
The count of self-citations for an author 
\begin_inset Formula $A$
\end_inset

, denoted 
\begin_inset Formula $self\left(A\right)$
\end_inset

, is defined as the number of citation pairs 
\begin_inset Formula $\left(P_{1},P_{2}\right)$
\end_inset

 where 
\begin_inset Formula $A$
\end_inset

 is the author of both.
 The count of citations given by an author 
\begin_inset Formula $A$
\end_inset

, denoted 
\begin_inset Formula $give\left(A\right)$
\end_inset

, is the count of citation pairs 
\begin_inset Formula $\left(P_{1},P_{2}\right)$
\end_inset

 such that 
\begin_inset Formula $A$
\end_inset

 is an author of 
\begin_inset Formula $P_{1}$
\end_inset

.
 The count of citations received by 
\begin_inset Formula $A$
\end_inset

, denoted 
\begin_inset Formula $receive\left(A\right)$
\end_inset

, is the count of citation pairs 
\begin_inset Formula $\left(P_{1},P_{2}\right)$
\end_inset

 where 
\begin_inset Formula $A$
\end_inset

 is an author of 
\begin_inset Formula $P_{2}$
\end_inset

.
 The ratio of self-citations to all citations given and received are then
 defined, respectively, as 
\begin_inset Formula $\frac{self\left(A\right)}{give\left(A\right)}$
\end_inset

 and 
\begin_inset Formula $\frac{self\left(A\right)}{receive\left(A\right)}$
\end_inset

.
 In case that 
\begin_inset Formula $receive\left(A\right)=0$
\end_inset

, you should omit the author 
\begin_inset Formula $A$
\end_inset

 from the results (note that 
\begin_inset Formula $give\left(A\right)$
\end_inset

 cannot be 0, as an author must have at least one paper, and a paper must
 have at least one citation).
 We provide an example output for the input data:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
AUTHOR
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SELFGIVERATIO
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SELFRECEIVERATIO
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C.
 Gutierrez
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1.000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1.000
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
J.
 Perez
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.333
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1.000
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
R.
 Angles
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.000
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard

\series bold
We will use Apache Spark to perform the analysis and compute the output.
 You should not assume any ordering of the input files.
 You do not need to order the output file in any particular way.
\end_layout

\begin_layout Standard

\series bold
Given this input and desired output, design a Spark process to complete
 the required processing.
 In particular, you should draw the high-level DAG of operations that the
 Spark process will perform, detailing the sequence of transformations and
 actions.
 You should briefly describe what each step does, clearly indicating which
 steps are transformations and which are actions.
 You should also indicate which RDDs are cirtual and which will be materialized.
 You should use caching if appropriate.
 You should provide details on any functions passed as arguments to the
 transformations/actions you use.
\end_layout

\begin_layout Subsection
Spark internals: Theoretical questions
\end_layout

\begin_layout Subsubsection
What indicates to Spark query optimizer the end of a stage and the beginning
 of the next one?
\end_layout

\begin_layout Subsection
Spark internals: Problems
\end_layout

\begin_layout Subsubsection
Considering the file and result example, briefly indicate the problems you
 find in the Spark code below (if any), and modify the code to fix them
 (if needed).
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Employees.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	EMP1;CARME;40000;MATARO;DPT1;PROJ1
\end_layout

\begin_layout Plain Layout

	EMP2;EUGENIA;35000;TOLEDO;DPT2;PROJ1
\end_layout

\begin_layout Plain Layout

	EMP3;JOSEP;25000;SITGES;DPT3;PROJ2
\end_layout

\begin_layout Plain Layout

	EMP4;RICARDO;25000;MADRID;DPT4;PROJ2
\end_layout

\begin_layout Plain Layout

	EMP5;EULALIA;15000;BARCELONA;DPT5;PROJ2
\end_layout

\begin_layout Plain Layout

	EMP6;MIQUEL;12500;BADALONA;DPT5;PROJ3
\end_layout

\begin_layout Plain Layout

	EMP7;MARIA;17500;MADRID;DPT6;PROJ3
\end_layout

\begin_layout Plain Layout

	EMP8;ESTEBAN;15000;MADRID;DPT6;PROJ3
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Expected result
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[ PROJ1,[ EUGENIA, 35000, 37500.0 ] ]
\end_layout

\begin_layout Plain Layout

[ PROJ2,[ EULALIA, 15000, 21666.6 ] ]
\end_layout

\begin_layout Plain Layout

[ PROJ3,[ MIQUEL, 12500, 15000.0 ] ]
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

rawEmps = sc.textFile(r"Employees.txt")
\end_layout

\begin_layout Plain Layout

emps = rawEmps.map(lambda l: tuple(l.split(";"))).cache()
\end_layout

\begin_layout Plain Layout

RDD1 = emps.map(lambda t: (t[5], (int(t[2]), 1)))
\end_layout

\begin_layout Plain Layout

RDD2 = RDD1.reduceByKey(lambda t1, t2: (t1[0] + t2[0])/(t1[1] + t2[1]))
\end_layout

\begin_layout Plain Layout

RDD3 = emps.map(lambda t: (t[5], t))
\end_layout

\begin_layout Plain Layout

RDD4 = RDD3.join(RDD2)
\end_layout

\begin_layout Plain Layout

RDD5 = RDD4.filter(lambda t: int(t[1][0][2])<t[1][1])
\end_layout

\begin_layout Plain Layout

RDD6 = RDD5.map(lambda t: (t[0],(t[1][0][1],t[1][0][2],t[1][1])))
\end_layout

\begin_layout Plain Layout

Result = RDD6.sortByKey()
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Consider the following pipeline.
 This pipeline runs in a 4-machine cluster with HDFS to store the files
 and Spark to execute it.
 
\begin_inset Formula $File1$
\end_inset

 and 
\begin_inset Formula $File2$
\end_inset

 are distributed in the cluster in 6 chunks each.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

RddF1 := sc.textFile(''...file1.txt'')
\end_layout

\begin_layout Plain Layout

RddF2 := sc.textFile(''...file2.txt'')
\end_layout

\begin_layout Plain Layout

Rdd2 := RddF1.mapToPair(s.split('';'')[0],s.split('';'')[1-2])
\end_layout

\begin_layout Plain Layout

Rdd3 := Rdd2.GroupByKey()
\end_layout

\begin_layout Plain Layout

Rdd4 := Rdd3.MapValues(f1)
\end_layout

\begin_layout Plain Layout

Rdd5 := RddF2.mapToPair(s.split('';'')[0],s.split('';'')[1-2])
\end_layout

\begin_layout Plain Layout

Rdd6 := Rdd5.GroupByKey()
\end_layout

\begin_layout Plain Layout

Rdd7 := Rdd6.MapValues(f2)
\end_layout

\begin_layout Plain Layout

Rdd8 := Rdd4.join(Rdd7)
\end_layout

\begin_layout Plain Layout

Rdd8.save(''...file3.txt'')
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate

\series bold
How many stages will the scheduler generate for this pipeline? (Justify
 your answer)
\end_layout

\begin_layout Enumerate

\series bold
How many tasks will be generated within each stage? (Justify your answer)
\end_layout

\begin_layout Subsubsection
Consider the legacy code written in MapReduce that specifies a 
\begin_inset Formula $map\left(\right),combine\left(\right)$
\end_inset

 and 
\begin_inset Formula $reduce\left(\right)$
\end_inset

 operations.
 This job reads from a text file 
\begin_inset Formula $f_{1}$
\end_inset

.
 The combine and reduce operations coincide and you can assume all functions
 are correct.
 Write a Spark pipeline equivalent to the MapReduce job.
 Use 
\begin_inset Formula $fmap$
\end_inset

 and 
\begin_inset Formula $freduce$
\end_inset

 to refer to the code executed inside the map and combine/reduce operations.
 You can parameterize the 
\begin_inset Formula $fmap$
\end_inset

 and 
\begin_inset Formula $freduce$
\end_inset

 functions but resulting in minimal code adaptation.
\end_layout

\begin_layout Subsubsection
Assume we have a MongoDB collection in a distributed cluster, which contains
 prices of apartments without any secondary index.
 Such collection is big enough not to completely fit in memory.
 We want to use Spark to compute the standard deviation per neighbourhood.
 Clearly identify the most efficient option and briefly justify the choice
 (it is not necessary to provide the Spark code).
\end_layout

\begin_layout Enumerate

\series bold
Use Spark only to push the query to MongoDB aggregation framework and simply
 get the result.
\end_layout

\begin_layout Enumerate

\series bold
Push only some of the operations to MongoDB aggregation framework and then
 run the rest in Spark.
\end_layout

\begin_layout Enumerate

\series bold
Load the whole collection to an RDD and perform all computations in Spark.
\end_layout

\begin_layout Section
Streams
\end_layout

\begin_layout Subsection
Problems
\end_layout

\begin_layout Subsubsection
Let's suppose an arrival rate 
\begin_inset Formula $\lambda=50\ msg/sec$
\end_inset

 and a service rate 
\begin_inset Formula $\mu=50\ msg/sec$
\end_inset

.
 Given the message arrivals in the table below and a size of 
\begin_inset Formula $100B$
\end_inset

 per message, which is the minimum buffer size needed to guarantee that
 no message is lost?
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="11">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Time
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
#Messages
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
50
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
75
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
150
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
40
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection
Let's suppose a stationary situation in the processing of a stream, where
 the whole memory available is occupied by messages.
 Assume also the existence of a separated buffer big enough to allow us
 the complete processing of these messages already in memory without being
 concerned with new arrivals.
 Assume we have 
\begin_inset Formula $M=10$
\end_inset

 memory pages with 
\begin_inset Formula $R_{S}=10$
\end_inset

 messages per page.
 If the processing of these messages consists only of a lookup and in-memory
 processing/comparison of a message and a tuple is thousand times smaller
 than a disk access, give the cost in these two situations considering that
 every disk block of the table contains also 
\begin_inset Formula $R_{T}=10$
\end_inset

 tuples:
\end_layout

\begin_layout Enumerate

\series bold
Going through an index for each message with cost 
\begin_inset Formula $h=3$
\end_inset

 for the index and one more disk access to the lookup table per message.
\end_layout

\begin_layout Enumerate

\series bold
Bringing each block of the lookup table (whose size is 
\begin_inset Formula $B=100$
\end_inset

) into memory one by one and checking all messages in memory against all
 its tuples.
\end_layout

\begin_layout Subsubsection
Let's suppose that setting the execution environment for the processing
 of messages in a stream is 
\begin_inset Formula $S=100$
\end_inset

 (e.g., placing & retrieving all the information to/from the stack), independently
 of their number.
 Both packing and unpacking the messages in a batch (i.e., a list of elements)
 have the same cost of 
\begin_inset Formula $Pk=1$
\end_inset

 per message, and processing each message is 
\begin_inset Formula $Ps=10$
\end_inset

.
\end_layout

\begin_layout Enumerate

\series bold
Which is the cost of truly streaming 10 messages one at a time?
\end_layout

\begin_layout Enumerate

\series bold
Which is the cost of processing one packed micro-batch of 10 messages at
 once?
\end_layout

\begin_layout Subsubsection
Let's suppose we have a log file recording the events coming from different
 machines.
 Thus, for each event we have the following information:
\begin_inset Formula 
\[
\left(logID,traceID,eventID,duration\right)
\]

\end_inset

 The 
\begin_inset Formula $logID$
\end_inset

 corresponds to the IP of the machine; the 
\begin_inset Formula $traceID$
\end_inset

 identifies the transaction inside the machine (i.e., two traceIDs can coincide
 in different machines); the 
\begin_inset Formula $eventID$
\end_inset

 identifies the kind of action performed by the machine; finally, the 
\begin_inset Formula $duration$
\end_inset

 is the number of milliseconds taken to implement the action.
 Assuming that we cannot keep all log entries in memory, and we decide to
 randomly sample them, give the attributes (up to three) you would use as
 parameters of the hash function implementing such sampling, so that each
 of the following queries gives a result as accurate as possible.
\end_layout

\begin_layout Enumerate

\series bold
Estimate the fraction of transactions where the same kind of action appears
 more than once.
\end_layout

\begin_layout Enumerate

\series bold
For each machine, estimate the average number of actions per transaction.
\end_layout

\begin_layout Enumerate

\series bold
Estimate the number of transactions with more than two actions taking more
 than 100ms.
\end_layout

\begin_layout Enumerate

\series bold
Estimate the average sum of the duration per transaction.
\end_layout

\begin_layout Subsubsection
Let's suppose we have a black-list of IP addresses (whose packages we do
 not want to cross our firewall), which it too long to be kept in memory
 (
\begin_inset Formula $10^{7}$
\end_inset

 elements).
 Thus, we decide to implement a Bloom filter (to avoid further processing
 of black-listed addresses), with only 
\begin_inset Formula $10^{8}$
\end_inset

 bits.
\end_layout

\begin_layout Enumerate

\series bold
How many hash functions would you use?
\end_layout

\begin_layout Enumerate

\series bold
What's the probability of a false positive in that case?
\end_layout

\begin_layout Enumerate

\series bold
Briefly explain what is the consequence of a false positive in this concrete
 case.
\end_layout

\begin_layout Subsubsection
Let's suppose we have a log file recording the events coming from different
 machines.
 Thus, for each event we have the following information:
\begin_inset Formula 
\[
\left(logID,traceID,eventID,duration\right).
\]

\end_inset

 The 
\begin_inset Formula $logID$
\end_inset

 corresponds to the IP of the machine; the 
\begin_inset Formula $traceID$
\end_inset

 identifies the transaction inside the machine; the 
\begin_inset Formula $eventID$
\end_inset

 identifies the kind of action performed by the machine; finally, the 
\begin_inset Formula $duration$
\end_inset

 is the number of milliseconds taken to implement the action.
 Consider the following table and assume that each machine generates the
 same number of events and at the same pace, and use an exponentially decaying
 window model with a constant 
\begin_inset Formula $c=0.5$
\end_inset

.
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Time
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
logID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
traceID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
eventID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
duration
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
D
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Enumerate

\series bold
Give the milliseconds (and details of calculation) used per machine (i.e.
 for Machine 1 and Machine 2) when the last event arrives, provided that
 the current milliseconds are more valuable than the oldest ones.
\end_layout

\begin_layout Subsubsection
Assume we ingest a stream with an event every time a ticket is sold at a
 theater.
 Precisely, the stream has the following structure:
\begin_inset Formula 
\[
\left(movieID,theaterID,timestamps,price\right).
\]

\end_inset

 Next, we ingest the following ordered set of events:
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(m1,t1,12h,10\text{€}\right)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(m2,t1,14h,12\text{€}\right)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(m2,t2,15h,18\text{€}\right)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(m1,t3,18h,6\text{€}\right)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(m3,t2,19:15h,13\text{€}\right)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(m1,t3,19:30h,10\text{€}\right)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(m2,t3,19:45h,25\text{€}\right)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(m3,t1,20h,17\text{€}\right)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(m1,t3,20:30h,10\text{€}\right)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(m2,t2,21h,8\text{€}\right)$
\end_inset


\end_layout

\begin_layout Standard

\series bold
Provide a detailed answer (i.e., describe the process) for the following questions
:
\end_layout

\begin_layout Enumerate

\series bold
Which theaters would be considered heavy hitters by the algorithm, given
 a required frequency of 50%?
\end_layout

\begin_layout Enumerate

\series bold
Under the exponentially-decaying window model, using an aging constant of
 
\begin_inset Formula $c=0.1$
\end_inset

 and a purging threshold of 
\begin_inset Formula $0.6$
\end_inset

 (i.e., we'll remove movies as soon as their popularity falls strictly below
 
\begin_inset Formula $0.6$
\end_inset

).
 What would be the most popular movies at 21h, considering an aging tick
 every 15 minutes? Give the value corresponding for each of the movies in
 that moment.
\end_layout

\begin_layout Subsubsection
If you have a stream of messages that arrive at a rate of 10 000 per second
 accounting for 512 MB per hour, how many RDDs will process your Spark Streaming
 process in one hour? Explicit all the assumptions you make.
\end_layout

\begin_layout Subsubsection
Assume we ingest a stream with an event every time a ticket is sold at a
 theater.
 Precisely, the stream has the structure 
\begin_inset Formula $\left(movieID,theaterID,timestamp,price\right)$
\end_inset

.
 Nest, we ingest the following ordered set of events:
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(m3,t4,12h,10\text{€}\right)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(m1,t2,13h,17\text{€}\right)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(m2,t4,14h,11\text{€}\right)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(m4,t1,15h,8\text{€}\right)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(m1,t3,16h,9\text{€}\right)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(m3,t4,17h,5\text{€}\right)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(m6,t1,18h,15\text{€}\right)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(m5,t2,19h,12\text{€}\right)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(m7,t5,20h,17\text{€}\right)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(m1,t1,21h,11\text{€}\right)$
\end_inset


\end_layout

\begin_layout Standard

\series bold
Which theaters would be considered heavy hitters (using the approximate
 method) considering a required frequency of 33%? Provide a detailed answer(i.e.,
 describe the content of the auxiliary structure after processing every
 message).
\end_layout

\begin_layout Section
Architectures
\end_layout

\begin_layout Subsection
Theoretical questions
\end_layout

\begin_layout Subsubsection
What problems do Data Lakes solve?
\end_layout

\begin_layout Subsection
Problems
\end_layout

\begin_layout Subsubsection
Consider the software architecture below and briefly explain the main management
 (maintenance) risk it has.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado11.png

\end_inset


\end_layout

\end_body
\end_document
