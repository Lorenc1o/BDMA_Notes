#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{graphicx}
\usepackage{color}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amsfonts}
%\usepackage{epstopdf}
\usepackage{matlab}
\end_preamble
\use_default_options true
\begin_modules
tcolorbox
customHeadersFooters
theorems-ams-bytype
theorems-sec-bytype
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=blue, urlcolor=marineblue, citecolor=green, pdfstartview={FitH}, unicode=true"
\papersize a4paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\boxbgcolor #62a0ea
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 3cm
\rightmargin 2cm
\bottommargin 3cm
\headheight 2cm
\headsep 1cm
\footskip 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle fancy
\listings_params "morekeywords={if, then, is, in, return, for, Let, do, while, all, Initialize,or, function, mark, as, not, any},morecomment={[f][\color{purple}]{\#}},escapechar={<@}"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
INFOH423 - Data Mining
\end_layout

\begin_layout Date
Fall 2022
\end_layout

\begin_layout Author
Jose Antonio Lorencio Abril
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 1200px-Université_libre_de_Bruxelles_(logo).svg.png
	scale 10

\end_inset


\end_layout

\begin_layout Standard
\align right
Professor: Mahmoud Sakr
\end_layout

\begin_layout Standard
\align right
Student e-mail: jose.lorencio.abril@ulb.be
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Address
This is a summary of the course 
\emph on
Data Mining
\emph default
, taught at the Université Libre de Bruxelles by Professor Mahmoud Sakr
 in the academic year 22/23.
 Most of the content of this document is adapted from the course notes by
 Sakr, 
\begin_inset CommandInset citation
LatexCommand cite
key "Sakr2022"
literal "false"

\end_inset

, and the basic bibliographic source of the course, the book of Aggarwal,
 
\begin_inset CommandInset citation
LatexCommand cite
key "Aggarwal_2015"
literal "false"

\end_inset

, so I won't be citing it all the time.
 Other references will be provided when used.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList table

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList algorithm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Introduction
\end_layout

\begin_layout Section
What is data mining?
\end_layout

\begin_layout Standard
Even though there is not a formal-accepted-by-all definition of data mining,
 most of them are in agreement that data mining is a field of study that
 focuses on the collection, cleaning, processing, analysis and gaining of
 useful insights from the data that we have access to.
\end_layout

\begin_layout Standard
As wider as these topics are, is also the data mining domain, which is nowadays
 a really hot topic both in academia and industry.
\end_layout

\begin_layout Standard
In academia, there exist many goals to achieve in this field:
\end_layout

\begin_layout Itemize
Developing new models.
\end_layout

\begin_layout Itemize
Developing new ways to deal with real world data.
\end_layout

\begin_layout Itemize
Understading what some complex models are actually doing.
\end_layout

\begin_layout Itemize
Developing the mathematical tools to be able to better describe the models
 that are made by computer scientist in a less formalized way (it is not
 rare that scientific models come before their mathematical formalization
\begin_inset Foot
status open

\begin_layout Plain Layout
For example, for Newton, differential calculus was just a tool he developed
 to be able to better understand some physical processes that were kind
 of obvious to him.
 Afterwards, it became one of the widest branches of mathematics and led
 to other mathematical tools, theories and developments in many other fields.
\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize
Using of data mining to gain a better understanding of medical, biological,
 chemical, economic,...
 data than we are able to gain using just traditional statistic techniques.
\end_layout

\begin_layout Standard
In the industry, the focus is mainly in two fields (disregarding research
 companies, which would have similar objectives as academia):
\end_layout

\begin_layout Itemize
Using well known models to understand what happened in the past.
\end_layout

\begin_layout Itemize
Using well known models to try to predict what will happen in the future.
\end_layout

\begin_layout Standard
These usages are made with the aim of improving the business processes and,
 ultimately, maximize profit.
\end_layout

\begin_layout Subsection
Why is data mining important today, if it was not yesterday?
\end_layout

\begin_layout Standard
Because the computing power has increased enormously, so now we are able
 to run algorithms that enable us to train models in a decent time, and
 this task was practically undoable a few years ago.
\end_layout

\begin_layout Standard
Not only that, but the data technology is rapidly evolving, too.
 We produce more data and store more data, so...
 we have more data! This data is potential knowledge and we know many tools
 to get this knowledge from it.
 
\end_layout

\begin_layout Standard
In fact, the amount of data is so vast, that not only we have to develop
 techniques to analyze data, but also to manage huge amounts of data.
\end_layout

\begin_layout Section
The Data Mining Process
\end_layout

\begin_layout Standard
The data mining process is a pipeline constructed around the basic steps:
\end_layout

\begin_layout Enumerate

\series bold
Data collection
\series default
: obtention of data from real world sources.
\end_layout

\begin_layout Enumerate

\series bold
Feature extraction 
\series default
and 
\series bold
data cleaning
\series default
: among all data retrieved from the real world, we have to select those
 characteristics or 
\series bold
features
\series default
 that are relevant for our purposes (feature extraction) and to decide what
 to do with mistaken/noisy/lost data (data cleaning).
 Also, as we might be collecting data from different sources, it is important
 to decide how to aggregate the data into a unified format for later processing.
\end_layout

\begin_layout Enumerate

\series bold
Analytical processing 
\series default
and 
\series bold
algorithms
\series default
: we now must develop suitable methods for analyzing our data.
 That is, we should decide what mathematical models to use to describe our
 data, and what algorithms to use in order to 
\emph on
train
\emph default
 the desired model
\begin_inset Foot
status open

\begin_layout Plain Layout
We will see what is specifically the meaning of 
\emph on
train
\emph default
, but in the meanwhile we can think of it as how we make a general model
 adapt to our particular data.
\end_layout

\end_inset

.
\end_layout

\begin_layout Enumerate
After these steps, we would enter a phase of analyzing the obtained results
 to obtain knowledge from data, as well as a iterative procedure, in which
 we could return to any previous step and try to improve different parts
 of the process
\begin_inset Foot
status open

\begin_layout Plain Layout
Usually, data is constantly updating, so at least it will necessary to produce
 checks of correctness and updates.
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Data Types
\end_layout

\begin_layout Standard
Not all data have have the same nature nor characteristic, so it is important
 to understand the differences between them and what techniques are applicable
 to what types of data.
\end_layout

\begin_layout Standard
We can characterize data in different levels of detail, and the most basic
 classification would distinguish between 
\emph on
nondependency-oriented
\emph default
 data and 
\emph on
dependency-oriented
\emph default
 data:
\end_layout

\begin_layout Itemize

\series bold
Nondependency-oriented data
\series default
: simple data types with no specified dependencies between the data items
 or the attributes.
\end_layout

\begin_layout Itemize

\series bold
Dependency-oriented data
\series default
: implicit or explicit relationships may exist between data items.
 
\end_layout

\begin_layout Standard
Dependency-oriented data are normally more complex to study because of the
 need to study not only the data itself, but also the relationships between
 different data items.
\end_layout

\begin_layout Standard
We will now define different subtypes of data that we can find.
\end_layout

\begin_layout Subsection
Nondependency-oriented data
\end_layout

\begin_layout Standard
The term nondependency-oriented data is interchangeable with the term 
\series bold
multidimensional data:
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
We will call 
\series bold
source space
\series default
, 
\begin_inset Formula $\mathcal{S}$
\end_inset

, to the set of all possible values that our data can take.
 This set does not have neccessarily to take any particular form.
 
\end_layout

\begin_layout Definition
If 
\begin_inset Formula $\mathcal{S}$
\end_inset

 is a product space, then each component is called a 
\series bold
feature
\series default
.
\end_layout

\end_inset


\end_layout

\begin_layout Example
If we are measuring the name, age, height and gender of the students of
 a school, then we will have
\begin_inset Formula 
\[
\mathcal{S}=\mathcal{T}\times\mathbb{N}\cap\left[0,150\right]\times\left(0,3\right)\times\left\{ M,F\right\} ,
\]

\end_inset

 where 
\begin_inset Formula $\mathcal{T}$
\end_inset

 represents the set of possible names and 
\begin_inset Formula $\left\{ M,F\right\} $
\end_inset

 are the two possible values of the gender.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
A 
\series bold
record
\series default
 (
\emph on
data point, instance, tuple
\emph default
) is just a point 
\begin_inset Formula $X=\left(x^{i}\right)_{i=1}^{d}\in\mathcal{S}$
\end_inset

 that we measure and store in some form.
\end_layout

\end_inset


\end_layout

\begin_layout Example
Following the previous example, some records of 
\begin_inset Formula $\mathcal{S}$
\end_inset

 are represented in the following table:
\end_layout

\begin_layout Example
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset CommandInset label
LatexCommand label
name "table:records_example"

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
index
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Age
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Height
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Gender
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Josh
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
23
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1.77
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
M
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
28
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1.62
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
F
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Larry
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1.58
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
M
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Records and multidimensional data set example
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Example
Note that we added an index column, because it is a common practice.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
A 
\series bold
multidimensional data set
\series default
, 
\begin_inset Formula $\mathcal{D}$
\end_inset

, is a set of 
\begin_inset Formula $n$
\end_inset

 records, 
\begin_inset Formula $\left\{ X_{j}\right\} _{j=1}^{n}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Example
Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "table:records_example"
plural "false"
caps "false"
noprefix "false"

\end_inset

 represents an example of a dataset, too.
\end_layout

\begin_layout Standard
As we can see, Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "table:records_example"
plural "false"
caps "false"
noprefix "false"

\end_inset

 contains attributes of different types (very obvious from the definition
 of the source space 
\begin_inset Formula $\mathcal{S}$
\end_inset

).
 Thus, we have to take into account also the type of each attributes of
 our data:
\end_layout

\begin_layout Itemize

\series bold
Quantitative multidimensional data
\series default
: numerical data features, as age or height.
 If a data set is wholy compound of this kind of features, it is said to
 be a quantitative multidimensional data.
 
\end_layout

\begin_deeper
\begin_layout Standard
This type of data is the easiest to analyze, as mathematical tools are directly
 applicable and most algorithms are developed assuming this type of data.
 For this reason, it is common to try to transform all non-quantitative
 data into quantitative data.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Categorical and Mixed Attribute data
\series default
: a 
\series bold
categorical
\series default
 feature is such that it can only take values among a finite set (unordered)
 of options, as the gender.
 
\end_layout

\begin_deeper
\begin_layout Standard
If we encounter a data set compound of categorial data, we would say it
 is a categorical multidimensional data.
\end_layout

\begin_layout Standard
A dataset with both quantitative and categorical features is called a mixed
 multidimensional data.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Binary and Set data
\series default
: binary data take values in 
\begin_inset Formula $\left\{ 0,1\right\} $
\end_inset

 and it can be considered a special case of both numerical data (obviously)
 and categorical data (as if have a categorical feature which can only take
 two values, then it is easy to map these values to the set 
\begin_inset Formula $\left\{ 0,1\right\} $
\end_inset

).
 For example, the gender is an obvious case of binary data.
\end_layout

\begin_deeper
\begin_layout Standard
Moreover, binary data can be seen as setwise data, where 1 indicates that
 the instance is in the set, while 0 indicates it is not.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Text data
\series default
: usually a string, such as the name.
\end_layout

\begin_layout Subsection
Dependency-oriented data
\end_layout

\begin_layout Standard
As outlined before, we can find implicit or explicit dependencies between
 instances:
\end_layout

\begin_layout Itemize

\series bold
Implicit dependencies
\series default
: the dependencies between instancies are not explicitly specified but are
 known to exist.
 For example, if we measure the number of students in the library every
 5 minutes, we would find that different instances are related via the temporal
 dimension, so measures with little time delay between them would be similar.
\end_layout

\begin_layout Itemize

\series bold
Explicit dependencies
\series default
: this term usually refers to graph or network data, in which edges represents
 relationships between nodes.
\end_layout

\begin_layout Standard
As before, let deepen a bit in some types of this kind of data:
\end_layout

\begin_layout Itemize

\series bold
Time-Series data
\series default
: it contains data that are generated by continuous measurement over time.
 This means that our source space has a temporal component.
 This dependency is implicit.
\end_layout

\begin_deeper
\begin_layout Standard
Formally, a 
\series bold
time series of length 
\begin_inset Formula $\boldsymbol{n}$
\end_inset

 and dimensionality 
\begin_inset Formula $\boldsymbol{d}$
\end_inset

 
\series default
contains 
\begin_inset Formula $d$
\end_inset

 numeric features at each of 
\begin_inset Formula $n$
\end_inset

 time stamps 
\begin_inset Formula $t_{1},...,t_{n}$
\end_inset

.
 Each time stamp contains a component for each of the 
\begin_inset Formula $d$
\end_inset

 series.
 Therefore, the set of values received at time stamp 
\begin_inset Formula $t_{i}$
\end_inset

 es 
\begin_inset Formula $Y_{i}=\left(y_{i}^{1},...,y_{i}^{d}\right)$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Discrete sequences
\series default
: these are the categorical analog of time-series data.
 We will now have categorical or text features along the temporal dimension.
 This dependency is implicit.
\end_layout

\begin_layout Itemize

\series bold
Spatial data
\series default
: in this type of data, the dependance of the instances is given by their
 proximity in space.
 For example, if we measure the temperature in a room per 
\begin_inset Formula $cm^{3}$
\end_inset

, we will find that points that are nearby show more similar temperature
 than points that are far away from each other.
 This dependency is implicit.
\end_layout

\begin_layout Itemize

\series bold
Spatiotemporal data
\series default
: this data captures both spatial and temporal dimension, so we have to
 deal with both relationships.
 As before, this dependency is implicit.
\end_layout

\begin_layout Itemize

\series bold
Network and graph data
\series default
: now, data values may correspond to nodes in the network, and the relationships
 between them would correspond to the edges between the nodes.
\end_layout

\begin_deeper
\begin_layout Standard
Formally, a 
\series bold
network
\series default
 is a pair 
\begin_inset Formula $G=\left(N,E\right)$
\end_inset

 where 
\begin_inset Formula $N$
\end_inset

 is a set of nodes and 
\begin_inset Formula $E\subset N\times N$
\end_inset

 is a set of edges, that represent the relationships between the nodes.
 There can be attributes associated to both nodes or edges.
\end_layout

\begin_layout Standard
Edges may be directed or indirected, depending on wether the link is bidirection
al or not.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Classification
\end_layout

\begin_layout Standard
A 
\series bold
classification problem
\series default
 consists in learning the structure of a dataset of examples, already partitione
d into groups, referred as 
\series bold
class
\series default
.
 This learning is typically achieved with a 
\series bold
model
\series default
, which is used to estimate the 
\series bold
class labels
\series default
 of unseen data examples with unknown labels.
 Thus, one of the inputs to the classification problem is the example dataset
 with known labels, 
\begin_inset Formula $\mathcal{D}$
\end_inset

, called 
\series bold
training data
\series default
, while the unseen data points to be classified are the 
\series bold
test data
\series default
.
 The model learnt is referred to as 
\series bold
training model
\series default
.
 The algorithm used to create the model is the 
\series bold
learner
\series default
.
 
\end_layout

\begin_layout Standard
The output of the classification algorithm can be of two types:
\end_layout

\begin_layout Itemize

\series bold
Label prediction
\series default
: a label is predicted for each test instance.
\end_layout

\begin_layout Itemize

\series bold
Numerical score
\series default
: the learner assigns a score to each instance-label possible combination.
 This score measures the propensity of the instance to belong to a particular
 class.
\end_layout

\begin_layout Section
Decision Trees
\end_layout

\begin_layout Standard

\series bold
Decision trees
\series default
 are a classification methodology, which uses a tree structure to partition
 the feature space.
 Each node of the tree represents a decision to make according to the data,
 called the 
\series bold
split criterion
\series default
, and is a condition on one or more features variables in the training data.
\end_layout

\begin_layout Standard
The goal is to identify a split criterion such that the level of 
\emph on
mixing
\emph default
 of the class variables in each branch of the tree is reduced as much as
 possible.
\end_layout

\begin_layout Standard
The splits can be 
\series bold
univariate
\series default
, if they use a single attribute in the condition, or 
\series bold
multivariate
\series default
, if more than one attribute are used in the condition.
\end_layout

\begin_layout Standard
The nodes can be of two types:
\end_layout

\begin_layout Itemize

\series bold
Internal node
\series default
: each internal node represents a partition of the space according to a
 certain condition.
\end_layout

\begin_layout Itemize

\series bold
Leaf node
\series default
: they are labeled with the dominant class of the remaining partition of
 the training set at that node.
\end_layout

\begin_layout Standard
The general algorithm for constructing a decision tree is as follows:
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "breaklines=true,morekeywords={Algorithm, begin, repeat, until, end},escapechar={<@}"
inline false
status open

\begin_layout Plain Layout

begin
\end_layout

\begin_layout Plain Layout

	Create root node containing D;
\end_layout

\begin_layout Plain Layout

	repeat
\end_layout

\begin_layout Plain Layout

		Select an eligible node in tree;
\end_layout

\begin_layout Plain Layout

		<@
\backslash
textcolor{red}{Split the selected node into two or more nodes based on the
 split criterion};<@
\end_layout

\begin_layout Plain Layout

	until no more eligible nodes for split;
\end_layout

\begin_layout Plain Layout

	<@
\backslash
textcolor{red}{Prune overfitting nodes from tree};<@
\end_layout

\begin_layout Plain Layout

	Label each leaf node with its dominant class;
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
GenericDecisionTree(Dataset: D)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The red lines indicate what changes accross the different algorithms to
 produce a specific decision tree.
\end_layout

\begin_layout Subsection
Split criteria
\end_layout

\begin_layout Standard
The split criterion aims to maximize the separation of the different classes
 among the children nodes.
 Its design depends on the attributes of the data:
\end_layout

\begin_layout Itemize
Binary attributes: produce a binary tree.
\end_layout

\begin_layout Itemize
Categorical attribute: there several approaches:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $r$
\end_inset

-way split: we split the branch in as many branches as distinct values of
 the attribute.
\end_layout

\begin_layout Itemize
binary split: testing each of the 
\begin_inset Formula $2^{r}-1$
\end_inset

 groupings of categorical attributes, and selecting the best one.
\end_layout

\end_deeper
\begin_layout Itemize
Numeric attribute: we have, again, several possibilities:
\end_layout

\begin_deeper
\begin_layout Itemize
If it contains a small number 
\begin_inset Formula $r$
\end_inset

 of ordered values, we can treat it as a categorial attribute and apply
 
\begin_inset Formula $r$
\end_inset

-way split.
\end_layout

\begin_layout Itemize
For continuous numeric attributes, the split is performed using a binary
 condition, like 
\begin_inset Formula $x\le a$
\end_inset

 for a certain contant 
\begin_inset Formula $a$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Standard
These methods require to determine the best split among a set of different
 splits, so we need a way to measure which one is better than other.
\end_layout

\begin_layout Standard
For this end, we are using the 
\series bold
entropy
\series default
.
\end_layout

\begin_layout Subsubsection
Entropy
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
Let 
\begin_inset Formula $p_{j}$
\end_inset

 be the fraction of data points belonging to the class 
\begin_inset Formula $j$
\end_inset

 for the attribute value 
\begin_inset Formula $v_{j}$
\end_inset

.
 Then, the 
\series bold
class-based entropy
\series default
, 
\begin_inset Formula $E\left(v_{i}\right)$
\end_inset

, 
\series bold
for the attribute
\series default
 value 
\begin_inset Formula $v_{i}$
\end_inset

 is
\begin_inset Formula 
\[
E\left(v_{i}\right)=-\sum_{j=1}^{k}p_{j}\log_{2}\left(p_{j}\right).
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Remark
When 
\begin_inset Formula $p_{j}=0$
\end_inset

, it is assumed that 
\begin_inset Formula $p_{j}\log_{2}\left(p_{j}\right)=0$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
\begin_inset Formula $E\left(v_{i}\right)\in\left[0,\log_{2}k\right]$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
Higher values of the entropy imply greater 
\emph on
mixing
\emph default
 of different classes, while a value of 0 implies perfect separation.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
The 
\series bold
overal entropy
\series default
 
\series bold
of an attribute
\series default
, 
\begin_inset Formula $E$
\end_inset

, is defined as the weighted average over the 
\begin_inset Formula $r$
\end_inset

 different attribute values:
\begin_inset Formula 
\[
E=\sum_{i=1}^{r}\frac{n_{i}}{n}E\left(v_{i}\right),
\]

\end_inset

 where 
\begin_inset Formula $n_{i}$
\end_inset

 is the frequency of attribute value 
\begin_inset Formula $v_{i}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The entropy is used in the ID3 algorithm for constructing decision trees.
\end_layout

\begin_layout Standard
The overall entropy for an 
\begin_inset Formula $r$
\end_inset

-way split of set 
\begin_inset Formula $S$
\end_inset

 into sets 
\begin_inset Formula $S_{1},...,S_{r}$
\end_inset

 may be computed as the weighted average of the entropy values of each 
\begin_inset Formula $S_{i}$
\end_inset

, being its weigth 
\begin_inset Formula $\left|S_{i}\right|$
\end_inset

.
 This is called the 
\series bold
entropy-split
\series default
:
\begin_inset Formula 
\[
Entropy-Split\left(S\implies S_{1},...,S_{r}\right)=\sum_{k=1}^{r}\frac{\left|S_{k}\right|}{\left|S\right|}E\left(v_{i}|S_{k}\right).
\]

\end_inset


\end_layout

\begin_layout Standard
In relation to this, the 
\series bold
information gain
\series default
 is defined as the reduction of entropy due to the split:
\begin_inset Formula 
\[
IG\left(S\implies S_{1},...,S_{r}\right)=E\left(S\right)-Entropy-Split\left(S\implies S_{1},...,S_{r}\right).
\]

\end_inset

 Note that lower values of the entropy-split and higher values of the informatio
n gain are more desirable.
\end_layout

\begin_layout Standard
Sometimes, there are attributes with lots of distinct values, so using them
 to split the data reduces the entropy a lot, but are not very useful for
 prediction
\begin_inset Foot
status open

\begin_layout Plain Layout
Think, for example, in an ID.
 See Subsubsection 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-problem-of"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\end_inset

.
 To account for this, we can divide the overall information gain with the
 normalization factor 
\begin_inset Formula 
\[
-\sum_{i=1}^{r}\frac{\left|S_{i}\right|}{\left|S\right|}\log_{2}\left(\frac{\left|S_{i}\right|}{\left|S\right|}\right),
\]

\end_inset

 which helps adjusting for the varying number of categorical values.
\end_layout

\begin_layout Example

\series bold
Entropy of the dataset 'Weather data'
\end_layout

\begin_layout Example
Consider the following dataset:
\end_layout

\begin_layout Example
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="15" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
outlook
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
temperature
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
humidity
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
windy
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
play
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
sunny
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
hot
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
high
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
false
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
no
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
sunny
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
hot
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
high
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
true
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
no
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
overcast
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
hot
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
high
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
false
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
yes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
rainy
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
mild
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
high
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
false
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
yes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
rainy
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cool
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
normal
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
false
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
yes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
rainy
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cool
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
normal
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
true
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
no
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
overcast
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cool
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
normal
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
true
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
yes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
sunny
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
mild
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
high
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
false
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
no
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
sunny
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cool
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
normal
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
false
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
yes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
rainy
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
mild
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
normal
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
false
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
yes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
sunny
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
mild
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
normal
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
true
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
yes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
overcast
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
mild
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
high
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
true
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
yes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
overcast
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
hot
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
normal
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
false
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
yes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
rainy
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
mild
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
high
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
true
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
no
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
The weather data.
 Source: 
\begin_inset CommandInset citation
LatexCommand cite
key "witten2011"
literal "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Example
If the class attribute is 
\emph on
play
\emph default
, what is the entropy of this source?
\end_layout

\begin_layout Example
\begin_inset Formula 
\begin{align*}
E\left(play\right)= & -p_{yes}\log_{2}\left(p_{yes}\right)-p_{no}\log_{2}\left(p_{no}\right)\\
= & -\frac{9}{14}\log_{2}\left(\frac{9}{14}\right)-\frac{5}{14}\log_{2}\left(\frac{5}{14}\right)\\
= & 0.94.
\end{align*}

\end_inset

 What if the Entropy-Split of the attribute 
\emph on
humidity
\emph default
?
\begin_inset Formula 
\begin{align*}
ES\left(S\implies S_{hum=high},S_{hum=normal}\right)= & \frac{\left|S_{hum=high}\right|}{\left|S\right|}E\left(play|hum=high\right)+\frac{\left|S_{hum=normal}\right|}{\left|S\right|}E\left(play|hum=normal\right)\\
= & \frac{7}{14}\left[-\frac{3}{7}\log_{2}\left(\frac{3}{7}\right)-\frac{4}{7}\log_{2}\left(\frac{4}{7}\right)\right]+\frac{7}{14}\left[-\frac{6}{7}\log_{2}\left(\frac{6}{7}\right)-\frac{1}{7}\log_{2}\left(\frac{1}{7}\right)\right]\\
= & 0.7885.
\end{align*}

\end_inset

 And the information gain?
\begin_inset Formula 
\begin{align*}
IG\left(S\implies S_{hum=high},S_{hum=normal}\right)= & E\left(play\right)-ES\left(S\implies S_{hum=high},S_{hum=normal}\right)\\
= & 0.94-0.79=0.15.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsection
ID3 Tree Induction Algorithm
\end_layout

\begin_layout Standard
ID3 is an algorithm to construct decision trees, in which the split criterion
 is the maximization of the information gain and the prunning strategy is
 to stop if all the records in a node are of the same class.
 The algorithm is more detailed in Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:ID3"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "morekeywords={if, then, is, in, return, for, Let},morecomment={[f][\color{purple}]{\#}}"
inline false
status open

\begin_layout Plain Layout

# I is the set of input attributes
\end_layout

\begin_layout Plain Layout

# O is the output attribute
\end_layout

\begin_layout Plain Layout

# T is a set of training data
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if (T is empty) then
\end_layout

\begin_layout Plain Layout

	return a single node with value 
\begin_inset Quotes eld
\end_inset

Failure
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if (all records  in T have the same value for O) then
\end_layout

\begin_layout Plain Layout

	return a single node with that value
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if (I is empty) then
\end_layout

\begin_layout Plain Layout

	return a single node with the most frequent value of O in T
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# else
\end_layout

\begin_layout Plain Layout

compute IG for each attribute in I using data in T
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Let X = argmin{IG(attr) for attr in I}
\end_layout

\begin_layout Plain Layout

Let {x_j for j=1,...,m} be the values in X
\end_layout

\begin_layout Plain Layout

Let {T_j for j=1,...,m} be the subsets of T when partitioned
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

return a tree with:
\end_layout

\begin_layout Plain Layout

	root node labelled X
\end_layout

\begin_layout Plain Layout

	arcs labelled x_1,...,x_m
\end_layout

\begin_layout Plain Layout

	connected to 
\end_layout

\begin_layout Plain Layout

	ID3(I-{X}, O, T_1),...,ID3(I-{X}, O, T_m)
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:ID3"

\end_inset

ID3(I, O, T) : Decision Tree
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Example
Compute the decision tree of the data in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "table:records_example"
plural "false"
caps "false"
noprefix "false"

\end_inset

 using ID3 algorithm.
\end_layout

\begin_layout Example

\series bold
Step 1: Root
\end_layout

\begin_layout Example
We start by computing IG for each attribute.
 To simplify notation, let 
\begin_inset Formula $P=play,\ O=outlook,\ T=temperature,\ H=humidity$
\end_inset

 and 
\begin_inset Formula $W=windy$
\end_inset

.
\end_layout

\begin_layout Example
We already know that 
\begin_inset Formula $E\left(P\right)=0.94$
\end_inset

 and 
\begin_inset Formula $IG\left(S\implies S_{H=high},S_{H=normal}\right)=0.15$
\end_inset

.
 Let's compute the rest of the values:
\begin_inset Formula 
\begin{align*}
ES\left(S\implies S_{O=sunny},S_{O=overcast},S_{O=rainy}\right)= & -\frac{5}{14}\left(\frac{3}{5}\log\frac{3}{5}+\frac{2}{5}\log\frac{2}{5}\right)\cdot2-0\\
= & 0.69.
\end{align*}

\end_inset

 Which implies that 
\begin_inset Formula $IG\left(S\implies S_{O=sunny},S_{O=overcast},S_{O=rainy}\right)=0.25$
\end_inset

.
\end_layout

\begin_layout Example
Repeating this process with temerature, we get 
\begin_inset Formula $IG\left(S\implies S_{T=hot},S_{T=mild},S_{T=cold}\right)=0.03$
\end_inset

 and with windy, we get 
\begin_inset Formula $IG\left(S\implies S_{W=True},S_{W=False}\right)=0.05$
\end_inset

.
\end_layout

\begin_layout Example
This means that we label the root node with 
\begin_inset Formula $X=O$
\end_inset

 and we create three arcs, each of them with one of the values from 
\begin_inset Formula $O$
\end_inset

.
 So we have the following Tree:
\end_layout

\begin_layout Example
\begin_inset Graphics
	filename pegado1.png

\end_inset


\end_layout

\begin_layout Example

\series bold
Step 2: Outlook=sunny
\end_layout

\begin_layout Example
Now, we are going to do the same thing, restricting ourselves to the records
 for which 
\emph on
Outlook=sunny
\emph default
.
 Now, we have to recompute the entropy and the gain for each of the rest
 of the attributes.
\end_layout

\begin_layout Example
Let's start with the entropy:
\begin_inset Formula 
\begin{align*}
E\left(P|O=sunny\right)= & -\left[\frac{3}{5}\log\frac{3}{5}+\frac{2}{3}\log\frac{2}{5}\right]=0.97.
\end{align*}

\end_inset

 Now, the Information Gain:
\begin_inset Formula 
\begin{align*}
IG\left(S_{O=sunny}\implies S_{O=sunny,H=high},S_{O=sunny,H=normal}\right)=\\
\frac{3}{5}E\left(P\land O=sunny|H=high\right)+\frac{2}{5}E\left(P\land O=sunny|H=normal\right)=\\
-\frac{3}{5}\left[\frac{3}{3}\log\frac{3}{3}+0\right]-\frac{2}{5}\left[\frac{2}{2}\log\frac{2}{2}+0\right]= & 0.
\end{align*}

\end_inset

 Which means that 
\begin_inset Formula $IG\left(S_{O=sunny}\implies S_{O=sunny,H=high},S_{O=sunny,H=normal}\right)=0.97$
\end_inset

.
 As this cannot be improved, we can savely not compute the rest of the values.
 This way, the Tree will now look as follows:
\end_layout

\begin_layout Example
\begin_inset Graphics
	filename pegado2.png

\end_inset


\end_layout

\begin_layout Example

\series bold
Step 3: Outlook=Sunny, Humidity=Normal
\end_layout

\begin_layout Example
Note that we are proceeding heightwise, but doing this breadthwise is also
 possible.
\end_layout

\begin_layout Example
This time, all the values for 
\begin_inset Formula $P$
\end_inset

 are 
\begin_inset Formula $Yes$
\end_inset

, so we enter the third 
\begin_inset Formula $if$
\end_inset

 of the algorithm and label the node as 
\begin_inset Formula $Yes$
\end_inset

.
\end_layout

\begin_layout Example

\series bold
Step 4: Outlook=Sunny, Humidity=High
\end_layout

\begin_layout Example
Same, now 
\begin_inset Formula $P=No$
\end_inset

.
\end_layout

\begin_layout Example

\series bold
Step 5: Outlook=Overcast
\end_layout

\begin_layout Example
Same, now 
\begin_inset Formula $P=Yes$
\end_inset

.
 
\end_layout

\begin_layout Example
So, now we have the following tree:
\end_layout

\begin_layout Example
\begin_inset Graphics
	filename pegado3.png

\end_inset


\end_layout

\begin_layout Example

\series bold
Step 6: Outlook=rainy
\end_layout

\begin_layout Example
\begin_inset Formula 
\[
E\left(P|O=rainy\right)=0.97
\]

\end_inset

 and 
\begin_inset Formula 
\[
IG\left(S_{O=rainy}\implies S_{O=rainy,W=True},S_{O=rainy,W=False}\right)=0.97,
\]

\end_inset

 so, again, it is maximum and we can continue using it as label:
\end_layout

\begin_layout Example
\begin_inset Graphics
	filename pegado4.png

\end_inset


\end_layout

\begin_layout Example

\series bold
Step 7: Outlook=rainy, Windy=False
\end_layout

\begin_layout Example
All records have 
\begin_inset Formula $P=Yes$
\end_inset

.
\end_layout

\begin_layout Example

\series bold
Step 8: Outlook=rainy, Windy=True
\end_layout

\begin_layout Example
All record have 
\begin_inset Formula $P=No$
\end_inset

.
\end_layout

\begin_layout Example
So, we have the tree
\end_layout

\begin_layout Example
\begin_inset Graphics
	filename pegado5.png

\end_inset


\end_layout

\begin_layout Example
And as there are no more nodes to analyze, this is the final decision tree.
\end_layout

\begin_layout Subsubsection
The problem of UID
\begin_inset CommandInset label
LatexCommand label
name "subsec:The-problem-of"

\end_inset


\end_layout

\begin_layout Standard
In general, attributes that have very many values have very high gain, but
 can lead to useless decision trees.
 Quinlan suggest choosing the attribute with the highest
\begin_inset Formula 
\[
GainRatio\left(X,S\right)=\frac{Gain\left(X,S\implies S_{1},...,S_{r}\right)}{Entropy\left(S\right)},
\]

\end_inset

 where 
\begin_inset Formula $X$
\end_inset

 is the label attribute.
\end_layout

\begin_layout Standard
The GainRatio favores attributes with higher gain, and punishes attributes
 with high entropy (many values).
\end_layout

\begin_layout Example
Repeat the decision tree ID3 algorithm, but use GainRatio instead.
\end_layout

\begin_layout Example
The same tree is obtained.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Model validation and data preparation
\end_layout

\begin_layout Section
Data preparation
\end_layout

\begin_layout Standard
The 
\series bold
data preparation phase
\series default
 is a multistage process that comprises several individual steps, some or
 all of which may be used in a given application.
 These steps are:
\end_layout

\begin_layout Enumerate

\series bold
Feature extraction and portability
\series default
: a 
\series bold
feature
\series default
 is characteristic of the data or derived from the data.
 For example, if we have a sensor measuring humidity, the level of humidity
 will be a feature directly present in the data; the difference between
 the humidity level at each measure and the average humidity level is a
 derived feature.
\end_layout

\begin_deeper
\begin_layout Standard
Features with good semantic interpretability are more desirable because
 this makes things easier for the analyst to understand results.
 So, the process of selecting which features to take into account for further
 analysis is called 
\series bold
feature extraction
\series default
.
\end_layout

\begin_layout Standard

\series bold
Data type portability
\series default
 refers to the process of transforming data into different formats.
 This could have several reasons behind: we could do this because we have
 several sources of data which we want to unify or because we use an internal
 datatype that will not be compatible with what the training algorithms
 expect.
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Data cleaning
\series default
: missing, erroneus and inconsistent entries are treated.
 We can either remove them or estimate them via the process of 
\series bold
imputation
\series default
.
\end_layout

\begin_layout Enumerate

\series bold
Data reduction, selection and transformation
\series default
: the size of the data is reduced through data subset selection, feature
 subset selection, or data transformation.
 This helps in two ways:
\end_layout

\begin_deeper
\begin_layout Enumerate
The algorithms perform more efficiently in smaller datasets.
\end_layout

\begin_layout Enumerate
The removal of irrelevant features or records improves the quality of the
 data mining process.
\end_layout

\end_deeper
\begin_layout Subsection
Feature extraction
\end_layout

\begin_layout Example

\series bold
Image feature extraction
\end_layout

\begin_layout Example
Image data are represented as pixel.
 Nonetheless, we know that pixels are related between each others and that
 combinations of pixels carry information about what we are seeing in the
 image.
 This is not straighforward for a computer to understand, as the computer
 only 'sees' a matrix of triplets.
\end_layout

\begin_layout Example
At a higher level, 
\series bold
color histograms
\series default
 can be used to represent the features in different segments of an image.
\end_layout

\begin_layout Example
Also, 
\series bold
visual words
\series default
 are used to extract features from images.
 A visual word is a semantically rich representation of parts of an image.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Example

\series bold
Document feature extraction
\end_layout

\begin_layout Example
Document data is often available in raw and unstructured form, and the data
 may contain rich linguistic relations between different entities.
 
\end_layout

\begin_layout Example
One approach is to remove stop words, stem the data, and use bag-of-words
 representation.
\end_layout

\begin_layout Example
Other methods use entity extraction to determine linguistic relationships.
 
\end_layout

\begin_layout Example

\series bold
Named-entity
\series default
 
\series bold
recognition
\series default
 is an important subtask of information extraction.
 It consists in locating and classifying atomic elements in text into predefined
 expressions of names of persons, organizations,...
\end_layout

\begin_layout Subsection
Data Type Portability
\end_layout

\begin_layout Itemize

\series bold
Numerical to categorizal data: discretizacion
\end_layout

\begin_deeper
\begin_layout Standard
The process of discretization divides the ranges of the numeric attribute
 into 
\begin_inset Formula $m$
\end_inset

 ranges.
 Then, the attribute is assumed to contain 
\begin_inset Formula $m$
\end_inset

 different categorical labeled values from 1 to 
\begin_inset Formula $m$
\end_inset

.
\end_layout

\begin_layout Standard
Variations within a range are not ditinguishable after discretization (some
 information is lost).
\end_layout

\begin_layout Standard
One challenge is that data may be nonuniformly distributed across the different
 intervals.
 Thus, there are several ways to perform the division:
\end_layout

\begin_layout Itemize

\series bold
Equi-width ranges
\series default
: the interval is divided into 
\begin_inset Formula $m$
\end_inset

 subintervals of equal length.
\end_layout

\begin_layout Itemize

\series bold
Equi-log ranges
\series default
: the interval is divided in such a way that the log-length is constant.
 If we want to divide the interval 
\begin_inset Formula $\left[a,b\right]$
\end_inset

 into 
\begin_inset Formula $m$
\end_inset

 equi-log ranges 
\begin_inset Formula $\left\{ \left[a_{i},b_{i}\right]\right\} _{i=1}^{m}$
\end_inset

, we have to ensure that
\begin_inset Formula 
\[
\log\left(b_{i}\right)-\log\left(a_{i}\right)=\log\left(b_{j}\right)-\log\left(a_{j}\right),\ \forall i,j=1,...,m
\]

\end_inset


\end_layout

\begin_layout Itemize

\series bold
Equi-depth ranges
\series default
: the ranges are selected so that each range has an equal number of records.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Categorical to numeric data: binarization
\end_layout

\begin_deeper
\begin_layout Standard
Suppose a categorical attribute with 
\begin_inset Formula $m$
\end_inset

 different values.
 Then, we can binarize it by creating 
\begin_inset Formula $m$
\end_inset

 attributes, and the record will have all of them set to 0, except the one
 corresponding to the value that it has, which will be set to 1.
 For example:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Role
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pedro
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CEO
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\implies$
\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Role:CEO
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Role:Employee
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Role:Director
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pedro
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Text to numeric data: Latent Semantic Analysis (LSA)
\end_layout

\begin_deeper
\begin_layout Standard
LSA transforms the text collection to a nonsparse representation with lower
 dimensionality.
 After transformation, each document 
\begin_inset Formula $X=\left(x_{1},...,x_{d}\right)$
\end_inset

 needs to be scaled to
\begin_inset Formula 
\[
\frac{1}{\sqrt{\sum_{i=1}^{d}x_{i}²}}\left(x_{1},...,x_{d}\right).
\]

\end_inset

 This is necessary to ensure that documents of varying length are treated
 in uniform way.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Time series to Discrete Sequence Data: Symbolic Aggregate Approximation
 (SAX)
\end_layout

\begin_deeper
\begin_layout Standard
Two steps:
\end_layout

\begin_layout Itemize

\series bold
Window-based averaging: 
\series default
the series is divided into windows of length 
\begin_inset Formula $w$
\end_inset

, and the average time-series value over each window is computed.
\end_layout

\begin_layout Itemize

\series bold
Value-based discretization:
\series default
 the averaged time-series values are discretized into a smaller number of
 equi-depth intervals.
 
\series bold
Idea
\series default
: ensure that each symbol has an approximately equal frequency in the time-serie
s.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Time series to Numeric Data: 
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
Discrete Wavelet Transform (DWT)
\series default
: converts the time series data to multidimensional data, as a set of coefficien
ts that represent averaged differences between different portions of the
 series.
\end_layout

\begin_layout Itemize

\series bold
Discrete Fourier Transform (DFT)
\series default
: similar, using Fourier series' theory.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Discrete Sequence to Numeric Data:
\end_layout

\begin_deeper
\begin_layout Standard
Two steps:
\end_layout

\begin_layout Itemize
Convert the discrete sequence to a set of binary time series, with as many
 time series as the number of values the discrete sequence can take.
\end_layout

\begin_layout Itemize
H each of these time series into a multidimensional vector using the DWT.
 This combines the features from the different series, creating a single
 multidimensional record.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Spatial to Numeric Data:
\end_layout

\begin_deeper
\begin_layout Standard
The approach is the same as the one used for time-series data, but now there
 are two contextual attributes instead of one, so the DWT has to be modified
 to be two-dimensional.
\end_layout

\end_deeper
\begin_layout Subsection
Data Cleaning
\end_layout

\begin_layout Standard
Data in the real world is
\end_layout

\begin_layout Itemize

\series bold
incomplete
\series default
: there are values for some attributes that are missing.
 This can happen because some measures were not always taken of because
 of human/computer errors.
\end_layout

\begin_layout Itemize

\series bold
noisy
\series default
: there are errors.
 This can happen because the instruments used to collect data are not working
 properly, because errors in the data transmission occur or because of human/com
puter errors.
\end_layout

\begin_layout Itemize

\series bold
inconsistent
\series default
: there are discrepancies between different attributes that are related.
 This can happen when data from different sources needs to be combined or
 when some calculated values are not updated after changing their source
 values.
\end_layout

\begin_layout Itemize

\series bold
duplicate
\series default
: there are duplicate values.
\end_layout

\begin_layout Subsubsection
Handling Missing Entries
\end_layout

\begin_layout Standard
#TODO
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Model evaluation
\end_layout

\begin_layout Standard
Once we have trained a model, we want to assess how well it performs.
 This way, we can compare different models and discuss, quantitatively,
 which of them is preferrable for our purposes.
 Nonetheless, this task is not easy, and there are both methodological and
 quantification issues to take into account:
\end_layout

\begin_layout Itemize

\series bold
Methodological issues
\series default
: associated with dividing the labeled data appropriately into training
 and test segments for evaluation.
 The choice of methodology has a direct impact on the evaluation process,
 such as underestimation or overestimation of classifier accuracy.
 Several approaches are possible: 
\series bold
holdout
\series default
, 
\series bold
bootstrap
\series default
 and 
\series bold
cross-validation
\series default
.
\end_layout

\begin_layout Itemize

\series bold
Quantification issues
\series default
: associated with providing a numercial measure for the quality of the method
 after a specific methodology for evaluation has been selected.
\end_layout

\begin_layout Subsection
Holdout
\end_layout

\begin_layout Standard
The labeled data is randomly divided into two disjoint sets, corresponding
 to the training and test data.
 The training data is used to feed the training algorithm and produce a
 model, whose performance is assessed using the test data.
\end_layout

\begin_layout Standard
The approach can be repeated several times with multiple samples to provide
 a final estimate.
\end_layout

\begin_layout Itemize

\series bold
Problem
\series default
: classes that are overrepresented in the training data are underrepresented
 in the test data.
 This can have a significant impact when the original class distribution
 is imbalanced.
 The error estimates are pessimistic.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pegado6.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Holdout visualization.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Cross-Validation
\end_layout

\begin_layout Standard
The labeled data is divided into 
\begin_inset Formula $m$
\end_inset

 disjoint subsets of equal size 
\begin_inset Formula $\frac{n}{m}$
\end_inset

.
 A typical choice of 
\begin_inset Formula $m$
\end_inset

 is around 10.
 One of the 
\begin_inset Formula $m$
\end_inset

 segments is used for testing, and the other 
\begin_inset Formula $\left(m-1\right)$
\end_inset

 segments are used for training.
 This approach is repeated by selecting each of the 
\begin_inset Formula $m$
\end_inset

 different segments in the data as test set.
\end_layout

\begin_layout Standard
The average accuracy over the different test sets is then reported.
\end_layout

\begin_layout Standard
The overall accuracy of the cross.validation procedure tends to be a highly
 representative, but pessimistic estimate, of model accuracy.
\end_layout

\begin_layout Standard
When 
\begin_inset Formula $m$
\end_inset

 is chosen to be 
\begin_inset Formula $m=n$
\end_inset

, 
\begin_inset Formula $n-1$
\end_inset

 examples are used for training, and one example is used for testing.
 This is called 
\series bold
leave-one-out cross-validation
\series default
.
 This approach is very expensive for large datasets.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pegado7.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Cross-Validation visualization.
 
\begin_inset Formula $m=3$
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Stratified cross-validation
\series default
 uses proportional representation of each class in the different folds and
 usually provides less pessimistic results.
\end_layout

\begin_layout Subsection
Bootstrap
\end_layout

\begin_layout Standard
The labeled data is sampled uniformly with replacement, to create a training
 dataset, which can contain duplicates.
 The labeled data of size 
\begin_inset Formula $n$
\end_inset

 is sampled 
\begin_inset Formula $n$
\end_inset

 times with replacement.
\end_layout

\begin_layout Standard
The probability that a particular point is not included in a sample is
\begin_inset Formula 
\[
p_{1}=1-\frac{1}{n}.
\]

\end_inset

 Therefore, the probability that the point is not included in 
\begin_inset Formula $n$
\end_inset

 samples is
\begin_inset Formula 
\[
p_{n}=\left(1-\frac{1}{n}\right)^{n}.
\]

\end_inset

 For large values of 
\begin_inset Formula $n$
\end_inset

, this approximates 
\begin_inset Formula $\frac{1}{e}$
\end_inset

.
 Thus, the fraction of the labeled data points included at elast once in
 the training dataset is 
\begin_inset Formula $1-\frac{1}{e}$
\end_inset

.
 
\end_layout

\begin_layout Standard
The overall accuracy is computed using the original set of full labeled
 data as the test examples.
\end_layout

\begin_layout Standard
The estimate is highly optimistic of the true classifier accuracy because
 of the large overlap between the training and test examples.
\end_layout

\begin_layout Standard
A better strategy is the 
\series bold
leave-one-out bootstrap
\series default
, in which the accuracy of each labeled instance is computed using the classifie
r performance on only the subset of the bootstraped samples in which the
 instance is not part of.
\end_layout

\begin_layout Standard
This approach provides a pessimistic accuracy estimate, 
\begin_inset Formula $A_{l}$
\end_inset

, given by the mean value of the accuracy computed for each labeled instance.
\end_layout

\begin_layout Standard
The 
\series bold
0.632-bootstrap
\series default
 improves the accuracy estimate with a compromise approach.
 The average training-data accuracy 
\begin_inset Formula $A_{t}$
\end_inset

 over 
\begin_inset Formula $b$
\end_inset

 bootstrapped samples is computed.
 This is a highly optimistic estimate.
 The overall accuracy is a weighted average of the leave-one-out accuracy
 and the training-data accuracy:
\begin_inset Formula 
\[
A=\left(0.632\right)\cdot A_{l}+\left(0.368\right)\cdot A_{t}.
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Clustering
\end_layout

\begin_layout Standard
Some applications require to divide the data into different groups, that
 share some characteristics.
 The problem many of these times is that we don't know which characteristics
 or at how much extend are useful to characterize the data.
 The general (unsupervised) approach to tackle this problem is 
\series bold
clustering
\series default
.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition

\series bold
Clustering problem (Informal)
\end_layout

\begin_layout Definition
Given a set of data points, partition them into groups containing similar
 data points.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This definition is informal and general, but gives enough information to
 understand the problem, as well as enough freedom to tackle it from different
 perspectives.
\end_layout

\begin_layout Section
Representative-Based Algorithms
\end_layout

\begin_layout Standard
These are the simplest of all clustering algorithms, as they directly use
 distances or similarities to cluster the data.
 They not capture hierarchical relationships and use a set of 
\series bold
representatives
\series default
 to cluster the data.
 The main insight is that the discovery of good clusters equates to the
 discovery of good representatives.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition

\series bold
Representative-Based general clustering problem
\end_layout

\begin_layout Definition
Given a data set 
\begin_inset Formula $\mathcal{D}$
\end_inset

 with 
\begin_inset Formula $n$
\end_inset

 data points 
\begin_inset Formula $X_{1},...,X_{n}$
\end_inset

 in a 
\begin_inset Formula $d$
\end_inset

-dimensional space and a specified number of clusters, 
\begin_inset Formula $k$
\end_inset

, the goal of a representative-based algorithm is to determine 
\begin_inset Formula $k$
\end_inset

 representatives 
\begin_inset Formula $Y_{1},...,Y_{n}$
\end_inset

 such that the objective function
\begin_inset Formula 
\[
O=\sum_{i=1}^{n}\left[\min_{j}\ Dist\left(X_{i},Y_{j}\right)\right]
\]

\end_inset

 is minimized, i.e., the sum of the distances of the different data points
 to their closest representative needs to be miminized.
\end_layout

\end_inset


\end_layout

\begin_layout Remark
The representatives 
\begin_inset Formula $Y_{1},...,Y_{k}$
\end_inset

 and the optimal assigmnent of data points to representatives are unknown
 a priori, but they depend on each other in a circular way.
 This fact allows us to develop a iterative approach to solve the problem.
\end_layout

\begin_layout Standard
The 
\series bold
generic 
\begin_inset Formula $k$
\end_inset

-representative approach
\series default
 is as in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Generic-k-representative-approach"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "morekeywords={if, then, is, in, return, for, Let},morecomment={[f][\color{purple}]{\#}}"
inline false
status open

\begin_layout Plain Layout

Initialize Y = {Y_1,...,Y_k} <@
\backslash
textcolor{purple}{
\backslash
#Using heuristics}<@
\end_layout

\begin_layout Plain Layout

Initialize clusters C_1 = {},...
 C_k = {}
\end_layout

\begin_layout Plain Layout

do
\end_layout

\begin_layout Plain Layout

# Assign step
\end_layout

\begin_layout Plain Layout

	for(X in D):
\end_layout

\begin_layout Plain Layout

		assign X to Y_j such that <@
\backslash
textcolor{blue}{$Dist(X,Y_j) = 
\backslash
min_i Dist(X,Y_i)$}<@
\end_layout

\begin_layout Plain Layout

		C_j.add(X)
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

# Optimize step
\end_layout

\begin_layout Plain Layout

	for all Clusters C_j:
\end_layout

\begin_layout Plain Layout

		determine Y_j' such that 
\end_layout

\begin_layout Plain Layout

			<@
\backslash
textcolor{blue}{$
\backslash
sum_{X_i 
\backslash
in C_j} Dist(X_i,Y_j')$}<@
\end_layout

\begin_layout Plain Layout

		is minimized
\end_layout

\begin_layout Plain Layout

		Y_j = Y_j'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

while <@$O=
\backslash
sum_{i=1}^{n}
\backslash
left[
\backslash
min_{j}
\backslash
 Dist
\backslash
left(X_{i},Y_{j}
\backslash
right)
\backslash
right]$<@ > eps
\end_layout

\begin_layout Plain Layout

return {C_1, Y_1},...,{C_k, Y_k}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:Generic-k-representative-approach"

\end_inset

Generic 
\begin_inset Formula $k$
\end_inset

-representative approach (Data D, int k, threshold eps) : Set of representatives
 Y and Clusters C
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Remark
The idea is to improve the objective function over multiple iterations.
 The increase is usually greater in early iterations, and decreases rapidly.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
The main computational bottleneck is the assignment step, where distances
 need to be computed between all point to the representatives.
\end_layout

\begin_layout Subsection
The k-Means algorithm
\end_layout

\begin_layout Standard
The 
\begin_inset Formula $k-means$
\end_inset

 algorithm is a representative clustering method in which the distance used
 is the squared Euclidean distance (or squared 
\begin_inset Formula $L_{2}-$
\end_inset

norm):
\begin_inset Formula 
\[
Dist\left(X_{i},Y_{j}\right)=\left\Vert X_{i}-Y_{j}\right\Vert _{2}^{2}.
\]

\end_inset

 Thus, the objective function minimizes the sum of square errors over the
 data points, this is called the 
\begin_inset Formula $SSE$
\end_inset

 (Sum of Squared Errors).
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Proposition
The optimal representative 
\begin_inset Formula $Y_{j}$
\end_inset

 for each of the optimize iterative steps is the mean of the data points
 in cluster 
\begin_inset Formula $C_{j}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Proof
In the current step, we have a fixed clustering asssignment from the last
 step, 
\begin_inset Formula $C_{1},...,C_{k}$
\end_inset

.
 The overall clustering objective function is
\begin_inset Formula 
\[
O\left(X,Y\right)=\sum_{j=1}^{k}\sum_{X_{i}\in C_{j}}\left\Vert X_{i}-Y_{j}\right\Vert _{2}^{2},
\]

\end_inset

 so its gradient for each 
\begin_inset Formula $Y_{j}$
\end_inset

 is
\begin_inset Formula 
\[
\frac{d}{dY_{j}}O\left(X,Y\right)=2\sum_{X_{i}\in C_{j}}\left(X_{i}-Y_{j}\right).
\]

\end_inset

 When imposing the gradient equals to 0 (for optimization purposes), we
 get 
\begin_inset Formula 
\[
\sum_{X_{i}\in C_{j}}X_{i}-Y_{j}=0,
\]

\end_inset

 or, equivalently, 
\begin_inset Formula 
\[
\sum_{X_{i}\in C_{j}}X_{i}=\left|C_{j}\right|Y_{j}\implies Y_{j}=\frac{\sum_{X_{i}\in C_{j}}X_{i}}{\left|C_{j}\right|}=mean\left(C_{j}\right).
\]

\end_inset


\end_layout

\begin_layout Remark
Note that the obtained representatives could be a point which is not a point
 in the data.
 This property sometimes is undesirable.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
Note also that for the proof, we have suposed a numerical attribute.
 Computing the mean of different (for example) texts does not seem easy
 (think for example in the words 
\begin_inset Formula $classification$
\end_inset

 and 
\begin_inset Formula $regression$
\end_inset

, they could be certainly clustered inside 
\begin_inset Formula $data\ mining\ techniques$
\end_inset

, but the latter is hardly the mean of the two former words).
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
Regarding time complexity:
\end_layout

\begin_deeper
\begin_layout Itemize
The assign step is 
\begin_inset Formula $O\left(n\cdot k\right),$
\end_inset

 as we have to compute for each point, 
\begin_inset Formula $k$
\end_inset

 distances.
\end_layout

\begin_layout Itemize
The optimize step is 
\begin_inset Formula $O\left(n\right)$
\end_inset

, as we have to compute the 
\begin_inset Formula $k$
\end_inset

 different means using all 
\begin_inset Formula $n$
\end_inset

 points.
\end_layout

\begin_layout Itemize
Overall, then, it is 
\begin_inset Formula $O\left(n\cdot k\right)$
\end_inset

 per iteration.
 But usually few iterations are needed.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
Disadvantages:
\end_layout

\begin_deeper
\begin_layout Itemize
All points are clustered and taken into account equally for the objective
 function.
 This makes 
\begin_inset Formula $k-means$
\end_inset

 sensitive to outliers, which introduces bias.
\end_layout

\begin_layout Itemize
In some situations we cannot compute the mean of the data points (as the
 previous example).
\end_layout

\begin_layout Itemize
We need to know 
\begin_inset Formula $k$
\end_inset

 in advance.
\end_layout

\begin_layout Itemize
As we are minimizing the Euclidean distance, the algorithm is biased towards
 finding spherical clusters, because the sphere is the shape whose maximum
 distance to its center is constant:
\begin_inset Formula 
\[
\mathbb{S}^{n}\left(y,r\right)=\left\{ x\in\mathbb{R}^{n+1}:\sum_{i=1}^{n+1}\left|x_{i}-y_{i}\right|\leq r^{2}\right\} .
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Example
Apply the 
\begin_inset Formula $k-means$
\end_inset

 algorithm with 
\begin_inset Formula $k=3$
\end_inset

 to the dataset
\begin_inset Formula 
\[
D=\left\{ A_{1}=\left(2,10\right),A_{2}=\left(2,5\right),A_{3}=\left(8,4\right),A_{4}=\left(5,8\right),A_{5}=\left(7,5\right),A_{6}=\left(6,4\right),A_{7}=\left(1,2\right),A_{8}=\left(4,9\right)\right\} 
\]

\end_inset

 and using the seed 
\begin_inset Formula $Y_{1}=A_{5},\ Y_{2}=A_{6}$
\end_inset

 and 
\begin_inset Formula $Y_{3}=A_{8}$
\end_inset

.
\end_layout

\begin_layout Example
\begin_inset ERT
status open

\begin_layout Plain Layout

% This LaTeX was auto-generated from MATLAB code.
\end_layout

\begin_layout Plain Layout

% To make changes, update the MATLAB code and export to LaTeX again.
\end_layout

\begin_layout Plain Layout


\backslash
sloppy
\end_layout

\begin_layout Plain Layout


\backslash
matlabtitle{k-Means algorithm example (Example 7.1)}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{par}
\end_layout

\begin_layout Plain Layout


\backslash
begin{flushleft}
\end_layout

\begin_layout Plain Layout

Introduce the data
\end_layout

\begin_layout Plain Layout


\backslash
end{flushleft}
\end_layout

\begin_layout Plain Layout


\backslash
end{par}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

X1 = [2,10];
\end_layout

\begin_layout Plain Layout

X2 = [2,5];
\end_layout

\begin_layout Plain Layout

X3 = [8,4];
\end_layout

\begin_layout Plain Layout

X4 = [5,8];
\end_layout

\begin_layout Plain Layout

X5 = [7,5];
\end_layout

\begin_layout Plain Layout

X6 = [6,4];
\end_layout

\begin_layout Plain Layout

X7 = [1,2];
\end_layout

\begin_layout Plain Layout

X8 = [4,9];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

D = [X1;X2;X3;X4;X5;X6;X7;X8]
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlaboutput}
\end_layout

\begin_layout Plain Layout

D = 8x2    
\end_layout

\begin_layout Plain Layout

     2    10
\end_layout

\begin_layout Plain Layout

     2     5
\end_layout

\begin_layout Plain Layout

     8     4
\end_layout

\begin_layout Plain Layout

     5     8
\end_layout

\begin_layout Plain Layout

     7     5
\end_layout

\begin_layout Plain Layout

     6     4
\end_layout

\begin_layout Plain Layout

     1     2
\end_layout

\begin_layout Plain Layout

     4     9
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{matlaboutput}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

Y = [X5; X6; X8]
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlaboutput}
\end_layout

\begin_layout Plain Layout

Y = 3x2    
\end_layout

\begin_layout Plain Layout

     7     5
\end_layout

\begin_layout Plain Layout

     6     4
\end_layout

\begin_layout Plain Layout

     4     9
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{matlaboutput}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{par}
\end_layout

\begin_layout Plain Layout


\backslash
begin{flushleft}
\end_layout

\begin_layout Plain Layout

Compute the distance between all points
\end_layout

\begin_layout Plain Layout


\backslash
end{flushleft}
\end_layout

\begin_layout Plain Layout


\backslash
end{par}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

dist = zeros(3);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

for j=1:3
\end_layout

\begin_layout Plain Layout

    for i=1:8
\end_layout

\begin_layout Plain Layout

        dist(i,j)=distance(D(i,:),Y(j,:),2);
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{par}
\end_layout

\begin_layout Plain Layout


\backslash
begin{flushleft}
\end_layout

\begin_layout Plain Layout

Select, for each point, the point that minimizes the distance
\end_layout

\begin_layout Plain Layout


\backslash
end{flushleft}
\end_layout

\begin_layout Plain Layout


\backslash
end{par}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

[v, idx] = min(dist, [], 2);
\end_layout

\begin_layout Plain Layout

D = [D,idx];
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{par}
\end_layout

\begin_layout Plain Layout


\backslash
begin{flushleft}
\end_layout

\begin_layout Plain Layout

Plot the clusters:
\end_layout

\begin_layout Plain Layout


\backslash
end{flushleft}
\end_layout

\begin_layout Plain Layout


\backslash
end{par}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

c1 = D(:,3) == 1
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlaboutput}
\end_layout

\begin_layout Plain Layout

c1 = 8x1 logical array    
\end_layout

\begin_layout Plain Layout

   0
\end_layout

\begin_layout Plain Layout

   0
\end_layout

\begin_layout Plain Layout

   1
\end_layout

\begin_layout Plain Layout

   0
\end_layout

\begin_layout Plain Layout

   1
\end_layout

\begin_layout Plain Layout

   0
\end_layout

\begin_layout Plain Layout

   0
\end_layout

\begin_layout Plain Layout

   0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{matlaboutput}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

c2 = D(:,3) == 2;
\end_layout

\begin_layout Plain Layout

c3 = D(:,3) == 3;
\end_layout

\begin_layout Plain Layout

scatter(D(c1,1),D(c1,2), 'MarkerFaceColor', 'b');
\end_layout

\begin_layout Plain Layout

hold on
\end_layout

\begin_layout Plain Layout

scatter(D(c2,1),D(c2,2), 'MarkerFaceColor', 'g');
\end_layout

\begin_layout Plain Layout

scatter(D(c3,1),D(c3,2), 'MarkerFaceColor', 'r');
\end_layout

\begin_layout Plain Layout

hold off
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\end_inset


\end_layout

\begin_layout Example
\begin_inset Graphics
	filename scripts/example7_1_images/figure_0.eps
	scale 60

\end_inset


\end_layout

\begin_layout Example
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{par}
\end_layout

\begin_layout Plain Layout


\backslash
begin{flushleft}
\end_layout

\begin_layout Plain Layout

Compute the new 
\backslash
texttt{Y:}
\end_layout

\begin_layout Plain Layout


\backslash
end{flushleft}
\end_layout

\begin_layout Plain Layout


\backslash
end{par}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

for i=1:3
\end_layout

\begin_layout Plain Layout

    ci = D(:,3) == i;
\end_layout

\begin_layout Plain Layout

    x = mean(D(ci,1));
\end_layout

\begin_layout Plain Layout

    y = mean(D(ci,2));
\end_layout

\begin_layout Plain Layout

    Y(i,:)=[x,y];
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

Y
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlaboutput}
\end_layout

\begin_layout Plain Layout

Y = 3x2    
\end_layout

\begin_layout Plain Layout

    7.5000    4.5000
\end_layout

\begin_layout Plain Layout

    3.0000    3.6667
\end_layout

\begin_layout Plain Layout

    3.6667    9.0000
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{matlaboutput}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{par}
\end_layout

\begin_layout Plain Layout


\backslash
begin{flushleft}
\end_layout

\begin_layout Plain Layout

Repeat the process:
\end_layout

\begin_layout Plain Layout


\backslash
end{flushleft}
\end_layout

\begin_layout Plain Layout


\backslash
end{par}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

%Distances
\end_layout

\begin_layout Plain Layout

for j=1:3
\end_layout

\begin_layout Plain Layout

    for i=1:8
\end_layout

\begin_layout Plain Layout

        dist(i,j)=distance(D(i,1:2),Y(j,:),2);
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

dist
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlaboutput}
\end_layout

\begin_layout Plain Layout

dist = 8x3    
\end_layout

\begin_layout Plain Layout

    7.7782    6.4118    1.9437
\end_layout

\begin_layout Plain Layout

    5.5227    1.6667    4.3333
\end_layout

\begin_layout Plain Layout

    0.7071    5.0111    6.6165
\end_layout

\begin_layout Plain Layout

    4.3012    4.7726    1.6667
\end_layout

\begin_layout Plain Layout

    0.7071    4.2164    5.2068
\end_layout

\begin_layout Plain Layout

    1.5811    3.0185    5.5176
\end_layout

\begin_layout Plain Layout

    6.9642    2.6034    7.4907
\end_layout

\begin_layout Plain Layout

    5.7009    5.4263    0.3333
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{matlaboutput}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

%Assign
\end_layout

\begin_layout Plain Layout

[v, idx] = min(dist, [], 2);
\end_layout

\begin_layout Plain Layout

D(:,3) = idx;
\end_layout

\begin_layout Plain Layout

%Plot
\end_layout

\begin_layout Plain Layout

c1 = D(:,3) == 1
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlaboutput}
\end_layout

\begin_layout Plain Layout

c1 = 8x1 logical array    
\end_layout

\begin_layout Plain Layout

   0
\end_layout

\begin_layout Plain Layout

   0
\end_layout

\begin_layout Plain Layout

   1
\end_layout

\begin_layout Plain Layout

   0
\end_layout

\begin_layout Plain Layout

   1
\end_layout

\begin_layout Plain Layout

   1
\end_layout

\begin_layout Plain Layout

   0
\end_layout

\begin_layout Plain Layout

   0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{matlaboutput}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

c2 = D(:,3) == 2;
\end_layout

\begin_layout Plain Layout

c3 = D(:,3) == 3;
\end_layout

\begin_layout Plain Layout

scatter(D(c1,1),D(c1,2), 'MarkerFaceColor', 'b');
\end_layout

\begin_layout Plain Layout

hold on
\end_layout

\begin_layout Plain Layout

scatter(Y(1,1),Y(1,2), 'MarkerFaceColor', 'b');
\end_layout

\begin_layout Plain Layout

scatter(D(c2,1),D(c2,2), 'MarkerFaceColor', 'g');
\end_layout

\begin_layout Plain Layout

scatter(Y(2,1),Y(2,2), 'MarkerFaceColor', 'g');
\end_layout

\begin_layout Plain Layout

scatter(D(c3,1),D(c3,2), 'MarkerFaceColor', 'r');
\end_layout

\begin_layout Plain Layout

scatter(Y(3,1),Y(3,2), 'MarkerFaceColor', 'r');
\end_layout

\begin_layout Plain Layout

hold off
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\end_inset


\end_layout

\begin_layout Example
\begin_inset Graphics
	filename scripts/example7_1_images/figure_1.eps
	scale 60

\end_inset


\end_layout

\begin_layout Example
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

%Optimize
\end_layout

\begin_layout Plain Layout

for i=1:3
\end_layout

\begin_layout Plain Layout

    ci = D(:,3) == i;
\end_layout

\begin_layout Plain Layout

    x = mean(D(ci,1));
\end_layout

\begin_layout Plain Layout

    y = mean(D(ci,2));
\end_layout

\begin_layout Plain Layout

    Y(i,:)=[x,y];
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

Y
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlaboutput}
\end_layout

\begin_layout Plain Layout

Y = 3x2    
\end_layout

\begin_layout Plain Layout

    7.0000    4.3333
\end_layout

\begin_layout Plain Layout

    1.5000    3.5000
\end_layout

\begin_layout Plain Layout

    3.6667    9.0000
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{matlaboutput}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{par}
\end_layout

\begin_layout Plain Layout


\backslash
begin{flushleft}
\end_layout

\begin_layout Plain Layout

Again:
\end_layout

\begin_layout Plain Layout


\backslash
end{flushleft}
\end_layout

\begin_layout Plain Layout


\backslash
end{par}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

%Distances
\end_layout

\begin_layout Plain Layout

for j=1:3
\end_layout

\begin_layout Plain Layout

    for i=1:8
\end_layout

\begin_layout Plain Layout

        dist(i,j)=distance(D(i,1:2),Y(j,:),2);
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

dist
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlaboutput}
\end_layout

\begin_layout Plain Layout

dist = 8x3    
\end_layout

\begin_layout Plain Layout

    7.5572    6.5192    1.9437
\end_layout

\begin_layout Plain Layout

    5.0442    1.5811    4.3333
\end_layout

\begin_layout Plain Layout

    1.0541    6.5192    6.6165
\end_layout

\begin_layout Plain Layout

    4.1767    5.7009    1.6667
\end_layout

\begin_layout Plain Layout

    0.6667    5.7009    5.2068
\end_layout

\begin_layout Plain Layout

    1.0541    4.5277    5.5176
\end_layout

\begin_layout Plain Layout

    6.4377    1.5811    7.4907
\end_layout

\begin_layout Plain Layout

    5.5478    6.0415    0.3333
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{matlaboutput}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

%Assign
\end_layout

\begin_layout Plain Layout

[v, idx] = min(dist, [], 2);
\end_layout

\begin_layout Plain Layout

D(:,3) = idx;
\end_layout

\begin_layout Plain Layout

%Plot
\end_layout

\begin_layout Plain Layout

c1 = D(:,3) == 1
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlaboutput}
\end_layout

\begin_layout Plain Layout

c1 = 8x1 logical array    
\end_layout

\begin_layout Plain Layout

   0
\end_layout

\begin_layout Plain Layout

   0
\end_layout

\begin_layout Plain Layout

   1
\end_layout

\begin_layout Plain Layout

   0
\end_layout

\begin_layout Plain Layout

   1
\end_layout

\begin_layout Plain Layout

   1
\end_layout

\begin_layout Plain Layout

   0
\end_layout

\begin_layout Plain Layout

   0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{matlaboutput}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

c2 = D(:,3) == 2;
\end_layout

\begin_layout Plain Layout

c3 = D(:,3) == 3;
\end_layout

\begin_layout Plain Layout

scatter(D(c1,1),D(c1,2), 'MarkerFaceColor', 'b');
\end_layout

\begin_layout Plain Layout

hold on
\end_layout

\begin_layout Plain Layout

scatter(Y(1,1),Y(1,2), 'MarkerFaceColor', 'b');
\end_layout

\begin_layout Plain Layout

scatter(D(c2,1),D(c2,2), 'MarkerFaceColor', 'g');
\end_layout

\begin_layout Plain Layout

scatter(Y(2,1),Y(2,2), 'MarkerFaceColor', 'g');
\end_layout

\begin_layout Plain Layout

scatter(D(c3,1),D(c3,2), 'MarkerFaceColor', 'r');
\end_layout

\begin_layout Plain Layout

scatter(Y(3,1),Y(3,2), 'MarkerFaceColor', 'r');
\end_layout

\begin_layout Plain Layout

hold off
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\end_inset


\end_layout

\begin_layout Example
\begin_inset Graphics
	filename scripts/example7_1_images/figure_2.eps
	scale 60

\end_inset


\end_layout

\begin_layout Example
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

%Optimize
\end_layout

\begin_layout Plain Layout

for i=1:3
\end_layout

\begin_layout Plain Layout

    ci = D(:,3) == i;
\end_layout

\begin_layout Plain Layout

    x = mean(D(ci,1));
\end_layout

\begin_layout Plain Layout

    y = mean(D(ci,2));
\end_layout

\begin_layout Plain Layout

    Y(i,:)=[x,y];
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

Y
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlaboutput}
\end_layout

\begin_layout Plain Layout

Y = 3x2    
\end_layout

\begin_layout Plain Layout

    7.0000    4.3333
\end_layout

\begin_layout Plain Layout

    1.5000    3.5000
\end_layout

\begin_layout Plain Layout

    3.6667    9.0000
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{matlaboutput}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{par}
\end_layout

\begin_layout Plain Layout


\backslash
begin{flushleft}
\end_layout

\begin_layout Plain Layout

At this point we see how the clusters are the ones that we see naturally
 with our eyes.
 If we execute it again, we can see that the changes are very slight now:
\end_layout

\begin_layout Plain Layout


\backslash
end{flushleft}
\end_layout

\begin_layout Plain Layout


\backslash
end{par}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

%Distances
\end_layout

\begin_layout Plain Layout

for j=1:3
\end_layout

\begin_layout Plain Layout

    for i=1:8
\end_layout

\begin_layout Plain Layout

        dist(i,j)=distance(D(i,1:2),Y(j,:),2);
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

dist
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlaboutput}
\end_layout

\begin_layout Plain Layout

dist = 8x3    
\end_layout

\begin_layout Plain Layout

    7.5572    6.5192    1.9437
\end_layout

\begin_layout Plain Layout

    5.0442    1.5811    4.3333
\end_layout

\begin_layout Plain Layout

    1.0541    6.5192    6.6165
\end_layout

\begin_layout Plain Layout

    4.1767    5.7009    1.6667
\end_layout

\begin_layout Plain Layout

    0.6667    5.7009    5.2068
\end_layout

\begin_layout Plain Layout

    1.0541    4.5277    5.5176
\end_layout

\begin_layout Plain Layout

    6.4377    1.5811    7.4907
\end_layout

\begin_layout Plain Layout

    5.5478    6.0415    0.3333
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{matlaboutput}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

%Assign
\end_layout

\begin_layout Plain Layout

[v, idx] = min(dist, [], 2);
\end_layout

\begin_layout Plain Layout

D(:,3) = idx;
\end_layout

\begin_layout Plain Layout

%Plot
\end_layout

\begin_layout Plain Layout

c1 = D(:,3) == 1
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlaboutput}
\end_layout

\begin_layout Plain Layout

c1 = 8x1 logical array    
\end_layout

\begin_layout Plain Layout

   0
\end_layout

\begin_layout Plain Layout

   0
\end_layout

\begin_layout Plain Layout

   1
\end_layout

\begin_layout Plain Layout

   0
\end_layout

\begin_layout Plain Layout

   1
\end_layout

\begin_layout Plain Layout

   1
\end_layout

\begin_layout Plain Layout

   0
\end_layout

\begin_layout Plain Layout

   0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{matlaboutput}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

c2 = D(:,3) == 2;
\end_layout

\begin_layout Plain Layout

c3 = D(:,3) == 3;
\end_layout

\begin_layout Plain Layout

scatter(D(c1,1),D(c1,2), 'MarkerFaceColor', 'b');
\end_layout

\begin_layout Plain Layout

hold on
\end_layout

\begin_layout Plain Layout

scatter(Y(1,1),Y(1,2), 'MarkerFaceColor', 'b');
\end_layout

\begin_layout Plain Layout

scatter(D(c2,1),D(c2,2), 'MarkerFaceColor', 'g');
\end_layout

\begin_layout Plain Layout

scatter(Y(2,1),Y(2,2), 'MarkerFaceColor', 'g');
\end_layout

\begin_layout Plain Layout

scatter(D(c3,1),D(c3,2), 'MarkerFaceColor', 'r');
\end_layout

\begin_layout Plain Layout

scatter(Y(3,1),Y(3,2), 'MarkerFaceColor', 'r');
\end_layout

\begin_layout Plain Layout

hold off
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\end_inset


\end_layout

\begin_layout Example
\begin_inset Graphics
	filename scripts/example7_1_images/figure_3.eps
	scale 60

\end_inset


\end_layout

\begin_layout Example
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

%Optimize
\end_layout

\begin_layout Plain Layout

for i=1:3
\end_layout

\begin_layout Plain Layout

    ci = D(:,3) == i;
\end_layout

\begin_layout Plain Layout

    x = mean(D(ci,1));
\end_layout

\begin_layout Plain Layout

    y = mean(D(ci,2));
\end_layout

\begin_layout Plain Layout

    Y(i,:)=[x,y];
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

Y
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlaboutput}
\end_layout

\begin_layout Plain Layout

Y = 3x2    
\end_layout

\begin_layout Plain Layout

    7.0000    4.3333
\end_layout

\begin_layout Plain Layout

    1.5000    3.5000
\end_layout

\begin_layout Plain Layout

    3.6667    9.0000
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{matlaboutput}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{par}
\end_layout

\begin_layout Plain Layout


\backslash
begin{flushleft}
\end_layout

\begin_layout Plain Layout

In fact, Y is not changing anymore!
\end_layout

\begin_layout Plain Layout


\backslash
end{flushleft}
\end_layout

\begin_layout Plain Layout


\backslash
end{par}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
matlabheadingthree{Functions}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{par}
\end_layout

\begin_layout Plain Layout


\backslash
hfill 
\backslash
break
\end_layout

\begin_layout Plain Layout


\backslash
end{par}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

function d = distance(X, Y, m)
\end_layout

\begin_layout Plain Layout

    n = length(X);
\end_layout

\begin_layout Plain Layout

    d = 0;
\end_layout

\begin_layout Plain Layout

    for i=1:n
\end_layout

\begin_layout Plain Layout

        d = d + (X(i)-Y(i))^m;
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

    d = sqrt(d);
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
The k-Medians Algorithm
\end_layout

\begin_layout Standard
In this case the Manhattan distance (
\begin_inset Formula $L_{1}$
\end_inset

-norm) is used:
\begin_inset Formula 
\[
Dist\left(X_{i},Y_{j}\right)=\left\Vert X_{i}-Y_{j}\right\Vert _{1}.
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Proposition
The optimal representative 
\begin_inset Formula $Y_{j}$
\end_inset

 for each of the optimize iterative steps is the median of the data points
 along each dimension in cluster 
\begin_inset Formula $C_{j}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Proof
In this case, the objective function is
\begin_inset Formula 
\[
O\left(X,Y\right)=\sum_{j=1}^{k}\sum_{X_{i}\in C_{j}}\left\Vert X_{i}-Y_{j}\right\Vert _{1}.
\]

\end_inset

 Now, the 
\begin_inset Formula $L_{1}$
\end_inset

-norm is obtained by summing the absolute value in each dimension.
 The problem is that this function is not differentiable.
 Nonetheless, it is differentiable almost everywhere.
 We can obtain the sub-gradient of 
\begin_inset Formula $O$
\end_inset

 with respect to 
\begin_inset Formula $Y_{j}$
\end_inset

 as
\begin_inset Formula 
\[
\frac{d}{dY_{j}}O\left(X,Y\right)=\sum_{X_{i}\in C_{j}}sign\left(X_{i}-Y_{j}\right).
\]

\end_inset

 For this to equal 0, we need as many negative signs as positive signs:
 the median in each direction achieves exactly this, as it has as many values
 to its left as to its right.
\end_layout

\begin_layout Example
Repeat the example using the k-Medians algorithm.
\end_layout

\begin_layout Example
\begin_inset ERT
status open

\begin_layout Plain Layout

% This LaTeX was auto-generated from MATLAB code.
\end_layout

\begin_layout Plain Layout

% To make changes, update the MATLAB code and export to LaTeX again.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
matlabtitle{k-Medians algorithm example (Example 7.2)}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{par}
\end_layout

\begin_layout Plain Layout


\backslash
begin{flushleft}
\end_layout

\begin_layout Plain Layout

Introduce the data
\end_layout

\begin_layout Plain Layout


\backslash
end{flushleft}
\end_layout

\begin_layout Plain Layout


\backslash
end{par}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

X1 = [2,10];
\end_layout

\begin_layout Plain Layout

X2 = [2,5];
\end_layout

\begin_layout Plain Layout

X3 = [8,4];
\end_layout

\begin_layout Plain Layout

X4 = [5,8];
\end_layout

\begin_layout Plain Layout

X5 = [7,5];
\end_layout

\begin_layout Plain Layout

X6 = [6,4];
\end_layout

\begin_layout Plain Layout

X7 = [1,2];
\end_layout

\begin_layout Plain Layout

X8 = [4,9];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

D = [X1;X2;X3;X4;X5;X6;X7;X8];
\end_layout

\begin_layout Plain Layout

z = zeros([8,1]);
\end_layout

\begin_layout Plain Layout

D = [D,z]
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlaboutput}
\end_layout

\begin_layout Plain Layout

D = 8x3    
\end_layout

\begin_layout Plain Layout

     2    10     0
\end_layout

\begin_layout Plain Layout

     2     5     0
\end_layout

\begin_layout Plain Layout

     8     4     0
\end_layout

\begin_layout Plain Layout

     5     8     0
\end_layout

\begin_layout Plain Layout

     7     5     0
\end_layout

\begin_layout Plain Layout

     6     4     0
\end_layout

\begin_layout Plain Layout

     1     2     0
\end_layout

\begin_layout Plain Layout

     4     9     0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{matlaboutput}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

Y = [X5; X6; X8]
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlaboutput}
\end_layout

\begin_layout Plain Layout

Y = 3x2    
\end_layout

\begin_layout Plain Layout

     7     5
\end_layout

\begin_layout Plain Layout

     6     4
\end_layout

\begin_layout Plain Layout

     4     9
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{matlaboutput}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{par}
\end_layout

\begin_layout Plain Layout


\backslash
begin{flushleft}
\end_layout

\begin_layout Plain Layout

Apply k-Medians
\end_layout

\begin_layout Plain Layout


\backslash
end{flushleft}
\end_layout

\begin_layout Plain Layout


\backslash
end{par}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

%First iteration
\end_layout

\begin_layout Plain Layout

[D,Ynext] = kMediansIter(D,Y,3);
\end_layout

\begin_layout Plain Layout

%Plot
\end_layout

\begin_layout Plain Layout

c1 = D(:,3) == 1;
\end_layout

\begin_layout Plain Layout

c2 = D(:,3) == 2;
\end_layout

\begin_layout Plain Layout

c3 = D(:,3) == 3;
\end_layout

\begin_layout Plain Layout

scatter(D(c1,1),D(c1,2), 'MarkerFaceColor', 'b');
\end_layout

\begin_layout Plain Layout

hold on
\end_layout

\begin_layout Plain Layout

scatter(Y(1,1),Y(1,2), 'MarkerFaceColor', 'b');
\end_layout

\begin_layout Plain Layout

scatter(D(c2,1),D(c2,2), 'MarkerFaceColor', 'g');
\end_layout

\begin_layout Plain Layout

scatter(Y(2,1),Y(2,2), 'MarkerFaceColor', 'g');
\end_layout

\begin_layout Plain Layout

scatter(D(c3,1),D(c3,2), 'MarkerFaceColor', 'r');
\end_layout

\begin_layout Plain Layout

scatter(Y(3,1),Y(3,2), 'MarkerFaceColor', 'r');
\end_layout

\begin_layout Plain Layout

hold off
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\end_inset


\end_layout

\begin_layout Example
\begin_inset Graphics
	filename scripts/example7_2_images/figure_0.eps
	scale 60

\end_inset


\end_layout

\begin_layout Example
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

Y = Ynext;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%Second iteration
\end_layout

\begin_layout Plain Layout

%First iteration
\end_layout

\begin_layout Plain Layout

[D,Ynext] = kMediansIter(D,Y,3);
\end_layout

\begin_layout Plain Layout

%Plot
\end_layout

\begin_layout Plain Layout

c1 = D(:,3) == 1;
\end_layout

\begin_layout Plain Layout

c2 = D(:,3) == 2;
\end_layout

\begin_layout Plain Layout

c3 = D(:,3) == 3;
\end_layout

\begin_layout Plain Layout

scatter(D(c1,1),D(c1,2), 'MarkerFaceColor', 'b');
\end_layout

\begin_layout Plain Layout

hold on
\end_layout

\begin_layout Plain Layout

scatter(Y(1,1),Y(1,2), 'MarkerFaceColor', 'b');
\end_layout

\begin_layout Plain Layout

scatter(D(c2,1),D(c2,2), 'MarkerFaceColor', 'g');
\end_layout

\begin_layout Plain Layout

scatter(Y(2,1),Y(2,2), 'MarkerFaceColor', 'g');
\end_layout

\begin_layout Plain Layout

scatter(D(c3,1),D(c3,2), 'MarkerFaceColor', 'r');
\end_layout

\begin_layout Plain Layout

scatter(Y(3,1),Y(3,2), 'MarkerFaceColor', 'r');
\end_layout

\begin_layout Plain Layout

hold off
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\end_inset


\end_layout

\begin_layout Example
\begin_inset Graphics
	filename scripts/example7_2_images/figure_1.eps
	scale 60

\end_inset


\end_layout

\begin_layout Example
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

Y = Ynext;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%Third iteration
\end_layout

\begin_layout Plain Layout

[D,Ynext] = kMediansIter(D,Y,3);
\end_layout

\begin_layout Plain Layout

%Plot
\end_layout

\begin_layout Plain Layout

c1 = D(:,3) == 1;
\end_layout

\begin_layout Plain Layout

c2 = D(:,3) == 2;
\end_layout

\begin_layout Plain Layout

c3 = D(:,3) == 3;
\end_layout

\begin_layout Plain Layout

scatter(D(c1,1),D(c1,2), 'MarkerFaceColor', 'b');
\end_layout

\begin_layout Plain Layout

hold on
\end_layout

\begin_layout Plain Layout

scatter(Y(1,1),Y(1,2), 'MarkerFaceColor', 'b');
\end_layout

\begin_layout Plain Layout

scatter(D(c2,1),D(c2,2), 'MarkerFaceColor', 'g');
\end_layout

\begin_layout Plain Layout

scatter(Y(2,1),Y(2,2), 'MarkerFaceColor', 'g');
\end_layout

\begin_layout Plain Layout

scatter(D(c3,1),D(c3,2), 'MarkerFaceColor', 'r');
\end_layout

\begin_layout Plain Layout

scatter(Y(3,1),Y(3,2), 'MarkerFaceColor', 'r');
\end_layout

\begin_layout Plain Layout

hold off
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\end_inset


\end_layout

\begin_layout Example
\begin_inset Graphics
	filename scripts/example7_2_images/figure_2.eps
	scale 60

\end_inset


\end_layout

\begin_layout Example
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

Y = Ynext;
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

function d = distance(X, Y, m)
\end_layout

\begin_layout Plain Layout

    n = length(X);
\end_layout

\begin_layout Plain Layout

    d = 0;
\end_layout

\begin_layout Plain Layout

    for i=1:n
\end_layout

\begin_layout Plain Layout

        d = d + abs(X(i)-Y(i))^m;
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

    d = sqrt(d);
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

function [D2,Ynext] = kMediansIter(D,Y,k)
\end_layout

\begin_layout Plain Layout

    dist = zeros(k);
\end_layout

\begin_layout Plain Layout

    [n,m] = size(D);
\end_layout

\begin_layout Plain Layout

    %Distances
\end_layout

\begin_layout Plain Layout

    for j=1:k
\end_layout

\begin_layout Plain Layout

        for i=1:n
\end_layout

\begin_layout Plain Layout

            dist(i,j)=distance(D(i,1:2),Y(j,:),2);
\end_layout

\begin_layout Plain Layout

        end
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

    %Assign
\end_layout

\begin_layout Plain Layout

    [v, idx] = min(dist, [], 2);
\end_layout

\begin_layout Plain Layout

    D2 = D;
\end_layout

\begin_layout Plain Layout

    D2(:,3) = idx;
\end_layout

\begin_layout Plain Layout

    %Optimize
\end_layout

\begin_layout Plain Layout

    Ynext = Y;
\end_layout

\begin_layout Plain Layout

    for i=1:3
\end_layout

\begin_layout Plain Layout

        ci = D2(:,3) == i;
\end_layout

\begin_layout Plain Layout

        x = median(D(ci,1));
\end_layout

\begin_layout Plain Layout

        y = median(D(ci,2));
\end_layout

\begin_layout Plain Layout

        Ynext(i,:)=[x,y];
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
The k-Medoids Algorithm
\end_layout

\begin_layout Standard
In this algorithm the representatives are always selected from the database
 
\begin_inset Formula $\mathcal{D}$
\end_inset

, and this makes the structure of the algorithm different from the one we
 have seen before.
\end_layout

\begin_layout Standard
Reasons:
\end_layout

\begin_layout Itemize
This approach makes outlier handling easier than with 
\begin_inset Formula $k$
\end_inset

-means.
\end_layout

\begin_layout Itemize
It is sometimes difficult to compute the central representative of a complex
 data type (text or categorical data).
 The 
\begin_inset Formula $k$
\end_inset

-medoids algorithm can be defined in any datatype in which we are able to
 define a proper distance function.
\end_layout

\begin_layout Standard
The algorithm is as in Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:k-medoids"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "morekeywords={if, then, is, in, return, for, Let},morecomment={[f][\color{purple}]{\#}}"
inline false
status open

\begin_layout Plain Layout

Initialize Y = {Y_1,...,Y_k} <@
\backslash
textcolor{purple}{
\backslash
#Using heuristics}<@
\end_layout

\begin_layout Plain Layout

Initialize clusters C_1 = {},...
 C_k = {}
\end_layout

\begin_layout Plain Layout

do
\end_layout

\begin_layout Plain Layout

# Assign step
\end_layout

\begin_layout Plain Layout

	for(X in D):
\end_layout

\begin_layout Plain Layout

		assign X to Y_j such that <@
\backslash
textcolor{blue}{$Dist(X,Y_j) = 
\backslash
min_i Dist(X,Y_i)$}<@
\end_layout

\begin_layout Plain Layout

		C_j.add(X)
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

# Optimize step
\end_layout

\begin_layout Plain Layout

	Determine a pair X_i in D and Y_j in Y such that 
\end_layout

\begin_layout Plain Layout

		replacing Y_j with X_i leads to the 
\end_layout

\begin_layout Plain Layout

		greatest possible improvement in the objective function
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	Perform the exchange between X_i and Y_j only if improvement is positive.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

while <@$O=
\backslash
sum_{i=1}^{n}
\backslash
left[
\backslash
min_{j}
\backslash
 Dist
\backslash
left(X_{i},Y_{j}
\backslash
right)
\backslash
right]$<@ > eps 
\end_layout

\begin_layout Plain Layout

		or no improvement in current iteration
\end_layout

\begin_layout Plain Layout

return {C_1, Y_1},...,{C_k, Y_k}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:k-medoids"

\end_inset


\begin_inset Formula $k$
\end_inset

-medoids(Data D, int k, threshold eps) : Set of representatives Y and Clusters
 C
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Remark
In this algorithm we use a hill climbing strategy to obtain the best representat
ives.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
We can try all possible changes or sample points from the database to try
 with.
 The latter approach is often more desirable for time issues.
\end_layout

\begin_layout Subsection
Practical issues
\end_layout

\begin_layout Itemize
The initialization of the initial representative is not a trivial task.
 Normally they are selected randomly among the points of the datasets and
 most times the initialization step does not change the outcome of the algorithm
: the representative based algorithm are very robust to this selection.
 Nonetheless, sometimes suboptimal clusters arise because of a bad choice
 of initial representatives.
\end_layout

\begin_layout Itemize
Outliers can make a detrimental impact on the algorithms.
 If one outlier is selected as initial representative it is possible to
 obtain a singleton cluster with no meaning for the application.
\end_layout

\begin_layout Itemize
The number of clusters, 
\begin_inset Formula $k$
\end_inset

, is difficult to determine using automated methods.
 As it is not known a priori, a common approach is to start with larger
 values for 
\begin_inset Formula $k$
\end_inset

 than the one we think should be correct.
 Some natural clusters may split, but we can merge some of them as a postprocess
ing step.
\end_layout

\begin_layout Section
Grid and Density based Algorithms
\end_layout

\begin_layout Standard
One of the major problems with distance-based algorithms is that the shape
 of the clusters is implicitly enforced by the distance function.
 Thus, it can be hard to detect natural cluster of arbitrary form.
\end_layout

\begin_layout Standard

\series bold
Density-based algorithms
\series default
 are useful for this.
 The idea is to identify dense regions in the data, and use the positions
 of the different regions to determine the clusters.
\end_layout

\begin_layout Subsection
Grid-based methods
\end_layout

\begin_layout Standard
The data is discretized into 
\begin_inset Formula $p$
\end_inset

 intervals, typically equi-width.
 If the data has 
\begin_inset Formula $d$
\end_inset

 dimensions, we will obtain 
\begin_inset Formula $p^{d}$
\end_inset

 hyper-cubes.
 These are the building blocks for the clusters.
\end_layout

\begin_layout Standard
A 
\series bold
density threshold 
\begin_inset Formula $\tau$
\end_inset

 
\series default
is used to determine the dense hyper-cubes.
 In most real data-sets, an arbitrarily shaped cluster will result in multiple
 dense regions connected together by a side or a corner.
\end_layout

\begin_layout Standard
Two hyper-cubes are said to be 
\series bold
adjacently connected
\series default
 if they share a side (sometimes corners are also considered).
\end_layout

\begin_layout Standard
Two hyper-cubes are said to be 
\series bold
density connected
\series default
 if a path can be found from one to another containing only a sequence of
 adjacently connected grid regions.
\end_layout

\begin_layout Standard
The 
\series bold
goal
\series default
 is to determine the density connected regions.
 Using a graph representation, the problem is equivalent to finding the
 connected components of the graph, being the hyper-cubes the nodes and
 an edge is defined between every pair of adjacent cubes.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Plain Layout

\series bold
Advantages
\end_layout

\begin_layout Plain Layout
The number of clusters is not pre-defined, so we don't need to bother with
 the estimation of 
\begin_inset Formula $k$
\end_inset

.
\end_layout

\begin_layout Plain Layout

\series bold
Disadvantages
\end_layout

\begin_layout Plain Layout
We have to define 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $\tau$
\end_inset

, which is not easy.
 
\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $p$
\end_inset

 (number of ranges) is too small, the data points from multiple clusters
 will be present in the same hyper-cube.
 We will obtain undesired merged clusters.
\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $p$
\end_inset

 is too large, there will be many empty grid cells, so we may split a natural
 cluster.
 It also will be computationally expensive.
\end_layout

\begin_layout Itemize
The choice of 
\begin_inset Formula $\tau$
\end_inset

 has similar consecuences.
\end_layout

\begin_layout Plain Layout
Also, if the clusters present different densities, it is even more difficult
 to determine 
\begin_inset Formula $\tau$
\end_inset

 and 
\begin_inset Formula $p$
\end_inset

 because each cluster is 'asking' for different values.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The generic algorithm is as follows:
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Discretize each dimension into p ranges
\end_layout

\begin_layout Plain Layout

Determine grid cells at density level tau
\end_layout

\begin_layout Plain Layout

Create graph in which dense grids are connected if they are adjacent
\end_layout

\begin_layout Plain Layout

Determine connected components of the graph
\end_layout

\begin_layout Plain Layout

return points in each connected component as a cluster
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
GenericGrid(Data D, Ranges p, Density tau) : clusters C
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
DBSCAN
\end_layout

\begin_layout Standard
The idea behind DBSCAN is similar to the one we have seen, but density is
 considered at a pointwise level:
\end_layout

\begin_layout Standard
The 
\series bold
density of a data point
\series default
 is defined as the number of points that lie within a radius 
\begin_inset Formula $eps$
\end_inset

 from it, i.e.
 their neighbourhood of radius 
\begin_inset Formula $\tau$
\end_inset

.
 The densities are used to classify the points:
\end_layout

\begin_layout Itemize

\series bold
Core point
\series default
: its neighbourhood contains at least 
\begin_inset Formula $\tau$
\end_inset

 points.
\end_layout

\begin_layout Itemize

\series bold
Border point
\series default
: its neighbourhood contains less than 
\begin_inset Formula $\tau$
\end_inset

 points, but it contains one or more core points.
\end_layout

\begin_layout Itemize

\series bold
Noise points
\series default
: any other case.
\end_layout

\begin_layout Standard
And we define some relations between points:
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(p_{i},p_{j}\right)$
\end_inset

 are 
\series bold
directly density reachable
\series default
 if 
\begin_inset Formula $p_{i}$
\end_inset

 is a core point, and 
\begin_inset Formula $p_{j}$
\end_inset

 is in the neighbourhood of 
\begin_inset Formula $p_{i}$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(p_{i},p_{j}\right)$
\end_inset

 are 
\series bold
density reachable
\series default
 is 
\begin_inset Formula $p_{i}$
\end_inset

 is a core point, and there exists a chain of core points 
\begin_inset Formula $p_{i+1},...,p_{n}$
\end_inset

 where 
\begin_inset Formula $\left(p_{k},p_{k+1}\right)$
\end_inset

 are directly density reachable for 
\begin_inset Formula $k=i,...,n-1$
\end_inset

 and 
\begin_inset Formula $p_{j}$
\end_inset

 is in the neighbourhood of 
\begin_inset Formula $p_{n}$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(p_{i},p_{j}\right)$
\end_inset

 are 
\series bold
density connected
\series default
 if both 
\begin_inset Formula $p_{i}$
\end_inset

 and 
\begin_inset Formula $p_{j}$
\end_inset

 are density reachable from some point 
\begin_inset Formula $p_{k}$
\end_inset


\end_layout

\begin_layout Standard
After the points have been classified, a connectivity graph is constructed
 as a maximal set of points that are all reachable from one another under
 any of these definitions.
\end_layout

\begin_layout Standard
Now, we identify the connected components of the graph, which are the clusters.
\end_layout

\begin_layout Standard
The detailed algorithm is as follows:
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Clusters = {}
\end_layout

\begin_layout Plain Layout

for each unvisited point P in D
\end_layout

\begin_layout Plain Layout

	Neihbourhood = regionQuery(P, eps)
\end_layout

\begin_layout Plain Layout

	if sizeof(Neihbourhood) < tau
\end_layout

\begin_layout Plain Layout

		mark P as visited
\end_layout

\begin_layout Plain Layout

	else
\end_layout

\begin_layout Plain Layout

		C = next cluster
\end_layout

\begin_layout Plain Layout

		expandCluster(P, Neighbourhood, C, eps, tau)
\end_layout

\begin_layout Plain Layout

		if C not in Clusters
\end_layout

\begin_layout Plain Layout

			Clusters.add(C)
\end_layout

\begin_layout Plain Layout

return Clusters
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

function expandCluster(P, Neighbourhood, C, eps, tau)
\end_layout

\begin_layout Plain Layout

	mark P as visited
\end_layout

\begin_layout Plain Layout

	C.add(P)
\end_layout

\begin_layout Plain Layout

	for Q in Neighbourhood
\end_layout

\begin_layout Plain Layout

		if Q not visited
\end_layout

\begin_layout Plain Layout

			mark Q as visited
\end_layout

\begin_layout Plain Layout

			Neighbourhood_Q = regionQuery(Q, eps)
\end_layout

\begin_layout Plain Layout

			if sizeof(Neighbourhood_Q >= tau)
\end_layout

\begin_layout Plain Layout

				Neighbourhood.addAll(Neighbourhood_Q)
\end_layout

\begin_layout Plain Layout

			if Q is not in any cluster
\end_layout

\begin_layout Plain Layout

				C.add(Q)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
DBSCAN(Data D, Radius eps, Density tau) : clusters C
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Plain Layout

\series bold
Advantages
\end_layout

\begin_layout Plain Layout
This method is not very different from the graph method, and it can also
 discover clusters of any shape, without the need of knowing the number
 of clusters in advance.
\end_layout

\begin_layout Plain Layout

\series bold
Disadvantages
\end_layout

\begin_layout Plain Layout
Again, determining the correct values for 
\begin_inset Formula $eps$
\end_inset

 and 
\begin_inset Formula $\tau$
\end_inset

 is a complex task.
 Also, the existence of clusters with different densities makes it even
 harder.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
colback=green!5!white,colframe=cyan!75!black,title=Complexity
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The major time complexity is finding the neighbours: 
\begin_inset Formula $O\left(n^{2}\right)$
\end_inset

.
\end_layout

\begin_layout Plain Layout
In some special cases, an spatial index can reduce it to 
\begin_inset Formula $O\left(n\cdot\log n\right)$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Remark
Usually, grid based methods are more efficient because they partition the
 space, which makes the procedure less computationally expensive.
\end_layout

\begin_layout Subsubsection
Progressive DBSCAN
\end_layout

\begin_layout Standard
The idea is using the same value for 
\begin_inset Formula $\tau$
\end_inset

, apply DBSCAN in a progressive way, increasing the value of 
\begin_inset Formula $eps$
\end_inset

.
\end_layout

\begin_layout Enumerate
Start with a small 
\begin_inset Formula $eps$
\end_inset

 to find dense clusters.
\end_layout

\begin_layout Enumerate
Iteratively relax the 
\begin_inset Formula $eps$
\end_inset

 value to find less dense clusters.
\end_layout

\begin_layout Enumerate
After every iteration, the points that already belong to a cluster are removed
 from the dataset.
\end_layout

\begin_layout Subsection
DENCLUE
\end_layout

\begin_layout Standard
The DENCLUE algorithm is based on kernel-density estimation, which can be
 used to create a smooth profile of the density distribution, by defining
 the density 
\begin_inset Formula $f\left(X\right)$
\end_inset

 at coordinate 
\begin_inset Formula $X$
\end_inset

 as 
\begin_inset Formula 
\[
f\left(X\right)=\frac{1}{n}\sum_{i=1}^{n}K\left(X-X_{i}\right),
\]

\end_inset

 where 
\begin_inset Formula $K$
\end_inset

 is the kernel function 
\begin_inset Formula $X_{i}$
\end_inset

 are 
\begin_inset Formula $n$
\end_inset

 different data points.
 A commonly used kernel function is the 
\series bold
Gaussian Kernel
\series default
:
\begin_inset Formula 
\[
K\left(X-X_{i}\right)=\left(\frac{1}{h\sqrt{2\pi}}\right)^{d}e^{-\frac{\left\Vert X-X_{i}\right\Vert ^{2}}{2h^{2}}}.
\]

\end_inset

 The effect of this operation is to replace each discrete data point with
 a smooth bump, and the density at each points is the sum of all these bumps.
\end_layout

\begin_layout Example
A visual example of a kernel smoothing:
\end_layout

\begin_layout Example
\begin_inset Graphics
	filename pegado8.png

\end_inset


\end_layout

\begin_layout Standard
Once the density has been smoothed, the goal is to determine clusters by
 using a density threshold 
\begin_inset Formula $\tau$
\end_inset

 that intersects the density profile.
 Two examples showing how the choice of 
\begin_inset Formula $\tau$
\end_inset

 affects the result are shown in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "ex8-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Example
\begin_inset CommandInset label
LatexCommand label
name "ex8-2"

\end_inset

In the previous example, if we select 
\begin_inset Formula $\tau=0.1$
\end_inset

, we obtain the following:
\end_layout

\begin_layout Example
\begin_inset Graphics
	filename pegado9.png

\end_inset


\end_layout

\begin_layout Example
In this case, only one cluster is obtained.
 In contrast, if we choose 
\begin_inset Formula $\tau=0.13$
\end_inset

, two clusters are obtained:
\end_layout

\begin_layout Example
\begin_inset Graphics
	filename pegado10.png

\end_inset


\end_layout

\begin_layout Section
Probabilistic Model-Based Algorithms
\end_layout

\begin_layout Standard
Until now, all models described are 
\series bold
hard clustering algorithm
\series default
, meaning each data point is assigned to a particular cluster.
 Probabilistic model-based algorithms are 
\series bold
soft algorithms
\series default
, in which each data point may have a nonzero assignment probability to
 more than one cluster.
\end_layout

\begin_layout Subsection
Fuzzy sets and clusters
\end_layout

\begin_layout Standard
A 
\series bold
fuzzy cluster
\series default
 is a fuzzy set 
\begin_inset Formula $F_{S}:X\rightarrow\left[0,1\right]$
\end_inset

.
 For each data point 
\begin_inset Formula $X_{i}\in X$
\end_inset

, 
\begin_inset Formula $F_{S}\left(X_{i}\right)$
\end_inset

 represents the probability that 
\begin_inset Formula $X_{i}$
\end_inset

 is in cluster 
\begin_inset Formula $S$
\end_inset

.
 
\begin_inset Formula $F_{S}\left(X_{i}\right)$
\end_inset

 can be called 
\series bold
degree of membership
\series default
 of object 
\begin_inset Formula $X_{i}$
\end_inset

 to cluster 
\begin_inset Formula $S$
\end_inset

.
\end_layout

\begin_layout Standard
Formally, given a set of objects 
\begin_inset Formula $X_{1},...,X_{n}$
\end_inset

, a 
\series bold
fuzzy clustering
\series default
 of 
\begin_inset Formula $k$
\end_inset

 fuzzy clusters 
\begin_inset Formula $C_{1},...,C_{k}$
\end_inset

 can be represented using a 
\series bold
partition matrix
\series default
, 
\begin_inset Formula $M=\left[w_{ij}\right]$
\end_inset

, where
\begin_inset Formula 
\[
w_{ij}=F_{C_{j}}\left(X_{i}\right).
\]

\end_inset

 
\begin_inset Formula $M$
\end_inset

 should satisfy three conditions:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $w_{ij}\in\left[0,1\right],\ i=1,...,n,j=1,...,j$
\end_inset

.
 From the definition of a fuzzy cluster.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\sum_{j=1}^{k}w_{ij}=1,\ i=1,...,n$
\end_inset

.
 The sum of all probabilities is 1.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $0<\sum_{i=1}^{n}w_{ij}<n,\ j=1,...,k$
\end_inset

.
 There is no empty cluster.
\end_layout

\begin_layout Subsection
Mixture model
\end_layout

\begin_layout Standard
The underlying assumption of a 
\series bold
mixture-based generative model
\series default
 is to assume that the data was generated from a mixture of 
\begin_inset Formula $k$
\end_inset

 distributions with probability distributions 
\begin_inset Formula $G_{1},...,G_{k}$
\end_inset

.
 Each of them represents a cluster and is called 
\series bold
mixture component
\series default
.
 The data points, 
\begin_inset Formula $X_{i}$
\end_inset

, are generated by this model as follows:
\end_layout

\begin_layout Enumerate
Select a mixture component with prior probability 
\begin_inset Formula $\alpha_{i}=P\left(G_{i}\right)$
\end_inset

.
 Say 
\begin_inset Formula $G_{r}$
\end_inset

 is selected.
\end_layout

\begin_layout Enumerate
Generate a data point from 
\begin_inset Formula $G_{r}$
\end_inset

.
\end_layout

\begin_layout Standard
This generative model is denoted by 
\begin_inset Formula $\mathcal{M}$
\end_inset

.
 We don't know 
\begin_inset Formula $G_{i}$
\end_inset

 nor 
\begin_inset Formula $\alpha_{i}$
\end_inset

 in advance.
 The 
\begin_inset Formula $G_{i}$
\end_inset

 distributions are often assumed to be Gaussian
\begin_inset Foot
status open

\begin_layout Plain Layout
Note that any other distribution might be assumed.
\end_layout

\end_inset

, so we need to estimate the parameters of the distribution in such a way
 that the overall data has a maximum likelihood of being generated by the
 model.
 
\end_layout

\begin_layout Standard
Consider a set 
\begin_inset Formula $C$
\end_inset

 of 
\begin_inset Formula $k$
\end_inset

 probabilistic clusters 
\begin_inset Formula $C_{1},...,C_{k}$
\end_inset

 with probability density functions 
\begin_inset Formula $f_{1},...,f_{k}$
\end_inset

, respectively, and probabilities 
\begin_inset Formula $p_{1},...,p_{k}$
\end_inset

.
 The probability of an object 
\begin_inset Formula $X$
\end_inset

 being generated by the cluster 
\begin_inset Formula $C_{j}$
\end_inset

 is
\begin_inset Formula 
\[
P\left(X|C_{j}\right)=p_{j}\cdot f_{j}\left(X\right),
\]

\end_inset

 and the probability of 
\begin_inset Formula $X$
\end_inset

 being generated by the set 
\begin_inset Formula $C$
\end_inset

 is
\begin_inset Formula 
\[
P\left(X|C\right)=\sum_{j=1}^{k}p_{j}\cdot f_{j}\left(X\right).
\]

\end_inset

 As objects are assumed to be independently generated, for a data set 
\begin_inset Formula $\mathcal{D}=\left\{ X_{1},...,X_{n}\right\} $
\end_inset

, the probability that 
\begin_inset Formula $\mathcal{D}$
\end_inset

 is generated by 
\begin_inset Formula $C$
\end_inset

 is
\begin_inset Formula 
\[
P\left(\mathcal{D}|C\right)=\prod_{i=1}^{n}P\left(X_{i}|C\right)=\prod_{i=1}^{n}\sum_{j=1}^{k}p_{j}\cdot f_{j}\left(X_{i}\right).
\]

\end_inset

 Now, we want to estimate 
\begin_inset Formula $C$
\end_inset

 from 
\begin_inset Formula $\mathcal{D}$
\end_inset

 trying to maximize 
\begin_inset Formula $P\left(\mathcal{D}|C\right)$
\end_inset

 is maximized.
\end_layout

\begin_layout Standard
If we use the assumption that the underlying distributions are Gaussian
 
\begin_inset Formula $\mathcal{G}\left(\mu_{j},\sigma_{j}\right)$
\end_inset

, then the probability density function of each cluster are centered at
 
\begin_inset Formula $\mu_{j}$
\end_inset

 with standard deviation 
\begin_inset Formula $\sigma_{j}$
\end_inset

 is:
\begin_inset Formula 
\[
P\left(X_{i}|\Theta_{j}\right)=\frac{1}{\sigma_{j}\sqrt{2\pi}}e^{-\frac{\left(X_{i}-\mu_{j}\right)^{2}}{2\sigma^{2}}}.
\]

\end_inset

 And if we assume all clusters have the same probability 
\begin_inset Formula $p_{j}$
\end_inset

, then
\begin_inset Formula 
\[
P\left(X_{i}|\Theta\right)=\sum_{j=1}^{k}\frac{1}{\sigma_{j}\sqrt{2\pi}}e^{-\frac{\left(X_{i}-\mu_{j}\right)^{2}}{2\sigma^{2}}}.
\]

\end_inset

 Thus, our objective is to maximize
\begin_inset Formula 
\[
P\left(\mathcal{D}|\Theta\right)=\prod_{i=1}^{n}\sum_{j=1}^{k}\frac{1}{\sigma_{j}\sqrt{2\pi}}e^{-\frac{\left(X_{i}-\mu_{j}\right)^{2}}{2\sigma^{2}}}.
\]

\end_inset


\end_layout

\begin_layout Standard
This is achieved with the 
\series bold
expection-maximization (EM) algorithm
\series default
.
 The EM algorithm is a framework to approach maximum likelihood estimates
 of parameters in statistical models.
 It consists of two steps:
\end_layout

\begin_layout Enumerate

\series bold
E-step
\series default
: assigns objects to clusters according to the current fuzzy clustering
 or parameters of probabilistic clusters.
\end_layout

\begin_layout Enumerate

\series bold
M-step
\series default
: finds the new clustering or parameters that maximize the SSE or the expected
 likelihood.
\end_layout

\begin_layout Example
EM algorithm example.
\end_layout

\begin_layout Example
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
matlabtitle{EM Algorithm example (Example 9.1)}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{par}
\end_layout

\begin_layout Plain Layout


\backslash
begin{flushleft}
\end_layout

\begin_layout Plain Layout

Start defining the data set:
\end_layout

\begin_layout Plain Layout


\backslash
end{flushleft}
\end_layout

\begin_layout Plain Layout


\backslash
end{par}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

D = [3,3;
\end_layout

\begin_layout Plain Layout

    4,10;
\end_layout

\begin_layout Plain Layout

    9,6;
\end_layout

\begin_layout Plain Layout

    14,8;
\end_layout

\begin_layout Plain Layout

    18,11;
\end_layout

\begin_layout Plain Layout

    21,7];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

centers = [3,3;
\end_layout

\begin_layout Plain Layout

           4,10];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[p1,c1] = E_step(D, centers)
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlaboutput}
\end_layout

\begin_layout Plain Layout

p1 = 2x6    
\end_layout

\begin_layout Plain Layout

    1.0000         0    0.4767    0.4160    0.4053    0.4671
\end_layout

\begin_layout Plain Layout

         0    1.0000    0.5233    0.5840    0.5947    0.5329
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

c1 = 1x6    
\end_layout

\begin_layout Plain Layout

     1     2     2     2     2     2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{matlaboutput}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

centers_2 = M_step(D, p1)
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlaboutput}
\end_layout

\begin_layout Plain Layout

centers_2 = 2x2    
\end_layout

\begin_layout Plain Layout

    8.4178    5.0946
\end_layout

\begin_layout Plain Layout

   10.4632    8.9897
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{matlaboutput}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[result, probs, cl] = em_algorithm(D, centers, 0.5)
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlaboutput}
\end_layout

\begin_layout Plain Layout

result = 2x2    
\end_layout

\begin_layout Plain Layout

    6.3427    6.2224
\end_layout

\begin_layout Plain Layout

   16.6020    8.6542
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

probs = 2x6    
\end_layout

\begin_layout Plain Layout

    0.9096    0.8905    0.9012    0.1043    0.0449    0.0930
\end_layout

\begin_layout Plain Layout

    0.0904    0.1095    0.0988    0.8957    0.9551    0.9070
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

cl = 1x6    
\end_layout

\begin_layout Plain Layout

     1     1     1     2     2     2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{matlaboutput}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

D(:,3) = cl;
\end_layout

\begin_layout Plain Layout

c1 = D(:,3) == 1;
\end_layout

\begin_layout Plain Layout

c2 = D(:,3) == 2;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scatter(D(c1,1),D(c1,2), 'MarkerFaceColor', 'b');
\end_layout

\begin_layout Plain Layout

hold on
\end_layout

\begin_layout Plain Layout

scatter(result(1,1),result(1,2), 'MarkerFaceColor', 'b');
\end_layout

\begin_layout Plain Layout

scatter(D(c2,1),D(c2,2), 'MarkerFaceColor', 'g');
\end_layout

\begin_layout Plain Layout

scatter(result(2,1),result(2,2), 'MarkerFaceColor', 'g');
\end_layout

\begin_layout Plain Layout

hold off
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\end_inset


\end_layout

\begin_layout Example
\begin_inset Graphics
	filename scripts/example9_1_images/figure_0.eps

\end_inset


\end_layout

\begin_layout Example
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

function d = distance(X, Y, m)
\end_layout

\begin_layout Plain Layout

    n = length(X);
\end_layout

\begin_layout Plain Layout

    d = 0;
\end_layout

\begin_layout Plain Layout

    for i=1:n
\end_layout

\begin_layout Plain Layout

        d = d + abs(X(i)-Y(i))^m;
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

    d = sqrt(d);
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

function [probs,clusters] = E_step(data, centers)
\end_layout

\begin_layout Plain Layout

    k = length(centers);
\end_layout

\begin_layout Plain Layout

    n = length(data);
\end_layout

\begin_layout Plain Layout

    distances = zeros([k,n]);
\end_layout

\begin_layout Plain Layout

    for i = 1:k
\end_layout

\begin_layout Plain Layout

        for j = 1:n
\end_layout

\begin_layout Plain Layout

            distances(i,j) = distance(data(j,:),centers(i,:),2)^2;
\end_layout

\begin_layout Plain Layout

        end
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    full_dists = sum(distances,1);
\end_layout

\begin_layout Plain Layout

    probs = (full_dists - distances )./ full_dists;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    [c,idx] = min(distances,[],1);
\end_layout

\begin_layout Plain Layout

    clusters = idx;
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

function new_centers = M_step(data,probs)
\end_layout

\begin_layout Plain Layout

    sq_probs = probs.^2;
\end_layout

\begin_layout Plain Layout

    sum_sq_probs = sum(sq_probs,2);
\end_layout

\begin_layout Plain Layout

    new_centers = sq_probs * data;
\end_layout

\begin_layout Plain Layout

    new_centers = new_centers ./ sum_sq_probs;
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

function [centers, probs, clusters] = em_algorithm(data, in_centers, eps)
\end_layout

\begin_layout Plain Layout

    dif = inf;
\end_layout

\begin_layout Plain Layout

    while dif > eps
\end_layout

\begin_layout Plain Layout

        [probs,clusters] = E_step(data, in_centers);
\end_layout

\begin_layout Plain Layout

        centers = M_step(data, probs);
\end_layout

\begin_layout Plain Layout

        dif = sum(centers - in_centers);
\end_layout

\begin_layout Plain Layout

        in_centers = centers;
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

    [probs,clusters] = E_step(data, centers);
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Evaluating fuzzy clusters
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $c_{1},...,c_{k}$
\end_inset

 are the centers of the 
\begin_inset Formula $k$
\end_inset

 clusters, we define the sum of squared error (SSE) for a point 
\begin_inset Formula $X_{i}$
\end_inset

 as
\begin_inset Formula 
\[
SSE\left(X_{i}\right)=\sum_{j=1}^{k}w_{ij}^{p}\cdot dist\left(X_{i},c_{j}\right)^{2}.
\]

\end_inset


\end_layout

\begin_layout Standard
For a cluster 
\begin_inset Formula $C_{j}$
\end_inset

, we have its SSE as
\begin_inset Formula 
\[
SSE\left(C_{j}\right)=\sum_{i=1}^{n}w_{ij}^{p}\cdot dist\left(X_{i},c_{j}\right)^{2}.
\]

\end_inset


\end_layout

\begin_layout Standard
Finally, the SSE of the whole clustering is
\begin_inset Formula 
\[
SSE\left(\mathcal{C}\right)=\sum_{i=1}^{n}\sum_{j=1}^{k}w_{ij}^{p}\cdot dist\left(X_{i},c_{j}\right)^{2}.
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Frequent pattern and association rule mining
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Stream data mining
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Outlier mining
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Spatial and Spatiotemporal data mining
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintCited"
bibfiles "dm_bib"
options "bibtotoc,plain"

\end_inset


\end_layout

\end_body
\end_document
