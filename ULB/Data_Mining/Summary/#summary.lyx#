#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{graphicx}
\usepackage{color}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amsfonts}
%\usepackage{epstopdf}
\usepackage{matlab}
\end_preamble
\use_default_options true
\begin_modules
tcolorbox
customHeadersFooters
theorems-ams-bytype
theorems-sec-bytype
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=blue, urlcolor=marineblue, citecolor=green, pdfstartview={FitH}, unicode=true"
\papersize a4paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\boxbgcolor #62a0ea
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 3cm
\rightmargin 2cm
\bottommargin 3cm
\headheight 2cm
\headsep 1cm
\footskip 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle fancy
\listings_params "morekeywords={if, then, is, in, return, for, Let, do, while, all, Initialize,or, function, mark, as, not, any},morecomment={[f][\color{purple}]{\#}},escapechar={<@}"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
INFOH423 - Data Mining
\end_layout

\begin_layout Date
Fall 2022
\end_layout

\begin_layout Author
Jose Antonio Lorencio Abril
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 1200px-Université_libre_de_Bruxelles_(logo).svg.png
	scale 10

\end_inset


\end_layout

\begin_layout Standard
\align right
Professor: Mahmoud Sakr
\end_layout

\begin_layout Standard
\align right
Student e-mail: jose.lorencio.abril@ulb.be
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Address
This is a summary of the course 
\emph on
Data Mining
\emph default
, taught at the Université Libre de Bruxelles by Professor Mahmoud Sakr
 in the academic year 22/23.
 Most of the content of this document is adapted from the course notes by
 Sakr, 
\begin_inset CommandInset citation
LatexCommand cite
key "Sakr2022"
literal "false"

\end_inset

, and the basic bibliographic source of the course, the book of Aggarwal,
 
\begin_inset CommandInset citation
LatexCommand cite
key "Aggarwal_2015"
literal "false"

\end_inset

, so I won't be citing it all the time.
 Other references will be provided when used.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList table

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList algorithm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Introduction
\end_layout

\begin_layout Section
What is data mining?
\end_layout

\begin_layout Standard
Even though there is not a formal-accepted-by-all definition of data mining,
 most of them are in agreement that data mining is a field of study that
 focuses on the collection, cleaning, processing, analysis and gaining of
 useful insights from the data that we have access to.
\end_layout

\begin_layout Standard
As wider as these topics are, is also the data mining domain, which is nowadays
 a really hot topic both in academia and industry.
\end_layout

\begin_layout Standard
In academia, there exist many goals to achieve in this field:
\end_layout

\begin_layout Itemize
Developing new models.
\end_layout

\begin_layout Itemize
Developing new ways to deal with real world data.
\end_layout

\begin_layout Itemize
Understading what some complex models are actually doing.
\end_layout

\begin_layout Itemize
Developing the mathematical tools to be able to better describe the models
 that are made by computer scientist in a less formalized way (it is not
 rare that scientific models come before their mathematical formalization
\begin_inset Foot
status open

\begin_layout Plain Layout
For example, for Newton, differential calculus was just a tool he developed
 to be able to better understand some physical processes that were kind
 of obvious to him.
 Afterwards, it became one of the widest branches of mathematics and led
 to other mathematical tools, theories and developments in many other fields.
\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize
Using of data mining to gain a better understanding of medical, biological,
 chemical, economic,...
 data than we are able to gain using just traditional statistic techniques.
\end_layout

\begin_layout Standard
In the industry, the focus is mainly in two fields (disregarding research
 companies, which would have similar objectives as academia):
\end_layout

\begin_layout Itemize
Using well known models to understand what happened in the past.
\end_layout

\begin_layout Itemize
Using well known models to try to predict what will happen in the future.
\end_layout

\begin_layout Standard
These usages are made with the aim of improving the business processes and,
 ultimately, maximize profit.
\end_layout

\begin_layout Subsection
Why is data mining important today, if it was not yesterday?
\end_layout

\begin_layout Standard
Because the computing power has increased enormously, so now we are able
 to run algorithms that enable us to train models in a decent time, and
 this task was practically undoable a few years ago.
\end_layout

\begin_layout Standard
Not only that, but the data technology is rapidly evolving, too.
 We produce more data and store more data, so...
 we have more data! This data is potential knowledge and we know many tools
 to get this knowledge from it.
 
\end_layout

\begin_layout Standard
In fact, the amount of data is so vast, that not only we have to develop
 techniques to analyze data, but also to manage huge amounts of data.
\end_layout

\begin_layout Section
The Data Mining Process
\end_layout

\begin_layout Standard
The data mining process is a pipeline constructed around the basic steps:
\end_layout

\begin_layout Enumerate

\series bold
Data collection
\series default
: obtention of data from real world sources.
\end_layout

\begin_layout Enumerate

\series bold
Feature extraction 
\series default
and 
\series bold
data cleaning
\series default
: among all data retrieved from the real world, we have to select those
 characteristics or 
\series bold
features
\series default
 that are relevant for our purposes (feature extraction) and to decide what
 to do with mistaken/noisy/lost data (data cleaning).
 Also, as we might be collecting data from different sources, it is important
 to decide how to aggregate the data into a unified format for later processing.
\end_layout

\begin_layout Enumerate

\series bold
Analytical processing 
\series default
and 
\series bold
algorithms
\series default
: we now must develop suitable methods for analyzing our data.
 That is, we should decide what mathematical models to use to describe our
 data, and what algorithms to use in order to 
\emph on
train
\emph default
 the desired model
\begin_inset Foot
status open

\begin_layout Plain Layout
We will see what is specifically the meaning of 
\emph on
train
\emph default
, but in the meanwhile we can think of it as how we make a general model
 adapt to our particular data.
\end_layout

\end_inset

.
\end_layout

\begin_layout Enumerate
After these steps, we would enter a phase of analyzing the obtained results
 to obtain knowledge from data, as well as a iterative procedure, in which
 we could return to any previous step and try to improve different parts
 of the process
\begin_inset Foot
status open

\begin_layout Plain Layout
Usually, data is constantly updating, so at least it will necessary to produce
 checks of correctness and updates.
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Data Types
\end_layout

\begin_layout Standard
Not all data have have the same nature nor characteristic, so it is important
 to understand the differences between them and what techniques are applicable
 to what types of data.
\end_layout

\begin_layout Standard
We can characterize data in different levels of detail, and the most basic
 classification would distinguish between 
\emph on
nondependency-oriented
\emph default
 data and 
\emph on
dependency-oriented
\emph default
 data:
\end_layout

\begin_layout Itemize

\series bold
Nondependency-oriented data
\series default
: simple data types with no specified dependencies between the data items
 or the attributes.
\end_layout

\begin_layout Itemize

\series bold
Dependency-oriented data
\series default
: implicit or explicit relationships may exist between data items.
 
\end_layout

\begin_layout Standard
Dependency-oriented data are normally more complex to study because of the
 need to study not only the data itself, but also the relationships between
 different data items.
\end_layout

\begin_layout Standard
We will now define different subtypes of data that we can find.
\end_layout

\begin_layout Subsection
Nondependency-oriented data
\end_layout

\begin_layout Standard
The term nondependency-oriented data is interchangeable with the term 
\series bold
multidimensional data:
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
We will call 
\series bold
source space
\series default
, 
\begin_inset Formula $\mathcal{S}$
\end_inset

, to the set of all possible values that our data can take.
 This set does not have neccessarily to take any particular form.
 
\end_layout

\begin_layout Definition
If 
\begin_inset Formula $\mathcal{S}$
\end_inset

 is a product space, then each component is called a 
\series bold
feature
\series default
.
\end_layout

\end_inset


\end_layout

\begin_layout Example
If we are measuring the name, age, height and gender of the students of
 a school, then we will have
\begin_inset Formula 
\[
\mathcal{S}=\mathcal{T}\times\mathbb{N}\cap\left[0,150\right]\times\left(0,3\right)\times\left\{ M,F\right\} ,
\]

\end_inset

 where 
\begin_inset Formula $\mathcal{T}$
\end_inset

 represents the set of possible names and 
\begin_inset Formula $\left\{ M,F\right\} $
\end_inset

 are the two possible values of the gender.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
A 
\series bold
record
\series default
 (
\emph on
data point, instance, tuple
\emph default
) is just a point 
\begin_inset Formula $X=\left(x^{i}\right)_{i=1}^{d}\in\mathcal{S}$
\end_inset

 that we measure and store in some form.
\end_layout

\end_inset


\end_layout

\begin_layout Example
Following the previous example, some records of 
\begin_inset Formula $\mathcal{S}$
\end_inset

 are represented in the following table:
\end_layout

\begin_layout Example
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset CommandInset label
LatexCommand label
name "table:records_example"

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
index
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Age
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Height
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Gender
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Josh
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
23
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1.77
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
M
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
28
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1.62
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
F
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Larry
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1.58
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
M
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Records and multidimensional data set example
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Example
Note that we added an index column, because it is a common practice.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
A 
\series bold
multidimensional data set
\series default
, 
\begin_inset Formula $\mathcal{D}$
\end_inset

, is a set of 
\begin_inset Formula $n$
\end_inset

 records, 
\begin_inset Formula $\left\{ X_{j}\right\} _{j=1}^{n}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Example
Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "table:records_example"
plural "false"
caps "false"
noprefix "false"

\end_inset

 represents an example of a dataset, too.
\end_layout

\begin_layout Standard
As we can see, Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "table:records_example"
plural "false"
caps "false"
noprefix "false"

\end_inset

 contains attributes of different types (very obvious from the definition
 of the source space 
\begin_inset Formula $\mathcal{S}$
\end_inset

).
 Thus, we have to take into account also the type of each attributes of
 our data:
\end_layout

\begin_layout Itemize

\series bold
Quantitative multidimensional data
\series default
: numerical data features, as age or height.
 If a data set is wholy compound of this kind of features, it is said to
 be a quantitative multidimensional data.
 
\end_layout

\begin_deeper
\begin_layout Standard
This type of data is the easiest to analyze, as mathematical tools are directly
 applicable and most algorithms are developed assuming this type of data.
 For this reason, it is common to try to transform all non-quantitative
 data into quantitative data.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Categorical and Mixed Attribute data
\series default
: a 
\series bold
categorical
\series default
 feature is such that it can only take values among a finite set (unordered)
 of options, as the gender.
 
\end_layout

\begin_deeper
\begin_layout Standard
If we encounter a data set compound of categorial data, we would say it
 is a categorical multidimensional data.
\end_layout

\begin_layout Standard
A dataset with both quantitative and categorical features is called a mixed
 multidimensional data.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Binary and Set data
\series default
: binary data take values in 
\begin_inset Formula $\left\{ 0,1\right\} $
\end_inset

 and it can be considered a special case of both numerical data (obviously)
 and categorical data (as if have a categorical feature which can only take
 two values, then it is easy to map these values to the set 
\begin_inset Formula $\left\{ 0,1\right\} $
\end_inset

).
 For example, the gender is an obvious case of binary data.
\end_layout

\begin_deeper
\begin_layout Standard
Moreover, binary data can be seen as setwise data, where 1 indicates that
 the instance is in the set, while 0 indicates it is not.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Text data
\series default
: usually a string, such as the name.
\end_layout

\begin_layout Subsection
Dependency-oriented data
\end_layout

\begin_layout Standard
As outlined before, we can find implicit or explicit dependencies between
 instances:
\end_layout

\begin_layout Itemize

\series bold
Implicit dependencies
\series default
: the dependencies between instancies are not explicitly specified but are
 known to exist.
 For example, if we measure the number of students in the library every
 5 minutes, we would find that different instances are related via the temporal
 dimension, so measures with little time delay between them would be similar.
\end_layout

\begin_layout Itemize

\series bold
Explicit dependencies
\series default
: this term usually refers to graph or network data, in which edges represents
 relationships between nodes.
\end_layout

\begin_layout Standard
As before, let deepen a bit in some types of this kind of data:
\end_layout

\begin_layout Itemize

\series bold
Time-Series data
\series default
: it contains data that are generated by continuous measurement over time.
 This means that our source space has a temporal component.
 This dependency is implicit.
\end_layout

\begin_deeper
\begin_layout Standard
Formally, a 
\series bold
time series of length 
\begin_inset Formula $\boldsymbol{n}$
\end_inset

 and dimensionality 
\begin_inset Formula $\boldsymbol{d}$
\end_inset

 
\series default
contains 
\begin_inset Formula $d$
\end_inset

 numeric features at each of 
\begin_inset Formula $n$
\end_inset

 time stamps 
\begin_inset Formula $t_{1},...,t_{n}$
\end_inset

.
 Each time stamp contains a component for each of the 
\begin_inset Formula $d$
\end_inset

 series.
 Therefore, the set of values received at time stamp 
\begin_inset Formula $t_{i}$
\end_inset

 es 
\begin_inset Formula $Y_{i}=\left(y_{i}^{1},...,y_{i}^{d}\right)$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Discrete sequences
\series default
: these are the categorical analog of time-series data.
 We will now have categorical or text features along the temporal dimension.
 This dependency is implicit.
\end_layout

\begin_layout Itemize

\series bold
Spatial data
\series default
: in this type of data, the dependance of the instances is given by their
 proximity in space.
 For example, if we measure the temperature in a room per 
\begin_inset Formula $cm^{3}$
\end_inset

, we will find that points that are nearby show more similar temperature
 than points that are far away from each other.
 This dependency is implicit.
\end_layout

\begin_layout Itemize

\series bold
Spatiotemporal data
\series default
: this data captures both spatial and temporal dimension, so we have to
 deal with both relationships.
 As before, this dependency is implicit.
\end_layout

\begin_layout Itemize

\series bold
Network and graph data
\series default
: now, data values may correspond to nodes in the network, and the relationships
 between them would correspond to the edges between the nodes.
\end_layout

\begin_deeper
\begin_layout Standard
Formally, a 
\series bold
network
\series default
 is a pair 
\begin_inset Formula $G=\left(N,E\right)$
\end_inset

 where 
\begin_inset Formula $N$
\end_inset

 is a set of nodes and 
\begin_inset Formula $E\subset N\times N$
\end_inset

 is a set of edges, that represent the relationships between the nodes.
 There can be attributes associated to both nodes or edges.
\end_layout

\begin_layout Standard
Edges may be directed or indirected, depending on wether the link is bidirection
al or not.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Classification
\end_layout

\begin_layout Standard
A 
\series bold
classification problem
\series default
 consists in learning the structure of a dataset of examples, already partitione
d into groups, referred as 
\series bold
class
\series default
.
 This learning is typically achieved with a 
\series bold
model
\series default
, which is used to estimate the 
\series bold
class labels
\series default
 of unseen data examples with unknown labels.
 Thus, one of the inputs to the classification problem is the example dataset
 with known labels, 
\begin_inset Formula $\mathcal{D}$
\end_inset

, called 
\series bold
training data
\series default
, while the unseen data points to be classified are the 
\series bold
test data
\series default
.
 The model learnt is referred to as 
\series bold
training model
\series default
.
 The algorithm used to create the model is the 
\series bold
learner
\series default
.
 
\end_layout

\begin_layout Standard
The output of the classification algorithm can be of two types:
\end_layout

\begin_layout Itemize

\series bold
Label prediction
\series default
: a label is predicted for each test instance.
\end_layout

\begin_layout Itemize

\series bold
Numerical score
\series default
: the learner assigns a score to each instance-label possible combination.
 This score measures the propensity of the instance to belong to a particular
 class.
\end_layout

\begin_layout Section
Decision Trees
\end_layout

\begin_layout Standard

\series bold
Decision trees
\series default
 are a classification methodology, which uses a tree structure to partition
 the feature space.
 Each node of the tree represents a decision to make according to the data,
 called the 
\series bold
split criterion
\series default
, and is a condition on one or more features variables in the training data.
\end_layout

\begin_layout Standard
The goal is to identify a split criterion such that the level of 
\emph on
mixing
\emph default
 of the class variables in each branch of the tree is reduced as much as
 possible.
\end_layout

\begin_layout Standard
The splits can be 
\series bold
univariate
\series default
, if they use a single attribute in the condition, or 
\series bold
multivariate
\series default
, if more than one attribute are used in the condition.
\end_layout

\begin_layout Standard
The nodes can be of two types:
\end_layout

\begin_layout Itemize

\series bold
Internal node
\series default
: each internal node represents a partition of the space according to a
 certain condition.
\end_layout

\begin_layout Itemize

\series bold
Leaf node
\series default
: they are labeled with the dominant class of the remaining partition of
 the training set at that node.
\end_layout

\begin_layout Standard
The general algorithm for constructing a decision tree is as follows:
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "breaklines=true,morekeywords={Algorithm, begin, repeat, until, end},escapechar={<@}"
inline false
status open

\begin_layout Plain Layout

begin
\end_layout

\begin_layout Plain Layout

	Create root node containing D;
\end_layout

\begin_layout Plain Layout

	repeat
\end_layout

\begin_layout Plain Layout

		Select an eligible node in tree;
\end_layout

\begin_layout Plain Layout

		<@
\backslash
textcolor{red}{Split the selected node into two or more nodes based on the
 split criterion};<@
\end_layout

\begin_layout Plain Layout

	until no more eligible nodes for split;
\end_layout

\begin_layout Plain Layout

	<@
\backslash
textcolor{red}{Prune overfitting nodes from tree};<@
\end_layout

\begin_layout Plain Layout

	Label each leaf node with its dominant class;
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
GenericDecisionTree(Dataset: D)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The red lines indicate what changes accross the different algorithms to
 produce a specific decision tree.
\end_layout

\begin_layout Subsection
Split criteria
\end_layout

\begin_layout Standard
The split criterion aims to maximize the separation of the different classes
 among the children nodes.
 Its design depends on the attributes of the data:
\end_layout

\begin_layout Itemize
Binary attributes: produce a binary tree.
\end_layout

\begin_layout Itemize
Categorical attribute: there several approaches:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $r$
\end_inset

-way split: we split the branch in as many branches as distinct values of
 the attribute.
\end_layout

\begin_layout Itemize
binary split: testing each of the 
\begin_inset Formula $2^{r}-1$
\end_inset

 groupings of categorical attributes, and selecting the best one.
\end_layout

\end_deeper
\begin_layout Itemize
Numeric attribute: we have, again, several possibilities:
\end_layout

\begin_deeper
\begin_layout Itemize
If it contains a small number 
\begin_inset Formula $r$
\end_inset

 of ordered values, we can treat it as a categorial attribute and apply
 
\begin_inset Formula $r$
\end_inset

-way split.
\end_layout

\begin_layout Itemize
For continuous numeric attributes, the split is performed using a binary
 condition, like 
\begin_inset Formula $x\le a$
\end_inset

 for a certain contant 
\begin_inset Formula $a$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Standard
These methods require to determine the best split among a set of different
 splits, so we need a way to measure which one is better than other.
\end_layout

\begin_layout Standard
For this end, we are using the 
\series bold
entropy
\series default
.
\end_layout

\begin_layout Subsubsection
Entropy
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
Let 
\begin_inset Formula $p_{j}$
\end_inset

 be the fraction of data points belonging to the class 
\begin_inset Formula $j$
\end_inset

 for the attribute value 
\begin_inset Formula $v_{j}$
\end_inset

.
 Then, the 
\series bold
class-based entropy
\series default
, 
\begin_inset Formula $E\left(v_{i}\right)$
\end_inset

, 
\series bold
for the attribute
\series default
 value 
\begin_inset Formula $v_{i}$
\end_inset

 is
\begin_inset Formula 
\[
E\left(v_{i}\right)=-\sum_{j=1}^{k}p_{j}\log_{2}\left(p_{j}\right).
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Remark
When 
\begin_inset Formula $p_{j}=0$
\end_inset

, it is assumed that 
\begin_inset Formula $p_{j}\log_{2}\left(p_{j}\right)=0$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
\begin_inset Formula $E\left(v_{i}\right)\in\left[0,\log_{2}k\right]$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
Higher values of the entropy imply greater 
\emph on
mixing
\emph default
 of different classes, while a value of 0 implies perfect separation.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
The 
\series bold
overal entropy
\series default
 
\series bold
of an attribute
\series default
, 
\begin_inset Formula $E$
\end_inset

, is defined as the weighted average over the 
\begin_inset Formula $r$
\end_inset

 different attribute values:
\begin_inset Formula 
\[
E=\sum_{i=1}^{r}\frac{n_{i}}{n}E\left(v_{i}\right),
\]

\end_inset

 where 
\begin_inset Formula $n_{i}$
\end_inset

 is the frequency of attribute value 
\begin_inset Formula $v_{i}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The entropy is used in the ID3 algorithm for constructing decision trees.
\end_layout

\begin_layout Standard
The overall entropy for an 
\begin_inset Formula $r$
\end_inset

-way split of set 
\begin_inset Formula $S$
\end_inset

 into sets 
\begin_inset Formula $S_{1},...,S_{r}$
\end_inset

 may be computed as the weighted average of the entropy values of each 
\begin_inset Formula $S_{i}$
\end_inset

, being its weigth 
\begin_inset Formula $\left|S_{i}\right|$
\end_inset

.
 This is called the 
\series bold
entropy-split
\series default
:
\begin_inset Formula 
\[
Entropy-Split\left(S\implies S_{1},...,S_{r}\right)=\sum_{k=1}^{r}\frac{\left|S_{k}\right|}{\left|S\right|}E\left(v_{i}|S_{k}\right).
\]

\end_inset


\end_layout

\begin_layout Standard
In relation to this, the 
\series bold
information gain
\series default
 is defined as the reduction of entropy due to the split:
\begin_inset Formula 
\[
IG\left(S\implies S_{1},...,S_{r}\right)=E\left(S\right)-Entropy-Split\left(S\implies S_{1},...,S_{r}\right).
\]

\end_inset

 Note that lower values of the entropy-split and higher values of the informatio
n gain are more desirable.
\end_layout

\begin_layout Standard
Sometimes, there are attributes with lots of distinct values, so using them
 to split the data reduces the entropy a lot, but are not very useful for
 prediction
\begin_inset Foot
status open

\begin_layout Plain Layout
Think, for example, in an ID.
 See Subsubsection 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-problem-of"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\end_inset

.
 To account for this, we can divide the overall information gain with the
 normalization factor 
\begin_inset Formula 
\[
-\sum_{i=1}^{r}\frac{\left|S_{i}\right|}{\left|S\right|}\log_{2}\left(\frac{\left|S_{i}\right|}{\left|S\right|}\right),
\]

\end_inset

 which helps adjusting for the varying number of categorical values.
\end_layout

\begin_layout Example

\series bold
Entropy of the dataset 'Weather data'
\end_layout

\begin_layout Example
Consider the following dataset:
\end_layout

\begin_layout Example
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="15" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
outlook
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
temperature
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
humidity
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
windy
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
play
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
sunny
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
hot
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
high
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
false
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
no
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
sunny
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
hot
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
high
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
true
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
no
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
overcast
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
hot
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
high
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
false
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
yes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
rainy
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
mild
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
high
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
false
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
yes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
rainy
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cool
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
normal
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
false
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
yes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
rainy
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cool
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
normal
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
true
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
no
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
overcast
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cool
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
normal
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
true
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
yes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
sunny
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
mild
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
high
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
false
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
no
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
sunny
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cool
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
normal
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
false
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
yes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
rainy
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
mild
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
normal
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
false
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
yes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
sunny
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
mild
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
normal
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
true
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
yes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
overcast
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
mild
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
high
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
true
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
yes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
overcast
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
hot
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
normal
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
false
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
yes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
rainy
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
mild
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
high
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
true
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
no
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
The weather data.
 Source: 
\begin_inset CommandInset citation
LatexCommand cite
key "witten2011"
literal "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Example
If the class attribute is 
\emph on
play
\emph default
, what is the entropy of this source?
\end_layout

\begin_layout Example
\begin_inset Formula 
\begin{align*}
E\left(play\right)= & -p_{yes}\log_{2}\left(p_{yes}\right)-p_{no}\log_{2}\left(p_{no}\right)\\
= & -\frac{9}{14}\log_{2}\left(\frac{9}{14}\right)-\frac{5}{14}\log_{2}\left(\frac{5}{14}\right)\\
= & 0.94.
\end{align*}

\end_inset

 What if the Entropy-Split of the attribute 
\emph on
humidity
\emph default
?
\begin_inset Formula 
\begin{align*}
ES\left(S\implies S_{hum=high},S_{hum=normal}\right)= & \frac{\left|S_{hum=high}\right|}{\left|S\right|}E\left(play|hum=high\right)+\frac{\left|S_{hum=normal}\right|}{\left|S\right|}E\left(play|hum=normal\right)\\
= & \frac{7}{14}\left[-\frac{3}{7}\log_{2}\left(\frac{3}{7}\right)-\frac{4}{7}\log_{2}\left(\frac{4}{7}\right)\right]+\frac{7}{14}\left[-\frac{6}{7}\log_{2}\left(\frac{6}{7}\right)-\frac{1}{7}\log_{2}\left(\frac{1}{7}\right)\right]\\
= & 0.7885.
\end{align*}

\end_inset

 And the information gain?
\begin_inset Formula 
\begin{align*}
IG\left(S\implies S_{hum=high},S_{hum=normal}\right)= & E\left(play\right)-ES\left(S\implies S_{hum=high},S_{hum=normal}\right)\\
= & 0.94-0.79=0.15.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsection
ID3 Tree Induction Algorithm
\end_layout

\begin_layout Standard
ID3 is an algorithm to construct decision trees, in which the split criterion
 is the maximization of the information gain and the prunning strategy is
 to stop if all the records in a node are of the same class.
 The algorithm is more detailed in Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:ID3"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "morekeywords={if, then, is, in, return, for, Let},morecomment={[f][\color{purple}]{\#}}"
inline false
status open

\begin_layout Plain Layout

# I is the set of input attributes
\end_layout

\begin_layout Plain Layout

# O is the output attribute
\end_layout

\begin_layout Plain Layout

# T is a set of training data
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if (T is empty) then
\end_layout

\begin_layout Plain Layout

	return a single node with value 
\begin_inset Quotes eld
\end_inset

Failure
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if (all records  in T have the same value for O) then
\end_layout

\begin_layout Plain Layout

	return a single node with that value
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if (I is empty) then
\end_layout

\begin_layout Plain Layout

	return a single node with the most frequent value of O in T
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# else
\end_layout

\begin_layout Plain Layout

compute IG for each attribute in I using data in T
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Let X = argmin{IG(attr) for attr in I}
\end_layout

\begin_layout Plain Layout

Let {x_j for j=1,...,m} be the values in X
\end_layout

\begin_layout Plain Layout

Let {T_j for j=1,...,m} be the subsets of T when partitioned
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

return a tree with:
\end_layout

\begin_layout Plain Layout

	root node labelled X
\end_layout

\begin_layout Plain Layout

	arcs labelled x_1,...,x_m
\end_layout

\begin_layout Plain Layout

	connected to 
\end_layout

\begin_layout Plain Layout

	ID3(I-{X}, O, T_1),...,ID3(I-{X}, O, T_m)
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:ID3"

\end_inset

ID3(I, O, T) : Decision Tree
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Example
Compute the decision tree of the data in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "table:records_example"
plural "false"
caps "false"
noprefix "false"

\end_inset

 using ID3 algorithm.
\end_layout

\begin_layout Example

\series bold
Step 1: Root
\end_layout

\begin_layout Example
We start by computing IG for each attribute.
 To simplify notation, let 
\begin_inset Formula $P=play,\ O=outlook,\ T=temperature,\ H=humidity$
\end_inset

 and 
\begin_inset Formula $W=windy$
\end_inset

.
\end_layout

\begin_layout Example
We already know that 
\begin_inset Formula $E\left(P\right)=0.94$
\end_inset

 and 
\begin_inset Formula $IG\left(S\implies S_{H=high},S_{H=normal}\right)=0.15$
\end_inset

.
 Let's compute the rest of the values:
\begin_inset Formula 
\begin{align*}
ES\left(S\implies S_{O=sunny},S_{O=overcast},S_{O=rainy}\right)= & -\frac{5}{14}\left(\frac{3}{5}\log\frac{3}{5}+\frac{2}{5}\log\frac{2}{5}\right)\cdot2-0\\
= & 0.69.
\end{align*}

\end_inset

 Which implies that 
\begin_inset Formula $IG\left(S\implies S_{O=sunny},S_{O=overcast},S_{O=rainy}\right)=0.25$
\end_inset

.
\end_layout

\begin_layout Example
Repeating this process with temerature, we get 
\begin_inset Formula $IG\left(S\implies S_{T=hot},S_{T=mild},S_{T=cold}\right)=0.03$
\end_inset

 and with windy, we get 
\begin_inset Formula $IG\left(S\implies S_{W=True},S_{W=False}\right)=0.05$
\end_inset

.
\end_layout

\begin_layout Example
This means that we label the root node with 
\begin_inset Formula $X=O$
\end_inset

 and we create three arcs, each of them with one of the values from 
\begin_inset Formula $O$
\end_inset

.
 So we have the following Tree:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado1.png

\end_inset


\end_layout

\end_deeper
\begin_layout Example

\series bold
Step 2: Outlook=sunny
\end_layout

\begin_layout Example
Now, we are going to do the same thing, restricting ourselves to the records
 for which 
\emph on
Outlook=sunny
\emph default
.
 Now, we have to recompute the entropy and the gain for each of the rest
 of the attributes.
\end_layout

\begin_layout Example
Let's start with the entropy:
\begin_inset Formula 
\begin{align*}
E\left(P|O=sunny\right)= & -\left[\frac{3}{5}\log\frac{3}{5}+\frac{2}{3}\log\frac{2}{5}\right]=0.97.
\end{align*}

\end_inset

 Now, the Information Gain:
\begin_inset Formula 
\begin{align*}
IG\left(S_{O=sunny}\implies S_{O=sunny,H=high},S_{O=sunny,H=normal}\right)=\\
\frac{3}{5}E\left(P\land O=sunny|H=high\right)+\frac{2}{5}E\left(P\land O=sunny|H=normal\right)=\\
-\frac{3}{5}\left[\frac{3}{3}\log\frac{3}{3}+0\right]-\frac{2}{5}\left[\frac{2}{2}\log\frac{2}{2}+0\right]= & 0.
\end{align*}

\end_inset

 Which means that 
\begin_inset Formula $IG\left(S_{O=sunny}\implies S_{O=sunny,H=high},S_{O=sunny,H=normal}\right)=0.97$
\end_inset

.
 As this cannot be improved, we can savely not compute the rest of the values.
 This way, the Tree will now look as follows:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado2.png

\end_inset


\end_layout

\end_deeper
\begin_layout Example

\series bold
Step 3: Outlook=Sunny, Humidity=Normal
\end_layout

\begin_layout Example
Note that we are proceeding heightwise, but doing this breadthwise is also
 possible.
\end_layout

\begin_layout Example
This time, all the values for 
\begin_inset Formula $P$
\end_inset

 are 
\begin_inset Formula $Yes$
\end_inset

, so we enter the third 
\begin_inset Formula $if$
\end_inset

 of the algorithm and label the node as 
\begin_inset Formula $Yes$
\end_inset

.
\end_layout

\begin_layout Example

\series bold
Step 4: Outlook=Sunny, Humidity=High
\end_layout

\begin_layout Example
Same, now 
\begin_inset Formula $P=No$
\end_inset

.
\end_layout

\begin_layout Example

\series bold
Step 5: Outlook=Overcast
\end_layout

\begin_layout Example
Same, now 
\begin_inset Formula $P=Yes$
\end_inset

.
 
\end_layout

\begin_layout Example
So, now we have the following tree:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado3.png

\end_inset


\end_layout

\end_deeper
\begin_layout Example

\series bold
Step 6: Outlook=rainy
\end_layout

\begin_layout Example
\begin_inset Formula 
\[
E\left(P|O=rainy\right)=0.97
\]

\end_inset

 and 
\begin_inset Formula 
\[
IG\left(S_{O=rainy}\implies S_{O=rainy,W=True},S_{O=rainy,W=False}\right)=0.97,
\]

\end_inset

 so, again, it is maximum and we can continue using it as label:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado4.png

\end_inset


\end_layout

\end_deeper
\begin_layout Example

\series bold
Step 7: Outlook=rainy, Windy=False
\end_layout

\begin_layout Example
All records have 
\begin_inset Formula $P=Yes$
\end_inset

.
\end_layout

\begin_layout Example

\series bold
Step 8: Outlook=rainy, Windy=True
\end_layout

\begin_layout Example
All record have 
\begin_inset Formula $P=No$
\end_inset

.
\end_layout

\begin_layout Example
So, we have the tree
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado5.png

\end_inset


\end_layout

\end_deeper
\begin_layout Example
And as there are no more nodes to analyze, this is the final decision tree.
\end_layout

\begin_layout Subsubsection
The problem of UID
\begin_inset CommandInset label
LatexCommand label
name "subsec:The-problem-of"

\end_inset


\end_layout

\begin_layout Standard
In general, attributes that have very many values have very high gain, but
 can lead to useless decision trees.
 Quinlan suggest choosing the attribute with the highest
\begin_inset Formula 
\[
GainRatio\left(X,S\right)=\frac{Gain\left(X,S\implies S_{1},...,S_{r}\right)}{Entropy\left(S\right)},
\]

\end_inset

 where 
\begin_inset Formula $X$
\end_inset

 is the label attribute.
\end_layout

\begin_layout Standard
The GainRatio favores attributes with higher gain, and punishes attributes
 with high entropy (many values).
\end_layout

\begin_layout Example
Repeat the decision tree ID3 algorithm, but use GainRatio instead.
\end_layout

\begin_layout Example
The same tree is obtained.
\end_layout

\begin_layout Section
Bayesian classification
\end_layout

\begin_layout Standard

\series bold
Probabilistic classifiers
\series default
 construct a model that quantifies the relationships between the feature
 variables and the target variable as a probability.
 We are going to study a well-known kind of probabilistic classifier, namely
 the 
\series bold
Bayesian classifier
\series default
 or 
\series bold
Naive Bayes classifier
\series default
.
\end_layout

\begin_layout Subsection
Naive Bayes classifier
\end_layout

\begin_layout Standard
The 
\series bold
Bayes classifier
\series default
 is based on the Bayes' theorem for conditional probabilities.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Theorem

\series bold
Bayes' Theorem
\end_layout

\begin_layout Theorem
If A and B are probabilistic events and 
\begin_inset Formula $P\left(B\right)\neq0$
\end_inset

, then
\begin_inset Formula 
\[
P\left(A|B\right)=\frac{P\left(B|A\right)P\left(A\right)}{P\left(B\right)}.
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Proof
On one side
\begin_inset Formula 
\[
P\left(A|B\right)=\frac{P\left(A\cap B\right)}{P\left(B\right)}.
\]

\end_inset


\end_layout

\begin_layout Proof
On the other side, if 
\begin_inset Formula $P\left(A\right)\neq0$
\end_inset


\begin_inset Formula 
\[
P\left(B|A\right)=\frac{P\left(B\cap A\right)}{P\left(A\right)}\implies P\left(B\cap A\right)=P\left(B|A\right)\cdot P\left(A\right).
\]

\end_inset

 Now substituting this value in the previous equation, we get
\begin_inset Formula 
\[
P\left(A|B\right)=\frac{P\left(B|A\right)\cdot P\left(A\right)}{P\left(B\right)},
\]

\end_inset

 which is the result we wanted to proof.
\end_layout

\begin_layout Proof
If 
\begin_inset Formula $P\left(A\right)=0$
\end_inset

, then 
\begin_inset Formula $P\left(A|B\right)=0,\ \forall B$
\end_inset

, so the formula also holds.
\end_layout

\begin_layout Standard
This theorem quantifies the conditional probability of a random variable
 (the class variable), given known observations about another variables
 (the features).
 Let 
\begin_inset Formula $C$
\end_inset

 be the class variable and 
\begin_inset Formula $X$
\end_inset

 an unseen feature tuple.
 The goal of the method is to estimate
\begin_inset Formula 
\[
P\left(C=c|X=\left(a_{1},...,a_{d}\right)\right).
\]

\end_inset

Let the random variables for the individual dimensions of 
\begin_inset Formula $X$
\end_inset

 be denoted by 
\begin_inset Formula $X=\left(x_{1},...,x_{d}\right)$
\end_inset

, so we want to estimate
\begin_inset Formula 
\[
P\left(C=c|x_{1}=a_{1},...,x_{d}=a_{d}\right)\overset{Bayes}{=}\frac{P\left(C=c\right)P\left(x_{1}=a_{1},...,x_{d}=a_{d}|C=c\right)}{P\left(x_{1}=a_{1},...,x_{d}=a_{d}\right)}.
\]

\end_inset

 Here, we will be interested in maximizing this value.
 Since the denominator is the same independently of the class 
\begin_inset Formula $c$
\end_inset

, then we can focus on maximizing the denumerator
\begin_inset Formula 
\[
P\left(C=c\right)P\left(x_{1}=a_{1},...,x_{d}=a_{d}|C=c\right).
\]

\end_inset

 The value 
\begin_inset Formula $P\left(C=c\right)$
\end_inset

 is the 
\series bold
prior probability
\series default
 of the class identifier 
\begin_inset Formula $c$
\end_inset

 and can be estimated as the fraction of points in the data whose class
 is 
\begin_inset Formula $c$
\end_inset

.
 Thus, we now want to approximate the right factor.
 In the Naive Bayes approach, it is assumed that the feature values are
 independent of one another conditional on a fixed value of 
\begin_inset Formula $C$
\end_inset

.
 Then
\begin_inset Formula 
\[
P\left(x_{1}=a_{1},...,x_{d}=a_{d}|C=c\right)=\prod_{j=1}^{d}P\left(x_{j}=a_{j}|C=c\right),
\]

\end_inset

 so
\begin_inset Formula 
\[
P\left(C=c\right)P\left(x_{1}=a_{1},...,x_{d}=a_{d}|C=c\right)=P\left(C=c\right)\prod_{j=1}^{d}P\left(x_{j}=a_{j}|C=c\right).
\]

\end_inset

 And this terms are much easier to estimate: to estimate 
\begin_inset Formula $P\left(x_{j}=a_{j}|C=c\right)$
\end_inset

 we just need to take the fraction of training values with class 
\begin_inset Formula $c$
\end_inset

 and compute which fraction of them verifies 
\begin_inset Formula $x_{j}=a_{j}$
\end_inset

.
 This is usually written as
\begin_inset Formula 
\[
P\left(x_{j}=a_{j}|C=c\right)=\frac{q\left(a_{j},c\right)}{r\left(c\right)}.
\]

\end_inset


\end_layout

\begin_layout Remark
When there are not enough training samples to produce reliable estimates,
 we can use 
\series bold
Laplacian smoothing
\series default
 in which a small value 
\begin_inset Formula $\alpha$
\end_inset

 is added to the numerator and 
\begin_inset Formula $\alpha\cdot m_{j}$
\end_inset

 is added to the denominator, where 
\begin_inset Formula $m_{j}$
\end_inset

 is the number of distinct values of the 
\begin_inset Formula $j^{th}$
\end_inset

 attribute
\begin_inset Formula 
\[
P\left(x_{j}=a_{j}|C=c\right)=\frac{q\left(a_{j},c\right)+\alpha}{r\left(c\right)+\alpha\cdot m_{j}}.
\]

\end_inset

 
\begin_inset Formula $\alpha$
\end_inset

 is called the 
\series bold
Laplacian smoothing parameter
\series default
.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
If a feature is continuous, then the likelihood is computed using a Gaussian
 distribution with mean 
\begin_inset Formula $\mu$
\end_inset

 and standard deviation 
\begin_inset Formula $\sigma$
\end_inset

:
\begin_inset Formula 
\[
P\left(x_{j}=a_{j}|C=c\right)=g\left(a_{j},\mu_{c},\sigma_{c}\right)=\frac{1}{\sqrt{2\pi}\sigma_{c}}e^{-\frac{\left(a_{j}-\mu_{c}\right)^{2}}{2\sigma_{c}^{2}}}.
\]

\end_inset


\end_layout

\begin_layout Standard
This model is sometimes refererd to as the 
\series bold
Bernoully model for Bayes classification
\series default
 when it is applied to categorical data with only two outcomes of each feature
 attribute.
\end_layout

\begin_layout Standard
In cases where more than two outcomes are possible for a feature variable,
 the model is referred to as the 
\series bold
generalized Bernoulli model
\series default
.
\end_layout

\begin_layout Example
With the following training data:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="15" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Age
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Income
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Student
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Credit_Rating
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Buys
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\leq30$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
high
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
no
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
fair
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
no
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\leq30$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
high
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
no
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
excellent
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
no
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $31..40$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
high
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
no
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
fair
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
yes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $>40$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
medium
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
no
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
fair
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
yes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $>40$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
low
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
fair
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
yes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $>40$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
low
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
excellent
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
no
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $31..40$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
low
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
excellent
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
yes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\leq30$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
medium
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
no
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
fair
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
no
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\leq30$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
low
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
fair
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
yes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $>40$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
medium
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
fair
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
yes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\leq30$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
medium
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
excellent
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
yes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $31..40$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
medium
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
no
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
excellent
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
yes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $31..40$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
high
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
fair
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
yes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $>40$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
medium
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
no
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
excellent
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
no
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Example
Classify with the Naive Bayes model the unseen record
\begin_inset Formula 
\[
X=\left(\leq30,medium,yes,fair\right).
\]

\end_inset

 In this case, we have 
\begin_inset Formula $C\in\left\{ yes,no\right\} $
\end_inset

, so
\begin_inset Formula 
\[
P\left(C=yes\right)=\frac{9}{14},\qquad P\left(C=no\right)=\frac{5}{14}.
\]

\end_inset

 And for the feature variables, we have to compute 
\begin_inset Formula $P\left(x_{i}=a_{i}|C=yes\right)$
\end_inset

 and 
\begin_inset Formula $P\left(x_{i}=a_{i}|C=no\right)$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Itemize
Age 
\begin_inset Formula $\leq30$
\end_inset

:
\begin_inset Formula 
\[
P\left(\leq30|yes\right)=\frac{2}{9},\qquad P\left(\leq30|no\right)=\frac{3}{5}.
\]

\end_inset


\end_layout

\begin_layout Itemize
Income medium:
\begin_inset Formula 
\[
P\left(medium|yes\right)=\frac{4}{9},\qquad P\left(medium|no\right)=\frac{2}{5}.
\]

\end_inset


\end_layout

\begin_layout Itemize
Student yes:
\begin_inset Formula 
\[
P\left(yes|yes\right)=\frac{6}{9},\qquad P\left(yes|no\right)=\frac{1}{5}.
\]

\end_inset


\end_layout

\begin_layout Itemize
Credit_rating fair:
\begin_inset Formula 
\[
P\left(fair|yes\right)=\frac{6}{9},\qquad P\left(fair|no\right)=\frac{2}{5}.
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Example
Then, we have
\begin_inset Formula 
\[
P\left(C=yes\right)\cdot P\left(\leq30,medium,yes,fair|C=yes\right)=P\left(C=yes\right)\cdot\prod P\left(X_{i}|C=yes\right)=\frac{9}{14}\cdot\frac{2}{9}\frac{4}{9}\frac{6}{9}\frac{6}{9}=\frac{16}{567}\sim0.028,
\]

\end_inset


\begin_inset Formula 
\[
P\left(C=no\right)\cdot P\left(\leq30,medium,yes,fair|C=no\right)=\frac{5}{14}\cdot\frac{3}{5}\frac{2}{5}\frac{1}{5}\frac{2}{5}=\frac{6}{875}\sim0.007.
\]

\end_inset

 Thus, the model classifies 
\begin_inset Formula $X$
\end_inset

 with class 'yes'.
\end_layout

\begin_layout Subsubsection*
Some final comments
\end_layout

\begin_layout Standard
The 
\series bold
advantages
\series default
 of the Bayes Classifier is that it is easy to implement and can lead to
 fairly good results.
\end_layout

\begin_layout Standard
The 
\series bold
drawbacks
\series default
 are that the main assumption of class conditional independence is not very
 trustable, which may lead to a loss of accuracy, because dependencies axist
 among variables.
 To deal with this issue there is a more complex model: 
\series bold
Bayesian Belief Networks
\series default
.
\end_layout

\begin_layout Section
Model evaluation and selection
\end_layout

\begin_layout Standard
With a given dataset, we can train multiple classification models and each
 of them will behave differently, many times without an intuitive explanation
 of the differences observed.
 Thus, it becomes crucial to establish means of comparison between different
 models, so it is possible to choose between several models trained with
 the same data.
\end_layout

\begin_layout Standard
The simplest classification measure is the 
\series bold
accuracy
\series default
, which indicates the portion of well classified records.
 Nonetheless, if we compute the accuracy using the training data, we could
 be enhance overfitting to the training data, and maybe choose models that
 do not work well with unseen data.
 This is why it is usual to use a 
\series bold
validation test set
\series default
 to compute comparison measures: the idea is that given a dataset, we can
 divide it into training data and test data.
 Then, models will be trained using the training data and evaluated with
 the test data, which has not been seen before.
 This makes the measures more reliable and the comparisons more fair.
\end_layout

\begin_layout Standard
There are several ways to extract training and test data from a dataset,
 which are detailed in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Model-evaluation"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Subsection
Confusion Matrix
\end_layout

\begin_layout Standard
A confusion matrix is a visual and intuitive way to assess a classification
 algorithm.
 In its simplest form it is used to assess a binary classification model
 and it shows the following metrics:
\end_layout

\begin_layout Itemize

\series bold
True Positives
\series default
: count of records classified as True that are actually True.
\end_layout

\begin_layout Itemize

\series bold
False Positives
\series default
: count of records classified as True that were False in reality.
\end_layout

\begin_layout Itemize

\series bold
True Negatives
\series default
: count of records classified as False that were actually False.
\end_layout

\begin_layout Itemize

\series bold
False Negatives
\series default
: count of records classified as False that were True in reality.
\end_layout

\begin_layout Standard
In this case, the confusion matrix has the form:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Predicted True
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Predicted False
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Actual True
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
TP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FN
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Actual False
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
TN
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
In the more general case in which we have a 
\begin_inset Formula $N$
\end_inset

-class classifier, each cell 
\begin_inset Formula $M_{ij}$
\end_inset

 would have the count of records classified as class 
\begin_inset Formula $j$
\end_inset

 that are of class 
\begin_inset Formula $i$
\end_inset

 in reality:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Predicted 
\begin_inset Formula $C_{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Predicted 
\begin_inset Formula $C_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Predicted 
\begin_inset Formula $C_{N}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Actual 
\begin_inset Formula $C_{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $TC_{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $FC_{2,1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $FC_{N,1}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Actual 
\begin_inset Formula $C_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $FC_{1,2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $TC_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $FC_{N,2}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vdots$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vdots$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vdots$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\ddots$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vdots$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Actual 
\begin_inset Formula $C_{N}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $FC_{1,N}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $FC_{2,N}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $TC_{N}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
From these confusion matrices, we can derive some interesting measures:
\end_layout

\begin_layout Itemize

\series bold
Accuracy
\series default
: the accuracy can be computed from the matrix as
\begin_inset Formula 
\[
Acc=\frac{TP+TN}{All}.
\]

\end_inset


\end_layout

\begin_layout Itemize

\series bold
Error rate
\series default
: the reverse of the accuracy:
\begin_inset Formula 
\[
ER=1-Acc=\frac{FP+FN}{All}.
\]

\end_inset


\end_layout

\begin_layout Itemize

\series bold
Class imbalance measures
\series default
: sometimes, one class appears in a little amount of records (this is specially
 common in disease detection, for example), and is usually the case to have
 the focus on being able to correctly detect this rare cases.
\end_layout

\begin_deeper
\begin_layout Example
As an example, imagine we are trying to detect fraudulent transactions in
 a banking context.
 Out of thousands of transactions, only a very few amount would be fraudulent.
 Say there are 1M records for training and only 100 are known to be fraudulent.
 If we predict all records as OK, we would get 
\begin_inset Formula $\frac{999\ 900}{10^{6}}=99.99\%$
\end_inset

 accuracy, but we will not detect any fraud! So the accuracy is stunning
 but the model is useless.
\end_layout

\begin_layout Standard
For example like this the following measures have a motive:
\end_layout

\begin_layout Itemize

\series bold
Sensitivity
\series default
: focuses on correctly detecting True outcomes
\begin_inset Formula 
\[
Sens=\frac{TP}{Actual\ True}.
\]

\end_inset


\end_layout

\begin_layout Itemize

\series bold
Specificity
\series default
: focuses on correctly detecting False outcomes
\begin_inset Formula 
\[
Spec=\frac{TN}{Actual\ False}.
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Precision
\series default
: how many records labeled as True are actually True
\begin_inset Formula 
\[
Prec=\frac{TP}{TP+FP}.
\]

\end_inset


\end_layout

\begin_layout Itemize

\series bold
Recall
\series default
: a synonym of sensitivity.
\end_layout

\begin_layout Itemize

\series bold
F-score
\series default
: the harmonic mean of the precision and recall
\begin_inset Formula 
\[
F=\frac{2\cdot precision\cdot recall}{precision+recall}.
\]

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\boldsymbol{F_{\beta}}$
\end_inset

: weighted measure of precision and recall.
 Assigns 
\begin_inset Formula $\beta$
\end_inset

 times as much weight to recall as to precision
\begin_inset Formula 
\[
F_{\beta}=\frac{\left(1+\beta^{2}\right)\cdot precision\cdot recall}{\beta^{2}precision+recall}.
\]

\end_inset


\end_layout

\begin_layout Section
Ensemble methods: increasing accuracy
\end_layout

\begin_layout Standard
An 
\series bold
ensemble method
\series default
 for classification is a composite model, made up of a combination of classifier
s.
 The idea is that given an unseen record, it can be classified using several
 models, and then make a consensus between all of them to decide the final
 decision of the class of the record.
 Usually, a voting scheme is used, in which the most voted class is the
 chosen one for classification.
 This approach usually improves the accuracy of each component.
\end_layout

\begin_layout Standard
Let's analyze why this works! There are three primary primary components
 to the error of a classifier:
\end_layout

\begin_layout Enumerate

\series bold
Bias
\series default
: every classifier has its own assumptions about the nature of the decision
 boundary between classes.
 When a classifier has high bias, it will make consistently incorrect prediction
s over records that lie near the incorrectly-modeled decision boundary.
\end_layout

\begin_deeper
\begin_layout Example
Bias is shown below.
 
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado11.png
	scale 60

\end_inset


\end_layout

\end_deeper
\begin_layout Example
The real model has been generated using the blue line.
 The classification model has the assumption that the data can be classified
 using a straight line.
 As we can see, points near to the boundary would be missclassified.
 
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Variance
\series default
: random variations in the choices of the traiing data will lead to different
 models.
 This is closely related to overfitting.
 When a classifier has an overfitting tendency, it will make inconsistent
 predictions for the same test instance oevr different training data sets.
\end_layout

\begin_deeper
\begin_layout Example
Variance is shown below.
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado12.png
	scale 60

\end_inset


\end_layout

\end_deeper
\begin_layout Example
In this case, the yellow-ish model happen to have used few red points near
 the boundary, so it became a perfect blue classifier, but a bad red classifier.
 The opposite happened to the blue-ish model.
 Note that this variations are only due to random selection of the training
 points.
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Noise
\series default
: it is the intrinsic errors in the target class labeling.
 As this is intrinsic, there is not much one can do.
 Therefore, we will focus in the two latter sources of error.
\end_layout

\begin_layout Standard
In addition, bias and variance are often in a trade-off relationship: improving
 bias worsens variance, and vice-versa.
 Generally speaking, simplified assumptions about the decision boundary
 lead to greater bias but lower variance, while complex assumptions reduce
 bias but are harder to robustly estimate with limited data.
\end_layout

\begin_layout Standard
Ensemble analysis can often be used to reduce both the bias and variance
 of the classification process, because a combination of different simple
 models with high bias and little variance will reduce the bias as the assumptio
ns will be combined to model more complex scenarios.
 On the other hand, a combination of complex models with low bias and high
 variance, will reduce the variance because decisions made by multiple models
 tend to be more consistent than those made by individual models.
\end_layout

\begin_layout Subsubsection*
Looking at the accuracy
\end_layout

\begin_layout Standard
Now, let's look at the accuracy of the ensemble model in comparison to its
 component models in the case of binary classification (for ease).
 Let's say the ensemble model is composed of 
\begin_inset Formula $N$
\end_inset

 models, each of them with an accuracy 
\begin_inset Formula $acc_{i}$
\end_inset

.
 Then, for the ensemble model to classify a new record as correct, at least
 half of the models need to classify the tuple correctly.
 Let's define the random variable 
\begin_inset Formula $X$
\end_inset

 as '
\emph on
number of classifiers that classify the tuple as correct
\emph default
', then
\begin_inset Formula 
\[
P\left(correct\right)=P\left(X\geq\frac{N}{2}\right)=1-P\left(X<\frac{N}{2}\right),
\]

\end_inset

 and we can decompose
\begin_inset Formula 
\[
P\left(X<\frac{N}{2}\right)=P\left(X=1\right)+P\left(X=2\right)+...+P\left(X=\frac{N}{2}-1\right).
\]

\end_inset


\end_layout

\begin_layout Standard
Here, assuming independence of the different models, it is
\begin_inset Formula 
\[
P\left(X=1\right)=\sum_{i}acc_{i}\times\prod_{j\neq i}\left(1-acc_{j}\right),
\]

\end_inset


\begin_inset Formula 
\[
P\left(X=2\right)=\sum_{i}\sum_{j\neq i}acc_{i}\times acc_{j}\times\prod_{k\neq i,j}\left(1-acc_{k}\right),
\]

\end_inset

 and so on.
 This yields to a complex formula, but when the case is the simplest in
 which 
\begin_inset Formula $A=acc_{i}=acc_{j},\forall i,j$
\end_inset

, we are in a binomial distribution, having
\begin_inset Formula 
\[
P\left(X=k\right)=\binom{N}{k}A^{k}\left(1-A\right)^{N-k}.
\]

\end_inset

 
\end_layout

\begin_layout Example
Suppose an ensemble model with 
\begin_inset Formula $N=3$
\end_inset

 and equal accuracy for the three models, 
\begin_inset Formula $A>0$
\end_inset

.
 Then, the accuracy for the ensemble model is
\begin_inset Formula 
\[
Acc=P\left(correct\right)=1-P\left(X=1\right)=1-3A\left(1-A\right)^{2},
\]

\end_inset

 which can be compared with the individual accuracies:
\begin_inset Formula 
\[
Acc-A=1-3A\left(1-A\right)^{2}-A=-3A\left(1-A\right)^{2}+1-A=\left(1-A\right)\left[1-3A\left(1-A\right)\right].
\]

\end_inset

 At this point, the accuracy will be increased whenever
\begin_inset Formula 
\[
1-3A\left(1-A\right)>0\iff3A^{2}-3A+1>0.
\]

\end_inset

 The discriminant of this polynomial is 
\begin_inset Formula 
\[
b^{2}-4ac=9-12=-3<0,
\]

\end_inset

 so all its solutions are complex and it does not cut the X axis.
 As the leading coefficient is positive, this polynomial is always positive
 and we conclude that the 3-ensemble method always improves the accuracy
 of the individual models.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Example
Suppose an ensemble model with 
\begin_inset Formula $N=5$
\end_inset

 and equal accuracy for the three models, 
\begin_inset Formula $A>0$
\end_inset

.
 Then, the accuracy for the ensemble model is
\begin_inset Formula 
\begin{align*}
Acc=1-P\left(X=1\right)-P\left(X=2\right) & =1-5\cdot A\left(1-A\right)^{4}-\frac{5!}{2!3!}A^{2}\left(1-A\right)^{3}\\
 & =1-5A\left(1-A\right)^{4}-10A^{2}\left(1-A\right)^{3},
\end{align*}

\end_inset

 and when compared to the individual values we obtain
\begin_inset Formula 
\begin{align*}
Acc-A & =1-5A\left(1-A\right)^{4}-10A^{2}\left(1-A\right)^{3}-A\\
 & =\left(1-A\right)\left[1-5A\left(1-A\right)^{3}-10A^{2}\left(1-A\right)^{2}\right].
\end{align*}

\end_inset

 This is an increased accuracy whenever
\begin_inset Formula 
\[
1-5A\left(1-A\right)^{3}-10A^{2}\left(1-A\right)^{2}>0,
\]

\end_inset

 which corresponds to the polynomial
\begin_inset Formula 
\[
-5A^{4}+5A^{3}+5A^{2}-5A+1>0.
\]

\end_inset

 The graph of this polynomial is 
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado13.png
	scale 60

\end_inset


\end_layout

\end_deeper
\begin_layout Example
So for 
\begin_inset Formula $A\in\left(0,1\right)$
\end_inset

 it is positive everywhere except the interval 
\begin_inset Formula $\left(0.354,0.423\right)$
\end_inset

, in which it is negative.
 This means that the accuracy is improved in all cases outside this interval.
\end_layout

\begin_layout Example
For example, if 
\begin_inset Formula $A=0.7$
\end_inset

, then 
\begin_inset Formula $Acc=0.839$
\end_inset

, which is indeed an improvement.
\end_layout

\begin_layout Standard
There are several ways to make ensemble methods:
\end_layout

\begin_layout Enumerate

\series bold
Bagging
\series default
: the data is bootstrapped 
\begin_inset Formula $N$
\end_inset

 times, collecting a training data set of approximately the same size of
 the original data set for each model.
 Then, each model is trained with a different bootstrap.
\end_layout

\begin_deeper
\begin_layout Standard
This approach reduces the variance, because the differences owed to the
 sampling are reduced by performing this sampling 
\begin_inset Formula $N$
\end_inset

 times.
 However, bagging does not improve the bias, because all the models used
 have the same assumptions.
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Boosting
\series default
: a weight is associated with each training instance and the 
\begin_inset Formula $N$
\end_inset

 classifiers are trained with the use of these weights.
 When the classifier 
\begin_inset Formula $M_{i}$
\end_inset

 has finished its training, those records in which the model missclassify
 are increased in weight, so the next model 
\begin_inset Formula $M_{i+1}$
\end_inset

 will be trained paying more attention to those records.
\end_layout

\begin_deeper
\begin_layout Standard
With this approach, the overall bias is reduced because each model focuses
 on those places where the past models tend to fail.
 
\end_layout

\begin_layout Enumerate

\series bold
Adaboost
\series default
: a particular algorithm approach based on the boosting idea.
 Given a dataset, 
\begin_inset Formula $\mathcal{D}$
\end_inset

, of 
\begin_inset Formula $k$
\end_inset

 records with label 
\begin_inset Formula $y_{i}$
\end_inset

, 
\begin_inset Formula $\left(X_{1},y_{1}\right),...,\left(X_{k},y_{k}\right)$
\end_inset

 :
\end_layout

\begin_deeper
\begin_layout Enumerate
Set initial weights to 
\begin_inset Formula $w_{i}=\frac{1}{k},\ \forall i=1,...,k$
\end_inset

.
\end_layout

\begin_layout Enumerate
j = 1
\end_layout

\begin_layout Enumerate
While j<N
\end_layout

\begin_deeper
\begin_layout Enumerate
Bootstrap 
\begin_inset Formula $\mathcal{D}$
\end_inset

 to get a training set 
\begin_inset Formula $\mathcal{T}_{j}$
\end_inset

, select tuples with probability 
\begin_inset Formula $w_{i}$
\end_inset

.
\end_layout

\begin_layout Enumerate
Train model 
\begin_inset Formula $M_{j}$
\end_inset

 with 
\begin_inset Formula $\mathcal{T}_{j}$
\end_inset

.
\end_layout

\begin_layout Enumerate
Compute the error rate of 
\begin_inset Formula $M_{j}$
\end_inset

 using 
\begin_inset Formula $\mathcal{D}$
\end_inset

.
\end_layout

\begin_layout Enumerate
Update the weigths
\end_layout

\begin_deeper
\begin_layout Enumerate
If a tuple is misclassified: increase its weight
\end_layout

\begin_layout Enumerate
If it is correctly classified: decrease its weight
\end_layout

\end_deeper
\begin_layout Enumerate
j = j+1
\end_layout

\end_deeper
\begin_layout Standard
The error rate with weights is computed as
\begin_inset Formula 
\[
ER\left(M_{j}\right)=\sum_{i=1}^{d}w_{i}\cdot error\left(M_{j},X_{i}\right),
\]

\end_inset

 where 
\begin_inset Formula $error\left(M,X\right)=\begin{cases}
0 & if\ M\ classifies\ X\ correctly\\
1 & if\ M\ misclassifies\ X
\end{cases}$
\end_inset

.
\end_layout

\begin_layout Standard
When the voting is performed, the votes are also weighted, with
\begin_inset Formula 
\[
w\left(M_{i}\right)=\log\frac{1-ER\left(M_{i}\right)}{ER\left(M_{i}\right)}.
\]

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate

\series bold
Random Forest
\series default
: bagging does not work very well combined with decision trees, because
 the ID3 algorithm tends to generate similar/correlated trees.
 The idea here is to add randomness to the tree induction algorithm itself,
 as follows:
\end_layout

\begin_deeper
\begin_layout Enumerate
Before each split, 
\begin_inset Formula $L$
\end_inset

 attributes are randomly selected out of the available 
\begin_inset Formula $K$
\end_inset

 attributes.
\end_layout

\begin_layout Enumerate
The split attribute is selected from this group of 
\begin_inset Formula $L$
\end_inset

 attributes.
\end_layout

\begin_layout Standard
When 
\begin_inset Formula $L$
\end_inset

 is selecte
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Model validation and data preparation
\end_layout

\begin_layout Section
Data preparation
\end_layout

\begin_layout Standard
The 
\series bold
data preparation phase
\series default
 is a multistage process that comprises several individual steps, some or
 all of which may be used in a given application.
 These steps are:
\end_layout

\begin_layout Enumerate

\series bold
Feature extraction and portability
\series default
: a 
\series bold
feature
\series default
 is characteristic of the data or derived from the data.
 For example, if we have a sensor measuring humidity, the level of humidity
 will be a feature directly present in the data; the difference between
 the humidity level at each measure and the average humidity level is a
 derived feature.
\end_layout

\begin_deeper
\begin_layout Standard
Features with good semantic interpretability are more desirable because
 this makes things easier for the analyst to understand results.
 So, the process of selecting which features to take into account for further
 analysis is called 
\series bold
feature extraction
\series default
.
\end_layout

\begin_layout Standard

\series bold
Data type portability
\series default
 refers to the process of transforming data into different formats.
 This could have several reasons behind: we could do this because we have
 several sources of data which we want to unify or because we use an internal
 datatype that will not be compatible with what the training algorithms
 expect.
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Data cleaning
\series default
: missing, erroneus and inconsistent entries are treated.
 We can either remove them or estimate them via the process of 
\series bold
imputation
\series default
.
\end_layout

\begin_layout Enumerate

\series bold
Data reduction, selection and transformation
\series default
: the size of the data is reduced through data subset selection, feature
 subset selection, or data transformation.
 This helps in two ways:
\end_layout

\begin_deeper
\begin_layout Enumerate
The algorithms perform more efficiently in smaller datasets.
\end_layout

\begin_layout Enumerate
The removal of irrelevant features or records improves the quality of the
 data mining process.
\end_layout

\end_deeper
\begin_layout Subsection
Feature extraction
\end_layout

\begin_layout Example

\series bold
Image feature extraction
\end_layout

\begin_layout Example
Image data are represented as pixel.
 Nonetheless, we know that pixels are related between each others and that
 combinations of pixels carry information about what we are seeing in the
 image.
 This is not straighforward for a computer to understand, as the computer
 only 'sees' a matrix of triplets.
\end_layout

\begin_layout Example
At a higher level, 
\series bold
color histograms
\series default
 can be used to represent the features in different segments of an image.
\end_layout

\begin_layout Example
Also, 
\series bold
visual words
\series default
 are used to extract features from images.
 A visual word is a semantically rich representation of parts of an image.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Example

\series bold
Document feature extraction
\end_layout

\begin_layout Example
Document data is often available in raw and unstructured form, and the data
 may contain rich linguistic relations between different entities.
 
\end_layout

\begin_layout Example
One approach is to remove stop words, stem the data, and use bag-of-words
 representation.
\end_layout

\begin_layout Example
Other methods use entity extraction to determine linguistic relationships.
 
\end_layout

\begin_layout Example

\series bold
Named-entity
\series default
 
\series bold
recognition
\series default
 is an important subtask of information extraction.
 It consists in locating and classifying atomic elements in text into predefined
 expressions of names of persons, organizations,...
\end_layout

\begin_layout Subsection
Data Type Portability
\end_layout

\begin_layout Itemize

\series bold
Numerical to categorizal data: discretizacion
\end_layout

\begin_deeper
\begin_layout Standard
The process of discretization divides the ranges of the numeric attribute
 into 
\begin_inset Formula $m$
\end_inset

 ranges.
 Then, the attribute is assumed to contain 
\begin_inset Formula $m$
\end_inset

 different categorical labeled values from 1 to 
\begin_inset Formula $m$
\end_inset

.
\end_layout

\begin_layout Standard
Variations within a range are not ditinguishable after discretization (some
 information is lost).
\end_layout

\begin_layout Standard
One challenge is that data may be nonuniformly distributed across the different
 intervals.
 Thus, there are several ways to perform the division:
\end_layout

\begin_layout Itemize

\series bold
Equi-width ranges
\series default
: the interval is divided into 
\begin_inset Formula $m$
\end_inset

 subintervals of equal length.
\end_layout

\begin_layout Itemize

\series bold
Equi-log ranges
\series default
: the interval is divided in such a way that the log-length is constant.
 If we want to divide the interval 
\begin_inset Formula $\left[a,b\right]$
\end_inset

 into 
\begin_inset Formula $m$
\end_inset

 equi-log ranges 
\begin_inset Formula $\left\{ \left[a_{i},b_{i}\right]\right\} _{i=1}^{m}$
\end_inset

, we have to ensure that
\begin_inset Formula 
\[
\log\left(b_{i}\right)-\log\left(a_{i}\right)=\log\left(b_{j}\right)-\log\left(a_{j}\right),\ \forall i,j=1,...,m
\]

\end_inset


\end_layout

\begin_layout Itemize

\series bold
Equi-depth ranges
\series default
: the ranges are selected so that each range has an equal number of records.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Categorical to numeric data: binarization
\end_layout

\begin_deeper
\begin_layout Standard
Suppose a categorical attribute with 
\begin_inset Formula $m$
\end_inset

 different values.
 Then, we can binarize it by creating 
\begin_inset Formula $m$
\end_inset

 attributes, and the record will have all of them set to 0, except the one
 corresponding to the value that it has, which will be set to 1.
 For example:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Role
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pedro
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CEO
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\implies$
\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Role:CEO
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Role:Employee
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Role:Director
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pedro
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Text to numeric data: Latent Semantic Analysis (LSA)
\end_layout

\begin_deeper
\begin_layout Standard
LSA transforms the text collection to a nonsparse representation with lower
 dimensionality.
 After transformation, each document 
\begin_inset Formula $X=\left(x_{1},...,x_{d}\right)$
\end_inset

 needs to be scaled to
\begin_inset Formula 
\[
\frac{1}{\sqrt{\sum_{i=1}^{d}x_{i}²}}\left(x_{1},...,x_{d}\right).
\]

\end_inset

 This is necessary to ensure that documents of varying length are treated
 in uniform way.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Time series to Discrete Sequence Data: Symbolic Aggregate Approximation
 (SAX)
\end_layout

\begin_deeper
\begin_layout Standard
Two steps:
\end_layout

\begin_layout Itemize

\series bold
Window-based averaging: 
\series default
the series is divided into windows of length 
\begin_inset Formula $w$
\end_inset

, and the average time-series value over each window is computed.
\end_layout

\begin_layout Itemize

\series bold
Value-based discretization:
\series default
 the averaged time-series values are discretized into a smaller number of
 equi-depth intervals.
 
\series bold
Idea
\series default
: ensure that each symbol has an approximately equal frequency in the time-serie
s.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Time series to Numeric Data: 
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
Discrete Wavelet Transform (DWT)
\series default
: converts the time series data to multidimensional data, as a set of coefficien
ts that represent averaged differences between different portions of the
 series.
\end_layout

\begin_layout Itemize

\series bold
Discrete Fourier Transform (DFT)
\series default
: similar, using Fourier series' theory.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Discrete Sequence to Numeric Data:
\end_layout

\begin_deeper
\begin_layout Standard
Two steps:
\end_layout

\begin_layout Itemize
Convert the discrete sequence to a set of binary time series, with as many
 time series as the number of values the discrete sequence can take.
\end_layout

\begin_layout Itemize
H each of these time series into a multidimensional vector using the DWT.
 This combines the features from the different series, creating a single
 multidimensional record.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Spatial to Numeric Data:
\end_layout

\begin_deeper
\begin_layout Standard
The approach is the same as the one used for time-series data, but now there
 are two contextual attributes instead of one, so the DWT has to be modified
 to be two-dimensional.
\end_layout

\end_deeper
\begin_layout Subsection
Data Cleaning
\end_layout

\begin_layout Standard
Data in the real world is
\end_layout

\begin_layout Itemize

\series bold
incomplete
\series default
: there are values for some attributes that are missing.
 This can happen because some measures were not always taken of because
 of human/computer errors.
\end_layout

\begin_layout Itemize

\series bold
noisy
\series default
: there are errors.
 This can happen because the instruments used to collect data are not working
 properly, because errors in the data transmission occur or because of human/com
puter errors.
\end_layout

\begin_layout Itemize

\series bold
inconsistent
\series default
: there are discrepancies between different attributes that are related.
 This can happen when data from different sources needs to be combined or
 when some calculated values are not updated after changing their source
 values.
\end_layout

\begin_layout Itemize

\series bold
duplicate
\series default
: there are duplicate values.
\end_layout

\begin_layout Subsubsection
Handling Missing and Inconsistent entries
\end_layout

\begin_layout Standard
We can:
\end_layout

\begin_layout Itemize
Delete the entire record: this is a safe option, because we don't introduce
 bias, but it usually not practical, because we might delete too many entries.
\end_layout

\begin_layout Itemize
Impute/estimate the missing values: we use the rest of the data to estimate
 the values that are missing or choose some constant based on some assumption.
 The problem with this approach is that one way or another we are introducing
 bias in the data.
\end_layout

\begin_layout Itemize
Change the mining algorithm: there are some algorithms that are developed
 to deal with missing values.
\end_layout

\begin_layout Subsubsection
Handling Noisy entries
\end_layout

\begin_layout Standard
We can:
\end_layout

\begin_layout Itemize
Perform kernel smoothing: for numerical data, we can use a kernel function
 to smooth the data values.
\end_layout

\begin_deeper
\begin_layout Itemize
kNN smoother: replaces each value with the average of itself and its k-nearest
 neighbors.
\end_layout

\begin_layout Itemize
kernel average smoother: replace a value with the weighted average of itself
 and its neighbors in a fixed size window.
\end_layout

\end_deeper
\begin_layout Itemize
Binning: it is also possible to sort the data and partition it into equally
 sized bins.
 Then, the data can be smoothed by the bin mean, median or boundary values.
\end_layout

\begin_layout Itemize
Regression: smooth by fitting the data to a regression function.
\end_layout

\begin_layout Itemize
Change the mining algorithm: there are algorithms designed to tolerate noise.
\end_layout

\begin_layout Subsection
Exploratory analysis
\end_layout

\begin_layout Standard
Exploratory analysis is the task to understand the data, from the meaning
 of the features, to their range of values or even their statistical distributio
ns.
 There are many actions we can do to explore the data, such as counting
 nulls, searching for repetition, compute some statistics as the maximum,
 the minimum, the mean,...
 of the data, and many more.
\end_layout

\begin_layout Subsubsection
Central tendency measures
\end_layout

\begin_layout Standard
Central tendency measures are a 1 number summary that can be helpful:
\end_layout

\begin_layout Itemize
Mean:
\begin_inset Formula 
\[
\overline{X}=\frac{\sum X_{_{i}}}{N}.
\]

\end_inset


\end_layout

\begin_layout Itemize
Weighted mean:
\begin_inset Formula 
\[
\tilde{X}=\frac{\sum w_{i}X_{i}}{\sum w_{i}}.
\]

\end_inset


\end_layout

\begin_layout Itemize
Trimmed mean: a mean calculated disregarding extreme values.
\end_layout

\begin_layout Itemize
Median: the middle value of the data.
\end_layout

\begin_layout Itemize
Mode: value that occurs most frequently in the data.
\end_layout

\begin_layout Subsubsection
Symmetric and Skewed data
\end_layout

\begin_layout Standard
Using the mean, median and mode, we can understand in a soft way the distributio
n of the data:
\end_layout

\begin_layout Itemize
If the three values are very similar, then the distribution is very symmetric,
 having this values in the center.
\end_layout

\begin_layout Itemize
If the order is 
\begin_inset Formula 
\[
Mode<Median<Mean,
\]

\end_inset

 then the distribution is skewed to the left.
\end_layout

\begin_layout Itemize
If the order is
\begin_inset Formula 
\[
Mean<Median<Mode,
\]

\end_inset

 then the distribution is skewed to the right.
\end_layout

\begin_layout Subsubsection
Measuring the dispersion
\end_layout

\begin_layout Itemize
Quartiles: the Q1 (25th percentile) and Q3 (75th) percentile.
\end_layout

\begin_layout Itemize
Inter-quartile range:
\begin_inset Formula 
\[
IQR=Q_{3}-Q_{1}
\]

\end_inset


\end_layout

\begin_layout Itemize
Five number summary: minimum, Q1, median, Q3, maximum.
\end_layout

\begin_layout Itemize
Boxplot: the median is marked and there is a box around it which ends in
 the queartiles.
 Outliers are plotted individually.
\end_layout

\begin_layout Itemize
Outlier: a value that lies outside the range 
\begin_inset Formula $1.5\times IQR$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Comparing with the normal distribution
\end_layout

\begin_layout Standard
We can compute the mean 
\begin_inset Formula $\mu$
\end_inset

 and the standard deviation 
\begin_inset Formula $\sigma$
\end_inset

 and check if the data behaves as a normal distribution:
\end_layout

\begin_layout Itemize
In 
\begin_inset Formula $\left(\mu-\sigma,\mu+\sigma\right)$
\end_inset

 there is about 68% of the data.
\end_layout

\begin_layout Itemize
In 
\begin_inset Formula $\left(\mu-2\sigma,\mu+2\sigma\right)$
\end_inset

 there is about 96% of the data.
\end_layout

\begin_layout Itemize
In 
\begin_inset Formula $\left(\mu-3\sigma,\mu+3\sigma\right)$
\end_inset

 there is about 99.7% of the data.
\end_layout

\begin_layout Standard
We can also perform the Kolmogorov-Smirnov test or the Shapiro-Wilk test,
 which are statistical test that try to assess is a distribution is normal.
\end_layout

\begin_layout Subsection
Similarity and Distance
\end_layout

\begin_layout Standard
There are many data mining algorithms which uses the notions of similarity
 or distance between two points.
 Usually, the selection of the distance function is an important decision
 before using an algorithm, because it will ultimately influence the results
 and their implications.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
The 
\begin_inset Formula $\boldsymbol{L_{p}}$
\end_inset


\series bold
-norm
\series default
 is a distance function defined by
\begin_inset Formula 
\[
Dist\left(X,Y\right)=\left(\sum_{i=1}^{d}\left|X_{i}-Y_{i}\right|^{p}\right)^{\frac{1}{p}}.
\]

\end_inset


\end_layout

\begin_layout Definition
For 
\begin_inset Formula $p=2$
\end_inset

 it is the well-known Euclidean distance.
\end_layout

\begin_layout Definition
For 
\begin_inset Formula $p=1$
\end_inset

 it is called the Manhattan distance, because it is like traversing a grid
 made of rectangles, similar to the streetmap of Manhattan.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
The 
\series bold
generalized Minkowski distance
\series default
 is defined by
\begin_inset Formula 
\[
Dist\left(X,Y\right)=\left(\sum_{i=1}^{d}a_{i}\cdot\left|X_{i}-Y_{i}\right|^{p}\right)^{\frac{1}{p}}.
\]

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Remark
As we can see Minkowski is a weighted 
\begin_inset Formula $L_{p}$
\end_inset

-norm.
 This is useful in context where some features are more important than others,
 so they can have a higher weight in the distance measures.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
Generally, 
\begin_inset Formula $p$
\end_inset

 is set to 
\begin_inset Formula $d$
\end_inset

, the number of dimensions of the data.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
Multidimensional data has normally different scales for the different dimensions
, resulting in features dominating others in distance computations.
 To solve this issue we can do 
\series bold
normalization
\series default
 and 
\series bold
scaling.
\end_layout

\begin_deeper
\begin_layout Itemize
Normalization is to replace each value 
\begin_inset Formula $X_{i}$
\end_inset

 with
\begin_inset Formula 
\[
Z_{i}^{j}=\frac{X_{i}^{j}-\mu_{j}}{\sigma_{j}},
\]

\end_inset

 where 
\begin_inset Formula $\mu_{j}$
\end_inset

 is the mean of the attribute 
\begin_inset Formula $j$
\end_inset

 and 
\begin_inset Formula $\sigma_{j}$
\end_inset

 its standard deviation.
\end_layout

\begin_layout Itemize
Scaling maps the values to the range 
\begin_inset Formula $\left[0,1\right]$
\end_inset

:
\begin_inset Formula 
\[
Y_{i}^{j}=\frac{X_{i}^{j}-\min_{j}}{\max_{j}-\min_{j}}.
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
The 
\series bold
edit distance
\series default
 is a distance defined over strings.
 
\end_layout

\begin_layout Definition
We have the operators:
\end_layout

\begin_deeper
\begin_layout Itemize
r: replace one character by another.
\end_layout

\begin_layout Itemize
i: insert one character.
\end_layout

\begin_layout Itemize
d: delete one character.
\end_layout

\end_deeper
\begin_layout Definition
The edit distance between two strings 
\begin_inset Formula $s_{1}$
\end_inset

 and 
\begin_inset Formula $s_{2}$
\end_inset

 is the minimum amount of operations needed to convert 
\begin_inset Formula $s_{1}$
\end_inset

 to 
\begin_inset Formula $s_{2}$
\end_inset

.
\end_layout

\begin_layout Definition
The formula is
\begin_inset Formula 
\[
edit\left(s_{1},s_{2}\right)=\begin{cases}
\left|s_{1}\right| & if\ \left|s_{2}\right|=0\\
\left|s_{2}\right| & if\ \left|s_{1}\right|=0\\
edit\left(tail\left(s_{1}\right),tail\left(s_{2}\right)\right) & if\ s_{1}\left[0\right]=s_{2}\left[0\right]\\
1+\min\left\{ \begin{array}{c}
edit\left(tail\left(s_{1}\right),s_{2}\right)\\
edit\left(s_{1},tail\left(s_{2}\right)\right)\\
edit\left(tail\left(s_{1}\right),tail\left(s_{2}\right)\right)
\end{array}\right\}  & otherwise
\end{cases}
\]

\end_inset

 where 
\begin_inset Formula $tail\left(s\right)$
\end_inset

 is the string 
\begin_inset Formula $s$
\end_inset

 minus its first character.
\end_layout

\end_inset


\end_layout

\begin_layout Remark
If the edit distance is computed recursively, its complexity measures are:
\end_layout

\begin_deeper
\begin_layout Itemize
Time: 
\begin_inset Formula $O\left(\left|s_{1}\right|\times\left|s_{2}\right|\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
Space: 
\begin_inset Formula $O\left(\left|s_{1}\right|\times\left|s_{2}\right|\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
Backtrace (length of the longest backtracking path): 
\begin_inset Formula $O\left(\left|s_{1}\right|+\left|s_{2}\right|\right)$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
If we do it with dynamic programming, with the algorithm in Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:DP_Edit(s1,-s2)"
plural "false"
caps "false"
noprefix "false"

\end_inset

, then its complexity measures are:
\end_layout

\begin_deeper
\begin_layout Itemize
Time: 
\begin_inset Formula $O\left(\left|s_{1}\right|\times\left|s_{2}\right|\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
Space: 
\begin_inset Formula $O\left(\left|s_{1}\right|\times\left|s_{2}\right|\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
Backtrace: 0.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Python,morekeywords={do, to, min, then, else, for, return, [,]}"
inline false
status open

\begin_layout Plain Layout

for i=1 to |s1| do
\end_layout

\begin_layout Plain Layout

	for j=1 to |s2| do
\end_layout

\begin_layout Plain Layout

		m[i,j] = min{m[i-1,j-1] + if[(s1[i] = s2[j] then 0 else 1],
\end_layout

\begin_layout Plain Layout

					 m[i-1,j] + 1,
\end_layout

\begin_layout Plain Layout

					 m[i,j-1] +1
\end_layout

\begin_layout Plain Layout

					}
\end_layout

\begin_layout Plain Layout

return m[|s1|,|s2|]
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:DP_Edit(s1,-s2)"

\end_inset

DP_Edit(s1, s2)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Remark
There is a further improvement that can be made.
 If we perform the dynamic programming only using rows or columns, then
 we only need to store two of them: the current one and the previous one.
 The complexity measures in this case are:
\end_layout

\begin_deeper
\begin_layout Itemize
Time: 
\begin_inset Formula $O\left(\left|s_{1}\right|\times\left|s_{2}\right|\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
Space: 
\begin_inset Formula $O\left(\min\left(\left|s_{1}\right|,\left|s_{2}\right|\right)\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
Backtrace: 0.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Model evaluation
\begin_inset CommandInset label
LatexCommand label
name "sec:Model-evaluation"

\end_inset


\end_layout

\begin_layout Standard
Once we have trained a model, we want to assess how well it performs.
 This way, we can compare different models and discuss, quantitatively,
 which of them is preferrable for our purposes.
 Nonetheless, this task is not easy, and there are both methodological and
 quantification issues to take into account:
\end_layout

\begin_layout Itemize

\series bold
Methodological issues
\series default
: associated with dividing the labeled data appropriately into training
 and test segments for evaluation.
 The choice of methodology has a direct impact on the evaluation process,
 such as underestimation or overestimation of classifier accuracy.
 Several approaches are possible: 
\series bold
holdout
\series default
, 
\series bold
bootstrap
\series default
 and 
\series bold
cross-validation
\series default
.
\end_layout

\begin_layout Itemize

\series bold
Quantification issues
\series default
: associated with providing a numercial measure for the quality of the method
 after a specific methodology for evaluation has been selected.
\end_layout

\begin_layout Subsection
Holdout
\end_layout

\begin_layout Standard
The labeled data is randomly divided into two disjoint sets, corresponding
 to the training and test data.
 The training data is used to feed the training algorithm and produce a
 model, whose performance is assessed using the test data.
\end_layout

\begin_layout Standard
The approach can be repeated several times with multiple samples to provide
 a final estimate.
\end_layout

\begin_layout Itemize

\series bold
Problem
\series default
: classes that are overrepresented in the training data are underrepresented
 in the test data.
 This can have a significant impact when the original class distribution
 is imbalanced.
 The error estimates are pessimistic.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pegado6.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Holdout visualization.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Cross-Validation
\end_layout

\begin_layout Standard
The labeled data is divided into 
\begin_inset Formula $m$
\end_inset

 disjoint subsets of equal size 
\begin_inset Formula $\frac{n}{m}$
\end_inset

.
 A typical choice of 
\begin_inset Formula $m$
\end_inset

 is around 10.
 One of the 
\begin_inset Formula $m$
\end_inset

 segments is used for testing, and the other 
\begin_inset Formula $\left(m-1\right)$
\end_inset

 segments are used for training.
 This approach is repeated by selecting each of the 
\begin_inset Formula $m$
\end_inset

 different segments in the data as test set.
\end_layout

\begin_layout Standard
The average accuracy over the different test sets is then reported.
\end_layout

\begin_layout Standard
The overall accuracy of the cross.validation procedure tends to be a highly
 representative, but pessimistic estimate, of model accuracy.
\end_layout

\begin_layout Standard
When 
\begin_inset Formula $m$
\end_inset

 is chosen to be 
\begin_inset Formula $m=n$
\end_inset

, 
\begin_inset Formula $n-1$
\end_inset

 examples are used for training, and one example is used for testing.
 This is called 
\series bold
leave-one-out cross-validation
\series default
.
 This approach is very expensive for large datasets.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pegado7.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Cross-Validation visualization.
 
\begin_inset Formula $m=3$
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Stratified cross-validation
\series default
 uses proportional representation of each class in the different folds and
 usually provides less pessimistic results.
\end_layout

\begin_layout Subsection
Bootstrap
\end_layout

\begin_layout Standard
The labeled data is sampled uniformly with replacement, to create a training
 dataset, which can contain duplicates.
 The labeled data of size 
\begin_inset Formula $n$
\end_inset

 is sampled 
\begin_inset Formula $n$
\end_inset

 times with replacement.
\end_layout

\begin_layout Standard
The probability that a particular point is not included in a sample is
\begin_inset Formula 
\[
p_{1}=1-\frac{1}{n}.
\]

\end_inset

 Therefore, the probability that the point is not included in 
\begin_inset Formula $n$
\end_inset

 samples is
\begin_inset Formula 
\[
p_{n}=\left(1-\frac{1}{n}\right)^{n}.
\]

\end_inset

 For large values of 
\begin_inset Formula $n$
\end_inset

, this approximates 
\begin_inset Formula $\frac{1}{e}$
\end_inset

.
 Thus, the fraction of the labeled data points included at elast once in
 the training dataset is 
\begin_inset Formula $1-\frac{1}{e}$
\end_inset

.
 
\end_layout

\begin_layout Standard
The overall accuracy is computed using the original set of full labeled
 data as the test examples.
\end_layout

\begin_layout Standard
The estimate is highly optimistic of the true classifier accuracy because
 of the large overlap between the training and test examples.
\end_layout

\begin_layout Standard
A better strategy is the 
\series bold
leave-one-out bootstrap
\series default
, in which the accuracy of each labeled instance is computed using the classifie
r performance on only the subset of the bootstraped samples in which the
 instance is not part of.
\end_layout

\begin_layout Standard
This approach provides a pessimistic accuracy estimate, 
\begin_inset Formula $A_{l}$
\end_inset

, given by the mean value of the accuracy computed for each labeled instance.
\end_layout

\begin_layout Standard
The 
\series bold
0.632-bootstrap
\series default
 improves the accuracy estimate with a compromise approach.
 The average training-data accuracy 
\begin_inset Formula $A_{t}$
\end_inset

 over 
\begin_inset Formula $b$
\end_inset

 bootstrapped samples is computed.
 This is a highly optimistic estimate.
 The overall accuracy is a weighted average of the leave-one-out accuracy
 and the training-data accuracy:
\begin_inset Formula 
\[
A=\left(0.632\right)\cdot A_{l}+\left(0.368\right)\cdot A_{t}.
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Clustering
\end_layout

\begin_layout Standard
Some applications require to divide the data into different groups, that
 share some characteristics.
 The problem many of these times is that we don't know which characteristics
 or at how much extend are useful to characterize the data.
 The general (unsupervised) approach to tackle this problem is 
\series bold
clustering
\series default
.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition

\series bold
Clustering problem (Informal)
\end_layout

\begin_layout Definition
Given a set of data points, partition them into groups containing similar
 data points.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This definition is informal and general, but gives enough information to
 understand the problem, as well as enough freedom to tackle it from different
 perspectives.
\end_layout

\begin_layout Section
Representative-Based Algorithms
\end_layout

\begin_layout Standard
These are the simplest of all clustering algorithms, as they directly use
 distances or similarities to cluster the data.
 They not capture hierarchical relationships and use a set of 
\series bold
representatives
\series default
 to cluster the data.
 The main insight is that the discovery of good clusters equates to the
 discovery of good representatives.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition

\series bold
Representative-Based general clustering problem
\end_layout

\begin_layout Definition
Given a data set 
\begin_inset Formula $\mathcal{D}$
\end_inset

 with 
\begin_inset Formula $n$
\end_inset

 data points 
\begin_inset Formula $X_{1},...,X_{n}$
\end_inset

 in a 
\begin_inset Formula $d$
\end_inset

-dimensional space and a specified number of clusters, 
\begin_inset Formula $k$
\end_inset

, the goal of a representative-based algorithm is to determine 
\begin_inset Formula $k$
\end_inset

 representatives 
\begin_inset Formula $Y_{1},...,Y_{n}$
\end_inset

 such that the objective function
\begin_inset Formula 
\[
O=\sum_{i=1}^{n}\left[\min_{j}\ Dist\left(X_{i},Y_{j}\right)\right]
\]

\end_inset

 is minimized, i.e., the sum of the distances of the different data points
 to their closest representative needs to be miminized.
\end_layout

\end_inset


\end_layout

\begin_layout Remark
The representatives 
\begin_inset Formula $Y_{1},...,Y_{k}$
\end_inset

 and the optimal assigmnent of data points to representatives are unknown
 a priori, but they depend on each other in a circular way.
 This fact allows us to develop a iterative approach to solve the problem.
\end_layout

\begin_layout Standard
The 
\series bold
generic 
\begin_inset Formula $k$
\end_inset

-representative approach
\series default
 is as in Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Generic-k-representative-approach"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "morekeywords={if, then, is, in, return, for, Let},morecomment={[f][\color{purple}]{\#}}"
inline false
status open

\begin_layout Plain Layout

Initialize Y = {Y_1,...,Y_k} <@
\backslash
textcolor{purple}{
\backslash
#Using heuristics}<@
\end_layout

\begin_layout Plain Layout

Initialize clusters C_1 = {},...
 C_k = {}
\end_layout

\begin_layout Plain Layout

do
\end_layout

\begin_layout Plain Layout

# Assign step
\end_layout

\begin_layout Plain Layout

	for(X in D):
\end_layout

\begin_layout Plain Layout

		assign X to Y_j such that <@
\backslash
textcolor{blue}{$Dist(X,Y_j) = 
\backslash
min_i Dist(X,Y_i)$}<@
\end_layout

\begin_layout Plain Layout

		C_j.add(X)
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

# Optimize step
\end_layout

\begin_layout Plain Layout

	for all Clusters C_j:
\end_layout

\begin_layout Plain Layout

		determine Y_j' such that 
\end_layout

\begin_layout Plain Layout

			<@
\backslash
textcolor{blue}{$
\backslash
sum_{X_i 
\backslash
in C_j} Dist(X_i,Y_j')$}<@
\end_layout

\begin_layout Plain Layout

		is minimized
\end_layout

\begin_layout Plain Layout

		Y_j = Y_j'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

while <@$O=
\backslash
sum_{i=1}^{n}
\backslash
left[
\backslash
min_{j}
\backslash
 Dist
\backslash
left(X_{i},Y_{j}
\backslash
right)
\backslash
right]$<@ > eps
\end_layout

\begin_layout Plain Layout

return {C_1, Y_1},...,{C_k, Y_k}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:Generic-k-representative-approach"

\end_inset

Generic 
\begin_inset Formula $k$
\end_inset

-representative approach (Data D, int k, threshold eps) : Set of representatives
 Y and Clusters C
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Remark
The idea is to improve the objective function over multiple iterations.
 The increase is usually greater in early iterations, and decreases rapidly.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
The main computational bottleneck is the assignment step, where distances
 need to be computed between all point to the representatives.
\end_layout

\begin_layout Subsection
The k-Means algorithm
\end_layout

\begin_layout Standard
The 
\begin_inset Formula $k-means$
\end_inset

 algorithm is a representative clustering method in which the distance used
 is the squared Euclidean distance (or squared 
\begin_inset Formula $L_{2}-$
\end_inset

norm):
\begin_inset Formula 
\[
Dist\left(X_{i},Y_{j}\right)=\left\Vert X_{i}-Y_{j}\right\Vert _{2}^{2}.
\]

\end_inset

 Thus, the objective function minimizes the sum of square errors over the
 data points, this is called the 
\begin_inset Formula $SSE$
\end_inset

 (Sum of Squared Errors).
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Proposition
The optimal representative 
\begin_inset Formula $Y_{j}$
\end_inset

 for each of the optimize iterative steps is the mean of the data points
 in cluster 
\begin_inset Formula $C_{j}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Proof
In the current step, we have a fixed clustering asssignment from the last
 step, 
\begin_inset Formula $C_{1},...,C_{k}$
\end_inset

.
 The overall clustering objective function is
\begin_inset Formula 
\[
O\left(X,Y\right)=\sum_{j=1}^{k}\sum_{X_{i}\in C_{j}}\left\Vert X_{i}-Y_{j}\right\Vert _{2}^{2},
\]

\end_inset

 so its gradient for each 
\begin_inset Formula $Y_{j}$
\end_inset

 is
\begin_inset Formula 
\[
\frac{d}{dY_{j}}O\left(X,Y\right)=2\sum_{X_{i}\in C_{j}}\left(X_{i}-Y_{j}\right).
\]

\end_inset

 When imposing the gradient equals to 0 (for optimization purposes), we
 get 
\begin_inset Formula 
\[
\sum_{X_{i}\in C_{j}}X_{i}-Y_{j}=0,
\]

\end_inset

 or, equivalently, 
\begin_inset Formula 
\[
\sum_{X_{i}\in C_{j}}X_{i}=\left|C_{j}\right|Y_{j}\implies Y_{j}=\frac{\sum_{X_{i}\in C_{j}}X_{i}}{\left|C_{j}\right|}=mean\left(C_{j}\right).
\]

\end_inset


\end_layout

\begin_layout Remark
Note that the obtained representatives could be a point which is not a point
 in the data.
 This property sometimes is undesirable.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
Note also that for the proof, we have suposed a numerical attribute.
 Computing the mean of different (for example) texts does not seem easy
 (think for example in the words 
\begin_inset Formula $classification$
\end_inset

 and 
\begin_inset Formula $regression$
\end_inset

, they could be certainly clustered inside 
\begin_inset Formula $data\ mining\ techniques$
\end_inset

, but the latter is hardly the mean of the two former words).
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
Regarding time complexity:
\end_layout

\begin_deeper
\begin_layout Itemize
The assign step is 
\begin_inset Formula $O\left(n\cdot k\right),$
\end_inset

 as we have to compute for each point, 
\begin_inset Formula $k$
\end_inset

 distances.
\end_layout

\begin_layout Itemize
The optimize step is 
\begin_inset Formula $O\left(n\right)$
\end_inset

, as we have to compute the 
\begin_inset Formula $k$
\end_inset

 different means using all 
\begin_inset Formula $n$
\end_inset

 points.
\end_layout

\begin_layout Itemize
Overall, then, it is 
\begin_inset Formula $O\left(n\cdot k\right)$
\end_inset

 per iteration.
 But usually few iterations are needed.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
Disadvantages:
\end_layout

\begin_deeper
\begin_layout Itemize
All points are clustered and taken into account equally for the objective
 function.
 This makes 
\begin_inset Formula $k-means$
\end_inset

 sensitive to outliers, which introduces bias.
\end_layout

\begin_layout Itemize
In some situations we cannot compute the mean of the data points (as the
 previous example).
\end_layout

\begin_layout Itemize
We need to know 
\begin_inset Formula $k$
\end_inset

 in advance.
\end_layout

\begin_layout Itemize
As we are minimizing the Euclidean distance, the algorithm is biased towards
 finding spherical clusters, because the sphere is the shape whose maximum
 distance to its center is constant:
\begin_inset Formula 
\[
\mathbb{S}^{n}\left(y,r\right)=\left\{ x\in\mathbb{R}^{n+1}:\sum_{i=1}^{n+1}\left|x_{i}-y_{i}\right|\leq r^{2}\right\} .
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Example
Apply the 
\begin_inset Formula $k-means$
\end_inset

 algorithm with 
\begin_inset Formula $k=3$
\end_inset

 to the dataset
\begin_inset Formula 
\[
D=\left\{ A_{1}=\left(2,10\right),A_{2}=\left(2,5\right),A_{3}=\left(8,4\right),A_{4}=\left(5,8\right),A_{5}=\left(7,5\right),A_{6}=\left(6,4\right),A_{7}=\left(1,2\right),A_{8}=\left(4,9\right)\right\} 
\]

\end_inset

 and using the seed 
\begin_inset Formula $Y_{1}=A_{5},\ Y_{2}=A_{6}$
\end_inset

 and 
\begin_inset Formula $Y_{3}=A_{8}$
\end_inset

.
\end_layout

\begin_layout Example
\begin_inset ERT
status open

\begin_layout Plain Layout

% This LaTeX was auto-generated from MATLAB code.
\end_layout

\begin_layout Plain Layout

% To make changes, update the MATLAB code and export to LaTeX again.
\end_layout

\begin_layout Plain Layout


\backslash
sloppy
\end_layout

\begin_layout Plain Layout


\backslash
matlabtitle{k-Means algorithm example (Example 7.1)}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{par}
\end_layout

\begin_layout Plain Layout


\backslash
begin{flushleft}
\end_layout

\begin_layout Plain Layout

Introduce the data
\end_layout

\begin_layout Plain Layout


\backslash
end{flushleft}
\end_layout

\begin_layout Plain Layout


\backslash
end{par}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

X1 = [2,10];
\end_layout

\begin_layout Plain Layout

X2 = [2,5];
\end_layout

\begin_layout Plain Layout

X3 = [8,4];
\end_layout

\begin_layout Plain Layout

X4 = [5,8];
\end_layout

\begin_layout Plain Layout

X5 = [7,5];
\end_layout

\begin_layout Plain Layout

X6 = [6,4];
\end_layout

\begin_layout Plain Layout

X7 = [1,2];
\end_layout

\begin_layout Plain Layout

X8 = [4,9];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

D = [X1;X2;X3;X4;X5;X6;X7;X8]
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlaboutput}
\end_layout

\begin_layout Plain Layout

D = 8x2    
\end_layout

\begin_layout Plain Layout

     2    10
\end_layout

\begin_layout Plain Layout

     2     5
\end_layout

\begin_layout Plain Layout

     8     4
\end_layout

\begin_layout Plain Layout

     5     8
\end_layout

\begin_layout Plain Layout

     7     5
\end_layout

\begin_layout Plain Layout

     6     4
\end_layout

\begin_layout Plain Layout

     1     2
\end_layout

\begin_layout Plain Layout

     4     9
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{matlaboutput}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

Y = [X5; X6; X8]
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlaboutput}
\end_layout

\begin_layout Plain Layout

Y = 3x2    
\end_layout

\begin_layout Plain Layout

     7     5
\end_layout

\begin_layout Plain Layout

     6     4
\end_layout

\begin_layout Plain Layout

     4     9
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{matlaboutput}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{par}
\end_layout

\begin_layout Plain Layout


\backslash
begin{flushleft}
\end_layout

\begin_layout Plain Layout

Compute the distance between all points
\end_layout

\begin_layout Plain Layout


\backslash
end{flushleft}
\end_layout

\begin_layout Plain Layout


\backslash
end{par}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

dist = zeros(3);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

for j=1:3
\end_layout

\begin_layout Plain Layout

    for i=1:8
\end_layout

\begin_layout Plain Layout

        dist(i,j)=distance(D(i,:),Y(j,:),2);
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{par}
\end_layout

\begin_layout Plain Layout


\backslash
begin{flushleft}
\end_layout

\begin_layout Plain Layout

Select, for each point, the point that minimizes the distance
\end_layout

\begin_layout Plain Layout


\backslash
end{flushleft}
\end_layout

\begin_layout Plain Layout


\backslash
end{par}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

[v, idx] = min(dist, [], 2);
\end_layout

\begin_layout Plain Layout

D = [D,idx];
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{par}
\end_layout

\begin_layout Plain Layout


\backslash
begin{flushleft}
\end_layout

\begin_layout Plain Layout

Plot the clusters:
\end_layout

\begin_layout Plain Layout


\backslash
end{flushleft}
\end_layout

\begin_layout Plain Layout


\backslash
end{par}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

c1 = D(:,3) == 1
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlaboutput}
\end_layout

\begin_layout Plain Layout

c1 = 8x1 logical array    
\end_layout

\begin_layout Plain Layout

   0
\end_layout

\begin_layout Plain Layout

   0
\end_layout

\begin_layout Plain Layout

   1
\end_layout

\begin_layout Plain Layout

   0
\end_layout

\begin_layout Plain Layout

   1
\end_layout

\begin_layout Plain Layout

   0
\end_layout

\begin_layout Plain Layout

   0
\end_layout

\begin_layout Plain Layout

   0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{matlaboutput}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

c2 = D(:,3) == 2;
\end_layout

\begin_layout Plain Layout

c3 = D(:,3) == 3;
\end_layout

\begin_layout Plain Layout

scatter(D(c1,1),D(c1,2), 'MarkerFaceColor', 'b');
\end_layout

\begin_layout Plain Layout

hold on
\end_layout

\begin_layout Plain Layout

scatter(D(c2,1),D(c2,2), 'MarkerFaceColor', 'g');
\end_layout

\begin_layout Plain Layout

scatter(D(c3,1),D(c3,2), 'MarkerFaceColor', 'r');
\end_layout

\begin_layout Plain Layout

hold off
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename scripts/example7_1_images/figure_0.eps
	scale 60

\end_inset


\end_layout

\end_deeper
\begin_layout Example
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{par}
\end_layout

\begin_layout Plain Layout


\backslash
begin{flushleft}
\end_layout

\begin_layout Plain Layout

Compute the new 
\backslash
texttt{Y:}
\end_layout

\begin_layout Plain Layout


\backslash
end{flushleft}
\end_layout

\begin_layout Plain Layout


\backslash
end{par}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

for i=1:3
\end_layout

\begin_layout Plain Layout

    ci = D(:,3) == i;
\end_layout

\begin_layout Plain Layout

    x = mean(D(ci,1));
\end_layout

\begin_layout Plain Layout

    y = mean(D(ci,2));
\end_layout

\begin_layout Plain Layout

    Y(i,:)=[x,y];
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

Y
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlaboutput}
\end_layout

\begin_layout Plain Layout

Y = 3x2    
\end_layout

\begin_layout Plain Layout

    7.5000    4.5000
\end_layout

\begin_layout Plain Layout

    3.0000    3.6667
\end_layout

\begin_layout Plain Layout

    3.6667    9.0000
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{matlaboutput}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{par}
\end_layout

\begin_layout Plain Layout


\backslash
begin{flushleft}
\end_layout

\begin_layout Plain Layout

Repeat the process:
\end_layout

\begin_layout Plain Layout


\backslash
end{flushleft}
\end_layout

\begin_layout Plain Layout


\backslash
end{par}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

%Distances
\end_layout

\begin_layout Plain Layout

for j=1:3
\end_layout

\begin_layout Plain Layout

    for i=1:8
\end_layout

\begin_layout Plain Layout

        dist(i,j)=distance(D(i,1:2),Y(j,:),2);
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

dist
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlaboutput}
\end_layout

\begin_layout Plain Layout

dist = 8x3    
\end_layout

\begin_layout Plain Layout

    7.7782    6.4118    1.9437
\end_layout

\begin_layout Plain Layout

    5.5227    1.6667    4.3333
\end_layout

\begin_layout Plain Layout

    0.7071    5.0111    6.6165
\end_layout

\begin_layout Plain Layout

    4.3012    4.7726    1.6667
\end_layout

\begin_layout Plain Layout

    0.7071    4.2164    5.2068
\end_layout

\begin_layout Plain Layout

    1.5811    3.0185    5.5176
\end_layout

\begin_layout Plain Layout

    6.9642    2.6034    7.4907
\end_layout

\begin_layout Plain Layout

    5.7009    5.4263    0.3333
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{matlaboutput}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

%Assign
\end_layout

\begin_layout Plain Layout

[v, idx] = min(dist, [], 2);
\end_layout

\begin_layout Plain Layout

D(:,3) = idx;
\end_layout

\begin_layout Plain Layout

%Plot
\end_layout

\begin_layout Plain Layout

c1 = D(:,3) == 1
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlaboutput}
\end_layout

\begin_layout Plain Layout

c1 = 8x1 logical array    
\end_layout

\begin_layout Plain Layout

   0
\end_layout

\begin_layout Plain Layout

   0
\end_layout

\begin_layout Plain Layout

   1
\end_layout

\begin_layout Plain Layout

   0
\end_layout

\begin_layout Plain Layout

   1
\end_layout

\begin_layout Plain Layout

   1
\end_layout

\begin_layout Plain Layout

   0
\end_layout

\begin_layout Plain Layout

   0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{matlaboutput}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

c2 = D(:,3) == 2;
\end_layout

\begin_layout Plain Layout

c3 = D(:,3) == 3;
\end_layout

\begin_layout Plain Layout

scatter(D(c1,1),D(c1,2), 'MarkerFaceColor', 'b');
\end_layout

\begin_layout Plain Layout

hold on
\end_layout

\begin_layout Plain Layout

scatter(Y(1,1),Y(1,2), 'MarkerFaceColor', 'b');
\end_layout

\begin_layout Plain Layout

scatter(D(c2,1),D(c2,2), 'MarkerFaceColor', 'g');
\end_layout

\begin_layout Plain Layout

scatter(Y(2,1),Y(2,2), 'MarkerFaceColor', 'g');
\end_layout

\begin_layout Plain Layout

scatter(D(c3,1),D(c3,2), 'MarkerFaceColor', 'r');
\end_layout

\begin_layout Plain Layout

scatter(Y(3,1),Y(3,2), 'MarkerFaceColor', 'r');
\end_layout

\begin_layout Plain Layout

hold off
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename scripts/example7_1_images/figure_1.eps
	scale 60

\end_inset


\end_layout

\end_deeper
\begin_layout Example
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

%Optimize
\end_layout

\begin_layout Plain Layout

for i=1:3
\end_layout

\begin_layout Plain Layout

    ci = D(:,3) == i;
\end_layout

\begin_layout Plain Layout

    x = mean(D(ci,1));
\end_layout

\begin_layout Plain Layout

    y = mean(D(ci,2));
\end_layout

\begin_layout Plain Layout

    Y(i,:)=[x,y];
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

Y
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlaboutput}
\end_layout

\begin_layout Plain Layout

Y = 3x2    
\end_layout

\begin_layout Plain Layout

    7.0000    4.3333
\end_layout

\begin_layout Plain Layout

    1.5000    3.5000
\end_layout

\begin_layout Plain Layout

    3.6667    9.0000
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{matlaboutput}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{par}
\end_layout

\begin_layout Plain Layout


\backslash
begin{flushleft}
\end_layout

\begin_layout Plain Layout

Again:
\end_layout

\begin_layout Plain Layout


\backslash
end{flushleft}
\end_layout

\begin_layout Plain Layout


\backslash
end{par}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

%Distances
\end_layout

\begin_layout Plain Layout

for j=1:3
\end_layout

\begin_layout Plain Layout

    for i=1:8
\end_layout

\begin_layout Plain Layout

        dist(i,j)=distance(D(i,1:2),Y(j,:),2);
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

dist
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlaboutput}
\end_layout

\begin_layout Plain Layout

dist = 8x3    
\end_layout

\begin_layout Plain Layout

    7.5572    6.5192    1.9437
\end_layout

\begin_layout Plain Layout

    5.0442    1.5811    4.3333
\end_layout

\begin_layout Plain Layout

    1.0541    6.5192    6.6165
\end_layout

\begin_layout Plain Layout

    4.1767    5.7009    1.6667
\end_layout

\begin_layout Plain Layout

    0.6667    5.7009    5.2068
\end_layout

\begin_layout Plain Layout

    1.0541    4.5277    5.5176
\end_layout

\begin_layout Plain Layout

    6.4377    1.5811    7.4907
\end_layout

\begin_layout Plain Layout

    5.5478    6.0415    0.3333
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{matlaboutput}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

%Assign
\end_layout

\begin_layout Plain Layout

[v, idx] = min(dist, [], 2);
\end_layout

\begin_layout Plain Layout

D(:,3) = idx;
\end_layout

\begin_layout Plain Layout

%Plot
\end_layout

\begin_layout Plain Layout

c1 = D(:,3) == 1
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlaboutput}
\end_layout

\begin_layout Plain Layout

c1 = 8x1 logical array    
\end_layout

\begin_layout Plain Layout

   0
\end_layout

\begin_layout Plain Layout

   0
\end_layout

\begin_layout Plain Layout

   1
\end_layout

\begin_layout Plain Layout

   0
\end_layout

\begin_layout Plain Layout

   1
\end_layout

\begin_layout Plain Layout

   1
\end_layout

\begin_layout Plain Layout

   0
\end_layout

\begin_layout Plain Layout

   0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{matlaboutput}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

c2 = D(:,3) == 2;
\end_layout

\begin_layout Plain Layout

c3 = D(:,3) == 3;
\end_layout

\begin_layout Plain Layout

scatter(D(c1,1),D(c1,2), 'MarkerFaceColor', 'b');
\end_layout

\begin_layout Plain Layout

hold on
\end_layout

\begin_layout Plain Layout

scatter(Y(1,1),Y(1,2), 'MarkerFaceColor', 'b');
\end_layout

\begin_layout Plain Layout

scatter(D(c2,1),D(c2,2), 'MarkerFaceColor', 'g');
\end_layout

\begin_layout Plain Layout

scatter(Y(2,1),Y(2,2), 'MarkerFaceColor', 'g');
\end_layout

\begin_layout Plain Layout

scatter(D(c3,1),D(c3,2), 'MarkerFaceColor', 'r');
\end_layout

\begin_layout Plain Layout

scatter(Y(3,1),Y(3,2), 'MarkerFaceColor', 'r');
\end_layout

\begin_layout Plain Layout

hold off
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename scripts/example7_1_images/figure_2.eps
	scale 60

\end_inset


\end_layout

\end_deeper
\begin_layout Example
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

%Optimize
\end_layout

\begin_layout Plain Layout

for i=1:3
\end_layout

\begin_layout Plain Layout

    ci = D(:,3) == i;
\end_layout

\begin_layout Plain Layout

    x = mean(D(ci,1));
\end_layout

\begin_layout Plain Layout

    y = mean(D(ci,2));
\end_layout

\begin_layout Plain Layout

    Y(i,:)=[x,y];
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

Y
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlaboutput}
\end_layout

\begin_layout Plain Layout

Y = 3x2    
\end_layout

\begin_layout Plain Layout

    7.0000    4.3333
\end_layout

\begin_layout Plain Layout

    1.5000    3.5000
\end_layout

\begin_layout Plain Layout

    3.6667    9.0000
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{matlaboutput}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{par}
\end_layout

\begin_layout Plain Layout


\backslash
begin{flushleft}
\end_layout

\begin_layout Plain Layout

At this point we see how the clusters are the ones that we see naturally
 with our eyes.
 If we execute it again, we can see that the changes are very slight now:
\end_layout

\begin_layout Plain Layout


\backslash
end{flushleft}
\end_layout

\begin_layout Plain Layout


\backslash
end{par}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

%Distances
\end_layout

\begin_layout Plain Layout

for j=1:3
\end_layout

\begin_layout Plain Layout

    for i=1:8
\end_layout

\begin_layout Plain Layout

        dist(i,j)=distance(D(i,1:2),Y(j,:),2);
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

dist
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlaboutput}
\end_layout

\begin_layout Plain Layout

dist = 8x3    
\end_layout

\begin_layout Plain Layout

    7.5572    6.5192    1.9437
\end_layout

\begin_layout Plain Layout

    5.0442    1.5811    4.3333
\end_layout

\begin_layout Plain Layout

    1.0541    6.5192    6.6165
\end_layout

\begin_layout Plain Layout

    4.1767    5.7009    1.6667
\end_layout

\begin_layout Plain Layout

    0.6667    5.7009    5.2068
\end_layout

\begin_layout Plain Layout

    1.0541    4.5277    5.5176
\end_layout

\begin_layout Plain Layout

    6.4377    1.5811    7.4907
\end_layout

\begin_layout Plain Layout

    5.5478    6.0415    0.3333
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{matlaboutput}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

%Assign
\end_layout

\begin_layout Plain Layout

[v, idx] = min(dist, [], 2);
\end_layout

\begin_layout Plain Layout

D(:,3) = idx;
\end_layout

\begin_layout Plain Layout

%Plot
\end_layout

\begin_layout Plain Layout

c1 = D(:,3) == 1
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlaboutput}
\end_layout

\begin_layout Plain Layout

c1 = 8x1 logical array    
\end_layout

\begin_layout Plain Layout

   0
\end_layout

\begin_layout Plain Layout

   0
\end_layout

\begin_layout Plain Layout

   1
\end_layout

\begin_layout Plain Layout

   0
\end_layout

\begin_layout Plain Layout

   1
\end_layout

\begin_layout Plain Layout

   1
\end_layout

\begin_layout Plain Layout

   0
\end_layout

\begin_layout Plain Layout

   0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{matlaboutput}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

c2 = D(:,3) == 2;
\end_layout

\begin_layout Plain Layout

c3 = D(:,3) == 3;
\end_layout

\begin_layout Plain Layout

scatter(D(c1,1),D(c1,2), 'MarkerFaceColor', 'b');
\end_layout

\begin_layout Plain Layout

hold on
\end_layout

\begin_layout Plain Layout

scatter(Y(1,1),Y(1,2), 'MarkerFaceColor', 'b');
\end_layout

\begin_layout Plain Layout

scatter(D(c2,1),D(c2,2), 'MarkerFaceColor', 'g');
\end_layout

\begin_layout Plain Layout

scatter(Y(2,1),Y(2,2), 'MarkerFaceColor', 'g');
\end_layout

\begin_layout Plain Layout

scatter(D(c3,1),D(c3,2), 'MarkerFaceColor', 'r');
\end_layout

\begin_layout Plain Layout

scatter(Y(3,1),Y(3,2), 'MarkerFaceColor', 'r');
\end_layout

\begin_layout Plain Layout

hold off
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename scripts/example7_1_images/figure_3.eps
	scale 60

\end_inset


\end_layout

\end_deeper
\begin_layout Example
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

%Optimize
\end_layout

\begin_layout Plain Layout

for i=1:3
\end_layout

\begin_layout Plain Layout

    ci = D(:,3) == i;
\end_layout

\begin_layout Plain Layout

    x = mean(D(ci,1));
\end_layout

\begin_layout Plain Layout

    y = mean(D(ci,2));
\end_layout

\begin_layout Plain Layout

    Y(i,:)=[x,y];
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

Y
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlaboutput}
\end_layout

\begin_layout Plain Layout

Y = 3x2    
\end_layout

\begin_layout Plain Layout

    7.0000    4.3333
\end_layout

\begin_layout Plain Layout

    1.5000    3.5000
\end_layout

\begin_layout Plain Layout

    3.6667    9.0000
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{matlaboutput}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{par}
\end_layout

\begin_layout Plain Layout


\backslash
begin{flushleft}
\end_layout

\begin_layout Plain Layout

In fact, Y is not changing anymore!
\end_layout

\begin_layout Plain Layout


\backslash
end{flushleft}
\end_layout

\begin_layout Plain Layout


\backslash
end{par}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
matlabheadingthree{Functions}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{par}
\end_layout

\begin_layout Plain Layout


\backslash
hfill 
\backslash
break
\end_layout

\begin_layout Plain Layout


\backslash
end{par}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

function d = distance(X, Y, m)
\end_layout

\begin_layout Plain Layout

    n = length(X);
\end_layout

\begin_layout Plain Layout

    d = 0;
\end_layout

\begin_layout Plain Layout

    for i=1:n
\end_layout

\begin_layout Plain Layout

        d = d + (X(i)-Y(i))^m;
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

    d = sqrt(d);
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
The k-Medians Algorithm
\end_layout

\begin_layout Standard
In this case the Manhattan distance (
\begin_inset Formula $L_{1}$
\end_inset

-norm) is used:
\begin_inset Formula 
\[
Dist\left(X_{i},Y_{j}\right)=\left\Vert X_{i}-Y_{j}\right\Vert _{1}.
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Proposition
The optimal representative 
\begin_inset Formula $Y_{j}$
\end_inset

 for each of the optimize iterative steps is the median of the data points
 along each dimension in cluster 
\begin_inset Formula $C_{j}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Proof
In this case, the objective function is
\begin_inset Formula 
\[
O\left(X,Y\right)=\sum_{j=1}^{k}\sum_{X_{i}\in C_{j}}\left\Vert X_{i}-Y_{j}\right\Vert _{1}.
\]

\end_inset

 Now, the 
\begin_inset Formula $L_{1}$
\end_inset

-norm is obtained by summing the absolute value in each dimension.
 The problem is that this function is not differentiable.
 Nonetheless, it is differentiable almost everywhere.
 We can obtain the sub-gradient of 
\begin_inset Formula $O$
\end_inset

 with respect to 
\begin_inset Formula $Y_{j}$
\end_inset

 as
\begin_inset Formula 
\[
\frac{d}{dY_{j}}O\left(X,Y\right)=\sum_{X_{i}\in C_{j}}sign\left(X_{i}-Y_{j}\right).
\]

\end_inset

 For this to equal 0, we need as many negative signs as positive signs:
 the median in each direction achieves exactly this, as it has as many values
 to its left as to its right.
\end_layout

\begin_layout Example
Repeat the example using the k-Medians algorithm.
\end_layout

\begin_layout Example
\begin_inset ERT
status open

\begin_layout Plain Layout

% This LaTeX was auto-generated from MATLAB code.
\end_layout

\begin_layout Plain Layout

% To make changes, update the MATLAB code and export to LaTeX again.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
matlabtitle{k-Medians algorithm example (Example 7.2)}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{par}
\end_layout

\begin_layout Plain Layout


\backslash
begin{flushleft}
\end_layout

\begin_layout Plain Layout

Introduce the data
\end_layout

\begin_layout Plain Layout


\backslash
end{flushleft}
\end_layout

\begin_layout Plain Layout


\backslash
end{par}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

X1 = [2,10];
\end_layout

\begin_layout Plain Layout

X2 = [2,5];
\end_layout

\begin_layout Plain Layout

X3 = [8,4];
\end_layout

\begin_layout Plain Layout

X4 = [5,8];
\end_layout

\begin_layout Plain Layout

X5 = [7,5];
\end_layout

\begin_layout Plain Layout

X6 = [6,4];
\end_layout

\begin_layout Plain Layout

X7 = [1,2];
\end_layout

\begin_layout Plain Layout

X8 = [4,9];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

D = [X1;X2;X3;X4;X5;X6;X7;X8];
\end_layout

\begin_layout Plain Layout

z = zeros([8,1]);
\end_layout

\begin_layout Plain Layout

D = [D,z]
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlaboutput}
\end_layout

\begin_layout Plain Layout

D = 8x3    
\end_layout

\begin_layout Plain Layout

     2    10     0
\end_layout

\begin_layout Plain Layout

     2     5     0
\end_layout

\begin_layout Plain Layout

     8     4     0
\end_layout

\begin_layout Plain Layout

     5     8     0
\end_layout

\begin_layout Plain Layout

     7     5     0
\end_layout

\begin_layout Plain Layout

     6     4     0
\end_layout

\begin_layout Plain Layout

     1     2     0
\end_layout

\begin_layout Plain Layout

     4     9     0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{matlaboutput}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

Y = [X5; X6; X8]
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlaboutput}
\end_layout

\begin_layout Plain Layout

Y = 3x2    
\end_layout

\begin_layout Plain Layout

     7     5
\end_layout

\begin_layout Plain Layout

     6     4
\end_layout

\begin_layout Plain Layout

     4     9
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{matlaboutput}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{par}
\end_layout

\begin_layout Plain Layout


\backslash
begin{flushleft}
\end_layout

\begin_layout Plain Layout

Apply k-Medians
\end_layout

\begin_layout Plain Layout


\backslash
end{flushleft}
\end_layout

\begin_layout Plain Layout


\backslash
end{par}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

%First iteration
\end_layout

\begin_layout Plain Layout

[D,Ynext] = kMediansIter(D,Y,3);
\end_layout

\begin_layout Plain Layout

%Plot
\end_layout

\begin_layout Plain Layout

c1 = D(:,3) == 1;
\end_layout

\begin_layout Plain Layout

c2 = D(:,3) == 2;
\end_layout

\begin_layout Plain Layout

c3 = D(:,3) == 3;
\end_layout

\begin_layout Plain Layout

scatter(D(c1,1),D(c1,2), 'MarkerFaceColor', 'b');
\end_layout

\begin_layout Plain Layout

hold on
\end_layout

\begin_layout Plain Layout

scatter(Y(1,1),Y(1,2), 'MarkerFaceColor', 'b');
\end_layout

\begin_layout Plain Layout

scatter(D(c2,1),D(c2,2), 'MarkerFaceColor', 'g');
\end_layout

\begin_layout Plain Layout

scatter(Y(2,1),Y(2,2), 'MarkerFaceColor', 'g');
\end_layout

\begin_layout Plain Layout

scatter(D(c3,1),D(c3,2), 'MarkerFaceColor', 'r');
\end_layout

\begin_layout Plain Layout

scatter(Y(3,1),Y(3,2), 'MarkerFaceColor', 'r');
\end_layout

\begin_layout Plain Layout

hold off
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename scripts/example7_2_images/figure_0.eps
	scale 60

\end_inset


\end_layout

\end_deeper
\begin_layout Example
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

Y = Ynext;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%Second iteration
\end_layout

\begin_layout Plain Layout

%First iteration
\end_layout

\begin_layout Plain Layout

[D,Ynext] = kMediansIter(D,Y,3);
\end_layout

\begin_layout Plain Layout

%Plot
\end_layout

\begin_layout Plain Layout

c1 = D(:,3) == 1;
\end_layout

\begin_layout Plain Layout

c2 = D(:,3) == 2;
\end_layout

\begin_layout Plain Layout

c3 = D(:,3) == 3;
\end_layout

\begin_layout Plain Layout

scatter(D(c1,1),D(c1,2), 'MarkerFaceColor', 'b');
\end_layout

\begin_layout Plain Layout

hold on
\end_layout

\begin_layout Plain Layout

scatter(Y(1,1),Y(1,2), 'MarkerFaceColor', 'b');
\end_layout

\begin_layout Plain Layout

scatter(D(c2,1),D(c2,2), 'MarkerFaceColor', 'g');
\end_layout

\begin_layout Plain Layout

scatter(Y(2,1),Y(2,2), 'MarkerFaceColor', 'g');
\end_layout

\begin_layout Plain Layout

scatter(D(c3,1),D(c3,2), 'MarkerFaceColor', 'r');
\end_layout

\begin_layout Plain Layout

scatter(Y(3,1),Y(3,2), 'MarkerFaceColor', 'r');
\end_layout

\begin_layout Plain Layout

hold off
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename scripts/example7_2_images/figure_1.eps
	scale 60

\end_inset


\end_layout

\end_deeper
\begin_layout Example
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

Y = Ynext;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%Third iteration
\end_layout

\begin_layout Plain Layout

[D,Ynext] = kMediansIter(D,Y,3);
\end_layout

\begin_layout Plain Layout

%Plot
\end_layout

\begin_layout Plain Layout

c1 = D(:,3) == 1;
\end_layout

\begin_layout Plain Layout

c2 = D(:,3) == 2;
\end_layout

\begin_layout Plain Layout

c3 = D(:,3) == 3;
\end_layout

\begin_layout Plain Layout

scatter(D(c1,1),D(c1,2), 'MarkerFaceColor', 'b');
\end_layout

\begin_layout Plain Layout

hold on
\end_layout

\begin_layout Plain Layout

scatter(Y(1,1),Y(1,2), 'MarkerFaceColor', 'b');
\end_layout

\begin_layout Plain Layout

scatter(D(c2,1),D(c2,2), 'MarkerFaceColor', 'g');
\end_layout

\begin_layout Plain Layout

scatter(Y(2,1),Y(2,2), 'MarkerFaceColor', 'g');
\end_layout

\begin_layout Plain Layout

scatter(D(c3,1),D(c3,2), 'MarkerFaceColor', 'r');
\end_layout

\begin_layout Plain Layout

scatter(Y(3,1),Y(3,2), 'MarkerFaceColor', 'r');
\end_layout

\begin_layout Plain Layout

hold off
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename scripts/example7_2_images/figure_2.eps
	scale 60

\end_inset


\end_layout

\end_deeper
\begin_layout Example
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

Y = Ynext;
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

function d = distance(X, Y, m)
\end_layout

\begin_layout Plain Layout

    n = length(X);
\end_layout

\begin_layout Plain Layout

    d = 0;
\end_layout

\begin_layout Plain Layout

    for i=1:n
\end_layout

\begin_layout Plain Layout

        d = d + abs(X(i)-Y(i))^m;
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

    d = sqrt(d);
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

function [D2,Ynext] = kMediansIter(D,Y,k)
\end_layout

\begin_layout Plain Layout

    dist = zeros(k);
\end_layout

\begin_layout Plain Layout

    [n,m] = size(D);
\end_layout

\begin_layout Plain Layout

    %Distances
\end_layout

\begin_layout Plain Layout

    for j=1:k
\end_layout

\begin_layout Plain Layout

        for i=1:n
\end_layout

\begin_layout Plain Layout

            dist(i,j)=distance(D(i,1:2),Y(j,:),2);
\end_layout

\begin_layout Plain Layout

        end
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

    %Assign
\end_layout

\begin_layout Plain Layout

    [v, idx] = min(dist, [], 2);
\end_layout

\begin_layout Plain Layout

    D2 = D;
\end_layout

\begin_layout Plain Layout

    D2(:,3) = idx;
\end_layout

\begin_layout Plain Layout

    %Optimize
\end_layout

\begin_layout Plain Layout

    Ynext = Y;
\end_layout

\begin_layout Plain Layout

    for i=1:3
\end_layout

\begin_layout Plain Layout

        ci = D2(:,3) == i;
\end_layout

\begin_layout Plain Layout

        x = median(D(ci,1));
\end_layout

\begin_layout Plain Layout

        y = median(D(ci,2));
\end_layout

\begin_layout Plain Layout

        Ynext(i,:)=[x,y];
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
The k-Medoids Algorithm
\end_layout

\begin_layout Standard
In this algorithm the representatives are always selected from the database
 
\begin_inset Formula $\mathcal{D}$
\end_inset

, and this makes the structure of the algorithm different from the one we
 have seen before.
\end_layout

\begin_layout Standard
Reasons:
\end_layout

\begin_layout Itemize
This approach makes outlier handling easier than with 
\begin_inset Formula $k$
\end_inset

-means.
\end_layout

\begin_layout Itemize
It is sometimes difficult to compute the central representative of a complex
 data type (text or categorical data).
 The 
\begin_inset Formula $k$
\end_inset

-medoids algorithm can be defined in any datatype in which we are able to
 define a proper distance function.
\end_layout

\begin_layout Standard
The algorithm is as in Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:k-medoids"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "morekeywords={if, then, is, in, return, for, Let},morecomment={[f][\color{purple}]{\#}}"
inline false
status open

\begin_layout Plain Layout

Initialize Y = {Y_1,...,Y_k} <@
\backslash
textcolor{purple}{
\backslash
#Using heuristics}<@
\end_layout

\begin_layout Plain Layout

Initialize clusters C_1 = {},...
 C_k = {}
\end_layout

\begin_layout Plain Layout

do
\end_layout

\begin_layout Plain Layout

# Assign step
\end_layout

\begin_layout Plain Layout

	for(X in D):
\end_layout

\begin_layout Plain Layout

		assign X to Y_j such that <@
\backslash
textcolor{blue}{$Dist(X,Y_j) = 
\backslash
min_i Dist(X,Y_i)$}<@
\end_layout

\begin_layout Plain Layout

		C_j.add(X)
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

# Optimize step
\end_layout

\begin_layout Plain Layout

	Determine a pair X_i in D and Y_j in Y such that 
\end_layout

\begin_layout Plain Layout

		replacing Y_j with X_i leads to the 
\end_layout

\begin_layout Plain Layout

		greatest possible improvement in the objective function
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	Perform the exchange between X_i and Y_j only if improvement is positive.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

while <@$O=
\backslash
sum_{i=1}^{n}
\backslash
left[
\backslash
min_{j}
\backslash
 Dist
\backslash
left(X_{i},Y_{j}
\backslash
right)
\backslash
right]$<@ > eps 
\end_layout

\begin_layout Plain Layout

		or no improvement in current iteration
\end_layout

\begin_layout Plain Layout

return {C_1, Y_1},...,{C_k, Y_k}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:k-medoids"

\end_inset


\begin_inset Formula $k$
\end_inset

-medoids(Data D, int k, threshold eps) : Set of representatives Y and Clusters
 C
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Remark
In this algorithm we use a hill climbing strategy to obtain the best representat
ives.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
We can try all possible changes or sample points from the database to try
 with.
 The latter approach is often more desirable for time issues.
\end_layout

\begin_layout Subsection
Practical issues
\end_layout

\begin_layout Itemize
The initialization of the initial representative is not a trivial task.
 Normally they are selected randomly among the points of the datasets and
 most times the initialization step does not change the outcome of the algorithm
: the representative based algorithm are very robust to this selection.
 Nonetheless, sometimes suboptimal clusters arise because of a bad choice
 of initial representatives.
\end_layout

\begin_layout Itemize
Outliers can make a detrimental impact on the algorithms.
 If one outlier is selected as initial representative it is possible to
 obtain a singleton cluster with no meaning for the application.
\end_layout

\begin_layout Itemize
The number of clusters, 
\begin_inset Formula $k$
\end_inset

, is difficult to determine using automated methods.
 As it is not known a priori, a common approach is to start with larger
 values for 
\begin_inset Formula $k$
\end_inset

 than the one we think should be correct.
 Some natural clusters may split, but we can merge some of them as a postprocess
ing step.
\end_layout

\begin_layout Section
Grid and Density based Algorithms
\end_layout

\begin_layout Standard
One of the major problems with distance-based algorithms is that the shape
 of the clusters is implicitly enforced by the distance function.
 Thus, it can be hard to detect natural cluster of arbitrary form.
\end_layout

\begin_layout Standard

\series bold
Density-based algorithms
\series default
 are useful for this.
 The idea is to identify dense regions in the data, and use the positions
 of the different regions to determine the clusters.
\end_layout

\begin_layout Subsection
Grid-based methods
\end_layout

\begin_layout Standard
The data is discretized into 
\begin_inset Formula $p$
\end_inset

 intervals, typically equi-width.
 If the data has 
\begin_inset Formula $d$
\end_inset

 dimensions, we will obtain 
\begin_inset Formula $p^{d}$
\end_inset

 hyper-cubes.
 These are the building blocks for the clusters.
\end_layout

\begin_layout Standard
A 
\series bold
density threshold 
\begin_inset Formula $\tau$
\end_inset

 
\series default
is used to determine the dense hyper-cubes.
 In most real data-sets, an arbitrarily shaped cluster will result in multiple
 dense regions connected together by a side or a corner.
\end_layout

\begin_layout Standard
Two hyper-cubes are said to be 
\series bold
adjacently connected
\series default
 if they share a side (sometimes corners are also considered).
\end_layout

\begin_layout Standard
Two hyper-cubes are said to be 
\series bold
density connected
\series default
 if a path can be found from one to another containing only a sequence of
 adjacently connected grid regions.
\end_layout

\begin_layout Standard
The 
\series bold
goal
\series default
 is to determine the density connected regions.
 Using a graph representation, the problem is equivalent to finding the
 connected components of the graph, being the hyper-cubes the nodes and
 an edge is defined between every pair of adjacent cubes.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Plain Layout

\series bold
Advantages
\end_layout

\begin_layout Plain Layout
The number of clusters is not pre-defined, so we don't need to bother with
 the estimation of 
\begin_inset Formula $k$
\end_inset

.
\end_layout

\begin_layout Plain Layout

\series bold
Disadvantages
\end_layout

\begin_layout Plain Layout
We have to define 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $\tau$
\end_inset

, which is not easy.
 
\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $p$
\end_inset

 (number of ranges) is too small, the data points from multiple clusters
 will be present in the same hyper-cube.
 We will obtain undesired merged clusters.
\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $p$
\end_inset

 is too large, there will be many empty grid cells, so we may split a natural
 cluster.
 It also will be computationally expensive.
\end_layout

\begin_layout Itemize
The choice of 
\begin_inset Formula $\tau$
\end_inset

 has similar consecuences.
\end_layout

\begin_layout Plain Layout
Also, if the clusters present different densities, it is even more difficult
 to determine 
\begin_inset Formula $\tau$
\end_inset

 and 
\begin_inset Formula $p$
\end_inset

 because each cluster is 'asking' for different values.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The generic algorithm is as follows:
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Discretize each dimension into p ranges
\end_layout

\begin_layout Plain Layout

Determine grid cells at density level tau
\end_layout

\begin_layout Plain Layout

Create graph in which dense grids are connected if they are adjacent
\end_layout

\begin_layout Plain Layout

Determine connected components of the graph
\end_layout

\begin_layout Plain Layout

return points in each connected component as a cluster
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
GenericGrid(Data D, Ranges p, Density tau) : clusters C
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
DBSCAN
\end_layout

\begin_layout Standard
The idea behind DBSCAN is similar to the one we have seen, but density is
 considered at a pointwise level:
\end_layout

\begin_layout Standard
The 
\series bold
density of a data point
\series default
 is defined as the number of points that lie within a radius 
\begin_inset Formula $eps$
\end_inset

 from it, i.e.
 their neighbourhood of radius 
\begin_inset Formula $\tau$
\end_inset

.
 The densities are used to classify the points:
\end_layout

\begin_layout Itemize

\series bold
Core point
\series default
: its neighbourhood contains at least 
\begin_inset Formula $\tau$
\end_inset

 points.
\end_layout

\begin_layout Itemize

\series bold
Border point
\series default
: its neighbourhood contains less than 
\begin_inset Formula $\tau$
\end_inset

 points, but it contains one or more core points.
\end_layout

\begin_layout Itemize

\series bold
Noise points
\series default
: any other case.
\end_layout

\begin_layout Standard
And we define some relations between points:
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(p_{i},p_{j}\right)$
\end_inset

 are 
\series bold
directly density reachable
\series default
 if 
\begin_inset Formula $p_{i}$
\end_inset

 is a core point, and 
\begin_inset Formula $p_{j}$
\end_inset

 is in the neighbourhood of 
\begin_inset Formula $p_{i}$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(p_{i},p_{j}\right)$
\end_inset

 are 
\series bold
density reachable
\series default
 is 
\begin_inset Formula $p_{i}$
\end_inset

 is a core point, and there exists a chain of core points 
\begin_inset Formula $p_{i+1},...,p_{n}$
\end_inset

 where 
\begin_inset Formula $\left(p_{k},p_{k+1}\right)$
\end_inset

 are directly density reachable for 
\begin_inset Formula $k=i,...,n-1$
\end_inset

 and 
\begin_inset Formula $p_{j}$
\end_inset

 is in the neighbourhood of 
\begin_inset Formula $p_{n}$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(p_{i},p_{j}\right)$
\end_inset

 are 
\series bold
density connected
\series default
 if both 
\begin_inset Formula $p_{i}$
\end_inset

 and 
\begin_inset Formula $p_{j}$
\end_inset

 are density reachable from some point 
\begin_inset Formula $p_{k}$
\end_inset


\end_layout

\begin_layout Standard
After the points have been classified, a connectivity graph is constructed
 as a maximal set of points that are all reachable from one another under
 any of these definitions.
\end_layout

\begin_layout Standard
Now, we identify the connected components of the graph, which are the clusters.
\end_layout

\begin_layout Standard
The detailed algorithm is as follows:
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Clusters = {}
\end_layout

\begin_layout Plain Layout

for each unvisited point P in D
\end_layout

\begin_layout Plain Layout

	Neihbourhood = regionQuery(P, eps)
\end_layout

\begin_layout Plain Layout

	if sizeof(Neihbourhood) < tau
\end_layout

\begin_layout Plain Layout

		mark P as visited
\end_layout

\begin_layout Plain Layout

	else
\end_layout

\begin_layout Plain Layout

		C = next cluster
\end_layout

\begin_layout Plain Layout

		expandCluster(P, Neighbourhood, C, eps, tau)
\end_layout

\begin_layout Plain Layout

		if C not in Clusters
\end_layout

\begin_layout Plain Layout

			Clusters.add(C)
\end_layout

\begin_layout Plain Layout

return Clusters
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

function expandCluster(P, Neighbourhood, C, eps, tau)
\end_layout

\begin_layout Plain Layout

	mark P as visited
\end_layout

\begin_layout Plain Layout

	C.add(P)
\end_layout

\begin_layout Plain Layout

	for Q in Neighbourhood
\end_layout

\begin_layout Plain Layout

		if Q not visited
\end_layout

\begin_layout Plain Layout

			mark Q as visited
\end_layout

\begin_layout Plain Layout

			Neighbourhood_Q = regionQuery(Q, eps)
\end_layout

\begin_layout Plain Layout

			if sizeof(Neighbourhood_Q >= tau)
\end_layout

\begin_layout Plain Layout

				Neighbourhood.addAll(Neighbourhood_Q)
\end_layout

\begin_layout Plain Layout

			if Q is not in any cluster
\end_layout

\begin_layout Plain Layout

				C.add(Q)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
DBSCAN(Data D, Radius eps, Density tau) : clusters C
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Plain Layout

\series bold
Advantages
\end_layout

\begin_layout Plain Layout
This method is not very different from the graph method, and it can also
 discover clusters of any shape, without the need of knowing the number
 of clusters in advance.
\end_layout

\begin_layout Plain Layout

\series bold
Disadvantages
\end_layout

\begin_layout Plain Layout
Again, determining the correct values for 
\begin_inset Formula $eps$
\end_inset

 and 
\begin_inset Formula $\tau$
\end_inset

 is a complex task.
 Also, the existence of clusters with different densities makes it even
 harder.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
colback=green!5!white,colframe=cyan!75!black,title=Complexity
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The major time complexity is finding the neighbours: 
\begin_inset Formula $O\left(n^{2}\right)$
\end_inset

.
\end_layout

\begin_layout Plain Layout
In some special cases, an spatial index can reduce it to 
\begin_inset Formula $O\left(n\cdot\log n\right)$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Remark
Usually, grid based methods are more efficient because they partition the
 space, which makes the procedure less computationally expensive.
\end_layout

\begin_layout Subsubsection
Progressive DBSCAN
\end_layout

\begin_layout Standard
The idea is using the same value for 
\begin_inset Formula $\tau$
\end_inset

, apply DBSCAN in a progressive way, increasing the value of 
\begin_inset Formula $eps$
\end_inset

.
\end_layout

\begin_layout Enumerate
Start with a small 
\begin_inset Formula $eps$
\end_inset

 to find dense clusters.
\end_layout

\begin_layout Enumerate
Iteratively relax the 
\begin_inset Formula $eps$
\end_inset

 value to find less dense clusters.
\end_layout

\begin_layout Enumerate
After every iteration, the points that already belong to a cluster are removed
 from the dataset.
\end_layout

\begin_layout Subsection
DENCLUE
\end_layout

\begin_layout Standard
The DENCLUE algorithm is based on kernel-density estimation, which can be
 used to create a smooth profile of the density distribution, by defining
 the density 
\begin_inset Formula $f\left(X\right)$
\end_inset

 at coordinate 
\begin_inset Formula $X$
\end_inset

 as 
\begin_inset Formula 
\[
f\left(X\right)=\frac{1}{n}\sum_{i=1}^{n}K\left(X-X_{i}\right),
\]

\end_inset

 where 
\begin_inset Formula $K$
\end_inset

 is the kernel function 
\begin_inset Formula $X_{i}$
\end_inset

 are 
\begin_inset Formula $n$
\end_inset

 different data points.
 A commonly used kernel function is the 
\series bold
Gaussian Kernel
\series default
:
\begin_inset Formula 
\[
K\left(X-X_{i}\right)=\left(\frac{1}{h\sqrt{2\pi}}\right)^{d}e^{-\frac{\left\Vert X-X_{i}\right\Vert ^{2}}{2h^{2}}}.
\]

\end_inset

 The effect of this operation is to replace each discrete data point with
 a smooth bump, and the density at each points is the sum of all these bumps.
\end_layout

\begin_layout Example
A visual example of a kernel smoothing:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado8.png
	scale 60

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Once the density has been smoothed, the goal is to determine clusters by
 using a density threshold 
\begin_inset Formula $\tau$
\end_inset

 that intersects the density profile.
 Two examples showing how the choice of 
\begin_inset Formula $\tau$
\end_inset

 affects the result are shown in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "ex8-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Example
\begin_inset CommandInset label
LatexCommand label
name "ex8-2"

\end_inset

In the previous example, if we select 
\begin_inset Formula $\tau=0.1$
\end_inset

, we obtain the following:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado9.png
	scale 60

\end_inset


\end_layout

\end_deeper
\begin_layout Example
In this case, only one cluster is obtained.
 In contrast, if we choose 
\begin_inset Formula $\tau=0.13$
\end_inset

, two clusters are obtained:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado10.png
	scale 60

\end_inset


\end_layout

\end_deeper
\begin_layout Section
Probabilistic Model-Based Algorithms
\end_layout

\begin_layout Standard
Until now, all models described are 
\series bold
hard clustering algorithm
\series default
, meaning each data point is assigned to a particular cluster.
 Probabilistic model-based algorithms are 
\series bold
soft algorithms
\series default
, in which each data point may have a nonzero assignment probability to
 more than one cluster.
\end_layout

\begin_layout Subsection
Fuzzy sets and clusters
\end_layout

\begin_layout Standard
A 
\series bold
fuzzy cluster
\series default
 is a fuzzy set 
\begin_inset Formula $F_{S}:X\rightarrow\left[0,1\right]$
\end_inset

.
 For each data point 
\begin_inset Formula $X_{i}\in X$
\end_inset

, 
\begin_inset Formula $F_{S}\left(X_{i}\right)$
\end_inset

 represents the probability that 
\begin_inset Formula $X_{i}$
\end_inset

 is in cluster 
\begin_inset Formula $S$
\end_inset

.
 
\begin_inset Formula $F_{S}\left(X_{i}\right)$
\end_inset

 can be called 
\series bold
degree of membership
\series default
 of object 
\begin_inset Formula $X_{i}$
\end_inset

 to cluster 
\begin_inset Formula $S$
\end_inset

.
\end_layout

\begin_layout Standard
Formally, given a set of objects 
\begin_inset Formula $X_{1},...,X_{n}$
\end_inset

, a 
\series bold
fuzzy clustering
\series default
 of 
\begin_inset Formula $k$
\end_inset

 fuzzy clusters 
\begin_inset Formula $C_{1},...,C_{k}$
\end_inset

 can be represented using a 
\series bold
partition matrix
\series default
, 
\begin_inset Formula $M=\left[w_{ij}\right]$
\end_inset

, where
\begin_inset Formula 
\[
w_{ij}=F_{C_{j}}\left(X_{i}\right).
\]

\end_inset

 
\begin_inset Formula $M$
\end_inset

 should satisfy three conditions:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $w_{ij}\in\left[0,1\right],\ i=1,...,n,j=1,...,j$
\end_inset

.
 From the definition of a fuzzy cluster.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\sum_{j=1}^{k}w_{ij}=1,\ i=1,...,n$
\end_inset

.
 The sum of all probabilities is 1.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $0<\sum_{i=1}^{n}w_{ij}<n,\ j=1,...,k$
\end_inset

.
 There is no empty cluster.
\end_layout

\begin_layout Subsection
Mixture model
\end_layout

\begin_layout Standard
The underlying assumption of a 
\series bold
mixture-based generative model
\series default
 is to assume that the data was generated from a mixture of 
\begin_inset Formula $k$
\end_inset

 distributions with probability distributions 
\begin_inset Formula $G_{1},...,G_{k}$
\end_inset

.
 Each of them represents a cluster and is called 
\series bold
mixture component
\series default
.
 The data points, 
\begin_inset Formula $X_{i}$
\end_inset

, are generated by this model as follows:
\end_layout

\begin_layout Enumerate
Select a mixture component with prior probability 
\begin_inset Formula $\alpha_{i}=P\left(G_{i}\right)$
\end_inset

.
 Say 
\begin_inset Formula $G_{r}$
\end_inset

 is selected.
\end_layout

\begin_layout Enumerate
Generate a data point from 
\begin_inset Formula $G_{r}$
\end_inset

.
\end_layout

\begin_layout Standard
This generative model is denoted by 
\begin_inset Formula $\mathcal{M}$
\end_inset

.
 We don't know 
\begin_inset Formula $G_{i}$
\end_inset

 nor 
\begin_inset Formula $\alpha_{i}$
\end_inset

 in advance.
 The 
\begin_inset Formula $G_{i}$
\end_inset

 distributions are often assumed to be Gaussian
\begin_inset Foot
status open

\begin_layout Plain Layout
Note that any other distribution might be assumed.
\end_layout

\end_inset

, so we need to estimate the parameters of the distribution in such a way
 that the overall data has a maximum likelihood of being generated by the
 model.
 
\end_layout

\begin_layout Standard
Consider a set 
\begin_inset Formula $C$
\end_inset

 of 
\begin_inset Formula $k$
\end_inset

 probabilistic clusters 
\begin_inset Formula $C_{1},...,C_{k}$
\end_inset

 with probability density functions 
\begin_inset Formula $f_{1},...,f_{k}$
\end_inset

, respectively, and probabilities 
\begin_inset Formula $p_{1},...,p_{k}$
\end_inset

.
 The probability of an object 
\begin_inset Formula $X$
\end_inset

 being generated by the cluster 
\begin_inset Formula $C_{j}$
\end_inset

 is
\begin_inset Formula 
\[
P\left(X|C_{j}\right)=p_{j}\cdot f_{j}\left(X\right),
\]

\end_inset

 and the probability of 
\begin_inset Formula $X$
\end_inset

 being generated by the set 
\begin_inset Formula $C$
\end_inset

 is
\begin_inset Formula 
\[
P\left(X|C\right)=\sum_{j=1}^{k}p_{j}\cdot f_{j}\left(X\right).
\]

\end_inset

 As objects are assumed to be independently generated, for a data set 
\begin_inset Formula $\mathcal{D}=\left\{ X_{1},...,X_{n}\right\} $
\end_inset

, the probability that 
\begin_inset Formula $\mathcal{D}$
\end_inset

 is generated by 
\begin_inset Formula $C$
\end_inset

 is
\begin_inset Formula 
\[
P\left(\mathcal{D}|C\right)=\prod_{i=1}^{n}P\left(X_{i}|C\right)=\prod_{i=1}^{n}\sum_{j=1}^{k}p_{j}\cdot f_{j}\left(X_{i}\right).
\]

\end_inset

 Now, we want to estimate 
\begin_inset Formula $C$
\end_inset

 from 
\begin_inset Formula $\mathcal{D}$
\end_inset

 trying to maximize 
\begin_inset Formula $P\left(\mathcal{D}|C\right)$
\end_inset

 is maximized.
\end_layout

\begin_layout Standard
If we use the assumption that the underlying distributions are Gaussian
 
\begin_inset Formula $\mathcal{G}\left(\mu_{j},\sigma_{j}\right)$
\end_inset

, then the probability density function of each cluster are centered at
 
\begin_inset Formula $\mu_{j}$
\end_inset

 with standard deviation 
\begin_inset Formula $\sigma_{j}$
\end_inset

 is:
\begin_inset Formula 
\[
P\left(X_{i}|\Theta_{j}\right)=\frac{1}{\sigma_{j}\sqrt{2\pi}}e^{-\frac{\left(X_{i}-\mu_{j}\right)^{2}}{2\sigma^{2}}}.
\]

\end_inset

 And if we assume all clusters have the same probability 
\begin_inset Formula $p_{j}$
\end_inset

, then
\begin_inset Formula 
\[
P\left(X_{i}|\Theta\right)=\sum_{j=1}^{k}\frac{1}{\sigma_{j}\sqrt{2\pi}}e^{-\frac{\left(X_{i}-\mu_{j}\right)^{2}}{2\sigma^{2}}}.
\]

\end_inset

 Thus, our objective is to maximize
\begin_inset Formula 
\[
P\left(\mathcal{D}|\Theta\right)=\prod_{i=1}^{n}\sum_{j=1}^{k}\frac{1}{\sigma_{j}\sqrt{2\pi}}e^{-\frac{\left(X_{i}-\mu_{j}\right)^{2}}{2\sigma^{2}}}.
\]

\end_inset


\end_layout

\begin_layout Standard
This is achieved with the 
\series bold
expection-maximization (EM) algorithm
\series default
.
 The EM algorithm is a framework to approach maximum likelihood estimates
 of parameters in statistical models.
 It consists of two steps:
\end_layout

\begin_layout Enumerate

\series bold
E-step
\series default
: assigns objects to clusters according to the current fuzzy clustering
 or parameters of probabilistic clusters.
\end_layout

\begin_layout Enumerate

\series bold
M-step
\series default
: finds the new clustering or parameters that maximize the SSE or the expected
 likelihood.
\end_layout

\begin_layout Example
EM algorithm example.
\end_layout

\begin_layout Example
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
matlabtitle{EM Algorithm example (Example 9.1)}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{par}
\end_layout

\begin_layout Plain Layout


\backslash
begin{flushleft}
\end_layout

\begin_layout Plain Layout

Start defining the data set:
\end_layout

\begin_layout Plain Layout


\backslash
end{flushleft}
\end_layout

\begin_layout Plain Layout


\backslash
end{par}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

D = [3,3;
\end_layout

\begin_layout Plain Layout

    4,10;
\end_layout

\begin_layout Plain Layout

    9,6;
\end_layout

\begin_layout Plain Layout

    14,8;
\end_layout

\begin_layout Plain Layout

    18,11;
\end_layout

\begin_layout Plain Layout

    21,7];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

centers = [3,3;
\end_layout

\begin_layout Plain Layout

           4,10];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[p1,c1] = E_step(D, centers)
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlaboutput}
\end_layout

\begin_layout Plain Layout

p1 = 2x6    
\end_layout

\begin_layout Plain Layout

    1.0000         0    0.4767    0.4160    0.4053    0.4671
\end_layout

\begin_layout Plain Layout

         0    1.0000    0.5233    0.5840    0.5947    0.5329
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

c1 = 1x6    
\end_layout

\begin_layout Plain Layout

     1     2     2     2     2     2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{matlaboutput}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

centers_2 = M_step(D, p1)
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlaboutput}
\end_layout

\begin_layout Plain Layout

centers_2 = 2x2    
\end_layout

\begin_layout Plain Layout

    8.4178    5.0946
\end_layout

\begin_layout Plain Layout

   10.4632    8.9897
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{matlaboutput}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[result, probs, cl] = em_algorithm(D, centers, 0.5)
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlaboutput}
\end_layout

\begin_layout Plain Layout

result = 2x2    
\end_layout

\begin_layout Plain Layout

    6.3427    6.2224
\end_layout

\begin_layout Plain Layout

   16.6020    8.6542
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

probs = 2x6    
\end_layout

\begin_layout Plain Layout

    0.9096    0.8905    0.9012    0.1043    0.0449    0.0930
\end_layout

\begin_layout Plain Layout

    0.0904    0.1095    0.0988    0.8957    0.9551    0.9070
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

cl = 1x6    
\end_layout

\begin_layout Plain Layout

     1     1     1     2     2     2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{matlaboutput}
\end_layout

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

D(:,3) = cl;
\end_layout

\begin_layout Plain Layout

c1 = D(:,3) == 1;
\end_layout

\begin_layout Plain Layout

c2 = D(:,3) == 2;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scatter(D(c1,1),D(c1,2), 'MarkerFaceColor', 'b');
\end_layout

\begin_layout Plain Layout

hold on
\end_layout

\begin_layout Plain Layout

scatter(result(1,1),result(1,2), 'MarkerFaceColor', 'b');
\end_layout

\begin_layout Plain Layout

scatter(D(c2,1),D(c2,2), 'MarkerFaceColor', 'g');
\end_layout

\begin_layout Plain Layout

scatter(result(2,1),result(2,2), 'MarkerFaceColor', 'g');
\end_layout

\begin_layout Plain Layout

hold off
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename scripts/example9_1_images/figure_0.eps

\end_inset


\end_layout

\end_deeper
\begin_layout Example
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{matlabcode}
\end_layout

\begin_layout Plain Layout

function d = distance(X, Y, m)
\end_layout

\begin_layout Plain Layout

    n = length(X);
\end_layout

\begin_layout Plain Layout

    d = 0;
\end_layout

\begin_layout Plain Layout

    for i=1:n
\end_layout

\begin_layout Plain Layout

        d = d + abs(X(i)-Y(i))^m;
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

    d = sqrt(d);
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

function [probs,clusters] = E_step(data, centers)
\end_layout

\begin_layout Plain Layout

    k = length(centers);
\end_layout

\begin_layout Plain Layout

    n = length(data);
\end_layout

\begin_layout Plain Layout

    distances = zeros([k,n]);
\end_layout

\begin_layout Plain Layout

    for i = 1:k
\end_layout

\begin_layout Plain Layout

        for j = 1:n
\end_layout

\begin_layout Plain Layout

            distances(i,j) = distance(data(j,:),centers(i,:),2)^2;
\end_layout

\begin_layout Plain Layout

        end
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    full_dists = sum(distances,1);
\end_layout

\begin_layout Plain Layout

    probs = (full_dists - distances )./ full_dists;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    [c,idx] = min(distances,[],1);
\end_layout

\begin_layout Plain Layout

    clusters = idx;
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

function new_centers = M_step(data,probs)
\end_layout

\begin_layout Plain Layout

    sq_probs = probs.^2;
\end_layout

\begin_layout Plain Layout

    sum_sq_probs = sum(sq_probs,2);
\end_layout

\begin_layout Plain Layout

    new_centers = sq_probs * data;
\end_layout

\begin_layout Plain Layout

    new_centers = new_centers ./ sum_sq_probs;
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

function [centers, probs, clusters] = em_algorithm(data, in_centers, eps)
\end_layout

\begin_layout Plain Layout

    dif = inf;
\end_layout

\begin_layout Plain Layout

    while dif > eps
\end_layout

\begin_layout Plain Layout

        [probs,clusters] = E_step(data, in_centers);
\end_layout

\begin_layout Plain Layout

        centers = M_step(data, probs);
\end_layout

\begin_layout Plain Layout

        dif = sum(centers - in_centers);
\end_layout

\begin_layout Plain Layout

        in_centers = centers;
\end_layout

\begin_layout Plain Layout

    end
\end_layout

\begin_layout Plain Layout

    [probs,clusters] = E_step(data, centers);
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout


\backslash
end{matlabcode}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Evaluating fuzzy clusters
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $c_{1},...,c_{k}$
\end_inset

 are the centers of the 
\begin_inset Formula $k$
\end_inset

 clusters, we define the sum of squared error (SSE) for a point 
\begin_inset Formula $X_{i}$
\end_inset

 as
\begin_inset Formula 
\[
SSE\left(X_{i}\right)=\sum_{j=1}^{k}w_{ij}^{p}\cdot dist\left(X_{i},c_{j}\right)^{2}.
\]

\end_inset


\end_layout

\begin_layout Standard
For a cluster 
\begin_inset Formula $C_{j}$
\end_inset

, we have its SSE as
\begin_inset Formula 
\[
SSE\left(C_{j}\right)=\sum_{i=1}^{n}w_{ij}^{p}\cdot dist\left(X_{i},c_{j}\right)^{2}.
\]

\end_inset


\end_layout

\begin_layout Standard
Finally, the SSE of the whole clustering is
\begin_inset Formula 
\[
SSE\left(\mathcal{C}\right)=\sum_{i=1}^{n}\sum_{j=1}^{k}w_{ij}^{p}\cdot dist\left(X_{i},c_{j}\right)^{2}.
\]

\end_inset


\end_layout

\begin_layout Subsection
Cluster quality measures
\end_layout

\begin_layout Standard
A good clustering methods will produce high quality clusters, i.e.
 clusters with the following characteristics:
\end_layout

\begin_layout Itemize

\series bold
High intra-class similarity
\series default
: cohesive within clusters.
 This means that the objects inside the clusters are similar to each other.
\end_layout

\begin_layout Itemize

\series bold
Low inter-class similarity
\series default
: distinctive between clusters.
 This means that the objects from different clusters are different.
\end_layout

\begin_layout Standard
The quality of the clustering method depends on the similarity measure used
 by the method, its implementation and its ability to discover the hidden
 patterns in the data.
\end_layout

\begin_layout Standard
Some examples of 
\series bold
quality measures
\series default
 are:
\end_layout

\begin_layout Itemize

\series bold
Sum of square distance to centroids
\series default
: the squared distance between the representative of each cluster to every
 other point in the cluster, and then summed.
 This measure is suitable for representative-based methods, but it favors
 clusters that suit the underlying distance function used:
\begin_inset Formula 
\[
SSD\left(\mathcal{C}\right)=\sum_{j=1}^{k}\sum_{i=1}^{n_{j}}dist\left(X_{i},c_{j}\right)^{2}.
\]

\end_inset


\end_layout

\begin_layout Itemize

\series bold
Intracluster to intercluster distance ratio
\series default
: we sample pairs of points from 
\begin_inset Formula $\mathcal{D}$
\end_inset

.
 Let 
\begin_inset Formula $P$
\end_inset

 be the pairs 
\begin_inset Formula $\left(X_{i},X_{j}\right)$
\end_inset

 such that 
\begin_inset Formula $X_{i}$
\end_inset

 and 
\begin_inset Formula $X_{j}$
\end_inset

 are in the same cluster, and 
\begin_inset Formula $Q$
\end_inset

 the pairs whose points are in different clusters.
 Then
\begin_inset Formula 
\[
IIDR=\frac{Intra}{Inter},
\]

\end_inset

 where
\begin_inset Formula 
\[
Intra=\sum_{\left(X_{i},X_{j}\right)\in P}\frac{dist\left(X_{i},X_{j}\right)}{\left|P\right|},
\]

\end_inset


\begin_inset Formula 
\[
Inter=\sum_{\left(X_{i},X_{j}\right)\in Q}\frac{dist\left(X_{i},X_{j}\right)}{\left|Q\right|}.
\]

\end_inset


\end_layout

\begin_layout Itemize

\series bold
Silhouette coefficient
\series default
: let 
\begin_inset Formula $D_{avg-in_{i}}$
\end_inset

 denote the average distance between a point in the cluster 
\begin_inset Formula $i$
\end_inset

 and the rest of the points in the same cluster.
 Let 
\begin_inset Formula $D_{avg-out_{i,j}}$
\end_inset

 denote the average distance between a point in the cluster 
\begin_inset Formula $i$
\end_inset

 and every other point in the cluster 
\begin_inset Formula $j$
\end_inset

.
 Let 
\begin_inset Formula $D_{min-out_{i}}=\min_{j}\left(D_{avg-out_{i,j}}\right)$
\end_inset

.
 Then:
\begin_inset Formula 
\[
SC_{i}=\frac{D_{min-out_{i}}-D_{avg-in_{i}}}{\max\left\{ D_{min-out_{i}},D_{avg-in_{i}}\right\} }.
\]

\end_inset

 It follows that 
\begin_inset Formula $SC_{i}\in\left(-1,1\right)$
\end_inset

, where large positive values indicate highly separated clusters (the distance
 to other clusters is high) and negative values are indicative of some level
 of mixing of data points from different clusters.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Frequent pattern and association rule mining
\end_layout

\begin_layout Section
Frequent Itemset Mining
\end_layout

\begin_layout Standard
Association pattern mining is usually defined in the context of supermarket
 data coontaining sets of items bought by cutomers, which are referred to
 as 
\series bold
transactions
\series default
.
 The goal is to determine associations between groups of items bought by
 customers.
 The discovered sets of items are reffered to as 
\series bold
frequent itemsets
\series default
.
\end_layout

\begin_layout Standard
This frequent itemset can then be used to generate 
\series bold
association rules
\series default
 of the form 
\begin_inset Formula 
\[
X\implies Y,
\]

\end_inset

 where 
\begin_inset Formula $X$
\end_inset

 and 
\begin_inset Formula $Y$
\end_inset

 are sets of items.
 The meaning of this is that we discovered that when some customer buys
 
\begin_inset Formula $X$
\end_inset

, it is likely that the same customer is going to/would like to by 
\begin_inset Formula $Y$
\end_inset

.
\end_layout

\begin_layout Standard
We have to be careful, nonetheless, because the raw frequency of a pattern
 is not the same as the statistical significance of the underlying correlations.
 This is why numerous models for frequent pattern mining have been proposed
 that are based on statistical significance.
\end_layout

\begin_layout Example
An intuitive example is that when someone buys bread, cheese and yogurt,
 it is probably the case that he will buy also milk and eggs:
\begin_inset Formula 
\[
\left\{ Bread,Cheese,Yogurt\right\} \implies\left\{ Milk,Eggs\right\} .
\]

\end_inset


\end_layout

\begin_layout Subsection
The model
\end_layout

\begin_layout Standard
The 
\series bold
problem of association pattern mining
\series default
 is defined on 
\emph on
unordered set-wise data
\emph default
.
\end_layout

\begin_layout Standard
The 
\series bold
database
\series default
 
\begin_inset Formula $\mathcal{T}$
\end_inset

 contains 
\begin_inset Formula $n$
\end_inset

 transactions, 
\begin_inset Formula $T_{1},...,T_{n}$
\end_inset

.
\end_layout

\begin_layout Standard
Each 
\series bold
transaction
\series default
 
\begin_inset Formula $T_{i}$
\end_inset

 is a subset of the set of all items 
\begin_inset Formula $T_{i}\subset\mathcal{U}_{items}=\mathcal{U}$
\end_inset

.
 The transactions can be represented as a multidimensional record of dimensional
ity 
\begin_inset Formula $d=\left|\mathcal{U}\right|$
\end_inset

, where the values are binary: 
\begin_inset Formula 
\[
T_{i}\left(item\right)=\begin{cases}
1 & if\ item\in T_{i}\\
0 & otherwise
\end{cases}.
\]

\end_inset


\end_layout

\begin_layout Standard
The universe of items is very large compared to the typical number of items
 in each transaction.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
An 
\series bold
itemset
\series default
 is a set of items, 
\begin_inset Formula $I\subset\mathcal{U}$
\end_inset

.
\end_layout

\begin_layout Definition
A 
\begin_inset Formula $\boldsymbol{k}$
\end_inset


\series bold
-itemset
\series default
 is an itemset with 
\begin_inset Formula $k$
\end_inset

 items, 
\begin_inset Formula $I\subset\mathcal{U}\land\left|I\right|=k$
\end_inset

.
\end_layout

\begin_layout Definition
The 
\series bold
support 
\series default
of an itemset 
\begin_inset Formula $I$
\end_inset

, 
\begin_inset Formula $sup\left(I\right)$
\end_inset

, is the fraction of the transactions in the database 
\begin_inset Formula $\mathcal{T}$
\end_inset

 that contain 
\begin_inset Formula $I$
\end_inset

 as a subset.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
The 
\series bold
frequent itemset mining problem
\series default
 is defined as follows:
\end_layout

\begin_layout Definition
Given a set of transactions 
\begin_inset Formula $\mathcal{T}=\left\{ T_{1},...,T_{n}\right\} $
\end_inset

, where each transaction 
\begin_inset Formula $T_{i}$
\end_inset

 is a subset of items from 
\begin_inset Formula $\mathcal{U}$
\end_inset

, determine all itemsets 
\begin_inset Formula $I$
\end_inset

 that occur as a subset of at least a predefined fraction 
\series bold
minsup
\series default
 of the transactions in 
\begin_inset Formula $\mathcal{T}$
\end_inset

.
\end_layout

\begin_layout Definition
The predefined fraction minsup is called 
\series bold
minimum support
\series default
.
\end_layout

\begin_layout Definition
The unique identifier of a transaction is referred to as 
\series bold
transaction identifier 
\series default
(tid).
\end_layout

\end_inset


\end_layout

\begin_layout Remark
The number of frequent itemset is generally very sensitive to the minimum
 suppor level: 
\end_layout

\begin_deeper
\begin_layout Itemize
The use of a lower minimum support level, yields a larger number of frequent
 patterns.
\end_layout

\begin_layout Itemize
If the support level is too high, no frequent patterns will be found.
\end_layout

\end_deeper
\begin_layout Remark
Therefore, an appropriate choice of the support level is crucial for discovering
 a set of frequent patterns with meaningful size.
\end_layout

\begin_layout Example
A very simple example:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tid
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Transaction
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Binary Representation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{Shirt, Trousers}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
110
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{Shirt, Jacket} 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
101
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{Shirt, Trousers, Jacket}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
111
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Example
In this case, the possible itemsets and their respective support is:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Itemset
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Support
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{Shirt}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{Trousers}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\frac{2}{3}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{Jacket}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\frac{2}{3}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{Shirt, Trousers}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\frac{2}{3}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{Shirt, Jacket}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\frac{2}{3}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{Trousers, Jacket}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\frac{1}{3}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{Shirt, Trousers, Jacket}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\frac{1}{3}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Example
If we select 
\begin_inset Formula $minsup=\frac{1}{3}$
\end_inset

, all possible itemsets would be selected.
\end_layout

\begin_layout Example
If we select 
\begin_inset Formula $minsup=1$
\end_inset

, only {Shirt} would be selected.
\end_layout

\begin_layout Standard
Now, let's think about how many possible itemsets there are: if an itemset
 if a subset of 
\begin_inset Formula $\mathcal{U}$
\end_inset

, then there are 
\begin_inset Formula $2^{card\left(\mathcal{U}\right)}$
\end_inset

 possible itemsets.
 This means that computing all their supports as in the previous example
 would take an exponential amount of time to the cardinality of the number
 of items.
 Not only this, but the database needs also to be accessed for counting,
 comparing,...
 So it is easy to see how this problem becomes rapidly innaccessible.
 Then, it is compulsory to find better ways to perform this counting and
 comparing, or to be able to discard itemsets even before counting.
 For this, there are some very convenient properties of itemsets:
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Plain Layout

\series bold
Property 1: Support Monotonicity Property
\end_layout

\begin_layout Plain Layout
The support of every subset 
\begin_inset Formula $J\subset I$
\end_inset

 is at greater than or equal to the support of 
\begin_inset Formula $I$
\end_inset

:
\begin_inset Formula 
\[
sup\left(J\right)\geq sup\left(I\right),\ \forall J\subset I.
\]

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This is because all subsets of the itemset 
\begin_inset Formula $I$
\end_inset

 are also itemsets.
 As the itemset 
\begin_inset Formula $I$
\end_inset

 appears in 
\begin_inset Formula $sup\left(I\right)$
\end_inset

 fraction of the total transactions, all its subsets also appears at least
 in the same transactions.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Plain Layout

\series bold
Property 2: Downward Closure Property
\end_layout

\begin_layout Plain Layout
Every subset of a frequent itemset is also frequent.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This is a natural implication of the previous property, and it is very useful:
 when we discover a frequent itemset, we don't need to check its subsets
 because it is already assured that they are frequent, too.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
A frequent itemset is 
\series bold
maximal
\series default
 at a given minimum support level 
\begin_inset Formula $minsup$
\end_inset

 if it is frequent, and no superset of it is also frequent.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The possible itemsets given a set of items can be conceptually arranged
 in the form of a 
\series bold
lattice
\series default
 
\series bold
of itemsets
\series default
, which contains one node for each of the 
\begin_inset Formula $2^{\left|\mathcal{U}\right|}$
\end_inset

 sets drawn from the universe of items.
 An edge exists between a pair of nodes if the corresponding sets differ
 by exactly one item.
 The lattice represents the search space of frequent patterns and it is
 separated into frequent and infrequent itemsets by a 
\series bold
border
\series default
.
\end_layout

\begin_layout Example
A lattice of itemset with 4 elements.
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename lattice_itemset.png
	scale 60

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
Association rule generation framework
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "def:confidence"

\end_inset

Let 
\begin_inset Formula $X,Y$
\end_inset

 be two itemsets.
 The 
\series bold
confidence
\series default
 
\series bold
of the rule
\series default
, 
\begin_inset Formula $conf\left(X\implies Y\right)$
\end_inset

, is the conditional probability of 
\begin_inset Formula $X\cup Y$
\end_inset

 ocurring in a transaction, given that the transaction contains 
\begin_inset Formula $X$
\end_inset

:
\begin_inset Formula 
\[
conf\left(X\implies Y\right)=Pr\left(X\cup Y|X\right)=\frac{sup\left(X\cup Y\right)}{sup\left(X\right)}.
\]

\end_inset


\begin_inset Formula $X$
\end_inset

 is called the 
\series bold
antecedent 
\series default
of the rule and 
\begin_inset Formula $Y$
\end_inset

 is the 
\series bold
consequent
\series default
.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
Let 
\begin_inset Formula $X,Y$
\end_inset

 be two itemsets.
 The rule 
\begin_inset Formula $X\implies Y$
\end_inset

 is said to be an 
\series bold
association rule at a minimum support of 
\begin_inset Formula $\boldsymbol{minsup}$
\end_inset

 and minimum confidence of 
\begin_inset Formula $\boldsymbol{minconf}$
\end_inset

 
\series default
if it satisfies:
\end_layout

\begin_layout Enumerate
The support of the itemset 
\begin_inset Formula $X\cup Y$
\end_inset

 is at least 
\begin_inset Formula $minsup$
\end_inset

.
\end_layout

\begin_layout Enumerate
The confidence of the rule 
\begin_inset Formula $X\implies Y$
\end_inset

 is at least 
\begin_inset Formula $minconf$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here, the first criterion ensures that there are enough transactions to
 believe that the rule has statistical relevance.
 The second criterion ensures that the rule is strength enough in terms
 of conditional probabilities.
\end_layout

\begin_layout Standard
The overall procedure for association rule generation uses two phases:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
Phase 1)
\end_layout

\end_inset

 The frequent itemsets are generated at the minimum support of 
\begin_inset Formula $minsup$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
Phase 2)
\end_layout

\end_inset

 The association rules are generated from the frequent itemsets at the minimum
 confidence level of 
\begin_inset Formula $minconf$
\end_inset

.
\end_layout

\begin_layout Standard
The first phase is more computationally intensive, so we are focusing on
 it from now on.
\end_layout

\begin_layout Subsection
Frequent itemset mining algorithms
\end_layout

\begin_layout Subsubsection
Brute Force Algorithms
\end_layout

\begin_layout Standard
For a universe of items 
\begin_inset Formula $\mathcal{U}$
\end_inset

, there are 
\begin_inset Formula $2^{\left|\mathcal{U}\right|}-1$
\end_inset

 distinct subsets, excluding the empty set.
 A naïve idea would be to generate all these candidate itemsets and count
 their suppor against the transaction database 
\begin_inset Formula $\mathcal{T}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
A 
\series bold
candidate itemset
\series default
 is an itemset that can be frequent, so it is needed to be checked.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now, we can verified the candidates against the transaction database by
 support counting, checking whether a given itemset 
\begin_inset Formula $I$
\end_inset

 is subset of each transaction 
\begin_inset Formula $T_{i}\in\mathcal{T}$
\end_inset

.
\end_layout

\begin_layout Standard
This approach is likely to be impractical when the universe of items is
 large.
\end_layout

\begin_layout Subsubsection*
A little tweak
\end_layout

\begin_layout Standard
The brute-force approach can be made faster by observing that no 
\begin_inset Formula $\left(k+1\right)$
\end_inset

-patterns are frequent if no 
\begin_inset Formula $k$
\end_inset

-patterns are frequent (this follows from the downward closure property).
 Thus, we can enumerate and count in increasing length for the patterns.
\end_layout

\begin_layout Standard
For sparse transaction databases, the value of 
\begin_inset Formula $l$
\end_inset

 (the largest frequent itemset) is usually small compared to 
\begin_inset Formula $\left|\mathcal{U}\right|$
\end_inset

.
 At this point, one can terminate.
 This approach is orders of magnitude faster, but its computational complexity
 is still not satisfactory for large values of 
\begin_inset Formula $\mathcal{U}$
\end_inset

.
\end_layout

\begin_layout Subsubsection*
Ideas to apply
\end_layout

\begin_layout Standard
Better algorithms can be developed by using one or more of the following
 approaches:
\end_layout

\begin_layout Enumerate
Reduce the size of the explored search space by prunning cadidate itemsets
 using tricks.
\end_layout

\begin_layout Enumerate
Counting the support of each candidate more efficiently by prunning transactions
 that are know to be irrelevant.
\end_layout

\begin_layout Enumerate
Using compact data structures to represent either candidates of transaction
 databases that suppor efficient counting.
\end_layout

\begin_layout Subsubsection
The Apriori Algorithm
\end_layout

\begin_layout Standard
The Apriori algorithm uses the downward closure property to prune candidates.
 If an itemset is infrequent, then all its supersets are also infrequent,
 so we don't need to count them.
\end_layout

\begin_layout Standard
The Apriori algorithm works as follows:
\end_layout

\begin_layout Enumerate
Count the support of the individual items to generate frequent 1-itemsets.
\end_layout

\begin_layout Enumerate
Combine the frequent 1-itemsets to generate candidate 2-itemsets.
 
\end_layout

\begin_layout Enumerate
Count the support of the candidate 2-itemsets to generate frequent 2-itemsets.
\end_layout

\begin_layout Enumerate
...
\end_layout

\begin_layout Standard
In general:
\end_layout

\begin_layout Enumerate
Combine the frequent 
\begin_inset Formula $\left(k-1\right)$
\end_inset

-itemsets to generate candidate 
\begin_inset Formula $k$
\end_inset

-itemsets.
\end_layout

\begin_layout Enumerate
Prune candidate 
\begin_inset Formula $k$
\end_inset

-itemsets which has some subset which is not frequent.
\end_layout

\begin_layout Enumerate
Count the support of the candidate 
\begin_inset Formula $k$
\end_inset

-itemsets to generate frequent 
\begin_inset Formula $k$
\end_inset

-itemsets.
\end_layout

\begin_layout Enumerate
Repeat until there are no bigger frequent itemsets.
\end_layout

\begin_layout Standard
The algorithm is detailed in Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Apriori(Transactions-T,-Minimum"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Python,morekeywords={end, do, is, not}"
inline false
status open

\begin_layout Plain Layout

k = 1
\end_layout

\begin_layout Plain Layout

F1 = {Frequent 1-itemsets}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

while Fk is not empty do
\end_layout

\begin_layout Plain Layout

	Generate C(k+1) by joining itemset-pairs of Fk
\end_layout

\begin_layout Plain Layout

	Prune itemsets from C(k+1) that violate the downward closure property
\end_layout

\begin_layout Plain Layout

	Determine F(k+1) by support counting (C(k+1),T)
\end_layout

\begin_layout Plain Layout

	k = k+1
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

return Union(F(i) for all i=1..k)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:Apriori(Transactions-T,-Minimum"

\end_inset

Apriori(Transactions T, Minimum Support minsup)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Remark
The downward closure property ensures that the candidate set generated does
 not miss any itemset that is frequent.
 This non-repetitive and exhaustive way of generating candidates can be
 interpreted in the context of a conceptual hierarchy of the patterns known
 as 
\series bold
enumeration tree
\series default
.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
To do the pruning, we check generated elements against non-frequent itemsets
 already generated.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
The support counting process is the most expensive part because it depends
 on the size of 
\begin_inset Formula $\mathcal{T}$
\end_inset

.
 The level-wise approach ensures that the algorithm is relatively efficient
 from a disk-access perspective: each set of candidates in 
\begin_inset Formula $C_{k}$
\end_inset

 can be counted in a single pass over the data without the need for random
 disk accesses.
 
\end_layout

\begin_layout Remark
Nonetheless, the counting procedure is still expensive.ç
\end_layout

\begin_layout Example
We are going to manually run an Apriori algorithm for a simple database
 using 
\begin_inset Formula $minsup=2$
\end_inset

 (the minsup can be also indicated as a count, instead of as a frequency).
 The database is
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="11" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Database
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
TID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Transaction
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A,B,E
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B,D
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B,C
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A,B,D
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A,C
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B,C
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A,C
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A,B,C,E
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A,B,C
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Example
Let's compute 
\begin_inset Formula $F_{1}$
\end_inset

 directly:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
F1
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Itemset
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Count
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
D
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Example
From this, we see that all 1-itemsets are frequent, so we are generating
 all possible 2-itemsets as C2, and counting them:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="12" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
C2
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Itemsets
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Count
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A,B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A,C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color red
A,D
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color red
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A,E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B,C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B,D
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B,E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color red
C,D
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color red
0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color red
C,E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color red
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color red
D,E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color red
0
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\implies$
\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
F2
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Itemsets
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Count
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A,B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A,C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A,E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B,C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B,D
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B,E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Example
We have coloured in red the infrequent itemset and generated F2.
 Now we can generate C3 by combining itemsets from F2.
 For this, we need to search for itemsets that share all values but one.
 For example: {A,B} and {A,C} are combinated to obtain {A,B,C}.
 After getting all possibilities, we find C3 and count:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
C3
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Itemset
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Count
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A,B,C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color purple
A,B,D
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A,B,E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color purple
A,C,D
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color purple
A,C,E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color purple
B,C,D
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color purple
B,C,E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color purple
B,D,E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\implies$
\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
F3
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Itemset
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Count
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A,B,C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A,B,E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Example
The purple coloured itemsets are pruned because they contain some of the
 infrequent itemsets of C2.
 The rest are still frequent, so we continue with the process.
 We combine the only two itemsets left to get {A,B,C,E} as C4.
 Note, nonetheless that {C,E} is an infrequent itemset of C2, so we will
 prune it and we are in fact done.
\end_layout

\begin_layout Example
The frequent itemsets with 
\begin_inset Formula $minsup=2$
\end_inset

 are F1, F2 and F3.
\end_layout

\begin_layout Subsubsection*
Limits of Apriori
\end_layout

\begin_layout Itemize
Apriori makes use of the downward closure property (sometimes called apriori
 property), which is nice.
\end_layout

\begin_layout Itemize
The lattice is traversed in a general-to-specific way, it is possible to
 a bi-directional traversal.
\end_layout

\begin_layout Itemize
It is done in a breadth-first manner, it might be done in a depth-first
 way.
\end_layout

\begin_layout Itemize
The generate-and test strategy:
\end_layout

\begin_deeper
\begin_layout Itemize
Generate is 
\begin_inset Formula $O\left(\frac{\left|\mathcal{U}\right|}{k}\right)$
\end_inset

 for 
\begin_inset Formula $k$
\end_inset

-candidates.
\end_layout

\begin_layout Itemize
Test is the counting, in which we are traversing the whole database, 
\begin_inset Formula $O\left(\left|\mathcal{T}\right|\right)$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Subsubsection*
Apriori improved with tricks
\end_layout

\begin_layout Standard
In Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Apriori_improved(Transactions-T,"
plural "false"
caps "false"
noprefix "false"

\end_inset

 it is detailed an improved version of the Apriori algorithm.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "morekeywords={foreach, in, and, join, end, do, is}"
inline false
status open

\begin_layout Plain Layout

	k = 1
\end_layout

\begin_layout Plain Layout

	F1 = {Frequent 1-itemsets}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	while Fk is not empty do
\end_layout

\begin_layout Plain Layout

		C(k+1) = generate(Lk)
\end_layout

\begin_layout Plain Layout

		for tran in T do
\end_layout

\begin_layout Plain Layout

			C(tran) = subset(C(k+1),tran)
\end_layout

\begin_layout Plain Layout

			for cand in C(tran)
\end_layout

\begin_layout Plain Layout

				cand.count++
\end_layout

\begin_layout Plain Layout

			end
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

		L(k+1)={cand in C(k+1) | cand.count >= minsup}
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	return Union(F(i) for i=1..k)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

procedure generate(Lk)
\end_layout

\begin_layout Plain Layout

	foreach itemset1 in Lk
\end_layout

\begin_layout Plain Layout

		foreach itemset2 in Lk
\end_layout

\begin_layout Plain Layout

			if itemset1[1]=itemset2[1] and ...
 and itemset1[k-1] = itemset2[k-1] and itemset1[k] < itemset2[k]
\end_layout

\begin_layout Plain Layout

				c = itemset1 join itemset2
\end_layout

\begin_layout Plain Layout

				if has_infreq_subsets(c,Lk)
\end_layout

\begin_layout Plain Layout

					continue
\end_layout

\begin_layout Plain Layout

				else
\end_layout

\begin_layout Plain Layout

					add c to C(k+1)
\end_layout

\begin_layout Plain Layout

				end
\end_layout

\begin_layout Plain Layout

			end
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	return C(k+1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

procedure has_infreq_subsets(c,Lk)
\end_layout

\begin_layout Plain Layout

	foreach k-subset s of c
\end_layout

\begin_layout Plain Layout

		if s not in Lk
\end_layout

\begin_layout Plain Layout

			return TRUE
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	return FALSE
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Apriori_improved(Transactions T, Minimum support minsup)
\begin_inset CommandInset label
LatexCommand label
name "alg:Apriori_improved(Transactions-T,"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
More Apriori Tricks
\end_layout

\begin_layout Itemize
Transaction reduction: a transaction that does not contain any frequent
 
\begin_inset Formula $k$
\end_inset

-itemsets, cannot contain any frequent 
\begin_inset Formula $\left(k+1\right)$
\end_inset

-itemset either, so it can be removed to make counting faster.
\end_layout

\begin_layout Itemize
Partitioning: divide the database into a set of disjoint partitions.
 Find all frequent itemsets in every partition.
 A local frequent itemset may not be frequent for the whole database, but
 a frequent itemset must be frequent in at least one partition.
 The best about this approach is that it allows for parallel processing
 and the partition size can be selected for it to fit in memory.
\end_layout

\begin_layout Itemize
Sampling: perform Apriori on a random sample of the data.
 Rule accuracy is harmed, but efficiency is improved.
\end_layout

\begin_layout Subsubsection
FP-Growth
\end_layout

\begin_layout Standard
Even though Apriori greatly improves the efficiency of the solution of the
 association pattern mining in comparison to the brute force approach, we
 have seen that it can still suffer from inefficiencies when the database
 is big.
 Particularly, counting is very costly and when there are lots of items
 we will need to count many times.
 There is an improved solution for the problem: 
\series bold
Frequent Pattern Growth (FP-Growth)
\series default
 which:
\end_layout

\begin_layout Enumerate
Transforms the database into a compressed data structur called 
\series bold
FP-Tree
\series default
, which retains frequent itemsets information.
\end_layout

\begin_layout Enumerate
Mines the FP-tree for frequent itemsets by:
\end_layout

\begin_deeper
\begin_layout Enumerate
Divide it into a set of conditional databases, the 
\series bold
conditional pattern bases
\series default
, each associated eith one frequent item.
\end_layout

\begin_layout Enumerate
Mines each of these patterns separately to generate association rules, without
 the need to re-count the original database.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
A 
\series bold
FP-Tree
\series default
 is a trie (prefix tree) data structure, which acts as a compressed representait
on of a conditional database.
\end_layout

\begin_layout Itemize
The path from the root to a leaf represents a repeated sub-transaction (frequent
 pattern) in the database.
\end_layout

\begin_layout Itemize
The path from the root to an internal node represents either a frequent
 pattern or a prefix.
\end_layout

\begin_layout Itemize
Each node is associated with a count, which is the number of transactions
 in the database containing the path to this node.
\end_layout

\begin_layout Itemize
The prefixes are sorted in the order from the most frequent to the least
 frequent to leverage the prefix-based comrpession.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The algorithm for FP-Growth is detailed in Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:FP-Growth(FP-Tree-FPT,-Minimum"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Python,morekeywords={end, from, remove, reconstruct, use, containing, extract, report, in, do}"
inline false
status open

\begin_layout Plain Layout

if FPT is a single path
\end_layout

\begin_layout Plain Layout

	determine all combinations C of nodes on the path, report Union(C,P) as
 frequent
\end_layout

\begin_layout Plain Layout

else
\end_layout

\begin_layout Plain Layout

	foreach item i in FPT do
\end_layout

\begin_layout Plain Layout

		report Pi = Union(i,P) as frequent
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		use pointers to extract conditional prefix paths from FPT containing i
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

		readjust counts of prefix paths
\end_layout

\begin_layout Plain Layout

		remove i
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		remove infrequent items from prefix paths
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		reconstruct FPTi
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		if FPTi not empty
\end_layout

\begin_layout Plain Layout

			FP-Growth(FPTi, minsup, Pi)
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:FP-Growth(FP-Tree-FPT,-Minimum"

\end_inset

FP-Growth(FP-Tree FPT, Minimum Support minsup, Current Suffix P)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Basically, what FP-Growth does is recursively find all frequent itemsets
 ending with a particular suffix by splitting the probelm into smaller subproble
ms.
\end_layout

\begin_layout Example
Let's use FP-Growth on the previous example database:
\end_layout

\begin_deeper
\begin_layout LyX-Code
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="11" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Database
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
TID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Transaction
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A,B,E
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B,D
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B,C
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A,B,D
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A,C
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B,C
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A,C
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A,B,C,E
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A,B,C
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Example
First, we need to construct the FP-Tree.
 For this purpose, we compute the frequent 1-itemsets and reorder them in
 the count order:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
F1
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Itemset
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Count
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
D
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\overset{In\ descending\ order}{\implies}$
\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
F1
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Itemset
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Count
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
D
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Example
Now we reorder the transactions in the database following this same ordering:
\end_layout

\begin_deeper
\begin_layout LyX-Code
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="11" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Database
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
TID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Transaction
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B,A,E
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B,D
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B,C
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B,A,D
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A,C
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B,C
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A,C
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B,A,C,E
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B,A,C
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Example
And now we construct the FP-Tree.
 We start with the root labeled as NULL, and then add the transactions one
 by one, reusing the prefixes when we can, and keeping a counter for each
 node.
 Every time we traverse a node, we increase the counter.
 The first transaction would be entered as:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename fpgrowth_0.png
	scale 50

\end_inset


\end_layout

\end_deeper
\begin_layout Example
The second one:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename fpgrowth_1.png
	scale 50

\end_inset


\end_layout

\end_deeper
\begin_layout Example
The third one:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename fpgrowth_2.png
	scale 50

\end_inset


\end_layout

\end_deeper
\begin_layout Example
And so on...
 Until all transactions are entered in the tree:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename fpgrowth_3.png
	scale 50

\end_inset


\end_layout

\end_deeper
\begin_layout Example
Now, we connect each item in the ordered F1 to one node in the database
 corresponding to the same item, and all nodes that are equal are connected,
 too.
 Like this:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename fpgrowth_4.png
	scale 50

\end_inset


\end_layout

\end_deeper
\begin_layout Example
And now we proceed with the algorithm.
 We start with the least frequent item, 
\begin_inset Formula $E$
\end_inset

.
 
\end_layout

\begin_deeper
\begin_layout Itemize
For item 
\begin_inset Formula $E$
\end_inset

, the conditional pattern base contains two itemsets: 
\begin_inset Formula $\left\{ \left[\left\{ B,A\right\} :1\right],\left[\left\{ B,A,C\right\} :1\right]\right\} $
\end_inset

.
 Thus, it follows that we have 
\begin_inset Formula $\left\{ \left[\left\{ B,A\right\} :2\right]\right\} $
\end_inset

, so the conditional FP-Tree is
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename cond_fptree_0.png
	scale 50

\end_inset


\end_layout

\begin_layout Standard
Thus, the generated frequent patterns are: 
\begin_inset Formula $\left\{ \left[\left\{ B,E\right\} :2\right],\left[\left\{ A,E\right\} :2\right],\left[\left\{ B,A,E\right\} :2\right]\right\} $
\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize
For item 
\begin_inset Formula $D,$
\end_inset

 the conditional pattern base also contains two itemsets: 
\begin_inset Formula $\left\{ \left[\left\{ B,A\right\} :1\right],\left[\left\{ B\right\} :1\right]\right\} $
\end_inset

.
 So now we have 
\begin_inset Formula $\left\{ \left[\left\{ B\right\} :2\right]\right\} $
\end_inset

 and the conditional FP-Tree is
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename cond_fptree_1.png
	scale 50

\end_inset


\end_layout

\begin_layout Standard
And the generated frequent patterns are 
\begin_inset Formula $\left\{ \left[\left\{ B,D\right\} :2\right]\right\} $
\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize
For item 
\begin_inset Formula $C,$
\end_inset

 the conditional pattern base contains one itemset: 
\begin_inset Formula $\left\{ \left[\left\{ B\right\} :4\right]\right\} $
\end_inset

.
 The conditional FP-Tree ends up being
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename cond_fptree_2.png
	scale 50

\end_inset


\end_layout

\begin_layout Standard
And the generated frequent patterns are 
\begin_inset Formula $\left\{ \left[\left\{ B,A,C\right\} :2\right],\left[\left\{ B,C\right\} :2\right],\left[\left\{ A,C\right\} :2\right]\right\} $
\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize
For item 
\begin_inset Formula $A,$
\end_inset

 the conditional pattern base contains three itemsets: 
\begin_inset Formula $\left\{ \left[\left\{ B,A\right\} :2\right],\left[\left\{ B\right\} :2\right],\left[\left\{ A\right\} :2\right]\right\} $
\end_inset

.
 So now we have the three of them and no combination.
 The conditional FP-Tree ends up being
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename cond_fptree_3.png
	scale 50

\end_inset


\end_layout

\begin_layout Standard
And the generated frequent patterns are 
\begin_inset Formula $\left\{ \left[\left\{ B,A\right\} :4\right]\right\} $
\end_inset

.
\end_layout

\end_deeper
\end_deeper
\begin_layout Example
And that's it!
\end_layout

\begin_layout Subsubsection*
Why FP-Growth outperforms Apriori?
\end_layout

\begin_layout Itemize
FP-Growth counts the database only once.
 This fact by itself is already a huge improvement, because Apriori needs
 to count one time per candidate.
\end_layout

\begin_layout Itemize
Also, Apriori needs indeed to create the candidates, which can also be expensive.
 FP-Growth, on the other hand, does not do a generation step, because the
 frequent itemsets are naturally obtained.
\end_layout

\begin_layout Itemize
In relation to the last point, Apriori creates candidates which end up being
 infrequent, while this does not happen with FP-Growth.
\end_layout

\begin_layout Itemize
Space complexity of FP-Growth is smaller because we don't need to store
 the candidates, only the FP-Tree, which is not much bigger than the number
 of items in 
\begin_inset Formula $\mathcal{U}$
\end_inset

.
 Also, the database is not needed after the FP-Tree is computed, so we have
 more memory to use for the tree itself.
\end_layout

\begin_layout Subsection
Mining Association Rules
\end_layout

\begin_layout Standard
Once the frequent itemsets have been found, it is time to obtain the association
 rules, which are the goal we were aiming at since the beggining.
 To do this, a common approach is to follow:
\end_layout

\begin_layout Enumerate
For each frequent itemset 
\begin_inset Formula $I$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Enumerate
Generate subsets of 
\begin_inset Formula $I$
\end_inset

, 
\begin_inset Formula $\emptyset\neq S\subset I$
\end_inset

.
\end_layout

\begin_layout Enumerate
For every 
\begin_inset Formula $\emptyset\neq S\subset I$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Enumerate
Output rule 
\begin_inset Formula $S\implies I\setminus S$
\end_inset

 if 
\begin_inset Formula $conf\left(S\implies I\setminus S\right)\geq minconf$
\end_inset

.
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsubsection
Evaluating association rules
\end_layout

\begin_layout Standard
In Definition 
\begin_inset CommandInset ref
LatexCommand ref
reference "def:confidence"
plural "false"
caps "false"
noprefix "false"

\end_inset

 we saw the concept of confidence, but there are more measures to assess
 how 'good' a rule is, as the lift or the correlation analysis.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
The 
\series bold
lift
\series default
 is
\begin_inset Formula 
\[
lift\left(X\implies Y\right)=\frac{sup\left(X\cup Y\right)}{sup\left(X\right)\cdot sup\left(Y\right)}.
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Remark
If 
\begin_inset Formula $lift=1$
\end_inset

, then 
\begin_inset Formula $X$
\end_inset

 and 
\begin_inset Formula $Y$
\end_inset

 are independent.
\end_layout

\begin_layout Remark
If 
\begin_inset Formula $lift>1$
\end_inset

, then 
\begin_inset Formula $X$
\end_inset

 and 
\begin_inset Formula $Y$
\end_inset

 have some dependency that is proportional to the lift value.
\end_layout

\begin_layout Remark
If 
\begin_inset Formula $lift<1$
\end_inset

 then 
\begin_inset Formula $X$
\end_inset

 and 
\begin_inset Formula $Y$
\end_inset

 are contradicting, i.e., the existence of 
\begin_inset Formula $X$
\end_inset

 discourages 
\begin_inset Formula $Y$
\end_inset

 and vice versa.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
The 
\series bold
correlation coefficient
\series default
 is
\begin_inset Formula 
\[
\Phi=\frac{TT\cdot FF-TF\cdot FT}{\sqrt{\_T\cdot\_F\cdot T\_\cdot F\_}},
\]

\end_inset

 where we are assuming a rule 
\begin_inset Formula $A\implies B$
\end_inset

 and:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $TT$
\end_inset

 is how many times 
\begin_inset Formula $A$
\end_inset

 is True and 
\begin_inset Formula $B$
\end_inset

 is True
\end_layout

\begin_layout Itemize
\begin_inset Formula $FF$
\end_inset

 is how many times 
\begin_inset Formula $A$
\end_inset

 is False and 
\begin_inset Formula $B$
\end_inset

 is False
\end_layout

\begin_layout Itemize
\begin_inset Formula $TF$
\end_inset

 is how many times 
\begin_inset Formula $A$
\end_inset

 is True and 
\begin_inset Formula $B$
\end_inset

 is False
\end_layout

\begin_layout Itemize
\begin_inset Formula $FT$
\end_inset

 is how many times 
\begin_inset Formula $A$
\end_inset

 is False and 
\begin_inset Formula $B$
\end_inset

 is True
\end_layout

\begin_layout Itemize
\begin_inset Formula $T\_/F\_$
\end_inset

 is how many times 
\begin_inset Formula $A$
\end_inset

 is True/False
\end_layout

\begin_layout Itemize
\begin_inset Formula $\_T/\_F$
\end_inset

 is how many times 
\begin_inset Formula $B$
\end_inset

 is True/False
\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Remark
In this case, if 
\begin_inset Formula $\Phi=-1$
\end_inset

 there is a perfect negative correlation.
\end_layout

\begin_layout Remark
If 
\begin_inset Formula $\Phi=1$
\end_inset

 there is a perfect positive correlation.
\end_layout

\begin_layout Remark
If 
\begin_inset Formula $\Phi=0$
\end_inset

 the two itemsets are statistically independent.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
The definitions of 
\begin_inset Formula $TT,FT$
\end_inset

,...
 can be summarized as in the following table:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\lnot$
\end_inset

B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Total
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
TT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
TF
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T_
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\lnot$
\end_inset

A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FF
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
F_
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Total
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
_T
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
_F
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Example
Imagine we have the rule 
\begin_inset Formula $\left\{ Tea\right\} \implies\left\{ Coffee\right\} $
\end_inset

 with the following data:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Coffee
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\lnot$
\end_inset

Coffee
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Total
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tea
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
150
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
50
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
200
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\lnot$
\end_inset

Tea
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
650
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
150
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
800
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Total
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
800
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
200
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Example
In this case, the confidence is
\begin_inset Formula 
\[
conf\left(\left\{ Tea\right\} \implies\left\{ Coffee\right\} \right)=\frac{150}{200}=0.75,
\]

\end_inset

 which is a high confidence...
 but 
\begin_inset Formula $sup\left(Coffee\right)=0.8$
\end_inset

, which means that drinking coffee in fact decreases the probability of
 drinking coffee!
\end_layout

\begin_layout Example
Now, the lift is
\begin_inset Formula 
\[
lift\left(\left\{ Tea\right\} \implies\left\{ Coffee\right\} \right)=\frac{0.15}{0.2\cdot0.8}=0.9375<1,
\]

\end_inset

 which means that Tea and Coffee are negatively correlated.
 This insight is better than the one obtained by only looking at the value
 of the confidence.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Example
But let's now look at this example:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
p
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\lnot$
\end_inset

p
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Total
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
q
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
880
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
50
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
930
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\lnot$
\end_inset

q
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
50
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
70
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Total
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
930
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
70
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\lnot$
\end_inset

r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Total
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
50
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
70
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\lnot$
\end_inset

s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
50
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
880
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
930
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Total
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
70
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
930
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Example
In this case
\begin_inset Formula 
\[
lift\left(\left\{ p\right\} \implies\left\{ q\right\} \right)=1.02
\]

\end_inset

 and
\begin_inset Formula 
\[
lift\left(\left\{ r\right\} \implies\left\{ s\right\} \right)=4.08,
\]

\end_inset

 but 
\begin_inset Formula $\left(p,q\right)$
\end_inset

 appear together 88% of the time, while 
\begin_inset Formula $\left(r,s\right)$
\end_inset

 appear together only 2% of the time.
 Confidence is a better indicator in this case.
 The problem here is that 
\begin_inset Formula $r,s$
\end_inset

 appears in a small portion of records in the data.
\end_layout

\begin_layout Subsubsection
How to choose a measure?
\end_layout

\begin_layout Standard
We have seen that we can obtain different conclusions by looking at different
 measures, so the choice of the measure is important because it will affect
 the results.
 A good choice must be based on a clear understanding of the measure and
 its properties, so we are aware of the flaws it entails and can leverage
 them for good.
\end_layout

\begin_layout Standard
We can also asses rules using interactive visualizations, subjective measures
 based on domain experience,...
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Stream data mining
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Outlier mining
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Spatial and Spatiotemporal data mining
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintCited"
bibfiles "dm_bib"
options "bibtotoc,plain"

\end_inset


\end_layout

\end_body
\end_document
