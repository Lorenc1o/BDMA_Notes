#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage[all]{xy}
\end_preamble
\use_default_options true
\begin_modules
tcolorbox
customHeadersFooters
theorems-ams-bytype
theorems-sec-bytype
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=blue, urlcolor=blue, citecolor=blue, pdfstartview={FitH}, unicode=true"
\papersize a4paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\boxbgcolor #62a0ea
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 3cm
\rightmargin 2cm
\bottommargin 3cm
\headheight 2cm
\headsep 1cm
\footskip 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
INFOH417 - Database Systems Architecture
\end_layout

\begin_layout Date
Fall 2022
\end_layout

\begin_layout Author
Jose Antonio Lorencio Abril
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 1200px-Université_libre_de_Bruxelles_(logo).svg.png
	scale 10

\end_inset


\end_layout

\begin_layout Standard
\align right
Professor: Mahmoud Sakr
\end_layout

\begin_layout Standard
\align right
Student e-mail: jose.lorencio.abril@ulb.be
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Address
This is a summary of the course 
\emph on
Database Systems Architecture
\emph default
, taught at the Université Libre de Bruxelles by Professor Mahmoud Sakr
 in the academic year 22/23.
 Most of the content of this document is adapted from the course notes by
 Sakr, 
\begin_inset CommandInset citation
LatexCommand cite
key "Sakr2022"
literal "false"

\end_inset

, so I won't be citing it all the time.
 Other references will be provided when used.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList algorithm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Query Planning: Translating SQL into Relational Algebra
\end_layout

\begin_layout Section
Relational Algebra
\end_layout

\begin_layout Standard
We are going to start with some definitions:
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
A 
\series bold
relation
\series default
 is a table whose columns have names, called 
\series bold
attributes
\series default
.
 The set of all attributes is called the 
\series bold
schema of the relation
\series default
.
 The rows of the table are tuples of values for each of the attributes,
 and are called simply 
\series bold
tuples
\series default
.
 We are going to denote 
\begin_inset Formula $R$
\end_inset

 a relation, and we will express it as 
\begin_inset Formula $R\sim\left[A_{1},...,A_{n}\right]$
\end_inset

 to indicate the schema of the relation, 
\begin_inset Formula $A_{i},i=1,...,n$
\end_inset

 are the attributes of the schema.
 If two relations, 
\begin_inset Formula $R$
\end_inset

 and 
\begin_inset Formula $R'$
\end_inset

, share the same schema, we will simply write 
\begin_inset Formula $R\simeq R'$
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
Note that the relationship 
\begin_inset Formula $\simeq$
\end_inset

 defines an equivalence relationship whose equivalence groups are all relations
 with the same schema.
\end_layout

\end_inset

.
\end_layout

\begin_layout Definition
A relation is 
\series bold
set-based
\series default
 if there are no duplicate tuples in it.
 If this is not the case, the relation is 
\series bold
bag-based
\series default
.
\end_layout

\begin_layout Definition
A 
\series bold
relational algebra operator
\series default
 takes as input 1 or more relations and produces as output a new relation.
 More formally, if we have a set of relations 
\begin_inset Formula $\Sigma=\left\{ R_{1},...,R_{n}\right\} \subset\mathcal{U}$
\end_inset

, where 
\begin_inset Formula $\mathcal{U}$
\end_inset

 identifies the set of all possible relations, a relational algebra operator
 is a function
\begin_inset Formula 
\[
Op:\mathcal{P}\left(\Sigma\right)\rightarrow\mathcal{U},
\]

\end_inset

 being 
\begin_inset Formula $\mathcal{P}\left(\Sigma\right)$
\end_inset

 the power set of 
\begin_inset Formula $\Sigma$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Example
\begin_inset CommandInset label
LatexCommand label
name "ex:1-1"

\end_inset

As an example, we can take 
\begin_inset Formula $\Sigma=\left\{ StarsIn,MovieStar\right\} $
\end_inset

, 
\begin_inset Formula $StartsIn=\left[starName,filmName\right]$
\end_inset

, 
\begin_inset Formula $MovieStar=\left[name,birthDate\right]$
\end_inset

.
 In this case, an operator 
\begin_inset Formula $Op$
\end_inset

 could be such that produces the relation that contains all names of films
 in which some movie stars in 
\begin_inset Formula $MovieStar$
\end_inset

 born in 1960 participated.
\end_layout

\begin_layout Standard
In this example, we have explained what we would like our operator to do,
 but we need some way to actually compute this.
 For this, there are some basic operators that can be combined to create
 complex operators.
\end_layout

\begin_layout Subsection
The extended relational algebra
\end_layout

\begin_layout Standard
Let's define a set of operators that are useful:
\end_layout

\begin_layout Standard
The 
\series bold
union
\series default
 of two relations with the same schema returns another relation with the
 same schema and all tuples in any of the two input relations: Let 
\begin_inset Formula $R_{i},R_{j}\in\Sigma$
\end_inset

 such that 
\begin_inset Formula $R_{i}\simeq R_{j}$
\end_inset

, then
\begin_inset Formula 
\[
R_{i}\cup R_{j}=\left\{ x|x\in R_{i}\ \lor\ x\in R_{j}\right\} \simeq R_{i}\simeq R_{j}.
\]

\end_inset


\end_layout

\begin_layout Standard
Note, nonetheless, that the result of the operator 
\begin_inset Formula $\cup$
\end_inset

 is different in set-based relations than in bag-based relations.
\end_layout

\begin_layout Example
An example of the operator 
\begin_inset Formula $\cup$
\end_inset

:
\end_layout

\begin_layout Example
\begin_inset Formula 
\[
\left[\begin{array}{cc}
A & B\\
1 & 2\\
3 & 4\\
5 & 6
\end{array}\right]\bigcup\left[\begin{array}{cc}
A & B\\
3 & 4\\
1 & 5
\end{array}\right]=\left\{ \overset{set-based}{\left[\begin{array}{cc}
A & B\\
1 & 2\\
3 & 4\\
5 & 6\\
1 & 5
\end{array}\right]},\overset{bag-based}{\left[\begin{array}{cc}
A & B\\
1 & 2\\
3 & 4\\
5 & 6\\
1 & 5\\
3 & 4
\end{array}\right]}\right\} 
\]

\end_inset


\end_layout

\begin_layout Standard
The 
\series bold
intersection
\series default
 of two relations with the same schema returns another relation with the
 same schema and all tuples in both of the two input relations: Let 
\begin_inset Formula $R_{i},R_{j}\in\Sigma$
\end_inset

 such that 
\begin_inset Formula $R_{i}\simeq R_{j}$
\end_inset

, then
\begin_inset Formula 
\[
R_{i}\cap R_{j}=\left\{ x|x\in R_{i}\ \land\ x\in R_{j}\right\} \simeq R_{i}\simeq R_{j}.
\]

\end_inset


\end_layout

\begin_layout Example
An example of the operator 
\begin_inset Formula $\cap$
\end_inset

:
\begin_inset Formula 
\[
\left[\begin{array}{cc}
A & B\\
1 & 2\\
3 & 4\\
5 & 6
\end{array}\right]\bigcap\left[\begin{array}{cc}
A & B\\
3 & 4\\
1 & 5
\end{array}\right]=\left[\begin{array}{cc}
A & B\\
3 & 4
\end{array}\right].
\]

\end_inset


\end_layout

\begin_layout Standard
The 
\series bold
difference
\series default
 of two relations with the same schema returns another relation with the
 same schema and all tuples in the first input relations which don't appear
 in the second input relation: Let 
\begin_inset Formula $R_{i},R_{j}\in\Sigma$
\end_inset

 such that 
\begin_inset Formula $R_{i}\simeq R_{j}$
\end_inset

, then
\begin_inset Formula 
\[
R_{i}-R_{j}=\left\{ x|x\in R_{i}\ \land\ x\notin R_{j}\right\} \simeq R_{i}\simeq R_{j}.
\]

\end_inset


\end_layout

\begin_layout Example
An example of the operator 
\begin_inset Formula $-$
\end_inset

:
\begin_inset Formula 
\[
\left[\begin{array}{cc}
A & B\\
1 & 2\\
3 & 4\\
5 & 6
\end{array}\right]-\left[\begin{array}{cc}
A & B\\
3 & 4\\
1 & 5
\end{array}\right]=\left[\begin{array}{cc}
A & B\\
1 & 2\\
5 & 6
\end{array}\right].
\]

\end_inset


\end_layout

\begin_layout Standard
The 
\series bold
selection
\series default
 operator applies a condition on the values of the tuples of the input relation
 and returns only those tuples that fullfil the condition: Let 
\begin_inset Formula $R\in\Sigma$
\end_inset

 and 
\begin_inset Formula $P$
\end_inset

 a condition, then
\begin_inset Formula 
\[
\sigma_{P}\left(R\right)=\left\{ x|x\in R\ \land\ P\left(R\right)==true\right\} .
\]

\end_inset


\end_layout

\begin_layout Example
An example of the operator 
\begin_inset Formula $\sigma_{P}$
\end_inset

:
\begin_inset Formula 
\[
\sigma_{A\geq3}\left(\left[\begin{array}{cc}
A & B\\
1 & 2\\
3 & 4\\
5 & 6
\end{array}\right]\right)=\left[\begin{array}{cc}
A & B\\
3 & 4\\
5 & 6
\end{array}\right].
\]

\end_inset

 In this case, the condition 
\begin_inset Formula $P$
\end_inset

 is: '
\emph on
the value of 
\begin_inset Formula $A$
\end_inset

 is bigger than or equal than 3
\emph default
'.
\end_layout

\begin_layout Standard
The 
\series bold
projection
\series default
 operator returns all tuples of the input relation, but deleting all unspecified
 attributes: Let 
\begin_inset Formula $R\in\Sigma$
\end_inset

 and 
\begin_inset Formula $A_{j_{1}},...,A_{j_{k}}\in\left[A_{1},...,A_{n}\right]\sim R$
\end_inset

, then
\begin_inset Formula 
\[
\Pi_{A_{j_{1}},...,A_{j_{k}}}\left(R\right)=R_{\left[A_{j_{1}},...,A_{j_{k}}\right]}^{'}=\left\{ y|\exists x\in R\ s.t.\ x\left(A_{j_{1}},...,A_{j_{k}}\right)=y\right\} .
\]

\end_inset


\end_layout

\begin_layout Standard
The result of this operation also depends on the type of relations used.
\end_layout

\begin_layout Example
An example of the operator 
\begin_inset Formula $\Pi_{\left[A_{j_{1}},...,A_{j_{k}}\right]}$
\end_inset

:
\begin_inset Formula 
\[
\Pi_{A,C}\left(\left[\begin{array}{cccc}
A & B & C & D\\
1 & 2 & 3 & 5\\
3 & 4 & 3 & 6\\
5 & 6 & 5 & 9\\
1 & 6 & 3 & 5
\end{array}\right]\right)=\left\{ \overset{set-based}{\left[\begin{array}{cc}
A & C\\
1 & 3\\
3 & 3\\
5 & 5
\end{array}\right]},\overset{bag-based}{\left[\begin{array}{cc}
A & C\\
1 & 3\\
3 & 3\\
5 & 5\\
1 & 3
\end{array}\right]}\right\} .
\]

\end_inset


\end_layout

\begin_layout Standard
The 
\series bold
cartesian product
\series default
 of two relations with disjoint schemas returns a relation with the schema
 resulting of combining both schemas and with all possible tuples made out
 of tuples from the first relation and tuples from the second relation:
 Let 
\begin_inset Formula $R_{i},R_{j}\in\Sigma$
\end_inset

 such that their schemas are disjoint, then
\begin_inset Formula 
\[
R_{i}\times R_{j}=\left\{ z=\left(x,y\right)|x\in R_{i}\ \land\ y\in R_{j}\right\} .
\]

\end_inset


\end_layout

\begin_layout Example
An example of the operator 
\begin_inset Formula $\times$
\end_inset

:
\begin_inset Formula 
\[
\left[\begin{array}{cc}
A & B\\
1 & 2\\
3 & 4
\end{array}\right]\times\left[\begin{array}{cc}
C & D\\
2 & 6\\
3 & 7\\
4 & 9
\end{array}\right]=\left[\begin{array}{cccc}
A & B & C & D\\
1 & 2 & 2 & 6\\
1 & 2 & 3 & 7\\
1 & 2 & 4 & 9\\
3 & 4 & 2 & 6\\
3 & 4 & 3 & 7\\
3 & 4 & 4 & 9
\end{array}\right].
\]

\end_inset


\end_layout

\begin_layout Standard
The 
\series bold
natural join
\series default
 of two tuples whose schemas share at most one attribute returns a relation
 with the schema resulting of combining both schemas and with all possible
 tuples made out of tuples from the first relation and tuples from the second
 relation with the condition that they have the same value for the shared
 attribute: Let 
\begin_inset Formula $R_{i},R_{j}\in\Sigma$
\end_inset

 such that their schemas share at most one attribute, 
\begin_inset Formula $A$
\end_inset

, then
\begin_inset Formula 
\[
R_{i}\bowtie R_{j}=\left\{ z=\left(x,y\right)|x\in R_{i}\ \land\ y\in R_{j}\ \land x\left(A\right)=y\left(A\right)\right\} .
\]

\end_inset


\end_layout

\begin_layout Standard
Note that if the relations are disjoint, the natural join gives the same
 results as the cartesian product.
\end_layout

\begin_layout Example
An example of the operator 
\begin_inset Formula $\bowtie$
\end_inset

:
\begin_inset Formula 
\[
\left[\begin{array}{cc}
A & B\\
1 & 2\\
3 & 4
\end{array}\right]\bowtie\left[\begin{array}{cc}
B & D\\
2 & 6\\
3 & 7\\
4 & 9
\end{array}\right]=\left[\begin{array}{ccc}
A & B & D\\
1 & 2 & 6\\
3 & 4 & 9
\end{array}\right].
\]

\end_inset


\end_layout

\begin_layout Standard
The 
\series bold
theta join
\series default
 of two relations given a condition 
\begin_inset Formula $P$
\end_inset

 returns all the tuples in the cartesian product of the two relations that
 fullfil the condition 
\begin_inset Formula $P$
\end_inset

: Let 
\begin_inset Formula $R_{i},R_{j}\in\Sigma$
\end_inset

 and 
\begin_inset Formula $P$
\end_inset

 a condition, then
\begin_inset Formula 
\[
R_{i}\bowtie_{P}R_{j}=\left\{ x|x\in R_{i}\times R_{j}\ \land\ P\left(x\right)==true\right\} =\sigma_{P}\left(R_{i}\times R_{j}\right).
\]

\end_inset


\end_layout

\begin_layout Example
An example of the operator 
\begin_inset Formula $\bowtie_{P}$
\end_inset

:
\begin_inset Formula 
\[
\left[\begin{array}{cc}
A & B\\
1 & 2\\
3 & 4
\end{array}\right]\bowtie_{B=C}\left[\begin{array}{cc}
C & D\\
2 & 6\\
3 & 7\\
4 & 9
\end{array}\right]=\left[\begin{array}{cccc}
A & B & C & D\\
1 & 2 & 2 & 6\\
3 & 4 & 4 & 9
\end{array}\right].
\]

\end_inset


\end_layout

\begin_layout Standard
The 
\series bold
left/right/full outer join
\series default
 operators are similar to the theta join, but for those tuples in the left/right
/both relation that does not find a match in the other relation, it returns
 a new tuples with the values of the tuple and the rest of the attributes
 empty.
\end_layout

\begin_layout Example
An example of 
\begin_inset Formula $=\bowtie,\ \bowtie=,=\bowtie=$
\end_inset

:
\begin_inset Formula 
\[
\left[\begin{array}{cc}
A & B\\
1 & 2\\
3 & 4\\
5 & 5
\end{array}\right]=\bowtie_{B=C}\left[\begin{array}{cc}
C & D\\
2 & 6\\
3 & 7\\
4 & 9
\end{array}\right]=\left[\begin{array}{cccc}
A & B & C & D\\
1 & 2 & 2 & 6\\
3 & 4 & 4 & 9\\
5 & 5
\end{array}\right]
\]

\end_inset


\begin_inset Formula 
\[
\left[\begin{array}{cc}
A & B\\
1 & 2\\
3 & 4\\
5 & 5
\end{array}\right]\bowtie=_{B=C}\left[\begin{array}{cc}
C & D\\
2 & 6\\
3 & 7\\
4 & 9
\end{array}\right]=\left[\begin{array}{cccc}
A & B & C & D\\
1 & 2 & 2 & 6\\
3 & 4 & 4 & 9\\
 &  & 3 & 7
\end{array}\right]
\]

\end_inset


\begin_inset Formula 
\[
\left[\begin{array}{cc}
A & B\\
1 & 2\\
3 & 4\\
5 & 5
\end{array}\right]=\bowtie=_{B=C}\left[\begin{array}{cc}
C & D\\
2 & 6\\
3 & 7\\
4 & 9
\end{array}\right]=\left[\begin{array}{cccc}
A & B & C & D\\
1 & 2 & 2 & 6\\
3 & 4 & 4 & 9\\
5 & 5\\
 &  & 3 & 7
\end{array}\right]
\]

\end_inset


\end_layout

\begin_layout Standard
The 
\series bold
renaming operator 
\series default
changes the name of a relation, 
\begin_inset Formula $\rho\left(R\right)=R'$
\end_inset

.
 The 
\series bold
feature rename operator
\series default
 changes the name of an attribute in a relation, 
\begin_inset Formula $A\rightarrow A'$
\end_inset

.
\end_layout

\begin_layout Standard
The 
\series bold
aggregation operator 
\series default
of a relation returns another relation in which the tuples that share the
 value of the aggregating attribute are merged using an 
\series bold
aggregate function
\series default
: Let 
\begin_inset Formula $R\in\Sigma$
\end_inset

, with 
\begin_inset Formula $R\sim\left[A_{1},...,A_{n},A\right]$
\end_inset

, 
\begin_inset Formula $A$
\end_inset

 the aggregating attribute and 
\begin_inset Formula $f_{1},...,f_{n}$
\end_inset

 the aggregating functions for the rest of the attributes, then
\begin_inset Formula 
\[
\gamma_{A,f_{1}\left(A_{1}\right),...,f_{n}\left(A_{n}\right)}\left(R\right)=\left\{ z=\left(v_{A},f_{1}\left(A_{1}^{v_{A}}\right),...f_{n}\left(A_{n}^{v_{A}}\right)\right)|v_{A}\in R\left(A\right)\right\} ,
\]

\end_inset

 where 
\begin_inset Formula $A_{j}^{v_{A}}$
\end_inset

 is a short notation for
\begin_inset Formula 
\[
A_{j}^{v_{A}}=\Pi_{A_{j}}\left(\sigma_{A=v_{A}}\left(R\right)\right),
\]

\end_inset

 i.e.
 all values in 
\begin_inset Formula $R\left(A_{j}^{v_{A}}\right)$
\end_inset

 such that come from a tuple whose values for the attribute 
\begin_inset Formula $A$
\end_inset

 is 
\begin_inset Formula $v$
\end_inset

.
\end_layout

\begin_layout Example
An example of the operator 
\begin_inset Formula $\gamma_{A,f_{1}\left(A_{1}\right),...,f_{n}\left(A_{n}\right)\left(R\right)}$
\end_inset

:
\begin_inset Formula 
\[
\gamma_{A,min\left(B\right)}\left[\begin{array}{cc}
A & B\\
1 & 2\\
1 & 1\\
3 & 7\\
3 & 9\\
4 & 4
\end{array}\right]=\left[\begin{array}{cc}
A & min\left(B\right)\\
1 & 1\\
3 & 7\\
4 & 4
\end{array}\right].
\]

\end_inset


\end_layout

\begin_layout Subsection
Relational algebra expressions
\end_layout

\begin_layout Standard
Now, we can build expressions in relational algebra to get new relations
 from current ones.
 Let's return to Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "ex:1-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we can define the operator 
\begin_inset Formula $Op$
\end_inset

 such that produces the relation that contains all names of films in which
 some movie stars in 
\begin_inset Formula $MovieStar$
\end_inset

 born in 1960 participated as:
\begin_inset Formula 
\[
R'=Op\left(MovieStar,StarsIn\right)=\Pi_{filmName}\left(\sigma_{birthDate.year=1960}\left(MovieStar\bowtie_{name=starName}StarsIn\right)\right).
\]

\end_inset


\end_layout

\begin_layout Standard
Relational algebra is the theoretical basis of the 
\series bold
SQL language
\series default
, meaning SQL is designed as an implementation of the relational algebra
 operators that we have seen so far.
 The equivalent SQL sentence to the last RA operator, 
\begin_inset Formula $OP$
\end_inset

, is
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT filmName
\end_layout

\begin_layout Plain Layout

FROM StarsIn
\end_layout

\begin_layout Plain Layout

JOIN MovieStar ON name=starName
\end_layout

\begin_layout Plain Layout

WHERE birthDate.year = 1960;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As explained in 
\begin_inset CommandInset citation
LatexCommand cite
key "SQLtoRA"
literal "false"

\end_inset

, translating an arbitrary SQL query into a 
\series bold
logical query plan
\series default
, or, equivalently, a relational algebra expression, is a complex task.
 Let's first give some examples.
\end_layout

\begin_layout Example
We are going to work with some examples now.
 Let's our database have the following relations:
\end_layout

\begin_deeper
\begin_layout Itemize
Movie(title: string, year: int, length: int, genre: string, studioName:
 string, producerCERT: int)
\end_layout

\begin_layout Itemize
MovieStar(name: string, address: string, gender: char, birthdate:date)
\end_layout

\begin_layout Itemize
StarsIn(movieTitle: string, movieYear: string, starName: string)
\end_layout

\begin_layout Itemize
MovieExec(name: string, address: string, CERT: int, netWorth: int)
\end_layout

\begin_layout Itemize
Studio(name: string, address: string, presCERT: int)
\end_layout

\begin_layout Standard
SQL:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT movieTitle, count(S.starName) AS numStars
\end_layout

\begin_layout Plain Layout

FROM StarsIn S, MovieStar M
\end_layout

\begin_layout Plain Layout

WHERE S.starName = M.name
\end_layout

\begin_layout Plain Layout

GROUP BY movieTitle;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
RA:
\begin_inset Formula 
\[
\gamma_{M.movieTitle,\ count\left(S.starName\right)\rightarrow numStars}\left(\rho_{S}\left(StarsIn\right)\bowtie_{S.starName=M.name}\rho_{M}\left(MovieStar\right)\right).
\]

\end_inset


\end_layout

\begin_layout Standard
SQL:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT movieTitle, count(S.starName) AS numStars
\end_layout

\begin_layout Plain Layout

FROM StarsIn S, MovieStar M
\end_layout

\begin_layout Plain Layout

WHERE S.starName = M.name
\end_layout

\begin_layout Plain Layout

GROUP BY movieTitle
\end_layout

\begin_layout Plain Layout

HAVING count(S.starName) > 5;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
RA:
\begin_inset Formula 
\[
\sigma_{numStars>5}\left(\gamma_{M.movieTitle,\ count\left(S.starName\right)\rightarrow numStars}\left(\rho_{S}\left(StarsIn\right)\bowtie_{S.starName=M.name}\rho_{M}\left(MovieStar\right)\right)\right).
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
At this point, one can understand that it is not easy at all to automatize
 this procedure of translating from SQL to RA.
 Not only the process is not trivial as is, but it is also needed to take
 into consideration that one SQL sentence can be translated into several
 equivalent RA expressions, which will ultimately be executed in a computer
 and the election of the translation to execute will affect the efficiency
 of the program.
 Let's review the paper 
\begin_inset CommandInset citation
LatexCommand cite
key "SQLtoRA"
literal "false"

\end_inset

, explaining each of the translations, assuming set-based relations.
\end_layout

\begin_layout Section
Translating SQL into Relational Algebra
\end_layout

\begin_layout Subsection
SELECT-FROM-WHERE statemets without subqueries
\begin_inset CommandInset label
LatexCommand label
name "subsec:SELECT-FROM-WHERE-statemets-without-SUB"

\end_inset


\end_layout

\begin_layout Standard
A query of the form:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT select-list
\end_layout

\begin_layout Plain Layout

FROM R1 T1,..., Rn Tn
\end_layout

\begin_layout Plain Layout

WHERE condition;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
in which the condition does not involve subqueries, we can translate it
 as
\begin_inset Formula 
\[
\Pi_{select-list}\left(\sigma_{condition}\left(\rho_{T1}\left(R1\right)\times...\times\rho_{Tn}\left(Rn\right)\right)\right).
\]

\end_inset


\end_layout

\begin_layout Subsection
Normalizing WHERE-subqueries into EXISTS and NOT EXISTS form
\end_layout

\begin_layout Standard
In general, queries in which there are subqueries in the WHERE clause can
 arise, and they need to be translated, too.
 The property used in these cases is that subqueries occurring in the WHERE
 clause that use the operators 
\begin_inset Formula $=,<,>,<=,>=,<>,EXISTS,IN,NOT\ EXISTS,NOT\ IN$
\end_inset

 or the quantifiers 
\begin_inset Formula $ANY$
\end_inset

 or 
\begin_inset Formula $ALL$
\end_inset

 can all be rewritten to use the operators 
\begin_inset Formula $EXISTS$
\end_inset

 and 
\begin_inset Formula $NOT\ EXISTS$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Proposition
All conditions using a subquery can be rewritten using only 
\begin_inset Formula $EXISTS$
\end_inset

 and 
\begin_inset Formula $NOT\ EXISTS$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Proof
Let's proof some of the results:
\end_layout

\begin_deeper
\begin_layout Itemize
The result using the 
\begin_inset Formula $EXISTS$
\end_inset

 and 
\begin_inset Formula $NOT\ EXISTS$
\end_inset

 operators is obvious.
\end_layout

\begin_layout Itemize
Case 
\begin_inset Formula $=ANY$
\end_inset

: a query would look like the following:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT select-list
\end_layout

\begin_layout Plain Layout

FROM R1
\end_layout

\begin_layout Plain Layout

WHERE R1.A = ANY (SELECT B
\end_layout

\begin_layout Plain Layout

		  FROM R2
\end_layout

\begin_layout Plain Layout

		  WHERE cond);
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Proof
An equivalent query is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT select-list
\end_layout

\begin_layout Plain Layout

FROM R1
\end_layout

\begin_layout Plain Layout

WHERE EXISTS(SELECT B
\end_layout

\begin_layout Plain Layout

		 FROM R2
\end_layout

\begin_layout Plain Layout

		 WHERE cond AND R2.B = R1.A);
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Case 
\begin_inset Formula $=ALL$
\end_inset

:
\end_layout

\end_deeper
\begin_layout Proof
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT select-list
\end_layout

\begin_layout Plain Layout

FROM R1
\end_layout

\begin_layout Plain Layout

WHERE R1.A = ALL (SELECT B
\end_layout

\begin_layout Plain Layout

			FROM R2
\end_layout

\begin_layout Plain Layout

			WHERE cond);
\end_layout

\end_inset


\end_layout

\begin_layout Proof
An equivalent query is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT select-list
\end_layout

\begin_layout Plain Layout

FROM R1
\end_layout

\begin_layout Plain Layout

WHERE NOT EXISTS(SELECT B
\end_layout

\begin_layout Plain Layout

			FROM R2
\end_layout

\begin_layout Plain Layout

			WHERE cond AND R2.B <> R1.A);
\end_layout

\end_inset


\end_layout

\begin_layout Proof
The rest of the cases 
\begin_inset Formula $binaryOP+ANY|ALL$
\end_inset

 is similar.
\end_layout

\begin_deeper
\begin_layout Itemize
Case 
\begin_inset Formula $IN$
\end_inset

:
\end_layout

\end_deeper
\begin_layout Proof
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT select-list
\end_layout

\begin_layout Plain Layout

FROM R1
\end_layout

\begin_layout Plain Layout

WHERE R1.A IN (SELECT B
\end_layout

\begin_layout Plain Layout

		   FROM R2
\end_layout

\begin_layout Plain Layout

		   WHERE cond);
\end_layout

\end_inset


\end_layout

\begin_layout Proof
An equivalent query is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT select-list
\end_layout

\begin_layout Plain Layout

FROM R1
\end_layout

\begin_layout Plain Layout

WHERE EXISTS(SELECT B
\end_layout

\begin_layout Plain Layout

		 FROM R2
\end_layout

\begin_layout Plain Layout

		 WHERE cond AND R2.B = R1.A);
\end_layout

\end_inset


\end_layout

\begin_layout Proof
The case 
\begin_inset Formula $NOT\ IN$
\end_inset

 is analogous.
\end_layout

\begin_layout Example
Let's see some examples from the paper:
\end_layout

\begin_layout Example
The query
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT movieTitle FROM StarsIn
\end_layout

\begin_layout Plain Layout

WHERE starName IN (SELECT name
\end_layout

\begin_layout Plain Layout

		   FROM MovieStar
\end_layout

\begin_layout Plain Layout

		   WHERE birthdate = 1960);
\end_layout

\end_inset

is equivalent to:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT movieTitle FROM StarsIn
\end_layout

\begin_layout Plain Layout

WHERE EXISTS (SELECT name
\end_layout

\begin_layout Plain Layout

	  FROM MovieStar
\end_layout

\begin_layout Plain Layout

	  WHERE birthdate = 1960 AND name = starName);
\end_layout

\end_inset


\end_layout

\begin_layout Example
The query
\end_layout

\begin_layout Example
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT name FROM MovieExec
\end_layout

\begin_layout Plain Layout

WHERE netWorth >= ALL (SELECT E.networth
\end_layout

\begin_layout Plain Layout

			FROM MovieExec E);
\end_layout

\end_inset

is equivalent to:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT name FROM MovieExec
\end_layout

\begin_layout Plain Layout

WHERE NOT EXISTS (SELECT E.networth
\end_layout

\begin_layout Plain Layout

		  FROM MovieExec E
\end_layout

\begin_layout Plain Layout

		  WHERE netWorth < E.netWorth);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Without loss of generality, we can now assume that all subqueries in the
 where clause are of the form 
\begin_inset Formula $EXISTS$
\end_inset

 or 
\begin_inset Formula $NOT\ EXISTS$
\end_inset

.
\end_layout

\begin_layout Standard
Now, to translate a query with subqueries, in which an arbitrary number
 of subqueries inside the subqueries may arise, it seems logical to proceed
 recursively.
 The idea is to translate into RA from inner queries to outer queries.
 For subqueries that do not contain more subqueries, we could translate
 them as in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:SELECT-FROM-WHERE-statemets-without-SUB"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The problem in this case is that the subqueries can refer to attributes
 of relations appearing in the FROM clause of the outer queries.
 This is known as 
\series bold
correlated queries
\series default
.
\end_layout

\begin_layout Example
\begin_inset CommandInset label
LatexCommand label
name "ex:A-correlated-query."

\end_inset

A correlated query.
\end_layout

\begin_layout Example
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT movieTitle
\end_layout

\begin_layout Plain Layout

FROM StarsIn
\end_layout

\begin_layout Plain Layout

WHERE EXISTS (SELECT name
\end_layout

\begin_layout Plain Layout

		FROM MovieStar
\end_layout

\begin_layout Plain Layout

		WHERE birthdate = 1960 AND name = starName);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The outer relations from which a correlated subquery uses certain attributes
 are called 
\series bold
context relations
\series default
.
 The attributes of the context relations are the 
\series bold
parameters
\series default
 of the subquery
\begin_inset Foot
status open

\begin_layout Plain Layout
Note that not all the parameters must appear in the subquery.
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Translating SELECT-FROM-WHERE subqueries
\begin_inset CommandInset label
LatexCommand label
name "subsec:Translating-SELECT-FROM-WHERE-suB"

\end_inset


\end_layout

\begin_layout Standard
To translate a SELECT-FROM-WHERE statement that is used as a subquery, we
 must make the following modifications to the method from Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:SELECT-FROM-WHERE-statemets-without-SUB"
plural "false"
caps "false"
noprefix "false"

\end_inset

:
\end_layout

\begin_layout Itemize
We must add all context relations to the cartesian product of the relations
 in the FROM list.
\end_layout

\begin_layout Itemize
We must add all parameters as attributes to the projection 
\begin_inset Formula $\pi$
\end_inset

.
\end_layout

\begin_layout Example
The subquery from Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "ex:A-correlated-query."
plural "false"
caps "false"
noprefix "false"

\end_inset

:
\end_layout

\begin_layout Example
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT name
\end_layout

\begin_layout Plain Layout

FROM MovieStar
\end_layout

\begin_layout Plain Layout

WHERE birthdate = 1960 AND name = starName
\end_layout

\end_inset


\end_layout

\begin_layout Example
is translated into
\begin_inset Formula 
\[
\Pi_{movieTitle,movieYear,starName,name}\left(\sigma_{birthdate=1960\ \land\ name=starName}\left(StarsIn\times MovieStar\right)\right).
\]

\end_inset


\end_layout

\begin_layout Subsection
De-correlation of subqueries appearing in a conjunctive WHERE condition
\end_layout

\begin_layout Standard
Now, let's focus on a particular case:
\end_layout

\begin_layout Standard
Suppose we have a query of the general form:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT Select-list
\end_layout

\begin_layout Plain Layout

FROM from-list
\end_layout

\begin_layout Plain Layout

WHERE condition;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
And the following assumption: 
\emph on
the condition is a conjunction (AND) of SELECT-FROM-WHERE subqueries, possibly
 with an additional condition that does not contain subqueries
\emph default
, i.e., the condition is of the form
\begin_inset Formula 
\[
\phi\ AND\ EXISTS(Q_{1})\ AND\ EXISTS\left(Q_{2}\right)\ AND...\ AND\ NOT\ EXISTS\ \left(P_{1}\right)\ AND...
\]

\end_inset

 where 
\begin_inset Formula $\phi$
\end_inset

 denotes the subquery-free condition and 
\begin_inset Formula $Q_{1},...,Q_{n},P_{1},...,P_{m}$
\end_inset

 are select statements.
 The translation is done in four steps:
\end_layout

\begin_layout Enumerate
Translate 
\begin_inset Formula $\phi$
\end_inset

.
\end_layout

\begin_layout Enumerate
De-correlate the EXISTS subqueries.
\end_layout

\begin_layout Enumerate
De-correlate the NOT EXISTS subqueries.
\end_layout

\begin_layout Enumerate
Apply the projection 
\begin_inset Formula $\Pi_{Select-list}.$
\end_inset


\end_layout

\begin_layout Subsubsection
Translating 
\begin_inset Formula $\phi$
\end_inset


\end_layout

\begin_layout Standard
It is translated using the method of Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:SELECT-FROM-WHERE-statemets-without-SUB"
plural "false"
caps "false"
noprefix "false"

\end_inset

, but the following context relations must be included:
\end_layout

\begin_layout Itemize
All context relations for which parameters occur in 
\begin_inset Formula $\phi$
\end_inset

.
\end_layout

\begin_layout Itemize
All context relations for which parameters only occur in NOT EXISTS subqueries.
\end_layout

\begin_layout Standard
We will obtain a expression of the form
\begin_inset Formula 
\[
\sigma_{\phi}\left(E\right),
\]

\end_inset

 where 
\begin_inset Formula $E$
\end_inset

 is a cartesian product of all the context relations involved.
 From now on, we are going to adapt and refine 
\begin_inset Formula $E$
\end_inset

 gradually when de-correlating the subqueries.
\end_layout

\begin_layout Example
\begin_inset CommandInset label
LatexCommand label
name "ex:decorr-ex1"

\end_inset

Consider the following query, with relations 
\begin_inset Formula $R\left(A,B\right)$
\end_inset

 and 
\begin_inset Formula $S\left(C\right)$
\end_inset

:
\end_layout

\begin_layout Example
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT R1.A, R1.B
\end_layout

\begin_layout Plain Layout

FROM R R1, S
\end_layout

\begin_layout Plain Layout

WHERE EXISTS
\end_layout

\begin_layout Plain Layout

	(SELECT R2.A, R2.B
\end_layout

\begin_layout Plain Layout

	FROM R R2
\end_layout

\begin_layout Plain Layout

	WHERE R2.A = R1.B AND EXISTS
\end_layout

\begin_layout Plain Layout

			(SELECT R3.A, R3.B
\end_layout

\begin_layout Plain Layout

			FROM R R3
\end_layout

\begin_layout Plain Layout

			WHERE R3.A = R2.B AND R3.B = S.C));
\end_layout

\end_inset


\end_layout

\begin_layout Example
Let's denote the queries, from outer to inner: 
\begin_inset Formula $Q_{1},Q_{2}$
\end_inset

 and 
\begin_inset Formula $Q_{3}$
\end_inset

.
 
\begin_inset Formula $Q_{1}$
\end_inset

 does not have a subquery-free part, so we continue with 
\begin_inset Formula $Q_{2}$
\end_inset

.
 The subquery-free part of 
\begin_inset Formula $Q_{2}$
\end_inset

 is:
\end_layout

\begin_layout Example
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT *
\end_layout

\begin_layout Plain Layout

FROM R R2
\end_layout

\begin_layout Plain Layout

WHERE R2.A = R1.B;
\end_layout

\end_inset


\end_layout

\begin_layout Example
So it can be translated as
\begin_inset Formula 
\[
\sigma_{R2.A=R1.B}\left(\rho_{R2}\left(R\right)\times\rho_{R1}\left(R\right)\right).
\]

\end_inset

 Note that 
\begin_inset Formula $S$
\end_inset

 is a context relation for this subquery-free part, but no parameter from
 it is needed and it is not only used in NOT EXISTS clauses, so it is not
 added.
\end_layout

\begin_layout Subsubsection
De-correlating EXISTS subqueries
\end_layout

\begin_layout Standard
After translating the subquery-free part, we translate all the subqueries
 
\begin_inset Formula $EXISTS\left(Q_{i}\right)$
\end_inset

 as explained in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Translating-SELECT-FROM-WHERE-suB"
plural "false"
caps "false"
noprefix "false"

\end_inset

, obtaining an algebra expression 
\begin_inset Formula $E_{Q_{i}}$
\end_inset

.
 
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $A_{1},...,A_{p}$
\end_inset

 be the list of parameters of context relations of 
\begin_inset Formula $Q_{i}$
\end_inset

.
 We can translate 
\begin_inset Formula $EXISTS\left(Q_{i}\right)$
\end_inset

 by joining 
\begin_inset Formula $E$
\end_inset

 with the space of parameters for 
\begin_inset Formula $E_{Q_{i}}$
\end_inset

, namely 
\begin_inset Formula $\Pi_{A_{1},...,A_{p}}\left(E_{Q_{i}}\right):$
\end_inset


\begin_inset Formula 
\[
E:=E\bowtie\pi_{A_{1},...,A_{p}}\left(E_{Q_{i}}\right).
\]

\end_inset


\end_layout

\begin_layout Example
Let's continue the translation of 
\begin_inset Formula $Q_{2}$
\end_inset

 from Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "ex:decorr-ex1"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Now, we have to translate 
\begin_inset Formula $Q_{3}$
\end_inset

 as:
\begin_inset Formula 
\[
\sigma_{R3.A=R2.B\ \land\ R3.B=S.C}\left(\rho_{R3}\left(R\right)\times\rho_{R2}\left(R\right)\times S\right).
\]

\end_inset


\end_layout

\begin_layout Example
At this point, we have
\begin_inset Formula 
\[
E=\rho_{R_{2}}\left(R\right)\times\rho_{R_{1}}\left(R\right),
\]

\end_inset


\begin_inset Formula 
\[
E_{Q_{3}}=\sigma_{R3.A=R2.B\ \land\ R3.B=S.C}\left(\rho_{R3}\left(R\right)\times\rho_{R2}\left(R\right)\times S\right),
\]

\end_inset

 and by joining 
\begin_inset Formula $E$
\end_inset

 and 
\begin_inset Formula $E_{Q_{3}}$
\end_inset

 on the parameters of 
\begin_inset Formula $Q_{3}$
\end_inset

 we ensure that we are taking the correct tuples from 
\begin_inset Formula $E$
\end_inset

 and 
\begin_inset Formula $E_{Q_{3}}$
\end_inset

.
 In particular, we are taking the tuples in 
\begin_inset Formula $R_{1}$
\end_inset

 for which tuples in 
\begin_inset Formula $R_{2},R_{3}$
\end_inset

 and 
\begin_inset Formula $S$
\end_inset

 exist that satisfy the requirements of 
\begin_inset Formula $Q_{2}$
\end_inset

:
\begin_inset Formula 
\[
\rho_{R_{2}}\left(R\right)\times\rho_{R_{1}}\left(R\right)\bowtie\Pi_{R_{2}.A,R_{2}.B,S.C}\left(\sigma_{R3.A=R2.B\ \land\ R3.B=S.C}\left(\rho_{R3}\left(R\right)\times\rho_{R2}\left(R\right)\times S\right)\right).
\]

\end_inset

 Note that this expression can be simplified:
\begin_inset Formula 
\[
E:=\rho_{R_{1}}\left(R\right)\bowtie\Pi_{R_{2}.A,R_{2}.B,S.C}\left(\sigma_{R3.A=R2.B\ \land\ R3.B=S.C}\left(\rho_{R3}\left(R\right)\times\rho_{R2}\left(R\right)\times S\right)\right),
\]

\end_inset

 because we are joining 
\begin_inset Formula $R_{2}$
\end_inset

 with a subset of itself, so we will obtain the entire subset.
\end_layout

\begin_layout Remark
This simplification can always be done.
 Before joining with 
\begin_inset Formula $\Pi_{A_{1},...,A_{p}}\left(E_{Q_{i}}\right),$
\end_inset

 we can remove from 
\begin_inset Formula $E$
\end_inset

 all context relations for 
\begin_inset Formula $Q_{i}$
\end_inset

, because they are already present in the parameter space.
 This way, denoting by 
\begin_inset Formula $\hat{E}$
\end_inset

 the adapted 
\begin_inset Formula $E$
\end_inset

, we can change what we explained later for
\begin_inset Formula 
\[
E:=\hat{E}\bowtie\Pi_{A_{1},...,A_{p}}\left(E_{Q_{i}}\right).
\]

\end_inset


\end_layout

\begin_layout Example
Now we can translate 
\begin_inset Formula $Q_{2}$
\end_inset

 as follows:
\begin_inset Formula 
\[
E_{2}:=\sigma_{R_{2}.A=R_{1}.B}\left(E\right)=
\]

\end_inset


\begin_inset Formula 
\[
\sigma_{R_{2}.A=R_{1}.B}\left(\rho_{R_{1}}\left(R\right)\bowtie\Pi_{R_{2}.A,R_{2}.B,S.C}\left(\sigma_{R3.A=R2.B\ \land\ R3.B=S.C}\left(\rho_{R3}\left(R\right)\times\rho_{R2}\left(R\right)\times S\right)\right)\right).
\]

\end_inset

 Notice how 
\begin_inset Formula $R_{2}$
\end_inset

 has been removed from the cartesian product of the subquery-free part of
 
\begin_inset Formula $Q_{2}$
\end_inset

 that we translated in the first of the examples.
\end_layout

\begin_layout Example
Finally, the translation of the entire 
\begin_inset Formula $Q_{1}$
\end_inset

 is
\begin_inset Formula 
\[
\Pi_{R_{1}.A,R_{1}.B}\left(E_{2}\right),
\]

\end_inset

 where 
\begin_inset Formula $\rho_{R_{1}}\left(R\right)$
\end_inset

 and 
\begin_inset Formula $S$
\end_inset

 have been removed from the cartesian product originating from the translation
 of the subquery-free part of 
\begin_inset Formula $Q_{1}$
\end_inset

 (the FROM clause).
\end_layout

\begin_layout Subsubsection
De-correlating NOT EXISTS subqueries
\end_layout

\begin_layout Standard
Now we can de-correlate the 
\begin_inset Formula $NOT\ EXISTS\left(P_{j}\right)$
\end_inset

 subqueries.
 We start translating 
\begin_inset Formula $P_{j}$
\end_inset

 into a RA expression 
\begin_inset Formula $E_{P_{j}}$
\end_inset

.
 Again, we consider the parameters 
\begin_inset Formula $A_{1},...,A_{p}$
\end_inset

 of the context relations of 
\begin_inset Formula $P_{j}$
\end_inset

.
 The difference now is that we don't join 
\begin_inset Formula $E$
\end_inset

 and 
\begin_inset Formula $E_{P_{j}}$
\end_inset

, but we perform an anti-join:
\begin_inset Formula 
\[
E:=E\overline{\bowtie}\Pi_{A_{1},...,A_{p}}\left(E_{P_{j}}\right),
\]

\end_inset

 where
\begin_inset Formula 
\[
R\overline{\bowtie}S=R-\left(R\bowtie S\right).
\]

\end_inset

 In this anti-join, it necessary that 
\begin_inset Formula $R$
\end_inset

 contains all attributes of 
\begin_inset Formula $S$
\end_inset

, and this is the reason why it is needed to add all context relations appearing
 only in NOT EXISTS clauses to the cartesian product of the subquery-free
 part of the query.
\end_layout

\begin_layout Subsubsection
Translating the Select-list
\end_layout

\begin_layout Standard
Finally, we apply the projection 
\begin_inset Formula $\Pi_{Select-list}$
\end_inset

.
\end_layout

\begin_layout Subsection
Flattening subqueries in bag-based relations
\end_layout

\begin_layout Standard
Until now, we have supposed that all relations involved are set-based, but
 this is not the case in real databases, where duplicates can occur.
 In this case, the requirements for flattening into a normal join are:
\end_layout

\begin_layout Itemize
There is a uniqueness condition that ensures that the subquery does not
 introduce any duplicates if it is flattened into the outer query block.
 
\end_layout

\begin_layout Itemize
Each table in the subquery's FROM list (after any view, derived table, or
 subquery flattening) must be a base table.
 
\end_layout

\begin_layout Itemize
The subquery is not under an OR.
 
\end_layout

\begin_layout Itemize
The subquery is not in the SELECT list of the outer query block.
 
\end_layout

\begin_layout Itemize
The subquery type is EXISTS, IN, or ANY, or it is an expression subquery
 on the right side of a comparison operator.
 
\end_layout

\begin_layout Itemize
There are no aggregates in the SELECT list of the subquery.
 
\end_layout

\begin_layout Itemize
The subquery does not have a GROUP BY clause.
 
\end_layout

\begin_layout Itemize
The subquery does not have an ORDER BY, result offset, or fetch first clause.
 
\end_layout

\begin_layout Itemize
If there is a WHERE clause in the subquery, there is at least one table
 in the subquery whose columns are in equality predicates with expressions
 that do not include any column references from the subquery block.
 These columns must be a superset of the key columns for any unique index
 on the table.
 For all other tables in the subquery, the columns in equality predicates
 with expressions that do not include columns from the same table are a
 superset of the unique columns for any unique index on the table.
 
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Query Optimization
\end_layout

\begin_layout Section
System-R
\end_layout

\begin_layout Standard
In this section, we are going to explain System R, which is a pioneering
 SQL system developed by IBM Research and which was released in 1976, with
 an accompanying paper, 
\begin_inset CommandInset citation
LatexCommand cite
key "systemR"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
System R was an experimental prototype database management system, with
 complete capability, including application programming, query capability,
 conccurent access support, system recovery, etc.
\end_layout

\begin_layout Subsection
Architecture Components
\end_layout

\begin_layout Standard
System R is composed by several parts:
\end_layout

\begin_layout Itemize

\series bold
Relational Storage Interface
\series default
 
\series bold
(RSI)
\series default
: internal interface which handles access to single tuples of base relations.
\end_layout

\begin_layout Itemize

\series bold
Relational Storage System (RSS)
\series default
: the supporting system of the RSI.
 It is a complete storage subsystem in the sense that it manages devices,
 space allocation, deadlock detection,...
 It maintain indexes on selected fields of base relations, and pointer chains
 across relations.
\end_layout

\begin_layout Itemize

\series bold
Relational Data Interface (RDI)
\series default
: the external interface that can be called directly from a programming
 language.
 The 
\series bold
SQL language
\series default
 is embedded within the RDI, and is used as the basis for all data definition
 and manipulation.
\end_layout

\begin_layout Itemize

\series bold
Relational Data System (RDS)
\series default
: supports the RDI, provides authorization, integrity enforcement and support
 for alternative views of data.
 The RDS contains an 
\series bold
optimizer
\series default
 which plans the execution of each RDI command, choosing a low cost access
 path to data from among those provided by the RSS.
 The RDS also maintains a set of 
\series bold
catalog relations
\series default
 which describe the other relations, views, images, links, assertions, and
 triggers known to the system.
\end_layout

\begin_layout Standard
A logical diagram of this architecture is depicted in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Architecture-of-System-R"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename systemR.drawio.png
	scale 65

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Architecture-of-System-R"

\end_inset

Architecture of System R
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Query language
\end_layout

\begin_layout Subsubsection
Data manipulation
\end_layout

\begin_layout Standard
The RDI interfaces SQL to a host programming language by means of a concept
 called a 
\series bold
cursor
\series default
, which is a name used at the RDI to identify a set of tuples called its
 
\series bold
active set
\series default
, and to maintain a position on one tuple of the set.
 The cursor is associted with a set of tuples by means of the RDI operator
 
\series bold
SEQUEL
\series default
; the tuples may then be retrieved, one at a time, by the RDI operator 
\series bold
FETCH
\series default
.
 The program must first give the system the addresses of the program variables
 to be used by means of the RDI operator 
\series bold
BIND
\series default
.
\end_layout

\begin_layout Example
Here, the host program identifies variables X and Y to the system and then
 issues a query whose results are to be placed in these variables:
\end_layout

\begin_layout Example
\begin_inset listings
lstparams "language={PL/I},showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

CALL BIND('X', ADDR(X));
\end_layout

\begin_layout Plain Layout

CALL BIND('Y', ADDR(Y));
\end_layout

\begin_layout Plain Layout

CALL SEQUEL(C1, 'SELECT NAME:X, SAL:Y
\end_layout

\begin_layout Plain Layout

		FROM EMP
\end_layout

\begin_layout Plain Layout

		WHERE JOB = 
\begin_inset Quotes eld
\end_inset

PROGRAMMER
\begin_inset Quotes erd
\end_inset

');
\end_layout

\begin_layout Plain Layout

CALL FETCH(C1);
\end_layout

\end_inset


\end_layout

\begin_layout Example
The SEQUEL operator is associating the cursor C1 with the set of tuples
 which satisfy the query and positioning it just before the first such tuple.
 The optimizer is invoked to choose an access path whereby the tuples may
 be materialized, but no tuples are actually materialized in response to
 the SEQUEL call.
 The materialization is done as they are called for, one at a time, by the
 FETCH operator.
 Each call to FETCH deliver the next tuple of the active set into program
 variables X and Y.
 In Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:exampleSystemR"
plural "false"
caps "false"
noprefix "false"

\end_inset

 we can see an example of the stored data in the relation EMP and the resulting
 Active Set.
 In this case, after calling FETCH(C1), the values of the variables would
 be X=
\begin_inset Quotes erd
\end_inset

Mike
\begin_inset Quotes erd
\end_inset

 and Y=800.
 If another call to FECTH(C1) were made, then the variables would be overrided
 to X=
\begin_inset Quotes erd
\end_inset

Sarah
\begin_inset Quotes erd
\end_inset

 and Y=810.
\end_layout

\begin_layout Example
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
EMP
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
NAME
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SAL
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
JOB
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

John
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

CEO
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

Mike
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
800
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

PROGRAMMER
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

Sarah
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
810
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

PROGRAMMER
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Active Set
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
NAME
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SAL
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

Mike
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
800
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

Sarah
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
810
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:exampleSystemR"

\end_inset

Result of the program.
 Stored data in EMP (left).
 Active Set (right).
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\series bold
DESCRIBE
\series default
 operator returns the degree and the data types of the active set.
 The degree is the number of attributes.
 It is useful when this information is not known in advanced, so it can
 be inputted to the FETCH operator.
\end_layout

\begin_layout Standard
The operator 
\series bold
OPEN
\series default
 is used to associate a cursor with an entire relation.
\end_layout

\begin_layout Standard
Each cursor remains active until an RDI operator 
\series bold
CLOSE
\series default
 or 
\series bold
KEEP
\series default
 is issued on it.
 CLOSE deactivates the cursor, while KEEP causes the tuples identified by
 a cursor to be copied to form a new permanent relation in the database.
\end_layout

\begin_layout Standard
The operator 
\series bold
FETCH_HOLD
\series default
 is as FETCH, but it also acquires a 
\emph on
hold
\emph default
 on the tuple returned, which prevents other users from updating or deleting
 it until it is explicitly released by the 
\series bold
RELEASE
\series default
 operator or until the holding transaction has ended.
\end_layout

\begin_layout Subsubsection
Data definition
\end_layout

\begin_layout Standard
The SQL statement 
\series bold
CREATE TABLE
\series default
 is used to create a new base relation.
 For each field, the field name and data type are specified.
 When a relation is no longer useful, it may be deleted by issuing a 
\series bold
DROP TABLE
\series default
 statement.
\end_layout

\begin_layout Standard
Access paths include images and binary links.
 
\series bold
Images
\series default
 are value orderings maintained on base relations by the RSS, using multilevel
 index structures
\begin_inset Foot
status open

\begin_layout Plain Layout
Images are today called just indexes.
\end_layout

\end_inset

, associating a value with one or more 
\series bold
tuple identifiers (TIDs)
\series default
, which are internal addresses allowing rapid access to a tuple.
 One image per relation can have the 
\series bold
clustering property
\series default
, which causes tuples whose sort field values are close to be physically
 stored near each other.
 
\series bold
Binary paths
\series default
 are access paths in the RSS which link tuples in one relation to related
 tuples of another relation through pointer chains.
 They are employed in a value dependent manner: the user specifies that
 each tuple of Relation 1 is to be linked to the tuples in Relation 2 which
 have matching values in some field/s, and that the tuples on the link are
 to be ordered in some way
\begin_inset Foot
status open

\begin_layout Plain Layout
So, binary paths are essentialy join indexes.
\end_layout

\end_inset

.
 A link may be declared to have the clustering property.
\end_layout

\begin_layout Standard
A 
\series bold
view
\series default
 is a relation derived from one or more relations, and can be used in the
 same way as a base table.
 It can be defined using the 
\series bold
DEFINE VIEW 
\series default
statement.
 Views are updated automatically when changes are made to the base tables
 on which they are defined.
 When the statement 
\series bold
DROP VIEW
\series default
 is issued, the indicated view and all other views defined in terms of it
 disappear from the system.
 Modifications to views are only allowed if the tuples of the view are associate
d one-to-one with tuples of an underlying base relation.
\end_layout

\begin_layout Standard
The statement 
\series bold
KEEP TABLE
\series default
 causes a temporary table to become permanent.
\end_layout

\begin_layout Standard
The statement 
\series bold
EXPAND TABLE
\series default
 is used to add a new field to an existing table.
\end_layout

\begin_layout Subsubsection
Data Control
\end_layout

\begin_layout Standard
A 
\series bold
transaction
\series default
 is a series of RDI calls which the user wishes to be processed as an atomic
 act.
 A transaction starts when the user issues a 
\series bold
BEGIN_TRANS
\series default
 statement and ends when 
\series bold
END_TRANS
\series default
 is called.
 Save points may be specified by means of the operator 
\series bold
SAVE
\series default
.
 When a transaction is active, the user may go back to the beginning of
 it, or to any save point using 
\series bold
RESTORE
\series default
.
\end_layout

\begin_layout Standard
Regarding 
\series bold
authorization
\series default
, System R does not require a particular individual to be the DB administrator,
 but allows each user to create his own data objects by executing the create
 staatements.
 The creator of an object has full authorization on it.
 The user can gran selected capabilities for his objects to other users
 with the statement 
\series bold
GRANT
\series default
.
\end_layout

\begin_layout Standard
About 
\series bold
integrity assertions
\series default
, any SQL predicate may be stated as an assertion about the integrity of
 data in a base table or view.
 When an assertion is made by an 
\series bold
ASSERT 
\series default
statement, its truth is checked.
 If true, the assertion is atuomatically enforced until it is explicitly
 dropped by a 
\series bold
DROP ASSERTION
\series default
 statement.
 Assertions may describe the permissible states of the database or the permissib
le transitions in the database.
 For this latter purpose, the keywords 
\series bold
OLD
\series default
 and 
\series bold
NEW
\series default
 are used in SQL to denote data values before and after modification.
\end_layout

\begin_layout Standard
If an assertion is 
\series bold
IMMEDIATE
\series default
, it cannot be suspended within a transaction, but is enforced after each
 data modification.
 Also, 
\emph on
integrity
\emph default
 
\emph on
points 
\emph default
may be established by the SQL 
\series bold
ENFORCE INTEGRITY
\series default
.
\end_layout

\begin_layout Standard

\series bold
Triggers
\series default
 are a generalization of the concept of assertion, causing a prespecified
 sequence of SQL statements to be executed when some triggering event occurs.
\end_layout

\begin_layout Subsection
Catalogues
\end_layout

\begin_layout Standard
Catalogues are maintained by the RDS, and they describe the information
 of the relations, views, images, links, assertions and triggers known to
 the system.
 Each user may access a set of views of the system catalogs which contain
 information pertinent to him.
 Users cannot modify a catalog directly, but it is modified indirectly,
 when tables are created, an image is dropped, etc.
 A user can enter commments into his various catalog entries by means of
 the 
\series bold
COMMENT
\series default
 statement.
\end_layout

\begin_layout Subsection
Cursors
\end_layout

\begin_layout Standard
As we have seen, 
\series bold
cursors
\series default
 are pointers to specific tuples on a resulting table from a query.
 They can be used to retrieve the values of the tuples individually or to
 store the tables into the database as permanent relations.
 Cursors are still used, although they are often a low level feature that
 is not directly used by users, by it is used by the DBMS to provide higher
 level features to the user.
\end_layout

\begin_layout Standard
In addition, SQL can be used to maniputale either one tuple at a time or
 a set of tuples with a single command.
 The current tuple of a particular cursor may be selected for some operation
 using the predicate 
\series bold
CURRENT TUPLE OF CURSOR
\series default
.
\end_layout

\begin_layout Example
Give a 10% raise to all employees in Dept.
 50.
\end_layout

\begin_layout Example
\begin_inset listings
lstparams "language={PL/I},showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

CALL SEQUEL('UPDATE EMP
\end_layout

\begin_layout Plain Layout

		SET SAL = SAL*1.1
\end_layout

\begin_layout Plain Layout

		WHERE DNO = 50');
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Example
Individual update.
\end_layout

\begin_layout Example
\begin_inset listings
lstparams "language={PL/I},showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

CALL BIND('NEWSAL', ADDR(NEWSAL));
\end_layout

\begin_layout Plain Layout

CALL SEQUEL('UPDATE EMP
\end_layout

\begin_layout Plain Layout

		SET SAL=NEWSAL
\end_layout

\begin_layout Plain Layout

		WHERE CURRENT TUPLE OF CURSOR C');
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Clustering images
\end_layout

\begin_layout Standard
Clustering images, as we have explained, are images (indexes) that can be
 used to physically store the data in the same order as it is indexed.
 At most one image per relation can have the clustering property.
 The reason is simple: it is not possible to store the same data physically
 in two different orders.
\end_layout

\begin_layout Subsection
Optimizer
\end_layout

\begin_layout Standard
The objective of the optimizer is to find a low cost means of executing
 a SQL statement, given the data structures and access paths available.
 For this, it attempts to minimize the expected number of pages to be fetches
 from disk into the RSS buffers.
 The cost of CPU instructions is also taken into account by means of an
 adjustable coefficient, 
\begin_inset Formula $H$
\end_inset

, which is multiplied by the number of tuple comparison operations to convert
 equivalent page accesses.
 
\begin_inset Formula $H$
\end_inset

 is useful to adjust the metric for compute-bounded systems or disk access-bound
ed systems.
\end_layout

\begin_layout Standard
The optimizers follows some steps when it receives a SQL statement:
\end_layout

\begin_layout Enumerate
Classify the SQL statement into one of several statement types.
\end_layout

\begin_layout Enumerate
Examine the system catalogs to find the set of images and links which are
 pertinent to the given statement.
\end_layout

\begin_layout Enumerate
A rough decision procedure is executed to find the set of reasonable methods
 of executing the statement.
\end_layout

\begin_layout Enumerate
If there is more than one reasonable method, the 
\series bold
expected cost formula
\series default
 is evaluated for each method, and the minimizing method is choosing.
\end_layout

\begin_layout Standard
The following parameters, available in the system catalogues, are taken
 into account:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
R
\end_layout

\end_inset

 
\series bold
relation cardinality
\series default
: number of tuples
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
D
\end_layout

\end_inset

 
\series bold
number of pages occupied by the relation
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
T
\end_layout

\end_inset

 
\series bold
average number of tuples per page:
\begin_inset Formula 
\[
T=\frac{R}{D}.
\]

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
I
\end_layout

\end_inset

 
\series bold
image cardinality
\series default
: number of distinct sort fields values in a given image.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
H
\end_layout

\end_inset

 
\series bold
coefficient of CPU cost
\series default
: 
\begin_inset Formula $\frac{1}{H}$
\end_inset

 is the number of tuple comparisons which are considered equivalent in cost
 to one disk page access.
\end_layout

\begin_layout Standard
An image 
\series bold
match
\series default
 a predicate if the sort field of the image is the field which is tested
 by the predicate.
\end_layout

\begin_layout Subsubsection
Simple query optimization
\end_layout

\begin_layout Standard
In the case of a simple query on a single relation, the optimizer compares
 the available images with the predicates of the query, in order to determine
 which of the following eight methods are available:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
Method 1
\end_layout

\end_inset

: use a clustering image which matches a predicate whose comparison operator
 is '='.
 The expected cost, 
\begin_inset Formula $C$
\end_inset

 is
\begin_inset Formula 
\[
C=\frac{R}{T\times I},
\]

\end_inset

 that is: from 
\begin_inset Formula $I$
\end_inset

 values, we want one, so we need to retrieve 
\begin_inset Formula $\frac{R}{I}$
\end_inset

 tuples on average.
 These fit in 
\begin_inset Formula $\frac{R}{T\times I}$
\end_inset

 pages.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
Method 2
\end_layout

\end_inset

: use a clustering image which matches a predicate whose comparison operator
 is not '='.
 Assuming half the tuples satisfy the predicate, we have
\begin_inset Formula 
\[
C=\frac{R}{T\times2}.
\]

\end_inset

 The idea is the same as before, but now we are assuming to retrieve 
\begin_inset Formula $\frac{R}{2}$
\end_inset

 tuples on average.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
Method 3
\end_layout

\end_inset

: use a non-clustering image which matches a predicate whose comparison
 operator is '='.
 In this case, we have
\begin_inset Formula 
\[
C=\frac{R}{I},
\]

\end_inset

 because now we might find only one correct tuple per page.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
Method 4
\end_layout

\end_inset

: use a non-clustering image which matches a predicate whose comparison
 operator is not '='.
 It is
\begin_inset Formula 
\[
C=\frac{R}{2}.
\]

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
Method 5
\end_layout

\end_inset

: use a clustering image which does not match any predicate.
 We would scan the image and test each tuple against all predicates.
 The expected cost is
\begin_inset Formula 
\[
C=\frac{R}{T}+H\times R\times N,
\]

\end_inset

 where 
\begin_inset Formula $N$
\end_inset

 is the number of predicates.
 So, we recover 
\begin_inset Formula $R$
\end_inset

 tuples, distributed in 
\begin_inset Formula $\frac{R}{T}$
\end_inset

 pages.
 In addition to this, we need to perform 
\begin_inset Formula $R\times N$
\end_inset

 comparisons (
\begin_inset Formula $N$
\end_inset

 predicates per tuple), which are weighted by the coefficient of CPU, 
\begin_inset Formula $H$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
Method 6
\end_layout

\end_inset

: use a non-clustering image which does not match any predicate:
\begin_inset Formula 
\[
C=R+H\times R\times N.
\]

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
Method 7
\end_layout

\end_inset

: use a relation scan, where this relation is the only one in its segment
 and test each tupple agains all predicates:
\begin_inset Formula 
\[
C=\frac{R}{T}+H\times R\times N.
\]

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
Method 8
\end_layout

\end_inset

: use a relation scan, where there are other relations sharing the segment.
 The cost is unknown, but is greater than 
\begin_inset Formula $\frac{R}{T}+H\times R\times N$
\end_inset

.
\end_layout

\begin_layout Standard
The optimizer then chooses a method from this set, according to the following
 rules:
\end_layout

\begin_layout Enumerate
If 
\series bold
Method 1
\series default
 is available, it is chose.
\end_layout

\begin_layout Enumerate
If exactly one among 
\series bold
Methods 2,3,5 and 7
\series default
 are available, it is chosen.
 If more than one method is available in this class, the expected cost formulas
 for these methods are evaluated and the method of minimum cost is chosen.
\end_layout

\begin_layout Enumerate
If none of the above methods are available, the optimizer chooses 
\series bold
Method 4
\series default
, if available.
\end_layout

\begin_layout Enumerate
Else, 
\series bold
Method 6
\series default
, if available.
\end_layout

\begin_layout Enumerate
Else, 
\series bold
Method 8
\series default
.
\end_layout

\begin_layout Subsubsection
Join query optimization
\end_layout

\begin_layout Standard
In the release paper, only 4 methods are explained, although they say the
 system takes more methods into account.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
Method 1
\end_layout

\end_inset

: use images on join fields.
 A simultaneous scan of the image on 
\begin_inset Formula $R1.A$
\end_inset

 and the image of 
\begin_inset Formula $R2.A$
\end_inset

.
 The idea is having two pointers, and advance them coordinately, using the
 fact that images are ordered to find matches.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
Method 2
\end_layout

\end_inset

: sort both relations.
 
\begin_inset Formula $R1$
\end_inset

 and 
\begin_inset Formula $R2$
\end_inset

 are ordered using their cluster images and two files, 
\begin_inset Formula $F1$
\end_inset

 and 
\begin_inset Formula $F2$
\end_inset

 are created.
 
\begin_inset Formula $F1$
\end_inset

 and 
\begin_inset Formula $F2$
\end_inset

 are sorted on field 
\begin_inset Formula $A$
\end_inset

.
 The resulting sorted files are scanned simultaneously and the join is performed.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
Method 3
\end_layout

\end_inset

: multiple passes.
 
\begin_inset Formula $R1$
\end_inset

 is scanned, storing the pertinent fields into a main memory data structure,
 
\begin_inset Formula $W$
\end_inset

.
 If space in main memory is available to insert a subtuple, 
\begin_inset Formula $S$
\end_inset

, it is inserted.
 If there is no space and 
\begin_inset Formula $S.A$
\end_inset

 is less than the current highest value of 
\begin_inset Formula $A$
\end_inset

 in 
\begin_inset Formula $W$
\end_inset

, 
\begin_inset Formula $S$
\end_inset

 is discarded.
 After completing the scan of 
\begin_inset Formula $R1$
\end_inset

, 
\begin_inset Formula $R2$
\end_inset

 is scanned using its clustering image and a tuple 
\begin_inset Formula $S'$
\end_inset

 of 
\begin_inset Formula $R2$
\end_inset

 is obtained.
 Then, 
\begin_inset Formula $W$
\end_inset

 is checked for the presence of 
\begin_inset Formula $S'.A$
\end_inset

.
 If present, 
\begin_inset Formula $S'$
\end_inset

 is joined to the appropriate subtuple in 
\begin_inset Formula $W$
\end_inset

.
 This process continues until all tuples of 
\begin_inset Formula $R2$
\end_inset

 have been examined.
 If any 
\begin_inset Formula $R1$
\end_inset

 subtuples were discarded, another scan of 
\begin_inset Formula $R1$
\end_inset

 is made to form a new 
\begin_inset Formula $W$
\end_inset

 consisting of subtuples with 
\begin_inset Formula $A$
\end_inset

 value greater than the current highest.
 
\begin_inset Formula $R2$
\end_inset

 is scanned again and the process is repeated.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
Method 4
\end_layout

\end_inset

: the TID algorithm.
 Basically, it works as follows:
\end_layout

\begin_deeper
\begin_layout Enumerate
Obtain the TIDs of tuples from 
\begin_inset Formula $R1$
\end_inset

 which satisfy additional restrictions to the join.
 Sort them and store the TIDs in a file 
\begin_inset Formula $F1$
\end_inset

.
 Do the same with 
\begin_inset Formula $R2$
\end_inset

, storing the TIDs in 
\begin_inset Formula $F2$
\end_inset

.
\end_layout

\begin_layout Enumerate
Perform a simultaneous scan over the images on 
\begin_inset Formula $R1.A$
\end_inset

 and 
\begin_inset Formula $R2.A$
\end_inset

, finding the TID pairs of tuples whose values for 
\begin_inset Formula $A$
\end_inset

 match.
\end_layout

\begin_layout Enumerate
Check each pair 
\begin_inset Formula $\left(TID1,TID2\right)$
\end_inset

 to see if 
\begin_inset Formula $TID1$
\end_inset

 is present in 
\begin_inset Formula $W1$
\end_inset

 and 
\begin_inset Formula $TID2$
\end_inset

 is present in 
\begin_inset Formula $W2$
\end_inset

.
 If they are, the tuples are fetched and joined.
\end_layout

\end_deeper
\begin_layout Standard
A method cannot be applied unless the appropriate access paths are available.
 The 
\series bold
performance of a method
\series default
 depends strongly on the clustering of the relations with respect to the
 access paths.
 In the paper, four situation are presented in which the optimizer would
 decide between the four methods, but they claim to detail the cost formulas
 on a later paper:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
Situation 1
\end_layout

\end_inset

: there are clustering images on both 
\begin_inset Formula $R1.A$
\end_inset

 and 
\begin_inset Formula $R2.A$
\end_inset

, but not no images on 
\begin_inset Formula $R1.B$
\end_inset

 or 
\begin_inset Formula $R2.C$
\end_inset

, which are additional conditions.
 
\series bold
Method 1
\series default
 is always chosen.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
Situation 2
\end_layout

\end_inset

: there are non-clustering images on 
\begin_inset Formula $R1.A$
\end_inset

 and 
\begin_inset Formula $R2.A$
\end_inset

, but no images on 
\begin_inset Formula $R1.B$
\end_inset

 or 
\begin_inset Formula $R2.C$
\end_inset

.
 
\series bold
Method 3
\series default
 is chosen if 
\begin_inset Formula $W$
\end_inset

 fits into the main memory buffer at once.
 Otherwise, 
\series bold
Method 2
\series default
 is chosen.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
Situation 3
\end_layout

\end_inset

: there are clustering images on 
\begin_inset Formula $R1.A$
\end_inset

 and 
\begin_inset Formula $R2.A$
\end_inset

 and non-clustering images on 
\begin_inset Formula $R1.B$
\end_inset

 or 
\begin_inset Formula $R2.C$
\end_inset

.
 
\series bold
Method 4 
\series default
is always chosen.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
Situation 4
\end_layout

\end_inset

: there are non-clustering images on 
\begin_inset Formula $R1.A,R2.A,R1.B$
\end_inset

 and 
\begin_inset Formula $R2.C$
\end_inset

.
 
\series bold
Method 3
\series default
 is chosen if 
\begin_inset Formula $W$
\end_inset

 fits into the main memory buffer.
 Otherwise, 
\series bold
Method 2
\series default
 is chosen if more than one tuple per disk page is expected to satisfy the
 restriction predicates.
 In other cases, 
\series bold
Method 4
\series default
 is chosen.
\end_layout

\begin_layout Subsubsection
Optimized Packages
\end_layout

\begin_layout Standard
After analyzing a SQL statement, the optimizer produces an 
\series bold
Optimized Package (OP)
\series default
 containing the parse tree and a plan for executing the statement.
 
\end_layout

\begin_layout Itemize
If the statement is a query, the OP is used to materialize tuples as they
 are called for by the FECTH command.
\end_layout

\begin_layout Itemize
If the statement is a view definition, the OP is stored in the form of a
 
\series bold
Pre-Optimized Package (POP)
\series default
, which can be fetched and utilized whenever an access is made via the specified
 view.
 If any change is made to the structure of a base relation or to the access
 paths maintained on it, the POPs of all views defined on that relation
 are invalidated, and each view must be reoptimized to form a new POP.
\end_layout

\begin_layout Itemize
When a view is accessed via the RDI operators OPEN and FETCH, the POP for
 the view can be used directly to materialize the tuples of the view.
\end_layout

\begin_layout Subsection
PostgreSQL in relation to System R
\end_layout

\begin_layout Standard
Here, we are going to examine how PostgreSQL is similar or different to
 the characteristics of System R:
\end_layout

\begin_layout Itemize

\series bold
Catalog
\series default
: PostgreSQL also maintains a catalog, with similar information about the
 relations, indexes, views,...
 of the system.
\end_layout

\begin_layout Itemize

\series bold
Tuple Identifier (TID)
\series default
: PostgreSQL also has the concept of TID, being it a pair 
\begin_inset Formula $\left(b,e\right)$
\end_inset

, where 
\begin_inset Formula $b$
\end_inset

 indicates the memory block in which the tuple is stored, and 
\begin_inset Formula $e$
\end_inset

 is the position where the tuple starts.
\end_layout

\begin_layout Itemize

\series bold
Image / Clustering image
\series default
: the concept of image is called just index in PostgreSQL, but they are
 extended.
 PostgreSQL defines several types of indexes, and not all of them are ordered.
 For instance, a Hash Index is an unordered index, but a BTree index is
 an ordered index, which would be the most similar one to the concept of
 image in System R.
 PostgreSQL also allows to cluster, but the clustering is made at one point
 in time, using a particular index: this means that subsequent insertions
 will not be done to maintain the clustering property
\begin_inset Foot
status open

\begin_layout Plain Layout
If one wishes to do this, the clustering would need to be redone.
\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize

\series bold
View
\series default
: views in PostgreSQL are very similar to views in System R.
 They can be thought as a stored query, very similar to what happens in
 System R.
 Views are automatically updated when the underlying tables are updated.
 The difference comes when one tries to directly modify a view.
 PostgreSQL has the concept of 
\series bold
Updatable view
\series default
, which are views that can be modified with INSERT, UPDATE or DELETE.
 This views are views that meet the conditions:
\end_layout

\begin_deeper
\begin_layout Itemize
The defining query of the view must have exactly one entry in the FROM clause,
 which can be a table or another updatable view.
\end_layout

\begin_layout Itemize
The defining query must not contain one of the following clauses at the
 top level: GROUP BY, HAVING, LIMIT, OFFSET, DISTINCT, WITH, UNION, INTERSECT,
 and EXCEPT.
 
\end_layout

\begin_layout Itemize
The selection list must not contain any window function , any set-returning
 function, or any aggregate function such as SUM, COUNT, AVG, MIN, and MAX.
\end_layout

\begin_layout Standard
If one tries to modify a updatable view, the system will automatically generate
 the query that performs the appropriate modification in the base table.
 Note that there are some columns that are not modifiable: if one tried
 to modify one of these columns, an error would be raised.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Cost-based query optimization
\series default
: PostgreSQL also has an optimizer that select the best execution plan among
 several equivalent plans with the objective of minimizing the expected
 cost.
\end_layout

\begin_layout Itemize

\series bold
Access path
\series default
: access path specify the path chosen by the system to retrieve the requested
 tuples from a relation.
 As we have seen so far, System R has basically five types of access paths:
 sequential scan, images, binary paths, order-and-scan and TID-scan.
 PostgreSQL defines a wider variety of access path: sequential scan, order-and-s
can, TID-scan, hash indexes, BTree indexes, BitMap indexes,...
\end_layout

\begin_layout Section
Query Optimization
\end_layout

\begin_layout Standard
As we have seen until now, there are alternative ways to evaluate a given
 query: there are equivalent RA expression for the same query, and also
 there are different methods that can physically execute a given query.
\end_layout

\begin_layout Standard
An 
\series bold
evaluation plan 
\series default
defines exactly what algorithm is ued for each operation and how the execution
 of the operations is coordinated.
\end_layout

\begin_layout Subsection
Cost-based query optimization
\end_layout

\begin_layout Standard
Cost difference between evaluation plans for a query can be enormous.
 The general steps in cost-based query optimization are as in System R:
\end_layout

\begin_layout Enumerate
Generate logically equivalent expressions using equivalence rules.
\end_layout

\begin_layout Enumerate
Annotate resultant expressions to get alternative query plans.
\end_layout

\begin_layout Enumerate
Choose the cheapest plan based on the estimated cost.
\end_layout

\begin_layout Standard
The 
\series bold
estimation of the cost
\series default
 is based on:
\end_layout

\begin_layout Itemize
Statistical information about relations.
\end_layout

\begin_layout Itemize
Statistics estimation for intermediate result.
\end_layout

\begin_layout Itemize
Cost formulae for algorithms, computed using statistics.
\end_layout

\begin_layout Subsection
Viewing query evaluation plans
\end_layout

\begin_layout Standard
Most database support the 
\series bold
EXPLAIN <QUERY>
\series default
 statement, which displays the plan chosen by the optimizer, along with
 the cost estimates that it uses for decision.
\end_layout

\begin_layout Standard
Some databases also support 
\series bold
EXPLAIN ANALYSE <QUERY>
\series default
, which shows actual runtime statistics found by running the query, in addition
 to showing the plan.
\end_layout

\begin_layout Standard
Some databases show the cost as
\begin_inset Formula 
\[
f..l
\]

\end_inset

 where 
\begin_inset Formula $f$
\end_inset

 is the cost of delivering the first tuple and 
\begin_inset Formula $l$
\end_inset

 is the cost of delivering all results.
\end_layout

\begin_layout Subsection
Generating equivalent expressions
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
Two relational algebra expressions are 
\series bold
equivalent
\series default
 if the two expressions generate the same set/bag of tuples on every legal
 database instance.
\end_layout

\begin_layout Definition
An 
\series bold
equivalence rule
\series default
 between two expressions ensure that both expressions are equivalent.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now, we are going to list some equivalence rules:
\end_layout

\begin_layout Enumerate
Conjunctive selection can be deconstructed into a sequence of individual
 selections:
\begin_inset Formula 
\[
\sigma_{P_{1}\land P_{2}}\left(E\right)\equiv\sigma_{P_{1}}\left(\sigma_{P_{2}}\left(E\right)\right).
\]

\end_inset


\end_layout

\begin_layout Enumerate
Selection is commutative:
\begin_inset Formula 
\[
\sigma_{P_{1}}\left(\sigma_{P_{2}}\left(E\right)\right)\equiv\sigma_{P_{2}}\left(\sigma_{P_{1}}\left(E\right)\right).
\]

\end_inset


\end_layout

\begin_layout Enumerate
In a sequence of projections, where 
\begin_inset Formula $L_{1}\subset L_{2}\subset...\subset L_{n}$
\end_inset

, only the outermost one is needed:
\begin_inset Formula 
\[
\Pi_{L_{1}}\left(\pi_{L_{2}}\left(...\left(\pi_{L_{n}}\left(E\right)\right)\right)\right)\equiv\Pi_{L_{1}}\left(E\right).
\]

\end_inset


\end_layout

\begin_layout Enumerate
Selections can be combined with cartesian products and theta joins:
\begin_inset Formula 
\[
\sigma_{P}\left(E_{1}\times E_{2}\right)\equiv E_{1}\bowtie_{P}E_{2},
\]

\end_inset


\begin_inset Formula 
\[
\sigma_{P_{1}}\left(E_{1}\bowtie_{P_{2}}E_{2}\right)\equiv E_{1}\bowtie_{P_{1}\land P_{2}}E_{2}.
\]

\end_inset


\end_layout

\begin_layout Enumerate
Theta join operations are commutative
\begin_inset Formula 
\[
E_{1}\bowtie E_{2}\equiv E_{2}\bowtie E_{1}.
\]

\end_inset


\end_layout

\begin_layout Enumerate
And they are associative, in a soft manner:
\end_layout

\begin_deeper
\begin_layout Enumerate
The natural join is associative:
\begin_inset Formula 
\[
\left(E_{1}\bowtie E_{2}\right)\bowtie E_{3}\equiv E_{1}\bowtie\left(E_{2}\bowtie E_{3}\right).
\]

\end_inset


\end_layout

\begin_layout Enumerate
The thetha join is associative in a soft sense:
\begin_inset Formula 
\[
\left(E_{1}\bowtie_{P_{1}}E_{2}\right)\bowtie_{P_{2}\land P_{3}}E_{3}\equiv E_{1}\bowtie_{P_{1}\land P_{3}}\left(E_{2}\bowtie_{P_{2}}E_{3}\right),
\]

\end_inset

 where 
\begin_inset Formula $P_{3}$
\end_inset

 involves attributes that are present in the three relations.
\end_layout

\begin_layout Standard
When we can decide the order of the joins, we would choose the smaller join
 to be performed before, so that we compute and store a smaller temporary
 relation.
\end_layout

\end_deeper
\begin_layout Enumerate
The selection operation distributes over the theta join operation in the
 following two situations:
\end_layout

\begin_deeper
\begin_layout Enumerate
When all the attributes in 
\begin_inset Formula $P_{0}$
\end_inset

 involve only the attributes of one of the expressions being joined:
\begin_inset Formula 
\[
\sigma_{P_{0}}\left(E_{1}\bowtie_{P}E_{2}\right)\equiv\sigma_{P_{0}}\left(E_{1}\right)\bowtie_{P}E_{2}.
\]

\end_inset


\end_layout

\begin_layout Enumerate
When 
\begin_inset Formula $P_{1}$
\end_inset

 involves only the attributes of 
\begin_inset Formula $E_{1}$
\end_inset

 and 
\begin_inset Formula $P_{2}$
\end_inset

 involves only the attributes of 
\begin_inset Formula $E_{2}$
\end_inset

:
\begin_inset Formula 
\[
\sigma_{P_{1}\land P_{2}}\left(E_{1}\bowtie_{P}E_{2}\right)\equiv\sigma_{P_{1}}\left(E_{1}\right)\bowtie_{P}\sigma_{P_{2}}\left(E_{2}\right).
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
The projection operation distributes over the theta join operation as follows:
 If 
\begin_inset Formula $P$
\end_inset

 involves only attributes from 
\begin_inset Formula $L_{1}\cup L_{2}$
\end_inset

:
\begin_inset Formula 
\[
\Pi_{L_{1}\cup L_{2}}\left(E_{1}\bowtie_{P}E_{2}\right)\equiv\Pi_{L_{1}}\left(E_{1}\right)\bowtie_{P}\Pi_{L_{2}}\left(E_{2}\right).
\]

\end_inset

 Similar equivalences hold for outerjoin operations.
\end_layout

\begin_layout Enumerate
Union and intersection are commutative:
\begin_inset Formula 
\[
E_{1}\cup E_{2}\equiv E_{2}\cup E_{1},
\]

\end_inset


\begin_inset Formula 
\[
E_{1}\cap E_{2}\equiv E_{2}\cap E_{1}.
\]

\end_inset


\end_layout

\begin_layout Enumerate
Union and intersection are associative:
\begin_inset Formula 
\[
\left(E_{1}\cup E_{2}\right)\cup E_{3}\equiv E_{1}\cup\left(E_{2}\cup E_{3}\right),
\]

\end_inset


\begin_inset Formula 
\[
\left(E_{1}\cap E_{2}\right)\cap E_{3}\equiv E_{1}\cap\left(E_{2}\cap E_{3}\right).
\]

\end_inset


\end_layout

\begin_layout Enumerate
The selection operation distributes over 
\begin_inset Formula $\cup,\cap$
\end_inset

 and 
\begin_inset Formula $-$
\end_inset

:
\begin_inset Formula 
\[
\sigma_{P}\left(E_{1}\cup E_{2}\right)\equiv\sigma_{P}\left(E_{1}\right)\cup\sigma_{P}\left(E_{2}\right),
\]

\end_inset


\begin_inset Formula 
\[
\sigma_{P}\left(E_{1}\cap E_{2}\right)\equiv\sigma_{P}\left(E_{1}\right)\cap\sigma_{P}\left(E_{2}\right),
\]

\end_inset


\begin_inset Formula 
\[
\sigma_{P}\left(E_{1}-E_{2}\right)\equiv\sigma_{P}\left(E_{1}\right)-\sigma_{P}\left(E_{2}\right),
\]

\end_inset


\begin_inset Formula 
\[
\sigma_{P}\left(E_{1}\cap E_{2}\right)\equiv\sigma_{P}\left(E_{1}\right)\cap E_{2},
\]

\end_inset


\begin_inset Formula 
\[
\sigma_{P}\left(E_{1}-E_{2}\right)\equiv\sigma_{P}\left(E_{1}\right)-E_{2}.
\]

\end_inset


\end_layout

\begin_layout Enumerate
The projection operation distributes over union:
\begin_inset Formula 
\[
\Pi_{L}\left(E_{1}\cup E_{2}\right)\equiv\Pi_{L}\left(E_{1}\right)\cup\Pi_{L}\left(E_{2}\right).
\]

\end_inset

 
\end_layout

\begin_layout Example
Pushing selections.
\end_layout

\begin_layout Example
Query: find the names of all instructors in the Music department, along
 with the title of the courses that they teach.
\end_layout

\begin_layout Example
A first RA expression could be the following:
\begin_inset Formula 
\[
\Pi_{name,title}\left(\sigma_{dpt\_name='Music'}\left(Instructor\bowtie\left(Teaches\bowtie\Pi_{course\_id,title}\left(Course\right)\right)\right)\right).
\]

\end_inset

 It can be transformed using rule 7a:
\begin_inset Formula 
\[
\Pi_{name,title}\left(\left(\sigma_{dpt\_name='Music'}\left(Instructor\right)\right)\bowtie\left(Teaches\right)\bowtie\Pi_{course\_id,title}\left(Course\right)\right).
\]

\end_inset

 The advantage of doing this is taht by performing the selection as early
 as possible we are reducing the size of the relation to be joined.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Example
Pushing projections.
\end_layout

\begin_layout Example
We start with the RA expression:
\begin_inset Formula 
\[
\Pi_{name,title}\left(\left(\sigma_{dpt\_name='Music'}\left(Instructor\right)\bowtie Teaches\right)\bowtie\Pi_{course\_id,title}\left(Course\right)\right).
\]

\end_inset

 When we compute 
\begin_inset Formula 
\[
\sigma_{dpt\_name='Music'}\left(Instructor\right)\bowtie Teaches,
\]

\end_inset

 we obtain a relation with schema 
\begin_inset Formula $\left(ID,name,dpt\_name,salary,course\_id,sec\_id,semester,year\right)$
\end_inset

.
 Equivalence rule 8 allows to push projections, eeliminating unneeded attributes
 from intermediate results to get:
\begin_inset Formula 
\[
\Pi_{name,title}\left(\left(\Pi_{name,course\_id}\left(\sigma_{dpt\_name='Music'}\left(Instructor\right)\bowtie Teaches\right)\right)\bowtie\Pi_{course\_id,title}\left(Course\right)\right).
\]

\end_inset

 This is useful because performing the projection as early as possible reduces
 the size of the relation to be joined.
 Note that 
\begin_inset Formula $course\_id$
\end_inset

 needs to be projected because it is needed for the join.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Example
Join ordering.
\end_layout

\begin_layout Example
Consider the expression
\begin_inset Formula 
\[
\Pi_{name,title}\left(\left(\sigma_{dpt\_name='Music'}\left(Instructor\right)\bowtie Teaches\right)\bowtie\Pi_{course\_id,title}\left(Course\right)\right).
\]

\end_inset

 In this case, we could compute
\begin_inset Formula 
\[
Teaches\bowtie\Pi_{course\_id,title}\left(Course\right)
\]

\end_inset

 first, and then join the result with the left relation.
 The problem with this approach is that doing this join first seems more
 likely to be large, as only a small fraction of the university's instructor
 are going to be from the Music department.
 So it is better to leave the query as is.
\end_layout

\begin_layout Subsection
Enumeration of equivalent expressions
\end_layout

\begin_layout Standard
Query optimizers use equivalence rules to systematically generate expressions
 equivalent to the given expression, which is a first translation of the
 query.
\end_layout

\begin_layout Standard
All the equivalent expressions can be generated with the following approach:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "morekeywords={REPEAT,APPLY,ADD,ON,UNTIL,TO}"
inline false
status open

\begin_layout Plain Layout

REPEAT
\end_layout

\begin_layout Plain Layout

	APPLY all applicable equivalence rules 
\end_layout

\begin_layout Plain Layout

		ON every subexpression of every equivalent expression found so far
\end_layout

\begin_layout Plain Layout

	ADD newly generated expressions 
\end_layout

\begin_layout Plain Layout

		TO the set of equivalent expressions
\end_layout

\begin_layout Plain Layout

UNTIL no new equivalent expressions are generated
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Cost estimation
\end_layout

\begin_layout Standard
The optimizer takes into account the cost of each operator and the statistics
 of the input relations, such as the number of tuples and the sizes of the
 tuples.
 Also, inputs can be results of sub-expressions, so we need to estimate
 estatistics of these results.
 For this purpose, more statistics, such as the number of distinct values
 for an attribute, are used.
\end_layout

\begin_layout Subsection
Choice of execution plan
\end_layout

\begin_layout Standard
Once we have generated different equivalent expressions, we need to decide
 which one to use to execute the query and get the results.
 For this, we must consider the interaction of evaluation techniques, because
 choosing the cheapest algorithm for each operation disregarding the others
 may not yield best overall algorithm.
 For example, a merge-join may be costlier than a hash-join, but may provide
 a sorted output which could reduce the cost for an outer level aggregation.
\end_layout

\begin_layout Standard
Practical query optimizers incorporate elements of two broad approaches:
\end_layout

\begin_layout Enumerate
Search all the plans and choose the best plan in a cost-based fashion.
\end_layout

\begin_layout Enumerate
Uses heuristics to choose a plan.
\end_layout

\begin_layout Subsubsection
Best join-order problem
\end_layout

\begin_layout Standard

\series bold
Problem:
\series default
 find the best join-order for
\begin_inset Formula 
\[
R_{1}\bowtie R_{2}\bowtie...\bowtie R_{n}.
\]

\end_inset


\end_layout

\begin_layout Standard
A first idea could be to check all possibilities and choose the cheapest
 one.
 But...
\end_layout

\begin_layout Proposition
For the best join-order problem, with 
\begin_inset Formula $n$
\end_inset

 relations involved, there are
\begin_inset Formula 
\[
\frac{\left(2\left(n-1\right)\right)!}{n-1}
\]

\end_inset

 different possible join orders.
\end_layout

\begin_layout Proof
First, we need to count all possible orderings, i.e.
 the number of permutations, which is known to be 
\begin_inset Formula $n!$
\end_inset

.
 Now, we have to count all possible ways to assign the 
\begin_inset Formula $n-1$
\end_inset

 needed parenthesis.
 This is known to be the Catalan number
\begin_inset Foot
status open

\begin_layout Plain Layout
See 
\begin_inset CommandInset href
LatexCommand href
name "Catalan Numbers"
target "https://en.wikipedia.org/wiki/Catalan_number#Applications_in_combinatorics"
literal "false"

\end_inset

.
\end_layout

\end_inset


\begin_inset Formula 
\[
\#()_{n-1}=C_{n-1}=\frac{\left(2\left(n-1\right)\right)!}{n!\left(n-1\right)!}.
\]

\end_inset


\end_layout

\begin_layout Proof
Thus, the total amount is
\begin_inset Formula 
\[
n!\cdot C_{n-1}=n!\times\frac{\left(2\left(n-1\right)\right)!}{n!\left(n-1\right)!}=\frac{\left(2\left(n-1\right)\right)!}{\left(n-1\right)!}.
\]

\end_inset


\end_layout

\begin_layout Standard
This number is huge, and it is unfeasable to check the whole search space.
 Thus, a different approach is needed.
\end_layout

\begin_layout Subsubsection*
Dynamic programming approach
\end_layout

\begin_layout Standard
Using dynamic programming, the least-cost join for any subset of 
\begin_inset Formula $\left\{ R_{1},...,R_{n}\right\} $
\end_inset

 is computed only once and stored for future use.
 The algorithm works as follows:
\end_layout

\begin_layout Itemize
Consider all possible plans of the form
\begin_inset Formula 
\[
S_{1}\bowtie\left(S-S_{1}\right),
\]

\end_inset

 where 
\begin_inset Formula $S_{1}$
\end_inset

 is any non-empty subset of 
\begin_inset Formula $S$
\end_inset

.
\end_layout

\begin_layout Itemize
Recursively compute costs for joinin subsets of 
\begin_inset Formula $S$
\end_inset

 to find the cost of each plan.
 Choose the cheapest of the 
\begin_inset Formula $2^{n}-2$
\end_inset

 alternatives.
\end_layout

\begin_layout Itemize

\series bold
Base case
\series default
: single relation access plan.
\end_layout

\begin_deeper
\begin_layout Itemize
Apply all selections on 
\begin_inset Formula $R_{i}$
\end_inset

 using best choice of indices on 
\begin_inset Formula $R_{i}$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize
When the plan for any subset is computed, we store it and reuse it when
 it is required again, instead of recomputing it.
\end_layout

\begin_layout Standard
The pseudocode is shown in Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:procedure-findbestplan(S)"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "morekeywords={if, return, set, and, else, for, each, of}"
inline false
status open

\begin_layout Plain Layout

if (bestplan[S].cost != infty)
\end_layout

\begin_layout Plain Layout

	return bestplan[S]¯
\end_layout

\begin_layout Plain Layout

// else it has not been computed yet
\end_layout

\begin_layout Plain Layout

if (S contains only 1 relation)
\end_layout

\begin_layout Plain Layout

	set bestplan[S].plan and bestplan[S].cost 
\end_layout

\begin_layout Plain Layout

		based on the best way to access S
\end_layout

\begin_layout Plain Layout

else for each non-empty proper subset S1 of S
\end_layout

\begin_layout Plain Layout

	P1 = findbestplan(S1)
\end_layout

\begin_layout Plain Layout

	P2 = findbestplan(S - S1)
\end_layout

\begin_layout Plain Layout

	A = best algorithm for joining P1 and P2
\end_layout

\begin_layout Plain Layout

	cost = P1.cost + P2.cost + A.cost
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	if cost < bestplan[S].cost
\end_layout

\begin_layout Plain Layout

		bestplan[S].cost = cost
\end_layout

\begin_layout Plain Layout

		bestplan[S].plan = plan
\end_layout

\begin_layout Plain Layout

	return bestplan[S]
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout

\series bold
\begin_inset CommandInset label
LatexCommand label
name "alg:procedure-findbestplan(S)"

\end_inset

procedure 
\series default
findbestplan(S)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The time complexity of this algorithm is 
\begin_inset Formula $O\left(3^{n}\right)$
\end_inset

 and the space complexity is 
\begin_inset Formula $O\left(2^{n}\right)$
\end_inset

.
 This is a huge gain with respect to checking the whole search space, but
 it is still a very high cost.
\end_layout

\begin_layout Subsubsection*
Left-deep join trees
\end_layout

\begin_layout Standard
In left-deep join trees, the right-hand-side input for each join is a relation,
 not the result of an intermediate join.
 In Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:A-left-deep-join"
plural "false"
caps "false"
noprefix "false"

\end_inset

 we can see an example of what is a left-deep join tree, and what is not.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula 
\[
\xymatrix{ &  &  &  & \bowtie\ar@{-}[dl]\ar@{-}[dr]\\
 &  &  & \bowtie\ar@{-}[dl]\ar@{-}[dr] &  & R_{5}\\
 &  & \bowtie\ar@{-}[dl]\ar@{-}[dr] &  & R_{4}\\
 & \bowtie\ar@{-}[dl]\ar@{-}[dr] &  & R_{3}\\
R_{1} &  & R_{2}
}
\]

\end_inset

 
\begin_inset Formula 
\[
\xymatrix{ &  &  & \bowtie\ar@{-}[dl]\ar@{-}[dr]\\
 &  & \bowtie\ar@{-}[dl]\ar@{-}[dr] &  & \bowtie\ar@{-}[d]\ar@{-}[dr]\\
 & \bowtie\ar@{-}[dl]\ar@{-}[dr] &  & R_{3} & R_{4} & R_{5}\\
R_{1} &  & R_{2}\\
\\
}
\]

\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:A-left-deep-join"

\end_inset

A left-deep join tree (top) and not a left-deep join tree (bottom).
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
With this structure, we can reduce the cost of the optimization problem.
\end_layout

\begin_layout Standard
For a set of 
\begin_inset Formula $n$
\end_inset

 relations, we can consider 
\begin_inset Formula $n$
\end_inset

 alternatives with one relation as right-hand-side input and the other relations
 as left-hand-side input.
\end_layout

\begin_layout Standard
The time complexity of finding the best join order is in this case 
\begin_inset Formula $O\left(n2^{n}\right)$
\end_inset

 and the space complexity remains the same.
\end_layout

\begin_layout Standard
At this points, one might think that it is of no use bothering with optimizing
 the order of queries, if it so costful, but, in reality, typical queries
 have a small 
\begin_inset Formula $n$
\end_inset

, usually less than 10, and a good ordering can change a query from being
 unfeasable to being executed in an acceptable time.
\end_layout

\begin_layout Subsubsection*
Heuristic optimization
\end_layout

\begin_layout Standard
As we have seen, cost-based optimization is expensive, even using dynamic
 programming.
\end_layout

\begin_layout Standard

\series bold
Heuristic optimization
\series default
 transforms the query-tree by using a set of rules that typically improve
 execution performance.
 These rules can include:
\end_layout

\begin_layout Itemize
Perform selection early.
\end_layout

\begin_layout Itemize
Perform projection early.
\end_layout

\begin_layout Itemize
Peform most restrictive selection and join operations before other similar
 operations.
\end_layout

\begin_layout Standard
Some systems use only heuristics, while others combine the two approaches.
 A frequently used approach is the following:
\end_layout

\begin_layout Enumerate
Heuristic rewriting of nested block structure and aggregation.
\end_layout

\begin_layout Enumerate
A cost-based join-order optimization for each block.
\end_layout

\begin_layout Standard
There is usually an 
\series bold
optimization cost budget
\series default
 to stop optimization early if the cost of the plan is less than the cost
 of the optimizations to be made.
\end_layout

\begin_layout Standard
Also, it can be useful to implement 
\series bold
plan caching
\series default
 to reuse previouly computed plans if queries are resubmitted.
\end_layout

\begin_layout Standard
It is worth to note that even with the use of heuristics, cost-based query
 optimization imposes a substantial overhead in the computations, but it
 is worthy for expensive queries.
 For this reason, optimizers often use simple heristics for cheap queries,
 and perform a more exhaustive enumeration for more expensive queries.
\end_layout

\begin_layout Section
Statistics for cost estimation
\end_layout

\begin_layout Standard
Statistics of relations are of great importance for improving the performance
 of the system, because they allow to estimate the cost more accurately.
\end_layout

\begin_layout Standard
Some statistical information that is used:
\end_layout

\begin_layout Itemize
\begin_inset Formula $n_{r}$
\end_inset

 the number of tuples in relation 
\begin_inset Formula $r$
\end_inset

,
\end_layout

\begin_layout Itemize
\begin_inset Formula $b_{r}$
\end_inset

 the number of blocks containing tuples of 
\begin_inset Formula $r$
\end_inset

,
\end_layout

\begin_layout Itemize
\begin_inset Formula $l_{r}$
\end_inset

 the size of a tuple of 
\begin_inset Formula $r$
\end_inset

,
\end_layout

\begin_layout Itemize
\begin_inset Formula $f_{r}$
\end_inset

 the blocking factor, or the number of tuples that fit into one block.
 If the tuples of 
\begin_inset Formula $r$
\end_inset

 are stored together physically in a file, then it is
\begin_inset Formula 
\[
b_{r}=\left\lceil \frac{n_{r}}{f_{r}}\right\rceil .
\]

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $V\left(A,r\right)$
\end_inset

 the number of distinct values that appear in 
\begin_inset Formula $r$
\end_inset

 for attribute 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\begin_layout Subsection
Histograms
\end_layout

\begin_layout Standard
Histograms are useful for cost estimation.
 Histogram can be of two types:
\end_layout

\begin_layout Itemize

\series bold
Equi-width
\series default
: the space is divided into 
\begin_inset Formula $M$
\end_inset

 buckets of the same size.
\end_layout

\begin_layout Itemize

\series bold
Equi-depth
\series default
: the space is divided into 
\begin_inset Formula $M$
\end_inset

 buckets, in such a way that all buckets have the same number of tuples
 inside.
\end_layout

\begin_layout Standard
Many databases store the 
\begin_inset Formula $n$
\end_inset

 most frequent values and their counts, and they construct histogram for
 the remaining values.
 Usually, they are computed not on all the actual values, but on a sample
 of them.
\end_layout

\begin_layout Standard
This sampling approach make it possible for the statistics to be outdated,
 so they need to be recomputed:
\end_layout

\begin_layout Itemize
Some databases require a ANALYZE (VACUUM) command to be explicitly executed
 to update statistics.
\end_layout

\begin_layout Itemize
Others automatically perform the recomputation.
\end_layout

\begin_layout Subsection
Estimation of selection size
\end_layout

\begin_layout Standard
We want to estimate the size of a selection, but this depends on the conditions
 to fullfil:
\end_layout

\begin_layout Itemize
\begin_inset Formula $\sigma_{A=v}\left(r\right)$
\end_inset

: a simple equality condition size is estimated as the size of the relation,
 divided by the number of distinct values for attribute 
\begin_inset Formula $A$
\end_inset

:
\begin_inset Formula 
\[
C=\frac{n_{r}}{V\left(A,r\right)}.
\]

\end_inset

 Nonetheless:
\end_layout

\begin_deeper
\begin_layout Itemize
If the attribute is a key attribute: the estimation is 1.
\end_layout

\begin_layout Itemize
If the value 
\begin_inset Formula $v$
\end_inset

 is among the most frequent values of attribute 
\begin_inset Formula $A$
\end_inset

, we can give more accurate estimations.
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $\sigma_{A\leq v}\left(r\right)$
\end_inset

: a simple inequality condition is more complex than before.
 Let 
\begin_inset Formula $c$
\end_inset

 denote the estimated number of tuples satisfying the condition.
 If 
\begin_inset Formula $m=\min\left(A,r\right)$
\end_inset

 and 
\begin_inset Formula $M=\max\left(A,r\right)$
\end_inset

 are available in the catalog then:
\begin_inset Formula 
\[
c=\begin{cases}
0, & if\ v<m\ \lor\ v>M\\
n_{r}\frac{v-m}{M-m}, & otherwise
\end{cases}
\]

\end_inset

 So, we approximate by a linear interpolation over the total number of records.
 Note that if histograms are available, this estimation can be refined by
 summing all buckets below 
\begin_inset Formula $v$
\end_inset

 and interpolating only in the bucket in which 
\begin_inset Formula $v$
\end_inset

 lies.
\end_layout

\begin_deeper
\begin_layout Standard
When there is a lack of statistical information, 
\begin_inset Formula $c$
\end_inset

 is assumed to be 
\begin_inset Formula $\frac{n_{r}}{2}$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Standard
For more complex conditions, we need a new definition:
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
The 
\series bold
selectivity
\series default
 of a condition 
\begin_inset Formula $P$
\end_inset

 is the probability that a tuple in the relation 
\begin_inset Formula $r$
\end_inset

 satisfies 
\begin_inset Formula $P$
\end_inset

.
 If 
\begin_inset Formula $s_{P}$
\end_inset

 is the number of tuples satisfying the condition, then the selectivity
 is given by
\begin_inset Formula 
\[
S_{P}=\frac{s_{P}}{n_{r}}.
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\series bold
Conjunction
\series default
, 
\begin_inset Formula $\sigma_{P_{1}\land...\land P_{k}}\left(r\right)$
\end_inset

: assuming independence, we have
\begin_inset Formula 
\[
c=n_{r}\times S_{P_{1}}\times...\times S_{P_{k}}=n_{r}\frac{s_{P_{1}}\cdot...\cdot s_{P_{k}}}{n_{r}^{n}}.
\]

\end_inset


\end_layout

\begin_layout Itemize

\series bold
Disjunction
\series default
, 
\begin_inset Formula $\sigma_{P_{1}\lor...\lor P_{k}}\left(r\right)$
\end_inset

: we do the following
\begin_inset Formula 
\[
Prob\left(A_{1}\lor...\lor A_{k}\right)=Prob\left(\overline{\overline{A_{1}\lor...\lor A_{k}}}\right)=Prob\left(\overline{\overline{A_{1}}\land...\land\overline{A_{k}}}\right)=1-Prob\left(\overline{A_{1}}\land...\land\overline{A_{k}}\right),
\]

\end_inset

 which, assuming independence is equal to
\begin_inset Formula 
\[
1-Prob\left(\overline{A_{1}}\right)\cdot...\cdot Prob\left(\overline{A_{k}}\right)=1-\left(1-Prob\left(A_{1}\right)\right)\cdot...\cdot\left(1-Prob\left(A_{k}\right)\right).
\]

\end_inset

 So, it is
\begin_inset Formula 
\[
c=n_{r}\times\left[1-\left(1-\frac{s_{P_{1}}}{n_{r}}\right)\cdot...\cdot\left(1-\frac{s_{P_{k}}}{n_{r}}\right)\right].
\]

\end_inset


\end_layout

\begin_layout Itemize

\series bold
Negation
\series default
, 
\begin_inset Formula $\sigma_{\lnot P}\left(R\right)$
\end_inset

: this is just
\begin_inset Formula 
\[
c=n_{r}\cdot\left(1-S_{P}\right)=n_{r}-n_{r}S_{P}=n_{r}-s_{p}.
\]

\end_inset


\end_layout

\begin_layout Subsection
Estimation of the size of joins
\end_layout

\begin_layout Standard
The 
\series bold
cartesian product
\series default
 of two relations 
\begin_inset Formula $r_{1}$
\end_inset

 and 
\begin_inset Formula $r_{2}$
\end_inset

 contains exactly 
\begin_inset Formula $n_{r_{1}}\times n_{r_{2}}$
\end_inset

 tuples, and each tuple occupies 
\begin_inset Formula $l_{r_{1}}+l_{r_{2}}$
\end_inset

 bytes.
\end_layout

\begin_layout Standard
About the join:
\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $r_{1}\cap r_{2}=\emptyset$
\end_inset

, then 
\begin_inset Formula $r_{1}\bowtie r_{2}$
\end_inset

 is the same as 
\begin_inset Formula $r_{1}\times r_{2}$
\end_inset

.
\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $r_{1}\cap r_{2}$
\end_inset

 is a key for 
\begin_inset Formula $r_{1}$
\end_inset

, then a tuple of 
\begin_inset Formula $r_{2}$
\end_inset

 will join with at most one tuple from 
\begin_inset Formula $r_{1}$
\end_inset

, so the number of tuples in 
\begin_inset Formula $r_{1}\bowtie r_{2}$
\end_inset

 is, at most, the number of tuples in 
\begin_inset Formula $r_{2}$
\end_inset

.
\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $r_{1}\cap r_{2}$
\end_inset

 is a foreign key in 
\begin_inset Formula $r_{2}$
\end_inset

 referencing 
\begin_inset Formula $r_{1}$
\end_inset

, then the number of tuples in 
\begin_inset Formula $r_{1}\bowtie r_{2}$
\end_inset

 is exactly the same as the number of tuples in 
\begin_inset Formula $r_{2}$
\end_inset

.
\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $r_{1}\cap r_{2}=\left\{ A\right\} $
\end_inset

 is not a key for 
\begin_inset Formula $r_{1}$
\end_inset

 nor 
\begin_inset Formula $r_{2}$
\end_inset

: let assume that every tuple 
\begin_inset Formula $t$
\end_inset

 in 
\begin_inset Formula $r_{1}$
\end_inset

 produces tuples in the join, then the number of tuples in the join is estimated
 to be
\begin_inset Formula 
\[
c=\frac{n_{r_{1}}\cdot n_{r_{2}}}{V\left(A,r_{2}\right)},
\]

\end_inset

 i.e., the number of tuples in the cartesian product, divided by the number
 of different values for the attribute 
\begin_inset Formula $A$
\end_inset

 in the second relation.
 This is because each value in 
\begin_inset Formula $r_{1}$
\end_inset

 will join with more or less 
\begin_inset Formula $\frac{n_{r_{2}}}{V\left(A,r_{2}\right)}$
\end_inset

 values.
\end_layout

\begin_deeper
\begin_layout Standard
If we assume the reverse, i.e., every tuple in 
\begin_inset Formula $r_{2}$
\end_inset

 produces tuples, then we get
\begin_inset Formula 
\[
c=\frac{n_{r_{1}}\cdot n_{r_{2}}}{V\left(A,r_{1}\right)},
\]

\end_inset

 for the same reason.
\end_layout

\begin_layout Standard
The lower of these two estimates is probably the most accurate one, so both
 are computed and the best one is chosen.
\end_layout

\begin_layout Standard
This estimates can be improved using histograms, by using the same formula
 but on each bucket, and summing them up.
\end_layout

\end_deeper
\begin_layout Example
Estimating the size of a join.
\end_layout

\begin_layout Example
Let perform 
\begin_inset Formula 
\[
student\bowtie takes
\]

\end_inset

 with the following information:
\end_layout

\begin_layout Itemize
\begin_inset Formula $n_{student}=5000,f_{student}=50$
\end_inset

 so 
\begin_inset Formula $b_{student}=\frac{5000}{50}=100$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $n_{takes}=10000,f_{takes}=25$
\end_inset

 so 
\begin_inset Formula $b_{takes}=\frac{10000}{25}=400$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $V\left(ID,takes\right)=2500$
\end_inset

, so, on average, each student that has taken a course, has taken 4 courses.
 
\end_layout

\begin_layout Itemize
The attribute 
\begin_inset Formula $ID$
\end_inset

 in takes is a foreign key referencing 
\begin_inset Formula $student$
\end_inset

, in which it is a primary key: 
\begin_inset Formula $V\left(ID,student\right)=5000$
\end_inset

.
\end_layout

\begin_layout Standard
The most accurate estimation in this case is the one using the fact that
 
\begin_inset Formula $ID$
\end_inset

 is a foreign key, which implies that the number of tuples is the same as
 the number of the referencing relation, 
\begin_inset Formula $takes$
\end_inset

, so
\begin_inset Formula 
\[
c=n_{takes}=10000.
\]

\end_inset

 Let's nonetheless compute an estimate disregarding this:
\begin_inset Formula 
\[
c_{1}=\frac{5000\cdot10000}{2500}=20000,
\]

\end_inset


\begin_inset Formula 
\[
c_{2}=\frac{5000\cdot10000}{5000}=10000.
\]

\end_inset

 We choose the lower estimate, 
\begin_inset Formula $c_{2}$
\end_inset

, which in this case is the same as the one we chose before! But this is
 no surprise, this will always happen with foreign keys, because 
\begin_inset Formula $V\left(A,r_{1}\right)=n_{r_{1}}$
\end_inset

 if 
\begin_inset Formula $A$
\end_inset

 is key, so we would have
\begin_inset Formula 
\[
c_{2}=\frac{n_{r_{1}}\cdot n_{r_{2}}}{n_{r_{1}}}=n_{r_{2}},
\]

\end_inset

 which is the same value that we get using the other estimation.
 Also, 
\begin_inset Formula $V\left(A,r_{2}\right)$
\end_inset

 will be at most 
\begin_inset Formula $n_{r_{1}}$
\end_inset

, because it is a foreign key, so it cannot have more values than the referenced
 attribute!
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Indexing
\end_layout

\begin_layout Section
Conventional indexes
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
An 
\series bold
index
\series default
 is a data structure that facilitates the recovering of data.
 The idea is to maintain pointers to the specific directions where some
 data is stored.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As we know, the disk can be logically seen as a sequence of pages of a certain
 size.
 Every file that we store in a computer must be stored in one or more pages.
 Now, imagine we want to retrieve a file's content.
 For this, we need to fetch the data from where it is stored.
 If we don't use indexes, we would need to sequentially traverse the disk
 until we find the desired file.
\end_layout

\begin_layout Example
Imagine a simplified setup with a disk of 
\begin_inset Formula $N$
\end_inset

 pages and with files that occupy one page.
 If we need to recover a specific file that is stored in memory, without
 further information, it would take an average of 
\begin_inset Formula $\frac{N}{2}$
\end_inset

 pages to be fetched.
\end_layout

\begin_layout Standard
An index can be used to mitigate this impact.
 There are multiple types of indexes, but the simplest form of an index
 is just a map in which each file identifier is associated to the direction
 of its first byte in memory.
 This way, only knowing which file we want to recover, we can access it
 directly using the index.
\end_layout

\begin_layout Example
In the previous setup, imagine we store an index in the first page.
 In this scenario, to recover a specific file we need to fetch the first
 page, look the index to get the direction of our file, and directly fetch
 the correct page.
 In total, we would fetch 2 pages.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
A 
\series bold
dense index
\series default
 is an index that maintains one pointer per key.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Properties of dense indexes:
\end_layout

\begin_layout Itemize
If a key is not listed, the key does not exist.
\end_layout

\begin_layout Itemize
They can be used in sequential and non-sequential files.
\end_layout

\begin_layout Itemize
Querying a dense index is more efficient than querying a sequential file
 because we will likely retrieve less pages from disk to memory.
\end_layout

\begin_layout Itemize
They are usually ordered, so searchs can be done using the binary search
 algorithm.
\end_layout

\begin_layout Example
A dense index.
\end_layout

\begin_layout Example
A dense index on a sequential file looks like this:
\end_layout

\begin_layout Example
\begin_inset Graphics
	filename dense_idx_seq.png
	scale 60

\end_inset


\end_layout

\begin_layout Example
And on a non-sequential file like this:
\end_layout

\begin_layout Example
\begin_inset Graphics
	filename dense_idx_nonseq.png
	scale 60

\end_inset


\end_layout

\begin_layout Example
If we want to retrieve the segment with key=30, we would do binary search
 in the index and then we would get the disk direction of this segment.
\end_layout

\begin_layout Example
If we are asked to retrieve a segment with a key that is not in the index,
 we would directly return an error after searching for it and not finding
 it, because we are sure there is no segment with that key in the disk.
 For example, there is no segment with key 25, and so there is no entry
 in the index with key 25.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
A 
\series bold
sparse index
\series default
 maintains a pointer per page/block.
 This means that only the first key on the each block.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Properties of sparse index:
\end_layout

\begin_layout Itemize
They are also sorted, so binary search can be conducted to find the requested
 key.
 In this case, we are looking for the biggest key that is less than the
 requested key.
 We then would go to the page where this key is and scan sequentially until
 we reach the requested key or a key bigger than it, in which case we would
 return an error.
\end_layout

\begin_layout Itemize
They need less space than dense indexes.
\end_layout

\begin_layout Itemize
Can only be used in sequential files, because the basic idea for sparse
 indexes to work is that data is sorted in the same way as the index.
\end_layout

\begin_layout Example
Sparse index.
\end_layout

\begin_layout Example
A sparse index looks like this:
\end_layout

\begin_layout Example
\begin_inset Graphics
	filename sparse_idx_seq.png
	scale 60

\end_inset


\end_layout

\begin_layout Example
If we want to retrieve the segment with key=30, the procedure is exactly
 as with a dense index.
\end_layout

\begin_layout Example
If we want to retrieve the segment with key=40, then we would search for
 30 (the biggest key smaller than 40), we would go to where it is.
 Then, we would advance until we found the segment with key=40.
\end_layout

\begin_layout Example
If we want to retrieve the segment with key=25, we would search for 10,
 we would go to where it is.
 Then, we would advance until we reached the end of the page, and we would
 return an error, because now we are sure there is no segment with key=25.
\end_layout

\begin_layout Subsection
Sparse second level index
\end_layout

\begin_layout Standard
When an index becomes very big, the searchs start to slow down, because
 the binary search needs to be done over a bigger index, which can even
 occupy several pages, which would need to be fetched.
 
\end_layout

\begin_layout Standard
When this happen, a possible way to speed up the search is to add a sparse
 index that points to the already defined index.
\end_layout

\begin_layout Example
A second level sparse index.
\end_layout

\begin_layout Example
In this diagram we can see a second level sparse index on a sparse index:
\end_layout

\begin_layout Example
\begin_inset Graphics
	filename sparse_idx_2nd_lvl.png
	scale 50

\end_inset


\end_layout

\begin_layout Example
If we wanted to retrieve the segment with key=30, we would check the 2nd
 level sparse index, we would get the page where the index should have this
 key stored.
 We would go to this page, and we would find the key=30 already in the index,
 so we would go to the indicated direction.
\end_layout

\begin_layout Standard

\series bold
Question:
\series default
 does it make sense to use a second level dense index?
\end_layout

\begin_layout Standard
No, it would be a copy of the first level index, so we would not gain anything.
 Second level indexes are sparse.
 Note, nonetheless, that the first level index can indeed be of any kind.
\end_layout

\begin_layout Standard

\series bold
Question:
\series default
 what is the tradeoff between sparse and dense indexes?
\end_layout

\begin_layout Standard
Sparse indexes needs less space to be stored and this also allows to have
 a bigger part of the index in memory when we need it.
 On the other hand, dense indexes can tell if any record exists without
 accessing the files.
\end_layout

\begin_layout Subsection
How to deal with duplicate keys.
\end_layout

\begin_layout Standard
Imagine we have a disk with the following data:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename dup_keys_disk.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
A naïve solution would be to just use a dense index, where all the keys
 are listed repeatedly:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename dup_keys_dense_idx.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
In this case, we are solving the problem of duplicate keys...
 but we are probably using more space that we wanted.
 It would be better to have unique keys in the indexes.
 Thus, a second approach could be to only store the first appearance of
 each key, and use it to fetch the data, scanning sequentially until all
 records with the same key have been retrieved.
 This is illustrated below:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename dup_keys_2ndway.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
See, nonetheless, that this solution requires that the file is sequentially
 stored in memory, because when we recover the second segment with key=10,
 in order to recover the third one, the only possible way is to continue
 a sequential scan.
\end_layout

\begin_layout Standard
Now, a third approach is an intermediate approach: we can use a sparse index
 with duplicate keys, meaning we index the first key in each page:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename dup_keys_sparse.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
In this case, when we want to search for a key, we always need to go to
 the biggest key that is smaller than the requested one, even if the requested
 one is in the index keyset.
 For example, if in the example above we used the indexed direction for
 key=20, we would miss the first record of this key.
\end_layout

\begin_layout Standard
An improved version of this solution is to index only the first new key
 in each page:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename dup_keys_sparse_v2.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
Note that in this case, all keys will be listed once, so we don't need to
 retrieve the file for inexistent keys, but sequentially ios required.
\end_layout

\begin_layout Subsection
How to delete records
\end_layout

\begin_layout Subsubsection
Deletion from sparse index with no duplicates
\end_layout

\begin_layout Standard
If we want to delete a record, we need to make sure that the index is updated
 if needed.
 The steps to delete a record are the following:
\end_layout

\begin_layout Enumerate
To delete key 
\begin_inset Formula $K$
\end_inset

, do a binary search in the index.
\end_layout

\begin_layout Enumerate
Depending if 
\begin_inset Formula $K$
\end_inset

 is in the index or not:
\end_layout

\begin_deeper
\begin_layout Enumerate
If 
\begin_inset Formula $K$
\end_inset

 is not in the index we visit the direction of the biggest key that is smaller
 than the requested one.
 We advance until we find the record with key 
\begin_inset Formula $K$
\end_inset

 and we delete it.
\end_layout

\begin_layout Enumerate
If 
\begin_inset Formula $K$
\end_inset

 is in the index, we visit its direction and we delete it.
 Now, two possibilities arise:
\end_layout

\begin_deeper
\begin_layout Enumerate
If there are more records in the same page, we shift them up, and we update
 the key.
\end_layout

\begin_layout Enumerate
If there no more records in the same page, we delete the key from the index
 and we shift the rest of the keys up.
\end_layout

\end_deeper
\end_deeper
\begin_layout Example
Case 2.(a): DELETE 40
\end_layout

\begin_layout Example
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Initial state
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Final state
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename sparse_idx_seq.png
	scale 40

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename sparse_idx_delete40.png
	scale 40

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Legend
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Red
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Delete
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Example
Case 2.(b).i.: DELETE 30
\end_layout

\begin_layout Example
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Initial state
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Second state
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Final state
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename sparse_idx_seq.png
	scale 25

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename sparse_idx_delete30_1.png
	scale 25

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename sparse_idx_delete30_2.png
	scale 25

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Legend
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Red
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Delete
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yellow
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Update
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Example
Case 2.(b).ii.: DELETE 30 and 40
\end_layout

\begin_layout Example
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Initial state
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Second state
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Final state
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename sparse_idx_seq.png
	scale 25

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename sparse_idx_delete3040_1.png
	scale 25

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename sparse_idx_delete3040_2.png
	scale 25

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Legend
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Red
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Delete
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yellow
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Update
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Subsubsection
Deletion from dense index
\end_layout

\begin_layout Standard
In this case, we will always find the keys to delete in the index, so the
 steps are easier:
\end_layout

\begin_layout Enumerate
To delete key 
\begin_inset Formula $K$
\end_inset

, do a binary search on the index.
\end_layout

\begin_layout Enumerate
Delete records in the corresponding page, shifting up the rest of the records
 to not leave holes.
\end_layout

\begin_layout Enumerate
Update all shifted records.
\end_layout

\begin_layout Example
Deletion from dense index: DELETE 30
\end_layout

\begin_layout Example
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Initial state
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Second state
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Final state
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename dense_idx_seq.png
	scale 25

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename dense_idx_delete30_1.png
	scale 25

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename dense_idx_delete30_2.png
	scale 25

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Legend
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Red
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Delete
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yellow
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Update
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
How to insert records
\end_layout

\begin_layout Standard
We need to follow the next steps
\begin_inset Foot
status open

\begin_layout Plain Layout
The steps are analogous for sparse and dense indexes.
\end_layout

\end_inset

:
\end_layout

\begin_layout Enumerate
We want to insert record with key 
\begin_inset Formula $K$
\end_inset

.
 First, we do a binary search to see where it should be located.
\end_layout

\begin_layout Enumerate
Now, in the first page that it can be located according to the index, two
 things can happen:
\end_layout

\begin_deeper
\begin_layout Enumerate
If there is space for the record: we insert it.
\end_layout

\begin_layout Enumerate
If there is not space for the record: we need to shift the following records
 down, updating the necessary index entries.
\end_layout

\end_deeper
\begin_layout Example
INSERT 15
\end_layout

\begin_layout Example
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Initial state
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Second state
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Final state
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename sparse_idx_insert_0.png
	scale 25

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename sparse_idx_insert_1.png
	scale 25

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename sparse_idx_insert_2.png
	scale 25

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Legend
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Red
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Delete
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yellow
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Update
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Green
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Insert
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
Secondary indexes
\end_layout

\begin_layout Standard
Imagine we have an unordered file in memory, which we would like to be able
 to traverse in order without implying great costs.
 If we try to do this by sequentially scanning the disk, we would need to
 fetch several times each page and it would be highly inneficient, so we
 could think on using indexes to solve this problem.
\end_layout

\begin_layout Standard
As we have seen, sparse indexes cannot be used with unordered files (some
 records would be lost), so our only option here is to use an ordered dense
 index that enables us to recover each record in the desired order.
 Now, as we are indexing the whole file with an dense index, it is likely
 that the index is huge, so it seems convenient to add a second level sparse
 index to speed things up even more.
\end_layout

\begin_layout Standard
This is a secondary index:
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
A 
\series bold
secondary index
\series default
 is a 
\begin_inset Formula $N$
\end_inset

-level index structure, composed by a first-level dense index and the rest
 of the levels are sparse.
 All this indexes are ordered to make use of binary search, in order to
 be capable of recovering unsequentially stored records from disk efficiently.
 
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Duplicate values and secondary indexes
\end_layout

\begin_layout Standard
Again, duplicate keys pose a problem to secondary indexes.
 Think in the following setup:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename second_index_disk.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
Here, the solutions that we proposed before don't work, because for them
 we needed sequentially stored files.
 In this case, again, the naïve solution is a dense index:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename second_index_0.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
The problem with this solution is that this cause an excessive overhead,
 both in disk space (we are storing repeatedly the same keys) and in search
 time (because the index keyset needs to be accessed several times per key).
 An alternative is to store only once each key, and associate a list of
 pointers:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename second_index_1.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
But this has the problem that the index entries can have different sizes,
 which difficult the search.
\end_layout

\begin_layout Standard
Another idea is to use buckets of pointers:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename second_index_2.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
This structure is very helpful in some situations, for example when we want
 to get data with some conditions that involves different fields indexed.
\end_layout

\begin_layout Example
Imagine the relation EMP(name,dept,floor), with a primary index on name
 and two secondary indexes with bucket structure in dept and floor.
\end_layout

\begin_layout Example
Now, let's say we want to retrieve all employees in the department 'Toy'
 and in floor 2.
 Our structure make this query very easy:
\end_layout

\begin_layout Example
\begin_inset Graphics
	filename bucket_intersection.png
	scale 35

\end_inset


\end_layout

\begin_layout Example
As we can see, it is possible to use both indexes and then fetch only those
 records that are return by the two of them!
\end_layout

\begin_layout Section
B-Trees
\end_layout

\begin_layout Standard
This section is adapted from 
\begin_inset CommandInset citation
LatexCommand cite
key "garcia2002"
literal "false"

\end_inset

.
 
\end_layout

\begin_layout Standard
B-trees automatically maintain as many levels of index as is appropriate
 for the size of the file being indexed and manage the space on the blocks
 they use so that every block is between half used and completely full.
\end_layout

\begin_layout Standard
A B-tree organizes its blocks into a tree that is balanced, meaning that
 all paths from the root to a leaf have the same length.
 A BTree can be visualized in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:A-BTree.-Source:"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pegado1.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:A-BTree.-Source:"

\end_inset

A BTree.
 Source: 
\begin_inset CommandInset citation
LatexCommand cite
key "garcia2002"
literal "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
There is a parameter 
\begin_inset Formula $n$
\end_inset

 associated with each B-tree index, and this parameter determines the layout
 of all blocks of the B-tree.
 Each block will have space for 
\begin_inset Formula $n$
\end_inset

 search-key values and 
\begin_inset Formula $n+1$
\end_inset

 pointers.
\end_layout

\begin_layout Standard
We pick 
\begin_inset Formula $n$
\end_inset

 to be as large as will allow 
\begin_inset Formula $n+1$
\end_inset

 pointers and 
\begin_inset Formula $n$
\end_inset

 keys to fit in one block.
\end_layout

\begin_layout Example
Suppose our blocks are 4096 bytes.
 Also let keys be integers of 4 bytes and let pointers be 8 bytes.
 If there is no header information kept on the blocks, then we want to find
 the largest integer value of 
\begin_inset Formula $n$
\end_inset

 such that 
\begin_inset Formula $4n+8(n+1)<4096$
\end_inset

.
 That value is 
\begin_inset Formula $n=340$
\end_inset

.
\end_layout

\begin_layout Standard
There are several important rules about what can appear in the blocks of
 a B-tree:
\end_layout

\begin_layout Itemize
The keys in leaf nodes are copies of keys from the data file.
 These keys are distributed among the leaves in sorted order, from left
 to right.
\end_layout

\begin_layout Itemize
At the root, there are at least two used pointers.
 All pointers point to B-tree blocks at the level below.
\end_layout

\begin_layout Itemize
At a leaf, the last pointer points to the next leaf block to the right,
 i.e., to the block with the next higher keys.
 Among the other 
\begin_inset Formula $n$
\end_inset

 pointers in a leaf block, at least 
\begin_inset Formula $\left\lfloor \frac{n+1}{2}\right\rfloor $
\end_inset

 of these pointers are used and point to data records; unused pointers are
 null and do not point anywhere.
 The 
\begin_inset Formula $i^{th}$
\end_inset

 pointer, if it is used, points to a record with the 
\begin_inset Formula $i^{th}$
\end_inset

 key.
\end_layout

\begin_layout Itemize
At an interior node, all 
\begin_inset Formula $n+1$
\end_inset

 pointers can be used to point to B-tree blocks at the next lower level.
 At least 
\begin_inset Formula $\left\lceil \frac{n+1}{2}\right\rceil $
\end_inset

 of them are actually used (but if the node is the root, then we require
 only that at least 2 be used, regardless of how large 
\begin_inset Formula $n$
\end_inset

 is).
 If 
\begin_inset Formula $j$
\end_inset

 pointers are used, then there will be 
\begin_inset Formula $j—1$
\end_inset

 keys, say 
\begin_inset Formula $K_{1},K_{2},...,K_{j-1}$
\end_inset

.
 The first pointer points to a part of the B-tree where some of the records
 with keys less than 
\begin_inset Formula $K_{1}$
\end_inset

 will be found.
 The second pointer goes to that part of the tree where all records with
 keys that are at least 
\begin_inset Formula $K_{1}$
\end_inset

, but less than 
\begin_inset Formula $K_{2}$
\end_inset

 will be found, and so on.
 Finally, the 
\begin_inset Formula $j^{th}$
\end_inset

 pointer gets us to the part of the B-tree where some of the records with
 keys greater than or equal to 
\begin_inset Formula $K_{j-1}$
\end_inset

 are found.
 Note that some records with keys far below 
\begin_inset Formula $K_{1}$
\end_inset

 or far above 
\begin_inset Formula $K_{j-1}$
\end_inset

 may not be reachable from this block at all, but will be reached via another
 block at the same level.
\end_layout

\begin_layout Itemize
All used pointers and their keys appear at the beginning of the block, with
 the exception of the 
\begin_inset Formula $\left(n+1\right)^{th}$
\end_inset

 pointer in a leaf, which points to the next leaf.
\end_layout

\begin_layout Standard
In Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:A-BTree.-Source:"
plural "false"
caps "false"
noprefix "false"

\end_inset

, the chosen 
\begin_inset Formula $n$
\end_inset

 is 3.
\end_layout

\begin_layout Subsection
Lookup in BTree
\end_layout

\begin_layout Standard
Suppose we want to find a record with key 
\begin_inset Formula $K$
\end_inset

.
 The procedure is:
\end_layout

\begin_layout Itemize

\series bold
Base
\series default
 
\series bold
case
\series default
: if we are at a leaf node, look among the keys.
 If the 
\begin_inset Formula $i^{th}$
\end_inset

 key is 
\begin_inset Formula $K$
\end_inset

, then the 
\begin_inset Formula $i^{th}$
\end_inset

 pointer is the one that we were looking for.
\end_layout

\begin_layout Itemize

\series bold
Inductive case
\series default
: if we are at an interior node with keys 
\begin_inset Formula $K_{1},...,K_{n}$
\end_inset

 we find 
\begin_inset Formula $i$
\end_inset

 such that 
\begin_inset Formula $K_{i-1}\leq K<K_{n}$
\end_inset

, or 1 if 
\begin_inset Formula $K<K_{1}$
\end_inset

.
 We choose the 
\begin_inset Formula $i^{th}$
\end_inset

 pointer to continue the search.
\end_layout

\begin_layout Example
Search 
\begin_inset Formula $K=29$
\end_inset

.
\end_layout

\begin_layout Example
\begin_inset Graphics
	filename btree.drawio.png
	scale 50

\end_inset


\end_layout

\begin_layout Example
The path to be followed is colored green:
\end_layout

\begin_deeper
\begin_layout Enumerate
In the root node, 
\begin_inset Formula $K_{1}<K$
\end_inset

 and and there are no more keys, so choose 
\begin_inset Formula $i=2$
\end_inset

.
\end_layout

\begin_layout Enumerate
In the next node, we find 
\begin_inset Formula $K_{1}<K<K_{2}$
\end_inset

, so choose 
\begin_inset Formula $i=2$
\end_inset

.
\end_layout

\begin_layout Enumerate
In the leave node, we find 
\begin_inset Formula $K_{2}=K$
\end_inset

, so choose 
\begin_inset Formula $i=2$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Subsection
Range queries
\end_layout

\begin_layout Standard
BTrees allow for a very efficient way to process range queries, that is,
 recover all records with keys lying in a given range 
\begin_inset Formula $\left[K_{min},K_{max}\right]$
\end_inset

.
 The procedure is:
\end_layout

\begin_layout Enumerate
Perform a lookup for 
\begin_inset Formula $K_{min}$
\end_inset

, whether it is found or not, we will reach the correct leaf node.
\end_layout

\begin_layout Enumerate
We traverse all leaf nodes until we find a key bigger than 
\begin_inset Formula $K_{max}$
\end_inset

.
\end_layout

\begin_layout Example
Search for range 
\begin_inset Formula $\left[12,40\right]$
\end_inset

.
\end_layout

\begin_layout Example
\begin_inset Graphics
	filename btree_range.png
	scale 50

\end_inset


\end_layout

\begin_layout Example
It is colored in green all the nodes that would be accepted into the range
 query.
 The order is up-down and left-right in the leaf level.
\end_layout

\begin_layout Subsection
Insertion into a BTree
\end_layout

\begin_layout Standard
The insertion is, in principle, recursive: 
\end_layout

\begin_layout Itemize
We try to find a place for the new key in the appropriate leaf, and we put
 it there if there is room.
 
\end_layout

\begin_layout Itemize
If there is no room in the proper leaf, we split the leaf into two and divide
 the keys between the two new nodes, so each is half full or just over half
 full.
 
\end_layout

\begin_layout Itemize
The splitting of nodes at one level appears to the level above as if a new
 key-pointer pair needs to be inserted at that higher level.
 We may thus recursively apply this strategy to insert at the next level:
 if there is room, insert it; if not, split the parent node and continue
 up the tree.
 
\end_layout

\begin_layout Itemize
As an exception, if we try to insert into the root, and there is no room,
 then we split the root into two nodes and create a new root at the next
 higher level; the new root has the two nodes resulting from the split as
 its children.
 Recall that no matter how large 
\begin_inset Formula $n$
\end_inset

 (the number of slots for keys at a node) is, it is always permissible for
 the root to have only one key and two children.
\end_layout

\begin_layout Example
Insert 
\begin_inset Formula $K=40$
\end_inset

.
\end_layout

\begin_layout Example
First, we lookup for the place where the record should be inserted.
\end_layout

\begin_layout Example
\begin_inset Graphics
	filename btree_insert40_0.png
	scale 50

\end_inset


\end_layout

\begin_layout Example
As there is not enough place, we need to split the node.
\end_layout

\begin_layout Example
\begin_inset Graphics
	filename btree_insert40_1.png
	scale 50

\end_inset


\end_layout

\begin_layout Example
Now, the key of the new node needs to be inserted into the parent node.
 But it is also full, so it needs to be splitted, too.
\end_layout

\begin_layout Example
\begin_inset Graphics
	filename btree_insert40_2.png
	scale 50

\end_inset

ç
\end_layout

\begin_layout Example
In the root node, the smaller key reachable from that node needs to bu inserted.
 In this case, the newly inserted one.
\end_layout

\begin_layout Subsection
Deletion from a BTree
\end_layout

\begin_layout Standard
The steps to delete record with key 
\begin_inset Formula $K$
\end_inset

 are:
\end_layout

\begin_layout Enumerate
Lookup for the record.
\end_layout

\begin_layout Enumerate
Delete the record from the data.
\end_layout

\begin_layout Enumerate
Delete the key-pointer pair from the BTree.
\end_layout

\begin_layout Enumerate
If the node from which we deleted still has the minimum number of pointers,
 that's it.
 But it is possible that the node is less occupy than the minimum required
 after the deletion.
 We need to do one of two things:
\end_layout

\begin_deeper
\begin_layout Enumerate
If one of the adjacent siblings of node 
\begin_inset Formula $N$
\end_inset

 has more than the minimum number of keys and pointers, then one key-pointer
 pair can be moved to 
\begin_inset Formula $N$
\end_inset

, keeping the order of keys intact.
 Possibly, the keys at the parent of 
\begin_inset Formula $N$
\end_inset

 must be adjusted to reflect the new situation.
 
\end_layout

\begin_layout Enumerate
The hard case is when neither adjacent sibling can be used to provide an
 extra key for 
\begin_inset Formula $N$
\end_inset

.
 However, in that case, we have two adjacent nodes, 
\begin_inset Formula $N$
\end_inset

 and a sibling 
\begin_inset Formula $M$
\end_inset

; the latter has the minimum number of keys and the former has fewer than
 the minimum.
 Therefore, together they have no more keys and pointers than are allowed
 in a single node.
 We merge these two nodes, effectively deleting one of them.
 We need to adjust the keys at the parent, and then delete a key and pointer
 at the parent.
 If the parent is still full enough, then we are done.
 If not, then we recursively apply the deletion algorithm at the parent.
 This process is called 
\series bold
coalesce siblings
\series default
.
\end_layout

\end_deeper
\begin_layout Example
Delete 
\begin_inset Formula $K=7$
\end_inset

.
\end_layout

\begin_layout Example
\begin_inset Graphics
	filename btree_delete7_0.png
	scale 50

\end_inset


\end_layout

\begin_layout Example
First, we find the correct node and delete the record.
\end_layout

\begin_layout Example
Now, the node left only has one pointer, so we need to fix this.
 As its left sibling node has 3 pointers, we can transfer the biggest one.
\end_layout

\begin_layout Example
\begin_inset Graphics
	filename btree_delete7_1.png
	scale 50

\end_inset


\end_layout

\begin_layout Example
Also, we need to update the parent node.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Example
Now, delete 
\begin_inset Formula $K=11$
\end_inset

.
\end_layout

\begin_layout Example
\begin_inset Graphics
	filename btree_delete11_0.png
	scale 50

\end_inset


\end_layout

\begin_layout Example
First, we locate the correct node and delete the record.
 Again, the node ends up with less pointers than it should, but now the
 left sibling does not have more than the minimum amount of pointers (it
 has the minimum) and the node does not have right siblings (the node to
 the right is from another parent), so we need to merge the two siblings.
\end_layout

\begin_layout Example
\begin_inset Graphics
	filename btree_delete11_1.png
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Physical Query Plans
\end_layout

\begin_layout Section
Physical Query Plans
\end_layout

\begin_layout Standard
We saw the steps to process a query: first, the query needs to be translated
 into and RA expression, which can then be modified using equivalence rules
 to get different expressions that lead to the same result.
 Then, it is needed to estimate the cost of each expression and to take
 the one that gives the minimum expected cost.
 For this, we need also to decide between several ways to access the data,
 e.g., whether to use an index or not, to order the data or not,...
 This is called 
\series bold
physical query planning
\series default
.
\end_layout

\begin_layout Standard
There are several ways to measure cost, but we are going to be using the
 number of disk blocks that must be read or written to execute a query plan.
\end_layout

\begin_layout Standard
We will also use different parameters:
\end_layout

\begin_layout Itemize
\begin_inset Formula $B\left(R\right)$
\end_inset

: number of blocks containing the tuples of relation 
\begin_inset Formula $R$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $f\left(R\right)$
\end_inset

: maximum number of tuples of 
\begin_inset Formula $R$
\end_inset

 per block.
\end_layout

\begin_layout Itemize
\begin_inset Formula $S\left(R\right)$
\end_inset

: size of tuples of 
\begin_inset Formula $R$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $M$
\end_inset

: memory blocks available.
\end_layout

\begin_layout Itemize
\begin_inset Formula $HT\left(i\right)$
\end_inset

: amount of levels in index 
\begin_inset Formula $i$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $LB\left(i\right)$
\end_inset

: amount of leaf nodes in index 
\begin_inset Formula $i$
\end_inset

.
\end_layout

\begin_layout Subsection
Computing joins
\end_layout

\begin_layout Standard
A join operation can be computed in several ways, depending on the options
 available.
 
\end_layout

\begin_layout Standard
The simplest and most costly option is an 
\series bold
iteration join
\series default
, which just performs a double loop over the two relations.
 The pseudocode can be read in Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Iteration-Join"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "morekeywords={for, each, in, do, if, then, output}"
inline false
status open

\begin_layout Plain Layout

for each r in R1 do
\end_layout

\begin_layout Plain Layout

	for each s in R2 do
\end_layout

\begin_layout Plain Layout

		if r.A = s.A then
\end_layout

\begin_layout Plain Layout

			output (r,s)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:Iteration-Join"

\end_inset

Iteration Join
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\series bold
merge join
\series default
 consists in first sorting the relations if they are not sorted, and then
 scanning them making use of the fact that they are ordered using the same
 attribute.
 The pseudocode can be read in Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:merge-join"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Python,morekeywords={for, each, in, do, if, then, output}"
inline false
status open

\begin_layout Plain Layout

if R1 not sorted on attribute A then
\end_layout

\begin_layout Plain Layout

	sort R1
\end_layout

\begin_layout Plain Layout

if r2 not sorted on attribute A then
\end_layout

\begin_layout Plain Layout

	sort R2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

i=1, j=1
\end_layout

\begin_layout Plain Layout

while i<=T(R1) and j<=T(R2) do
\end_layout

\begin_layout Plain Layout

	if R1[i].A = R2[j].A then
\end_layout

\begin_layout Plain Layout

		k=j
\end_layout

\begin_layout Plain Layout

		while R1[i].A = R2[k].A do
\end_layout

\begin_layout Plain Layout

			output (R1[i],R2[k])
\end_layout

\begin_layout Plain Layout

			k += 1
\end_layout

\begin_layout Plain Layout

		i += 1
\end_layout

\begin_layout Plain Layout

	else if R1[i].A > R2[j].A then
\end_layout

\begin_layout Plain Layout

		j += 1
\end_layout

\begin_layout Plain Layout

	else if R1[i].A < R2[j].A then
\end_layout

\begin_layout Plain Layout

		i += 1
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:merge-join"

\end_inset

Merge Join
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\series bold
index join
\series default
 uses an index defined on the joining attribute on one of the relations.
 The pseudocode can be read in Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:index-join-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Python,morekeywords={for, each, in, do, if, then, output}"
inline false
status open

\begin_layout Plain Layout

for each r in R1 do
\end_layout

\begin_layout Plain Layout

	X <- index(R2, A r.A) # search in index on R2.A tuples with value r.A
\end_layout

\begin_layout Plain Layout

	for each s in X do
\end_layout

\begin_layout Plain Layout

		output (r,s)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:index-join-1"

\end_inset

Index Join
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\series bold
hash join
\series default
 uses a hash function on the joinin attribute.
 The pseudocode can be read in Algorithm
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Python,morekeywords={for, each, in, do, if, then, output}"
inline false
status open

\begin_layout Plain Layout

hash R1 tuples into G buckets
\end_layout

\begin_layout Plain Layout

hash R2 tuples into H buckets
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

for i=0 to k
\end_layout

\begin_layout Plain Layout

	match tuples that lie in G[i] and H[i]
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:hash-join"

\end_inset

Hash Join (k buckets G1...Gk, H1...Hk)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Factors that affect performance
\end_layout

\begin_layout Subsubsection*
Are the tuples of the relation stored physically together?
\end_layout

\begin_layout Standard
The more compactly stored in memory the relations are, the less number of
 pages needs to be fetched and so the performance will increase.
\end_layout

\begin_layout Subsubsection*
Are relations sorted by join attribute?
\end_layout

\begin_layout Standard
If the relations are already sorted by the join attribute, the merge join
 is a great option, because the costly part is the sorting (
\begin_inset Formula $O\left(n\log n\right)$
\end_inset

), while the joinin itself is 
\begin_inset Formula $O\left(n+m\right)$
\end_inset

 where 
\begin_inset Formula $n,m$
\end_inset

 are the sizes of both relations.
\end_layout

\begin_layout Subsubsection*
Indexes exist?
\end_layout

\begin_layout Standard
If there are no indexes, the index join is not even an option.
 And when there are indexes, they are not always the best option, because
 if the attribute has low selectivity, the indexes will be returning single
 values often, and thus we will be only introducing overhead in the operation.
\end_layout

\begin_layout Example

\series bold
Iteration join 
\series default

\begin_inset Formula $R_{1}\bowtie R_{2}$
\end_inset

 where 
\series bold
relations are not contiguous
\series default
, 
\begin_inset Formula $T\left(R_{1}\right)=10000\ tuples,T\left(R_{2}\right)=5000\ tuples,S\left(R_{1}\right)=S\left(R_{2}\right)=\frac{1}{10}\ block$
\end_inset

 and 
\begin_inset Formula $M=101$
\end_inset

 blocks (so we can work with at most 1010 tuples in memory at once).
 In this case, 
\begin_inset Formula $B\left(R_{1}\right)=10000$
\end_inset

 and 
\begin_inset Formula $B\left(R_{2}\right)=5000$
\end_inset

.
\end_layout

\begin_layout Example
For each tuple in 
\begin_inset Formula $R_{1}$
\end_inset

, we need to:
\end_layout

\begin_deeper
\begin_layout Itemize
Read the tuple: 1 IO
\end_layout

\begin_layout Itemize
Read all tuples in 
\begin_inset Formula $R_{2}$
\end_inset

: 5000 IOs (This is because the relations are not contiguously stored, so
 we need to assume that we read a new block for each new tuple)
\end_layout

\begin_layout Standard
So, the total cost is
\begin_inset Formula 
\[
C=10000\left(1+5000\right)=50\ 010\ 000\ IOs.
\]

\end_inset


\end_layout

\begin_layout Standard
Can this be improved? Yes!
\end_layout

\begin_layout Standard
If we do it reading 1000 tuples of 
\begin_inset Formula $R_{1}$
\end_inset

 and doing the process in each of this chunks, we would need to, for each
 chunk in 
\begin_inset Formula $R1$
\end_inset

:
\end_layout

\begin_layout Itemize
Read all tuples in the chunk: 1000 IOs
\end_layout

\begin_layout Itemize
Read all tuples in 
\begin_inset Formula $R_{2}$
\end_inset

: 5000 IOs
\end_layout

\begin_layout Standard
So
\begin_inset Formula 
\[
C=10\left(1000+5000\right)=60\ 000\ IOs.
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Example
Can this be improved? Yes!
\end_layout

\begin_layout Example
If we reverse the order of the join: 
\begin_inset Formula $R_{2}\bowtie R_{1}$
\end_inset

, then, for each chunk in 
\begin_inset Formula $R2$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Itemize
Read all tuples in the chunk: 1000 IOs
\end_layout

\begin_layout Itemize
Read all tuples in 
\begin_inset Formula $R_{1}$
\end_inset

:10000 IOs
\end_layout

\end_deeper
\begin_layout Example
So
\begin_inset Formula 
\[
C=5\left(1000+10000\right)=55\ 000\ IOs.
\]

\end_inset

 
\end_layout

\begin_layout Standard
In fact, the bigger 
\begin_inset Formula $R_{2}$
\end_inset

 is compared to 
\begin_inset Formula $R_{1}$
\end_inset

 the greater gain obtained when changing the order.
\end_layout

\begin_layout Example

\series bold
Iteration join 
\series default

\begin_inset Formula $R_{1}\bowtie R_{2}$
\end_inset

 where 
\series bold
relations are contiguous 
\series default
(same parameters).
 In this case, 
\begin_inset Formula $B\left(R_{1}\right)=1000$
\end_inset

 and 
\begin_inset Formula $B\left(R_{2}\right)=500$
\end_inset

.
\end_layout

\begin_layout Example
For each chunk in 
\begin_inset Formula $R_{2}$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Itemize
Read the chunk: 100 IOs (now it is only 100 IOs because 
\begin_inset Formula $S\left(R_{2}\right)=\frac{1}{10}$
\end_inset

 block, so to read 1000 tuples we need to read 100 blocks)
\end_layout

\begin_layout Itemize
Read 
\begin_inset Formula $R1$
\end_inset

: 1000 IOs
\end_layout

\end_deeper
\begin_layout Example
Thus,
\begin_inset Formula 
\[
C=5\left(100+1000\right)=5\ 500\ IOs.
\]

\end_inset


\end_layout

\begin_layout Standard
We can see how the contigous storage greatly increase performance of the
 joins.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Theorem
In general, for an iteration join 
\begin_inset Formula $R_{1}\bowtie R_{2}$
\end_inset

 with sizes (in blocks) 
\begin_inset Formula $B\left(R_{1}\right)$
\end_inset

 and 
\begin_inset Formula $B\left(R_{2}\right)$
\end_inset

, and a memory capacity of 
\begin_inset Formula $M$
\end_inset

 blocks, the formula for the cost is
\begin_inset Formula 
\[
C=\frac{B\left(R_{1}\right)}{M-1}\left(M-1+B\left(R_{2}\right)\right).
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Proof
We want to first take as many blocks from the first relation as we can,
 but we need to leave space for joining the second relation, so we will
 use 
\begin_inset Formula $M-1$
\end_inset

 blocks for storing the tuples for the first relation.
 This will need to be done 
\begin_inset Formula $\frac{B\left(R_{1}\right)}{M-1}$
\end_inset

 times.
 Now, for each of this iterations, we need to actually read the 
\begin_inset Formula $M-1$
\end_inset

 blocks from 
\begin_inset Formula $R_{1}$
\end_inset

 and to read all blocks from 
\begin_inset Formula $R_{2}$
\end_inset

.
 So the formula arises.
\end_layout

\begin_layout Example

\series bold
Merge join 
\begin_inset Formula $R_{1}\bowtie R_{2}$
\end_inset

 
\series default
where both relations are 
\series bold
already ordered
\series default
 by the joinin attribute and relations are 
\series bold
contiguous
\series default
.
 In this case, we will need to read all blocks containing 
\begin_inset Formula $R_{1}$
\end_inset

 and all block containing 
\begin_inset Formula $R_{2}$
\end_inset

, once.
 So
\begin_inset Formula 
\[
C=1000+500=1\ 500\ IOs.
\]

\end_inset

 
\end_layout

\begin_layout Standard
So we can see how good a merge join where the relations are already ordered
 is.
 Let's see how the other case performs:
\end_layout

\begin_layout Example

\series bold
Merge join
\series default
 
\begin_inset Formula $R_{1}\bowtie R_{2}$
\end_inset

 where 
\begin_inset Formula $R_{1},R_{2}$
\end_inset

 are 
\series bold
not ordered
\series default
, but are 
\series bold
contiguous
\series default
.
 
\end_layout

\begin_layout Example
In this case, first we need to sort the relations and there are different
 ways to do this, we are going to explain one, the 
\series bold
merge join
\series default
:
\end_layout

\begin_deeper
\begin_layout Itemize
Merge sort: For each 100 tuples chunk of 
\begin_inset Formula $R$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Itemize
Read the chunk
\end_layout

\begin_layout Itemize
Sort in memory
\end_layout

\begin_layout Itemize
Write to disk the ordered chunks
\end_layout

\begin_layout Itemize
Read the ordered chunks and merge them
\end_layout

\begin_layout Itemize
Write to disk the ordered relation
\end_layout

\begin_layout Standard
Cost (in terms of IO): each chunk is read, written, read, written, so 
\begin_inset Formula $4\times\frac{T\left(R\right)}{S\left(R\right)}=4B\left(R\right)$
\end_inset

.
 
\end_layout

\begin_layout Standard
In our case
\begin_inset Formula 
\[
sortC\left(R1\right)=4000,\ sortC\left(R2\right)=2000.
\]

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Example
Now, the cost a merge join in which the relations are not ordered is the
 cost of the ordering plus the cost of the join, so
\begin_inset Formula 
\[
C=4000+2000+1500=7500\ IOs.
\]

\end_inset


\end_layout

\begin_layout Example
Remember that the iteration cost was 5500 IOs, so in this case the merge
 join is not the best option.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Theorem
In general, for a merge join 
\begin_inset Formula $R_{1}\bowtie R_{2}$
\end_inset

 with sizes (in blocks) 
\begin_inset Formula $B\left(R_{1}\right)$
\end_inset

 and 
\begin_inset Formula $B\left(R_{2}\right)$
\end_inset

 where the relations are contiguously stored, and a memory capacity of 
\begin_inset Formula $M$
\end_inset

 blocks, the formula for the cost is
\begin_inset Formula 
\[
C=5\left(B\left(R_{1}\right)+B\left(R_{2}\right)\right).
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Proof
The cost is
\begin_inset Formula 
\[
C=C_{order}\left(R_{1}\right)+C_{order}\left(R_{2}\right)+C_{join}.
\]

\end_inset

 We have seen that 
\begin_inset Formula $C_{order}\left(R\right)=4B\left(R\right)$
\end_inset

 and 
\begin_inset Formula $C_{join}\left(R_{1},R_{2}\right)=B\left(R_{1}\right)+B\left(R_{2}\right)$
\end_inset

, and so the formula arises.
\end_layout

\begin_layout Example
Let in this case 
\begin_inset Formula $R_{1},R_{2}$
\end_inset

 be contiguously stored, but unordered, with 
\begin_inset Formula $B(R_{1})=10000\ tuples$
\end_inset

 and 
\begin_inset Formula $B(R_{2})=5000\ tuples$
\end_inset

.
 In this case, the iteration join has a cost of
\begin_inset Formula 
\[
C_{IJ}=\frac{5000}{100}\left(100+10000\right)=505\ 000\ IOs.
\]

\end_inset


\end_layout

\begin_layout Example
And the merge join
\begin_inset Formula 
\[
C_{MJ}=5\left(10000+5000\right)=75\ 000\ IOs.
\]

\end_inset


\end_layout

\begin_layout Example
So, in this case the merge sort is better, even without the relations being
 previously ordered.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Theorem
For a join 
\begin_inset Formula $R_{1}\bowtie R_{2}$
\end_inset

 where the relations are contiguously stored and unordered, with sizes (in
 blocks) 
\begin_inset Formula $B\left(R_{1}\right)$
\end_inset

 and 
\begin_inset Formula $B\left(R_{2}\right)$
\end_inset

, a memory capacity of 
\begin_inset Formula $M$
\end_inset

 blocks, and assuming that 
\begin_inset Formula $\frac{B\left(R_{2}\right)}{M-1}>4$
\end_inset

, a merge join is preferred to an iteration join if, and only if,
\begin_inset Formula 
\[
B\left(R_{1}\right)>\frac{5B\left(R_{2}\right)}{\frac{B\left(R_{2}\right)}{M-1}-4}.
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Proof
The merge join is preferred to the iteration join if, and only if
\begin_inset Formula 
\[
5\left(B\left(R_{1}\right)+B\left(R_{2}\right)\right)<\frac{B\left(R_{1}\right)}{M-1}\left(M-1+B\left(R_{2}\right)\right)=B\left(R_{1}\right)+\frac{B\left(R_{1}\right)B\left(R_{2}\right)}{M-1}\iff
\]

\end_inset


\begin_inset Formula 
\[
4B\left(R_{1}\right)+5B\left(R_{2}\right)<\frac{B\left(R_{1}\right)B\left(R_{2}\right)}{M-1}\iff
\]

\end_inset


\begin_inset Formula 
\[
B\left(R_{1}\right)\left[4-\frac{B\left(R_{2}\right)}{M-1}\right]<-5B\left(R_{2}\right)\iff
\]

\end_inset


\begin_inset Formula 
\[
B\left(R_{1}\right)\left[\frac{B\left(R_{2}\right)}{M-1}-4\right]>5B\left(R_{2}\right)\iff
\]

\end_inset


\begin_inset Formula 
\[
B\left(R_{1}\right)>\frac{5B\left(R_{2}\right)}{\frac{B\left(R_{2}\right)}{M-1}-4}.
\]

\end_inset


\end_layout

\begin_layout Example
Let's apply the theorem to our two previous examples:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $R_{2}\bowtie R_{1},B\left(R_{1}\right)=1000,\ B\left(R_{2}\right)=500,\ M=101$
\end_inset

, then
\begin_inset Formula 
\[
\frac{5B\left(R_{1}\right)}{\frac{B\left(R_{1}\right)}{M-1}-4}=\frac{5000}{\frac{1000}{100}-4}=\frac{5000}{6}>833>500,
\]

\end_inset

 so in this case the iteration join is preferred.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $R_{2}\bowtie R_{1},B\left(R_{1}\right)=10000,B\left(R_{2}\right)=5000,M=101$
\end_inset

, then
\begin_inset Formula 
\[
\frac{5B\left(R_{1}\right)}{\frac{B\left(R_{1}\right)}{M-1}-4}=\frac{50000}{\frac{10000}{100}-4}=\frac{50000}{96}<521<5000,
\]

\end_inset

 so in this case the merge join is preferred.
\end_layout

\begin_layout Subsubsection*
How much memory do we need for merge sort?
\end_layout

\begin_layout Standard
Until now, we have disregarded the memory needed to perform the merge sort,
 but this is a crucial aspect of it.
 If the relation does not fit entirely in memory, it is not straightforward
 to merge all the ordered chunks to obtain a fully ordered relation.
 
\end_layout

\begin_layout Standard
In general, if we have 
\begin_inset Formula $M$
\end_inset

 blocks in memory, and 
\begin_inset Formula $B$
\end_inset

 blocks to sort, then we will take chunks of size 
\begin_inset Formula $k$
\end_inset

, so we will have 
\begin_inset Formula $\frac{x}{k}$
\end_inset

 chunks.
 Now, this number needs to be smaller than the memory size:
\begin_inset Formula 
\[
\frac{B}{M}\leq M,
\]

\end_inset

 or, equivalently
\begin_inset Formula 
\[
M^{2}\geq B\ or\ M\geq\sqrt{B}.
\]

\end_inset


\end_layout

\begin_layout Example
Following our examples: 
\begin_inset Formula $R_{1}$
\end_inset

 is 1000 blocks, so 
\begin_inset Formula $M\geq31.62$
\end_inset

 and 
\begin_inset Formula $R_{2}$
\end_inset

 is 500 blocks so 
\begin_inset Formula $M\geq22.36$
\end_inset

.
 In this case, we need 
\begin_inset Formula $M\geq32$
\end_inset

 blocks, so it could be done because the memory was 
\begin_inset Formula $M=101$
\end_inset

 blocks.
\end_layout

\begin_layout Subsubsection*
Can the merge join be improved?
\end_layout

\begin_layout Standard
Yes, we are imposing that the whole relation needs to be sorted, but maybe
 we can join the sorted chunks without merging them.
\end_layout

\begin_layout Standard
If we did this, we would need to:
\end_layout

\begin_layout Itemize
Read 
\begin_inset Formula $R_{1}$
\end_inset

 and write 
\begin_inset Formula $R_{1}$
\end_inset

 sorted chunks
\end_layout

\begin_layout Itemize
Read 
\begin_inset Formula $R_{2}$
\end_inset

 and write 
\begin_inset Formula $R_{2}$
\end_inset

 sorted chunks
\end_layout

\begin_layout Itemize
Join
\end_layout

\begin_layout Standard
So the total cost would be
\begin_inset Formula 
\[
C=2B\left(R_{1}\right)+2B\left(R_{2}\right)+\left[B\left(R_{1}\right)+B\left(R_{2}\right)\right]=3\left[B\left(R_{1}\right)+B\left(R_{2}\right)\right].
\]

\end_inset


\end_layout

\begin_layout Example

\series bold
Index join 
\begin_inset Formula $R_{2}\bowtie R_{1}$
\end_inset

 
\series default
with an 
\series bold
index
\series default
 on 
\begin_inset Formula $R_{1}.A$
\end_inset

 of two levels, 
\begin_inset Formula $R_{2}$
\end_inset

 
\series bold
contiguously
\series default
 stored and 
\series bold
unordered
\series default
 and assuming the 
\series bold
index fits in memory
\series default
.
 Then, the cost is:
\end_layout

\begin_layout Itemize
Read 
\begin_inset Formula $R_{2}$
\end_inset

: 500 IOs
\end_layout

\begin_layout Itemize
For each tuple in 
\begin_inset Formula $R_{2}$
\end_inset

, check the index and only read a tuple in 
\begin_inset Formula $R_{1}$
\end_inset

 if there is a match.
\end_layout

\begin_layout Standard
So
\begin_inset Formula 
\[
C=500+matches.
\]

\end_inset

 Thus, we need to estimate how many matches there will be.
 We can treat several cases:
\end_layout

\begin_layout Enumerate
If 
\begin_inset Formula $R_{1}.A$
\end_inset

 is a key attribute and 
\begin_inset Formula $R_{2}.A$
\end_inset

 is a foreign key:
\begin_inset Formula 
\[
matches\left(R_{2},R_{1}\right)=T\left(R_{2}\right).
\]

\end_inset

 In this case the cost is
\begin_inset Formula 
\[
C=500+5000=5500\ IOs.
\]

\end_inset


\end_layout

\begin_layout Enumerate
If we know 
\begin_inset Formula $V\left(R_{1},A\right)$
\end_inset

 (number of distinct values of attribute 
\begin_inset Formula $A$
\end_inset

 in 
\begin_inset Formula $R_{1}$
\end_inset

) and 
\begin_inset Formula $T\left(R_{1}\right)$
\end_inset

, we can assume uniformity and thus obtain
\begin_inset Formula 
\[
matches\left(R_{2},R_{1}\right)=\frac{V\left(R_{1},A\right)}{T\left(R_{1}\right)}\times T\left(R_{2}\right).
\]

\end_inset

 In this case the cost is, assuming 
\begin_inset Formula $V\left(R_{1},A\right)=5000$
\end_inset

,
\begin_inset Formula 
\[
C=500+\frac{10000}{5000}5000=10500\ IOs.
\]

\end_inset


\end_layout

\begin_layout Enumerate
If we know 
\begin_inset Formula $size\left(Dom\left(R_{1},A\right)\right)$
\end_inset

 (number of distinct values that attribute 
\begin_inset Formula $A$
\end_inset

 can take) and 
\begin_inset Formula $T\left(R_{1}\right)$
\end_inset

, we can assume uniformity and thus obtain
\begin_inset Formula 
\[
matches\left(R_{2},R_{1}\right)=\frac{T\left(R_{1}\right)}{size\left(Dom\left(R_{1},A\right)\right)}T\left(R_{2}\right).
\]

\end_inset

 In this case the cost is, assumiing 
\begin_inset Formula $size\left(Dom\left(R_{1},A\right)\right)=1\ 000\ 000$
\end_inset

,
\begin_inset Formula 
\[
C=500+\frac{10000}{1000000}5000=550\ IOs.
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Example
Let's see what happens if the index does not fit in memory.
\end_layout

\begin_layout Example
Let the 
\begin_inset Formula $R_{1}.A$
\end_inset

 index occupy 201 blocks (1 root and 200 leaves), so it cannot be fully
 fitted in memory 
\begin_inset Formula $\left(M=101\right)$
\end_inset

.
 We can store the root node and 99 leaf nodes in memory.
 Then for each value to check, there is a 
\begin_inset Formula $\frac{99}{200}$
\end_inset

 chance that we can find the value in memory, and 
\begin_inset Formula $\frac{101}{200}$
\end_inset

 that we don't.
 Then, the cost of checking the value in the index is
\begin_inset Formula 
\[
C_{index}=0\times\frac{99}{200}+1\times\frac{101}{200}\approx0.5.
\]

\end_inset

 Thus, the total cost is
\begin_inset Formula 
\[
C=500+5000\left[0.5+2\right]=13000\ IOs.
\]

\end_inset

 In this case, we have assumed the case 2.
 The detailed explanation is:
\end_layout

\begin_layout Itemize
Read 
\begin_inset Formula $R_{2}$
\end_inset

: 500 IOs
\end_layout

\begin_layout Itemize
For each tuple in 
\begin_inset Formula $R_{2}$
\end_inset

 
\begin_inset Formula $\left(5000\times\right)$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Itemize
We need to check the value in the index: 
\begin_inset Formula $0.5$
\end_inset

 IOs
\end_layout

\begin_layout Itemize
And we need to recover the matches: assuming case 2 is 
\begin_inset Formula $2$
\end_inset

 IOs, assuming case 3 is 0.1 IOs
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Theorem
In general, for an index join 
\begin_inset Formula $R_{1}\bowtie_{A}R_{2}$
\end_inset

 with sizes (in blocks) 
\begin_inset Formula $B\left(R_{1}\right)$
\end_inset

 and 
\begin_inset Formula $B\left(R_{2}\right)$
\end_inset

 and sizes (in tuples) 
\begin_inset Formula $T\left(R_{1}\right)$
\end_inset

 and 
\begin_inset Formula $T\left(R_{2}\right)$
\end_inset

, where:
\end_layout

\begin_deeper
\begin_layout Itemize
There is an index for 
\begin_inset Formula $R_{1}.A$
\end_inset

 of size 
\begin_inset Formula $B_{i}$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $R_{2}$
\end_inset

 is contiguously stored in memory.
\end_layout

\begin_layout Itemize
There is a memory capacity of 
\begin_inset Formula $M$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Theorem
If the index does not fit in memory, the estimated cost is
\begin_inset Formula 
\[
C=B\left(R_{2}\right)+T\left(R_{2}\right)\left[\left(1-\frac{M-2}{S_{i}}\right)+matched\right],
\]

\end_inset

 where 
\begin_inset Formula $matched$
\end_inset

 depends on the assumtions about how the values of the index are distributed.
\end_layout

\begin_layout Theorem
If the index fits in memory, the estimated cost is
\begin_inset Formula 
\[
C=B\left(R_{2}\right)+T\left(R_{2}\right)\times matched.
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Proof
We will need to read all blocks of 
\begin_inset Formula $R_{2}$
\end_inset

, which sums up to 
\begin_inset Formula $B\left(R_{2}\right)$
\end_inset

.
\end_layout

\begin_layout Proof
Then, for each tuple in 
\begin_inset Formula $R_{2}$
\end_inset

, we need to check the index and recover all matches.
 Thus, if the index fits in memory, the result is obvious.
\end_layout

\begin_layout Proof
If the index does not fit in memory, we will store the root and 
\begin_inset Formula $M-2$
\end_inset

 leave nodes.
 Thus
\begin_inset Formula 
\[
Prob\left(value\ in\ memory\right)=\frac{M-2}{S_{i}},
\]

\end_inset

 so
\begin_inset Formula 
\[
Prob\left(value\ not\ in\ memory\right)=1-Prob\left(value\ in\ memory\right)=1-\frac{M-2}{S_{i}}.
\]

\end_inset

 And so, we obtain the desired formula.
\end_layout

\begin_layout Standard
Let's now continue with the hash join:
\end_layout

\begin_layout Example

\series bold
Hash join
\series default
 
\begin_inset Formula $R_{1}\bowtie R_{2}$
\end_inset

 where 
\begin_inset Formula $R_{1},R_{2}$
\end_inset

 are 
\series bold
contiguously stored
\series default
 and 
\series bold
unordered
\series default
.
 According to 
\begin_inset CommandInset citation
LatexCommand cite
key "garcia2002"
literal "false"

\end_inset

, we may hash each relation to 100 buckets, so the average size of a bucket
 is 10 blocks for 
\begin_inset Formula $R_{1}$
\end_inset

 and 5 blocks for 
\begin_inset Formula $R_{2}$
\end_inset

.
 Since the smaller number, 5, is much less than the number of available
 buffers, we expect to have no trouble performing a one-pass join on each
 pair of buckets.
 The number of disk IOs is 1500 to read each of 
\begin_inset Formula $R_{1}$
\end_inset

 and 
\begin_inset Formula $R_{2}$
\end_inset

 while hashing into buckets, another 1500 to write all the buckets to disk,
 and a third 1500 to read each pair of buckets into main memory again while
 taking the one-pass join of corresponding buckets.
 Thus, the total cost is
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula 
\[
C=3\left(B\left(R_{1}\right)+B\left(R_{2}\right)\right)=4500\ IOs.
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
About the memory requirements, we need the buckets to fit into memory.
 We are taking 
\begin_inset Formula $M-1$
\end_inset

 buckets, so the size of the buckets are 
\begin_inset Formula $\frac{B\left(R_{1}\right)}{M-1}$
\end_inset

 blocks and 
\begin_inset Formula $\frac{B\left(R_{2}\right)}{M-1}$
\end_inset

 blocks for buckets of 
\begin_inset Formula $R_{1}$
\end_inset

 and buckets of 
\begin_inset Formula $R_{2}$
\end_inset

, respectively.
 It is enough to fit the smaller one, say 
\begin_inset Formula $\frac{B}{M-1}$
\end_inset

 blocks.
 Then, we need to ensure that 
\begin_inset Formula 
\[
\frac{B}{M-1}<M-1,
\]

\end_inset

 so we need to fulfill
\begin_inset Formula 
\[
B<\left(M-1\right)^{2}
\]

\end_inset

 or
\begin_inset Formula 
\[
\sqrt{B}<M-1.
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Extensibility
\end_layout

\begin_layout Section
Extensible databases: PostgreSQL
\end_layout

\begin_layout Standard
This section is adapted from the course slides and 
\begin_inset CommandInset href
LatexCommand href
name "PostgreSQL: Extensibility"
target "https://www.postgresql.org/docs/current/extend.html"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
PostgreSQL is extensible because its operation is catalog-driven.
 Relational DB systems store information about databases, tables, columns,
 etc., in what are commonly known as system catalogs.
 
\end_layout

\begin_layout Standard
The catalogs appear to the user as tables like any other, but the DBMS stores
 its internal bookkeeping in them.
 One key difference between PostgreSQL and standard relational database
 systems is that PostgreSQL stores much more information in its catalogs:
 not only information about tables and columns, but also information about
 data types, functions, access methods, and so on.
 These tables can be modified by the user, and since PostgreSQL bases its
 operation on these tables, this means that PostgreSQL can be extended by
 users.
 By comparison, conventional database systems can only be extended by changing
 hardcoded procedures in the source code or by loading modules specially
 written by the DBMS vendor.
\end_layout

\begin_layout Standard
The PostgreSQL server can moreover incorporate user-written code into itself
 through dynamic loading.
 That is, the user can specify an object code file (e.g., a shared library)
 that implements a new type or function, and PostgreSQL will load it as
 required.
 Code written in SQL is even more trivial to add to the server.
 This ability to modify its operation “on the fly” makes PostgreSQL uniquely
 suited for rapid prototyping of new applications and storage structures.
\end_layout

\begin_layout Subsection
Types
\end_layout

\begin_layout Subsubsection
Base types
\end_layout

\begin_layout Standard
Base types are those, like integer, that are implemented below the level
 of the SQL language.
 PostgreSQL can only operate on such types through functions provided by
 the user and only understands the behavior of such types to the extent
 that the user describes them.
\end_layout

\begin_layout Subsubsection
Container types
\end_layout

\begin_layout Standard
Container types can be arrays, composites and ranges:
\end_layout

\begin_layout Itemize

\series bold
Arrays
\series default
 can hold multiple values that are all of the same type.
 An array type is automatically created for each base type, composite type,
 range type, and domain type.
 But there are no arrays of arrays.
\end_layout

\begin_layout Itemize

\series bold
Composite
\series default
 types, or row types, are created whenever the user creates a table.
 It is also possible to use CREATE TYPE to define a “stand-alone” composite
 type with no associated table.
 A composite type is simply a list of types with associated field names.
 A value of a composite type is a row or record of field values.
\end_layout

\begin_layout Itemize
A 
\series bold
range
\series default
 type can hold two values of the same type, which are the lower and upper
 bounds of the range.
 Range types are user-created, although a few built-in ones exist.
 
\end_layout

\begin_layout Subsubsection
Domains
\end_layout

\begin_layout Standard
A domain is based on a particular underlying type and for many purposes
 is interchangeable with its underlying type.
 However, a domain can have constraints that restrict its valid values to
 a subset of what the underlying type would allow.
 Domains are created using the SQL command CREATE DOMAIN.
\end_layout

\begin_layout Subsubsection
Pseudo-types
\end_layout

\begin_layout Standard
There are a few “pseudo-types” for special purposes.
 Pseudo-types cannot appear as columns of tables or components of container
 types, but they can be used to declare the argument and result types of
 functions.
 This provides a mechanism within the type system to identify special classes
 of functions.
 
\end_layout

\begin_layout Subsubsection
Polymorphic types
\end_layout

\begin_layout Standard
Some pseudo-types of special interest are the polymorphic types, which are
 used to declare polymorphic functions.
 This powerful feature allows a single function definition to operate on
 many different data types, with the specific data type(s) being determined
 by the data types actually passed to it in a particular call.
 
\end_layout

\begin_layout Subsection
Functions
\end_layout

\begin_layout Standard
PostgreSQL provides four kinds of functions:
\end_layout

\begin_layout Itemize
query language functions (functions written in SQL)
\end_layout

\begin_layout Itemize
procedural language functions (functions written in, for example, PL/pgSQL
 or PL/Tcl)
\end_layout

\begin_layout Itemize
internal functions
\end_layout

\begin_layout Itemize
C-language functions
\end_layout

\begin_layout Standard
Every kind of function can take base types, composite types, or combinations
 of these as arguments (parameters).
 In addition, every kind of function can return a base type or a composite
 type.
 Functions can also be defined to return sets of base or composite values.
\end_layout

\begin_layout Subsubsection
SQL functions
\end_layout

\begin_layout Standard
SQL functions execute an arbitrary list of SQL statements, returning the
 result of the last query in the list.
 In the simple (non-set) case, the first row of the last query's result
 will be returned.
 (Bear in mind that “the first row” of a multirow result is not well-defined
 unless you use ORDER BY).
 If the last query happens to return no rows at all, the null value will
 be returned.
\end_layout

\begin_layout Standard
Alternatively, an SQL function can be declared to return a set (that is,
 multiple rows) by specifying the function's return type as SETOF sometype,
 or equivalently by declaring it as RETURNS TABLE(columns).
 In this case all rows of the last query's result are returned.
\end_layout

\begin_layout Standard
Any collection of commands in the SQL language can be packaged together
 and defined as a function.
 However, the final command must be a SELECT or have a RETURNING clause
 that returns whatever is specified as the function's return type.
 Alternatively, if you want to define an SQL function that performs actions
 but has no useful value to return, you can define it as returning void.
\end_layout

\begin_layout Example
A SQL function defined by the user.
\end_layout

\begin_layout Example
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

CREATE FUNCTION clean_emp() RETURNS void AS '
\end_layout

\begin_layout Plain Layout

    DELETE FROM emp
\end_layout

\begin_layout Plain Layout

        WHERE salary < 0;
\end_layout

\begin_layout Plain Layout

' LANGUAGE SQL;
\end_layout

\end_inset


\end_layout

\begin_layout Remark
The entire body of an SQL function is parsed before any of it is executed.
 While an SQL function can contain commands that alter the system catalogs
 (e.g., CREATE TABLE), the effects of such commands will not be visible during
 parse analysis of later commands in the function.
 Thus, for example, CREATE TABLE foo (...); INSERT INTO foo VALUES(...); will
 not work as desired if packaged up into a single SQL function, since foo
 won't exist yet when the INSERT command is parsed.
 It's recommended to use PL/pgSQL instead of an SQL function in this type
 of situation.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
More than one function can be defined with the same SQL name, so long as
 the arguments they take are different.
 In other words, function names can be overloaded.
 This is called 
\series bold
function overloading
\series default
.
\end_layout

\begin_layout Subsubsection
Procedural functions
\end_layout

\begin_layout Standard
PostgreSQL allows user-defined functions to be written in other languages
 besides SQL and C.
 These other languages are generically called procedural languages (PLs).
 Procedural languages aren't built into the PostgreSQL server; they are
 offered by loadable modules.
 
\end_layout

\begin_layout Subsubsection
Internal functions
\end_layout

\begin_layout Standard
Internal functions are functions written in C that have been statically
 linked into the PostgreSQL server.
 The “body” of the function definition specifies the C-language name of
 the function, which need not be the same as the name being declared for
 SQL use.
 
\end_layout

\begin_layout Standard
Normally, all internal functions present in the server are declared during
 the initialization of the database cluster, but a user could use CREATE
 FUNCTION to create additional alias names for an internal function.
 Internal functions are declared in CREATE FUNCTION with language name internal.
\end_layout

\begin_layout Example
An internal function.
\end_layout

\begin_layout Example
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

CREATE FUNCTION square_root(double precision) RETURNS double precision
\end_layout

\begin_layout Plain Layout

    AS 'dsqrt'
\end_layout

\begin_layout Plain Layout

    LANGUAGE internal
\end_layout

\begin_layout Plain Layout

    STRICT;
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
C-Language functions
\end_layout

\begin_layout Standard
User-defined functions can be written in C (or a language that can be made
 compatible with C, such as C++).
 Such functions are compiled into dynamically loadable objects (also called
 shared libraries) and are loaded by the server on demand.
 The dynamic loading feature is what distinguishes “C language” functions
 from “internal” functions — the actual coding conventions are essentially
 the same for both.
 (Hence, the standard internal function library is a rich source of coding
 examples for user-defined C functions.)
\end_layout

\begin_layout Standard
Currently only one calling convention is used for C functions (“version
 1”).
 Support for that calling convention is indicated by writing a PG_FUNCTION_INFO_
V1() macro call for the function.
\end_layout

\begin_layout Subsubsection
Function volatility categories
\end_layout

\begin_layout Standard
Every function has a volatility classification, with the possibilities being
 VOLATILE, STABLE, or IMMUTABLE.
 VOLATILE is the default if the CREATE FUNCTION command does not specify
 a category.
 The volatility category is a promise to the optimizer about the behavior
 of the function:
\end_layout

\begin_layout Itemize
A 
\series bold
VOLATILE
\series default
 function can do anything, including modifying the database.
 It can return different results on successive calls with the same arguments.
 The optimizer makes no assumptions about the behavior of such functions.
 A query using a volatile function will re-evaluate the function at every
 row where its value is needed.
\end_layout

\begin_layout Itemize
A 
\series bold
STABLE
\series default
 function cannot modify the database and is guaranteed to return the same
 results given the same arguments for all rows within a single statement.
 This category allows the optimizer to optimize multiple calls of the function
 to a single call.
 In particular, it is safe to use an expression containing such a function
 in an index scan condition.
 (Since an index scan will evaluate the comparison value only once, not
 once at each row, it is not valid to use a VOLATILE function in an index
 scan condition.)
\end_layout

\begin_layout Itemize
An 
\series bold
IMMUTABLE
\series default
 function cannot modify the database and is guaranteed to return the same
 results given the same arguments forever.
 This category allows the optimizer to pre-evaluate the function when a
 query calls it with constant arguments.
 For example, a query like SELECT ...
 WHERE x = 2 + 2 can be simplified on sight to SELECT ...
 WHERE x = 4, because the function underlying the integer addition operator
 is marked IMMUTABLE.
\end_layout

\begin_layout Standard
For best optimization results, you should label your functions with the
 strictest volatility category that is valid for them.
\end_layout

\begin_layout Subsection
Procedures
\end_layout

\begin_layout Standard
A procedure is a database object similar to a function.
 The key differences are:
\end_layout

\begin_layout Itemize
Procedures are defined with the CREATE PROCEDURE command, not CREATE FUNCTION.
\end_layout

\begin_layout Itemize
Procedures do not return a function value; hence CREATE PROCEDURE lacks
 a RETURNS clause.
 However, procedures can instead return data to their callers via output
 parameters
\end_layout

\begin_layout Itemize
While a function is called as part of a query or DML (data manipulation
 language) command, a procedure is called in isolation using the CALL command.
\end_layout

\begin_layout Itemize
A procedure can commit or roll back transactions during its execution (then
 automatically beginning a new transaction), so long as the invoking CALL
 command is not part of an explicit transaction block.
 A function cannot do that.
\end_layout

\begin_layout Itemize
Certain function attributes, such as strictness, don't apply to procedures.
 Those attributes control how the function is used in a query, which isn't
 relevant to procedures.
\end_layout

\begin_layout Standard
Collectively, functions and procedures are also known as 
\series bold
routines
\series default
.
 There are commands such as ALTER ROUTINE and DROP ROUTINE that can operate
 on functions and procedures without having to know which kind it is.
 Note, however, that there is no CREATE ROUTINE command.
\end_layout

\begin_layout Subsection
Interfacing extensions to indexes
\end_layout

\begin_layout Standard
The procedures described thus far let you define new types, new functions,
 and new operators.
 However, we cannot yet define an index on a column of a new data type.
 To do this, we must define an 
\series bold
operator class
\series default
 for the new data type.Operator classes can be grouped into operator families
 to show the relationships between semantically compatible classes.
 When only a single data type is involved, an operator class is sufficient.
\end_layout

\begin_layout Standard
The operators associated with an operator class are identified by “strategy
 numbers”, which serve to identify the semantics of each operator within
 the context of its operator class.
 For example, B-trees impose a strict ordering on keys, lesser to greater,
 and so operators like “less than” and “greater than or equal to” are interestin
g with respect to a B-tree.
 Because PostgreSQL allows the user to define operators, PostgreSQL cannot
 look at the name of an operator (e.g., < or >=) and tell what kind of comparison
 it is.
 Instead, the index method defines a set of “strategies”, which can be thought
 of as generalized operators.
 Each operator class specifies which actual operator corresponds to each
 strategy for a particular data type and interpretation of the index semantics.
\end_layout

\begin_layout Example
The B-tree index method defines five strategies, shown in the next Table.
\end_layout

\begin_layout Example
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Operation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Strategy Number
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
less than
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
less than or equal 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
equal 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
greater than or equal 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
greater than
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
Steps to create a PostgreSQL extension
\end_layout

\begin_layout Enumerate
Create the appropriate file structure: 
\begin_inset Formula $extension-version.sql$
\end_inset

, 
\begin_inset Formula $extension.c$
\end_inset

, 
\begin_inset Formula $Makefile$
\end_inset

, 
\begin_inset Formula $extension.control$
\end_inset

.
\end_layout

\begin_layout Enumerate
Create the data types.
\end_layout

\begin_layout Enumerate
Create I/O functions.
\end_layout

\begin_layout Enumerate
Create constructors, getters, setters.
\end_layout

\begin_layout Enumerate
Create needed functions.
\end_layout

\begin_layout Enumerate
Create operators 
\begin_inset Formula $=,<,\leq,>,\geq,...$
\end_inset


\end_layout

\begin_layout Enumerate
Define operator classes for indexes.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Failure Recovery and concurrency control
\end_layout

\begin_layout Section
Failure recovery
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition

\series bold
Integrity constraints
\series default
 are predicates that all data in the database must satisfy.
\end_layout

\begin_layout Definition
A database is said to be in a 
\series bold
consistent state
\series default
 if it satisfies all constraints defined on it.
 In such case, the database itself is said to be a 
\series bold
consistent DB
\series default
.
\end_layout

\end_inset


\end_layout

\begin_layout Remark
Databases cannot be consistent at all times, because when some operations
 are being done, it is possible to be in intermediate non-consistent states.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Plain Layout
A 
\series bold
transaction
\series default
 is a collection of actions that preserve consistency.
 Thus, a transaction should be the smallest unit of processing in the database.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A fundamental assumption about transactions is the correctness principle:
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Plain Layout

\series bold
Correctness principle
\series default
: If a transaction executes in the absence of any other transactions or
 system errors, and it starts with the database in a consistent state, then
 the database is also in a consistent state when the transaction ends.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
There is a converse to the correctness principle that forms the motivation
 for both the logging techniques that we are going to see.
 This converse involves two points:
\end_layout

\begin_layout Enumerate
A transaction is 
\series bold
atomic
\series default
, that is, it must be executed as a whole or not at all.
 If only part of a transaction executes, then the resulting database state
 may not be consistent.
 For example, if the system crashes in the middle of a transaction, if there
 is a media failure,...
\end_layout

\begin_layout Enumerate
Transactions that execute simultaneously are likely to lead to an inconsistent
 state unless we take steps to control their interactions (refer to Section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Concurrency-control"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
In order to study the details of logging algorithms and other transactionmanagem
ent algorithms, we need a notation that describes all the operations that
 move data between address spaces.
 The primitives we shall use are:
\end_layout

\begin_layout Itemize
INPUT(X): Copy the disk block containing database element X to a memory
 buffer.
\end_layout

\begin_layout Itemize
READ(X,t): Copy the database element X to the transaction’s local variable
 t.
 More precisely, if the block containing database element X is not in a
 memory buffer then first execute INPUT (X).
 Next, assign the value of X to local variable t.
 
\end_layout

\begin_layout Itemize
WRITE(X,t): Copy the value of local variable t to database element X in
 a memory buffer.
 More precisely, if the block containing database element X is not in a
 memory buffer then execute INPUT(X).
 Next, copy the value of t to X in the buffer.
 
\end_layout

\begin_layout Itemize
OUTPUT (X): Copy the block containing X from its buffer to disk
\end_layout

\begin_layout Subsection
Key problem: unfinished transactions
\end_layout

\begin_layout Standard
Unfinished transactions are a great problem when dealing with consistency.
 If we assume the correctness principle and all transactions execute completely
 (and isolated) then databases would always be consistent, and we would
 not be studying this, so there are reasons that makes transactions not
 to finish completely, leading to inconsistent states.
\end_layout

\begin_layout Example
Imagine we impose the constraint 
\begin_inset Formula $A=B$
\end_inset

 and we want to execute the transaction 
\begin_inset Formula 
\begin{align*}
T_{1}: & A\leftarrow A\times2\\
 & B\leftarrow B\times2
\end{align*}

\end_inset

 It is obvious that if the database is consistent at the beginning of the
 transaction, it will also be consistent at the end, because both values
 start being the same, and they are modified in the same way.
\end_layout

\begin_layout Example
Let's see how things can go wrong.
\end_layout

\begin_layout Example
Imagine the following plan:
\begin_inset Formula 
\begin{align*}
T_{1}: & Read\left(A,t\right); & t\leftarrow t\times2\\
 & Write\left(A,t\right);\\
 & Read\left(B,t\right); & t\leftarrow t\times2\\
 & Write\left(B,t\right);\\
 & Output\left(A\right);\\
 & Output\left(B\right);
\end{align*}

\end_inset

 The initial state is:
\end_layout

\begin_layout Example
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Memory
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Disk
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Example
After 
\begin_inset Formula $Read\left(A,t\right)$
\end_inset

:
\end_layout

\begin_layout Example
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Memory
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Disk
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Example
After 
\begin_inset Formula $t\leftarrow t\times2$
\end_inset

:
\end_layout

\begin_layout Example
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Memory
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Disk
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Example
After 
\begin_inset Formula $Write\left(A,t\right)$
\end_inset

:
\end_layout

\begin_layout Example
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Memory
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Disk
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Example
After 
\begin_inset Formula $Read\left(B,t\right)$
\end_inset

:
\end_layout

\begin_layout Example
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Memory
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Disk
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Example
After 
\begin_inset Formula $t\leftarrow t\times2$
\end_inset

:
\end_layout

\begin_layout Example
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Memory
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Disk
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Example
After 
\begin_inset Formula $Write\left(B,t\right)$
\end_inset

:
\end_layout

\begin_layout Example
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Memory
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Disk
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Example
After 
\begin_inset Formula $Output\left(A\right)$
\end_inset

:
\end_layout

\begin_layout Example
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Memory
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Disk
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Example
After 
\begin_inset Formula $Output\left(B\right)$
\end_inset

:
\end_layout

\begin_layout Example
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Memory
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Disk
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Example
If all actions execute, as we can see, the final state is consistent.
 Nonetheless, there is one point in the procedure when a failure in the
 system can leave it in an inconsistent state: after 
\begin_inset Formula $Output\left(A\right)$
\end_inset

 and before 
\begin_inset Formula $Output\left(B\right)$
\end_inset

 the database is inconsistent!
\end_layout

\begin_layout Standard
We need to be able to ensure 
\series bold
atomicity
\series default
 of transactions: all actions are executed, or none of them.
 For this purpose, 
\series bold
logging
\series default
 is an useful technique.
 Basically, the idea is to annotate all actions done in a file, and if the
 system crashes, we can consult this file and rollback unfinished transactions,
 continuing from the point left,...
\end_layout

\begin_layout Subsection
Logging
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
A 
\series bold
log
\series default
 is a file of log records, each telling something about what some transaction
 has done.
 If log records appear in nonvolatile storage, we can use them to restore
 the database to a consistent state after a system crash.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
There are several forms of log record that are used with each of the types
 of logging we discuss in this chapter.
 These are: 
\end_layout

\begin_layout Enumerate
<START T>: This record indicates that transaction T has begun.
 
\end_layout

\begin_layout Enumerate
<COMMIT T>: Transaction T has completed successfully and will make no more
 changes to database elements.
 Any changes to the database made by T should appear on disk.
 However, because we cannot control when the buffer manager chooses to copy
 blocks from memory to disk, we cannot in general be sure that the changes
 are already on disk when we see the <C0MMIT T> log record.
 If we insist that the changes already be on disk, this requirement must
 be enforced by the log manager (as is the case for undo logging).
 
\end_layout

\begin_layout Enumerate
< ABORT T>: Transaction T could not complete successfully.
 If transaction T aborts, no changes it made can have been copied to disk,
 and it is the job of the transaction manager to make sure that such changes
 never appear on disk, or that their effect on disk is cancelled if they
 do.
 
\end_layout

\begin_layout Subsubsection
Undo logging
\end_layout

\begin_layout Standard

\series bold
Undo logging
\series default
 makes repairs to the database state by undoing the effects of transactions
 that may not have completed before the crash.
\end_layout

\begin_layout Standard
For an undo log, the only other kind of log record we need is an update
 record, which is a triple < T ,X ,v> .
 The meaning of this record is: transaction T has changed database element
 X , and its former value was v.
 The change reflected by an update record normally occurs in memory, not
 disk.
\end_layout

\begin_layout Standard
An undo log does not record the new value of a database element, only the
 old value.
 If recovery is necessary in a system using undo logging, the only thing
 the recovery manager will do is cancel the possible effect of a transaction
 on disk by restoring the old value.
\end_layout

\begin_layout Example
Let's repeat the previous example with an undo log added to the scheme.
\end_layout

\begin_layout Example
Initially:
\end_layout

\begin_layout Example
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Memory
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Disk
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Log
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Example
The transaction 
\begin_inset Formula $T_{1}$
\end_inset

 starts:
\end_layout

\begin_layout Example
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Memory
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Disk
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Log
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<T1,start>
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Example
\begin_inset Formula $Read\left(A,t\right);t\leftarrow t\times2$
\end_inset

:
\end_layout

\begin_layout Example
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Memory
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Disk
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Log
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<T1,start>
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Example
\begin_inset Formula $Write\left(A,t\right)$
\end_inset

:
\end_layout

\begin_layout Example
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Memory
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Disk
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Log
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<T1,start>
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<T1,A,8>
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Example
\begin_inset Formula $Reat\left(B,t\right);t\leftarrow t\times2$
\end_inset

:
\end_layout

\begin_layout Example
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Memory
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Disk
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Log
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<T1,start>
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<T1,A,8>
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Example
\begin_inset Formula $Write\left(B,t\right)$
\end_inset

:
\end_layout

\begin_layout Example
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Memory
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Disk
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Log
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<T1,start>
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<T1,A,8>
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<T1,B,8>
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Example
\begin_inset Formula $Output\left(A\right)$
\end_inset

:
\end_layout

\begin_layout Example
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Memory
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Disk
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Log
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<T1,start>
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<T1,A,8>
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<T1,B,8>
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Example
\begin_inset Formula $Output\left(B\right)$
\end_inset

:
\end_layout

\begin_layout Example
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Memory
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Disk
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Log
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<T1,start>
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<T1,A,8>
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<T1,B,8>
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<T1,commit>
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Example
Imagine the system crashes after 
\begin_inset Formula $Output\left(A\right)$
\end_inset

 and before 
\begin_inset Formula $Output\left(B\right)$
\end_inset

.
 When we switch on the system again, the database system manager would check
 the log and see that 
\begin_inset Formula $T_{1}$
\end_inset

 is unfinished, so it would set the values of 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 to be 8, and consistency would be recovered.
\end_layout

\begin_layout Subsubsection*
Complications
\end_layout

\begin_layout Standard
Another aspect to take into account, is that the log must be first written
 in memory, not written to disk on every action, so some problems can arise.
\end_layout

\begin_layout Example
First bad state: DB modified before log is written
\end_layout

\begin_layout Example
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Memory
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Log:
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<T1,start>
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<T1,A,8>
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<T1,B,8>
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Disk
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Log
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Example
If the system crashes now, we lose the log information in memory, and we
 don't have it on disk, so we would not be able to recover to the previous
 consistent state.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Example
Second bad state: log written before DB modified
\end_layout

\begin_layout Example
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Memory
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Log:
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<T1,start>
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<T1,A,8>
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<T1,B,8>
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<T1,commit>
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Disk
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Log
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<T1,start>
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<T1,A,8>
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<T1,B,8>
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<T1,commit>
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Example
If the system fails now, we would think that 
\begin_inset Formula $B$
\end_inset

 has been correctly chanegd, because the buffer manager has not issued the
 
\begin_inset Formula $Output\left(B\right)$
\end_inset

 operator yet.
\end_layout

\begin_layout Standard
An undo log is sufficient to allow recovery from a system failure, provided
 transactions and the buffer manager obey two rules: 
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
U1)
\end_layout

\end_inset

 If transaction T modifies database element X , then the log record of the
 form < T ,X ,v> must be written to disk before the new value of X is written
 to disk.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
U2)
\end_layout

\end_inset

 If a transaction commits, then its COMMIT log record must be written to
 disk only after all database elements changed by the transaction have been
 written to disk, but as soon thereafter as possible.
\end_layout

\begin_layout Standard
In order to force log records to disk, the log manager needs a fiush-log
 command that tells the buffer manager to copy to disk any log blocks that
 have not previously been copied to disk or that have been changed since
 they were last copied.
 In sequences of actions, we shall show FLUSH LOG explicitly.
\end_layout

\begin_layout Example
Let's repeat the example with all this rules:
\end_layout

\begin_layout Example
\begin_inset Tabular
<lyxtabular version="3" rows="13" columns="9">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Step
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Action
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MemA
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MemB
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DiskA
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DiskB
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MemLog
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DiskLog
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<Start T>
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Read(A,t)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $t\leftarrow t\times2$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Write\left(A,t\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<T,A,8>
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Read\left(B,t\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $t\leftarrow t\times2$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Write\left(B,t\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<T,B,8>
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $FlushLog$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<Start T>;<T,A,8>;<T,B,8>
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Output\left(A\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Output\left(B\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
11
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<Commit T>
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $FlushLog$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<Commit T>
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Example
In this case, at any point in the process, if there is a failure, we would
 be able to rollback to a previous consistent state using the log written
 in disk.
\end_layout

\begin_layout Standard
When an error ocurrs, there is a procedure to follow, which is detailed
 in Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Undo-logging:-recovery"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Note that if a failure occurs during recovery, nothing goes wrong, because
 the recovery procedure would start over again when the system is switched
 on and the rollback operations would proceed in the same manner.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "morekeywords={Let, in, but, not, for, each, do, if, then}"
inline false
status open

\begin_layout Plain Layout

Let S = set of transaction with <Ti,start> in log, but no
\end_layout

\begin_layout Plain Layout

		<Ti,commit> not <Ti,abort> in log
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

for each <Ti,X,v> in log in reverse order do
\end_layout

\begin_layout Plain Layout

	if Ti in S then
\end_layout

\begin_layout Plain Layout

		write(X,v)
\end_layout

\begin_layout Plain Layout

		output(X)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

for each Ti in S do
\end_layout

\begin_layout Plain Layout

	write <Ti,abort> to log	
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:Undo-logging:-recovery"

\end_inset

Undo logging: recovery rules
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Redo logging
\end_layout

\begin_layout Standard
Undo logging has a potential problem that we cannot commit a transaction
 without first writing all its changed data to disk.
 Sometimes, we can save disk I/O ’s if we let changes to the database reside
 only in main memory for a while.
 As long as there is a log to fix things up in the event of a crash, it
 is safe to do so.
 The requirement for immediate backup of database elements to disk can be
 avoided if we use a logging mechanism called redo logging.
 The principal differences between redo and undo logging are:
\end_layout

\begin_layout Enumerate
While undo logging cancels the effect of incomplete transactions and ignores
 committed ones during recovery, redo logging ignores incomplete transactions
 and repeats the changes made by committed transactions.
 
\end_layout

\begin_layout Enumerate
While undo logging requires us to write changed database elements to disk
 before the COMMIT log record reaches disk, redo logging requires that the
 COMMIT record appear on disk before any changed values reach disk.
 
\end_layout

\begin_layout Enumerate
While the old values of changed database elements are exactly what we need
 to recover when the undo rules U1 and U2 are followed, to recover using
 redo logging, we need the new values instead.
\end_layout

\begin_layout Standard
In redo logging the meaning of a log record <T, X , v> is “
\emph on
transaction T wrote new value v for database element X
\emph default
”.
 There is no indication of the old value of X in this record.
 Every time a transaction T modifies a database element X , a record of
 the form < T ,X ,v> must be written to the log.
 
\end_layout

\begin_layout Standard
For redo logging, the order in which data and log entries reach disk can
 be described by a single “redo rule,” called the 
\series bold
write-ahead logging rule
\series default
.
 
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
R1)
\end_layout

\end_inset

 Before modifying any database element X on disk, it is necessary that all
 log records pertaining to this modification of X , including both the update
 record < T ,X ,v> and the <C0MMIT T> record, must appear on disk.
\end_layout

\begin_layout Example
Let's repeat the same example with this new logic.
\end_layout

\begin_layout Example
\begin_inset Tabular
<lyxtabular version="3" rows="12" columns="9">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Step
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Action
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MemA
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MemB
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DiskA
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DiskB
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MemLog
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DiskLog
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<Start T>
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Read(A,t)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $t\leftarrow t\times2$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Write\left(A,t\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<T,A,16>
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Read\left(B,t\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $t\leftarrow t\times2$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Write\left(B,t\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<T,B,16>
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<Commit T>
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<Start T>;<T,A,16>;<T,B,16>;<Commit T>
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Output\left(A\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
11
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Output\left(B\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
The procedure to recover from a failure is different from that of undo logging.
 In undo logging, we discard uncommited changes, because we are unsure if
 they are done in the database.
 In redo logging, we proceed by doing again those changes that are commited,
 because these are now those that we are unsure about, while uncommitted
 changes we know for sure that have not been made.
 The recovery rules for redo logging are illustrated in Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Redo-logging:-recovery"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "morekeywords={Let, in, but, not, for, each, do, if, then}"
inline false
status open

\begin_layout Plain Layout

Let S = set of transaction with <Ti,start> in log, but no
\end_layout

\begin_layout Plain Layout

		<Ti,commit> not <Ti,end> in log
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

for each <Ti,X,v> in log in forward order do
\end_layout

\begin_layout Plain Layout

	if Ti in S then
\end_layout

\begin_layout Plain Layout

		write(X,v)
\end_layout

\begin_layout Plain Layout

		output(X)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

for each Ti in S do
\end_layout

\begin_layout Plain Layout

	write <Ti,end> to log	
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:Redo-logging:-recovery"

\end_inset

Redo logging: recovery rules
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Combining <Ti,end> records
\end_layout

\begin_layout Standard
There exist objects that are accessed often, which are usually called 
\series bold
hot objects
\series default
.
 One idea about this object is that as they are accessed very often, they
 would require lots of I/O operations and, many times, updated values of
 these objects would not even be needed to have been on disk, so we can
 try to delay writing them to disk as long as we can work with their values
 in memory.
 This way, we can just write their latest value and perform less I/O operations.
\end_layout

\begin_layout Example
Imagine we have four transactions:
\end_layout

\begin_layout Example
\begin_inset Formula $T_{1}:..update\ X..$
\end_inset

,
\begin_inset Formula $T_{2}:..update\ X..$
\end_inset

,
\begin_inset Formula $T_{3}:..update\ X..$
\end_inset

,
\begin_inset Formula $T_{4}:..update\ X..$
\end_inset

 which can be executed with the following set of actions:
\end_layout

\begin_layout Example
\begin_inset Formula 
\[
\begin{array}{c}
Write\left(X\right)\\
Output\left(X\right)\\
Write\left(X\right)\\
Output\left(X\right)\\
Write\left(X\right)\\
Output\left(X\right)\\
Write\left(X\right)\\
Output\left(X\right)
\end{array}
\]

\end_inset

 And this way we would be updating 
\begin_inset Formula $X$
\end_inset

 unnecessarily.
 A better way to handle this is:
\end_layout

\begin_layout Example
\begin_inset Formula 
\[
\begin{array}{c}
Write\left(X\right)\\
\cancel{Output\left(X\right)}\\
Write\left(X\right)\\
\cancel{Output\left(X\right)}\\
Write\left(X\right)\\
\cancel{Output\left(X\right)}\\
Write\left(X\right)\\
Output\left(X\right)\\
combined\ <end>
\end{array}
\]

\end_inset


\end_layout

\begin_layout Standard
Nonetheless, there is an even better way to tackle this problem: 
\series bold
checkpointing
\series default
.
\end_layout

\begin_layout Subsubsection
Checkpointing with undo logging
\end_layout

\begin_layout Standard
As we observed, recovery requires that the entire log be examined, in principle.
 When logging follows the undo style, once a transaction has its COMMIT
 log record written to disk, the log records of that transaction are no
 longer needed during recovery.
 We might imagine that we could delete the log prior to a COMMIT, but sometimes
 we cannot.
 The reason is that often many transactions execute at once.
 If we truncated the log after one transaction committed, log records pertaining
 to some other active transaction T might be lost and could not be used
 to undo T if recovery were necessary.
 The simplest way to untangle potential problems is to checkpoint the log
 periodically.
 In a simple checkpoint, we:
\end_layout

\begin_layout Enumerate
Stop accepting new transactions.
 
\end_layout

\begin_layout Enumerate
Wait until all currently active transactions commit or abort and have written
 a COMMIT or ABORT record on the log.
 
\end_layout

\begin_layout Enumerate
Flush the log to disk.
 
\end_layout

\begin_layout Enumerate
Write a log record <CKPT>, and flush the log again.
 
\end_layout

\begin_layout Enumerate
Resume accepting transactions.
\end_layout

\begin_layout Example
An undo log with checkpointing:
\end_layout

\begin_layout Example
\begin_inset Formula 
\[
\begin{array}{c}
<Start\ T_{1}>\\
<T_{1},A,5>\\
<Start\ T_{2}>\\
<T_{2},B,10>\\
------\\
<T_{2},C,15>\\
<T_{1},D,20>\\
<Commit\ T_{1}>\\
<Commit\ T_{2}>\\
<CKPT>\\
<Start\ T_{3}>\\
<T_{3},E,25>\\
...
\end{array}
\]

\end_inset


\end_layout

\begin_layout Example
In the dotted line, a checkpoint was launched, so no more transactions are
 accepted to execute until 
\begin_inset Formula $T_{1}$
\end_inset

 and 
\begin_inset Formula $T_{2}$
\end_inset

 finish.
 When both transactions commit, we can now write the checkpoint and accept
 new transactions, such as 
\begin_inset Formula $T_{3}$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Checkpointing with redo logging
\end_layout

\begin_layout Standard
The steps to perform a checkpoint of a redo log are as follows: 
\end_layout

\begin_layout Enumerate
Write a log record <START CKPT (Ti,...
 ,Tk)>, where Ti,...
 ,Tk are all the active (uncommitted) transactions, and flush the log.
 
\end_layout

\begin_layout Enumerate
Write to disk all database elements that were written to buffers but not
 yet to disk by transactions that had already committed when the START CKPT
 record was written to the log.
 
\end_layout

\begin_layout Enumerate
Write an <END CKPT> record to the log and flush the log.
\end_layout

\begin_layout Example
A redo log with checkpointing:
\end_layout

\begin_layout Example
When we start the checkpoint, only T2 is active, but the value of A written
 by T1 may have reached disk.
 If not, then we must copy A to disk before the checkpoint can end.
 
\end_layout

\begin_layout Example
\begin_inset Formula 
\[
\begin{array}{c}
<Start\ T_{1}>\\
<T_{1},A,5>\\
<Start\ T_{2}>\\
<Commit\ T_{1}>\\
<T_{2},B,10>\\
<Start\ CKPT\left(T_{2}\right)>\\
<T_{2},C,15>\\
<Start\ T_{3}>\\
<T_{3},D,20>\\
<End\ CKPT>\\
<Commit\ T_{2}>\\
<Commit\ T_{3}>
\end{array}
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Undo/Redo logging
\end_layout

\begin_layout Standard
We have seen two different approaches to logging, differentiated by whether
 the log holds old values or new values when a database element is updated.
 Each has certain drawbacks: 
\end_layout

\begin_layout Itemize
Undo logging requires that data be written to disk immediately after a transacti
on finishes, perhaps increasing the number of disk I/O operations that need
 to be performed.
 
\end_layout

\begin_layout Itemize
On the other hand, redo logging requires us to keep all modified blocks
 in buffers until the transaction commits and the log records have been
 flushed, perhaps increasing the average number of buffers required by transacti
ons.
 
\end_layout

\begin_layout Itemize
Both undo and redo logs may put contradictory requirements on how buffers
 are handled during a checkpoint, unless the database elements are complete
 blocks or sets of blocks.
 For instance, if a buffer contains one database element A that was changed
 by a committed transaction and another database element B that was changed
 in the same buffer by a transaction that has not yet had its COMMIT record
 written to disk, then we are required to copy the buffer to disk because
 of A but also forbidden to do so, because rule R1 applies to B.
\end_layout

\begin_layout Standard
An 
\series bold
undo/redo log
\series default
 has the same sorts of log records as the other kinds of log, with one exception.
 The update log record that we write when a database element changes value
 has four components.
 Record < T ,X ,v,w > means that transaction T changed the value of database
 element X; its former value was v, and its new value is w.
 The constraints that an undo/redo logging system must follow are summarized
 by the following rule:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
UR1)
\end_layout

\end_inset

 Before modifying any database element X on disk because of changes made
 by some transaction T, it is necessary that the update record <T, X , v,
 w> appear on disk.
\end_layout

\begin_layout Example
An undo/redo log.
 Let's redo our typical example:
\end_layout

\begin_layout Example
\begin_inset Tabular
<lyxtabular version="3" rows="12" columns="9">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Step
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Action
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MemA
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MemB
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DiskA
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DiskB
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MemLog
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DiskLog
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<Start T>
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Read(A,t)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $t\leftarrow t\times2$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Write\left(A,t\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<T,A,8,16>
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Read\left(B,t\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $t\leftarrow t\times2$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Write\left(B,t\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<T,B,8,16>
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $FlushLog$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<Start T>;<T,A,8,16>;<T,B,8,16>
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Output\left(A\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<Commit T>
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
11
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Output\left(B\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Example
Note that, in this case, the last three steps could've appeared in any order.
\end_layout

\begin_layout Standard
The undo/redo recovery policy is:
\end_layout

\begin_layout Enumerate
Redo all the committed transactions in the order earlierst-first.
\end_layout

\begin_layout Enumerate
Undo all the uncommitted transactions in the order latest-first.
\end_layout

\begin_layout Section
Concurrency control
\begin_inset CommandInset label
LatexCommand label
name "sec:Concurrency-control"

\end_inset


\end_layout

\begin_layout Standard
Interactions among concurrently executing transactions can cause the database
 state to become inconsistent, even when the transactions individually preserve
 correctness of the state, and there is no system failure.
 Thus, the timing of individual steps of different transactions needs to
 be regulated in some manner.
 This regulation is the job of the 
\series bold
scheduler
\series default
 component of the DBMS, and the general process of assuring that transactions
 preserve consistency when executing simultaneously is called 
\series bold
concurrency control
\series default
.
\end_layout

\begin_layout Subsection
Schedules: serial, serializable and conflict-serializable
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
A 
\series bold
schedule
\series default
 is a sequence of the important actions taken by one or more transactions.
\end_layout

\end_inset


\end_layout

\begin_layout Example
Imagine we have the constraint 
\begin_inset Formula $A=B$
\end_inset

 and the following two transactions:
\begin_inset Formula 
\begin{align*}
T_{1}: & Read\left(A\right) & T_{2}: & Read\left(A\right)\\
 & A\leftarrow A+100 &  & A\leftarrow A\times2\\
 & Write\left(A\right) &  & Write\left(A\right)\\
 & Read\left(B\right) &  & Read\left(B\right)\\
 & B\leftarrow B+100 &  & B\leftarrow B\times2\\
 & Write\left(B\right) &  & Write\left(B\right)
\end{align*}

\end_inset

 Note how each of the transactions individually preserves the consistency
 of the database.
 Nonetheless, there exist some schedules that can make things go wrong!
\end_layout

\begin_layout Example

\series bold
Schedule A
\series default
:
\end_layout

\begin_layout Example
\begin_inset Tabular
<lyxtabular version="3" rows="11" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
25
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
25
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Read(A); A<-A+100
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Write(A);
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
125
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Read(B); B<-B+100
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Write(B);
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
125
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Read(B); A<-A*2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Write(A);
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
250
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Read(B); B<-B*2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Write(B);
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
250
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
250
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
250
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Example
This schedule poses no problems.
\end_layout

\begin_layout Example

\series bold
Schedule B
\series default
:
\end_layout

\begin_layout Example
\begin_inset Tabular
<lyxtabular version="3" rows="11" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
25
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
25
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Read(A); A<-A*2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Write(A);
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
50
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Read(B); B<-B*2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Write(B);
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
50
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Read(A); A<-A+100
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Write(A);
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
150
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Read(B); B<-B+100
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Write(B);
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
150
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
150
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
150
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Example
This schedule poses no problems.
 Note, nonetheless, how the different orderings affect the final result.
\end_layout

\begin_layout Example

\series bold
Schedule C
\series default
:
\end_layout

\begin_layout Example
\begin_inset Tabular
<lyxtabular version="3" rows="11" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
25
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
25
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Read(A); A<-A+100
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Write(A);
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
125
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Read(A); A<-A*2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Write(A);
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
250
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Read(B); B<-B+100
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Write(B);
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
125
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Read(B); B<-B*2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Write(B);
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
250
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
250
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
250
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Example
This schedule poses no problems.
\end_layout

\begin_layout Example

\series bold
Schedule D
\series default
:
\end_layout

\begin_layout Example
\begin_inset Tabular
<lyxtabular version="3" rows="11" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
25
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
25
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Read(A); A<-A+100
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Write(A);
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
125
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Read(A); A<-A*2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Write(A);
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
250
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Read(B); B<-B*2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Write(B);
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
50
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Read(B); B<-B+100
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Write(B);
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
150
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
250
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
150
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Example
But this schedule is problematic! The final state of the database is inconsisten
t.
\end_layout

\begin_layout Standard
We want schedules that are '
\emph on
good
\emph default
', in the sense that they ensure the final state of the database to be consisten
t, independent of the transactions' semantics and the initial (consistent)
 state of the database.
\end_layout

\begin_layout Standard
For this, we should only look at the order of read and writes.
\end_layout

\begin_layout Standard
A schedule can be represented as its sequence of actions, where 
\begin_inset Formula $r_{i}\left(X\right)$
\end_inset

 means 
\begin_inset Formula $X$
\end_inset

 is read in transaction 
\begin_inset Formula $i$
\end_inset

 and 
\begin_inset Formula $w_{i}\left(X\right)$
\end_inset

 means 
\begin_inset Formula $X$
\end_inset

 is written in transaction 
\begin_inset Formula $i$
\end_inset

.
\end_layout

\begin_layout Standard
For example, schedule C can be represented as
\begin_inset Formula 
\[
S_{C}=r_{1}\left(A\right)w_{1}\left(A\right)r_{2}\left(A\right)w_{2}\left(A\right)r_{1}\left(B\right)w_{1}\left(B\right)r_{2}\left(B\right)w_{2}\left(B\right).
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
A schedule is 
\series bold
serial
\series default
 if its actions consist of all the actions of one transaction, then all
 actions of another transaction, and so on.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For example, Schedules A and B are serial.
\end_layout

\begin_layout Remark
Note that all serial schedules work: they leave a consistent database, because
 of the correctness principle.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
A schedule 
\begin_inset Formula $S$
\end_inset

 is serializable if there is a serial schedule 
\begin_inset Formula $S'$
\end_inset

 such that for every initial database state, the effects of 
\begin_inset Formula $S$
\end_inset

 and 
\begin_inset Formula $S'$
\end_inset

 are the same.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For example, Schedule C is serializable, with 
\begin_inset Formula $C'=A$
\end_inset

, but schedule D is not serializable, because it leads to an inconsistent
 state.
\end_layout

\begin_layout Subsubsection*
The transaction game
\end_layout

\begin_layout Standard
It is a way to visually check for serializability (only for simple schedules).
\end_layout

\begin_layout Example
For example, Schedule C is:
\end_layout

\begin_layout Example
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="9">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
w
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
w
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
w
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
w
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
w
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
w
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
w
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
w
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Example
Here, we represents taken by each transaction and the affected variable,
 in the order of the schedule.
 Now, two steps can be exchanged if they are next to one another and they
 can slide without colliding.
\end_layout

\begin_layout Example
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="9">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color red
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color red
w
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color red
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color red
w
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
w
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
w
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color red
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color red
w
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
w
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color red
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color red
w
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
w
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Example
Here, the red colored steps cannot be exchanged, because they collide in
 the first row.
\end_layout

\begin_layout Example
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="9">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
w
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color teal
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color teal
w
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color teal
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color teal
w
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
w
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
w
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color teal
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color teal
w
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color teal
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color teal
w
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
w
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Example
But now, the green colored steps can be exchanged, because they are next
 to each other and they do not collide if we slide the columns:
\end_layout

\begin_layout Example
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="9">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
w
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
w
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
w
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
w
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
w
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
w
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
w
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
w
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Example
And this is schedule A!
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Example
Now, for schedule D:
\end_layout

\begin_layout Example
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="9">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color red
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color red
w
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color red
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color red
w
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color red
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color red
w
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color red
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color red
w
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color red
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color red
w
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color red
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color red
w
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color red
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color red
w
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color red
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color red
w
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Example
Everything is red!
\end_layout

\begin_layout Standard
Let's continue the discussion to try to understand why D is different from
 C.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
We define 
\series bold
conflicting actions
\series default
 as those that cannot be reordered in a schedule.
 These are:
\end_layout

\begin_layout Itemize
Obviously, actions made by the same transactions cannot be reordered.
\end_layout

\begin_layout Itemize
But there are also actions from different transactions whose reordering
 would affect the result:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $r_{1}\left(A\right)$
\end_inset

 and 
\begin_inset Formula $w_{2}\left(A\right)$
\end_inset

 cannot be reordered
\end_layout

\begin_layout Itemize
\begin_inset Formula $w_{2}\left(A\right)$
\end_inset

 and 
\begin_inset Formula $r_{1}\left(A\right)$
\end_inset

 cannot be reordered
\end_layout

\begin_layout Itemize
\begin_inset Formula $w_{1}\left(A\right)$
\end_inset

 and 
\begin_inset Formula $w_{2}\left(A\right)$
\end_inset

 cannot be reordered
\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
A schedule is 
\series bold
conflict serializable
\series default
 if it can be serialized without violating any conflicting action.
 If 
\begin_inset Formula $S$
\end_inset

 is conflict serializable to 
\begin_inset Formula $S'$
\end_inset

, then 
\begin_inset Formula $S$
\end_inset

 and 
\begin_inset Formula $S'$
\end_inset

 are 
\series bold
conflict equivalent
\series default
.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
These definitions allow us to create a mathematical tool for determining
 '
\emph on
good
\emph default
' schedules, understanding that as a conflict serializable schedule.
 This goal is achieved by a precedence graph:
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
A 
\series bold
precedence graph
\series default
 of a schedule 
\begin_inset Formula $S$
\end_inset

, 
\begin_inset Formula $P\left(S\right)$
\end_inset

, is graph 
\begin_inset Formula $P\left(S\right)=\left(N,E\right)$
\end_inset

 where:
\end_layout

\begin_deeper
\begin_layout Itemize
The nodes, 
\begin_inset Formula $N$
\end_inset

, are the transactions in 
\begin_inset Formula $S$
\end_inset

.
\end_layout

\begin_layout Itemize
The arcs are directed, and 
\begin_inset Formula $\left(T_{i},T_{j}\right)\in E$
\end_inset

 whenever:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $p_{i}\left(A\right),q_{j}\left(A\right)$
\end_inset

 are actions in 
\begin_inset Formula $S$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $p_{i}\left(A\right)<_{S}q_{j}\left(A\right)$
\end_inset

, i.e., 
\begin_inset Formula $p_{i}\left(A\right)$
\end_inset

 precedes 
\begin_inset Formula $q_{j}\left(A\right)$
\end_inset


\end_layout

\begin_layout Itemize
at least one of 
\begin_inset Formula $p_{i},q_{j}$
\end_inset

 is a write
\end_layout

\end_deeper
\end_deeper
\end_inset


\end_layout

\begin_layout Example
\begin_inset CommandInset label
LatexCommand label
name "ex:precedence-graph"

\end_inset

Let's compute 
\begin_inset Formula $P\left(S\right)$
\end_inset

 for
\begin_inset Formula 
\[
S=w_{3}\left(A\right)w_{2}\left(C\right)r_{1}\left(A\right)w_{1}\left(B\right)r_{1}\left(C\right)w_{2}\left(A\right)r_{4}\left(A\right)w_{4}\left(D\right)
\]

\end_inset


\end_layout

\begin_layout Example
\begin_inset Graphics
	filename pegado2.png

\end_inset


\end_layout

\begin_layout Subsubsection*
How to use precedence graphs to determine conflict-serializability?
\end_layout

\begin_layout Standard
To tell whether a schedule 
\begin_inset Formula $S$
\end_inset

 is conflict-serializable, construct the precedence graph for 
\begin_inset Formula $S$
\end_inset

 and ask if there are any cycles.
 If so, then 
\begin_inset Formula $S$
\end_inset

 is not conflict-serializable.
 But if the graph is acyclic, then 
\begin_inset Formula $S$
\end_inset

 is conflict-serializable.
\end_layout

\begin_layout Example
The schedule in Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "ex:precedence-graph"
plural "false"
caps "false"
noprefix "false"

\end_inset

 is not conflict serializable, because there is cycle between nodes 1 and
 2.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Example
Is 
\begin_inset Formula $S=w_{1}\left(A\right)r_{2}\left(A\right)r_{3}\left(A\right)w_{4}\left(A\right)$
\end_inset

 conflict serializable?
\end_layout

\begin_layout Example
First, construct the precedence graph:
\end_layout

\begin_layout Example
\begin_inset Graphics
	filename pegado3.png

\end_inset


\end_layout

\begin_layout Example
In this case, there are no cycles, so 
\begin_inset Formula $S$
\end_inset

 is conflict serializable.
\end_layout

\begin_layout Subsection
How to enforce serializability: locking
\end_layout

\begin_layout Subsubsection
Option 1: let luck be our friend
\end_layout

\begin_layout Standard
Run the system, recording the precedence graphs of the schedules used.
 At the end of the day (at some decided point in time), check for 
\begin_inset Formula $P\left(S\right)$
\end_inset

 cycles and declared if the execution was good.
\end_layout

\begin_layout Standard
Of course, this is not a very good option, because we are letting luck decide
 whether we are losing time and energy or not.
\end_layout

\begin_layout Subsubsection
Option 2: a locking protocol
\end_layout

\begin_layout Standard
Prevent cycles from occurring!
\end_layout

\begin_layout Standard
Now, we define two new actions:
\end_layout

\begin_layout Itemize
LOCK(A),
\begin_inset space ~
\end_inset


\begin_inset Formula $l_{i}\left(A\right)$
\end_inset

: lock access to object 
\begin_inset Formula $A$
\end_inset

, i.e., only transaction 
\begin_inset Formula $i$
\end_inset

 can access object 
\begin_inset Formula $A$
\end_inset

 both for read and write.
\end_layout

\begin_layout Itemize
UNLOCK(A), 
\begin_inset Formula $u_{i}\left(A\right)$
\end_inset

: unlock 
\begin_inset Formula $A$
\end_inset

 so it can be accessed by other transactions.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition

\series bold
Rule 1: 
\series default
A transaction is 
\series bold
well-formed
\series default
 if before performing any operation on an object 
\begin_inset Formula $A$
\end_inset

, it has locked it before, and it unlocks it afterwards.
\end_layout

\begin_layout Plain Layout
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition

\series bold
Rule 2: 
\series default
A schedule is 
\series bold
legal
\series default
 if all objects that are locked, have been previously unlocked (or never
 locked before).
\end_layout

\end_inset


\end_layout

\begin_layout Example
Let's analyze some schedules in terms of well-form and legality:
\end_layout

\begin_deeper
\begin_layout Itemize
S1=l1(A)l1(B)r1(A)w1(B)l2(B)u1(A)u1(B)r2(B)w2(B)u2(B)l3(B)r3(B)u3(B) ç
\end_layout

\begin_deeper
\begin_layout Standard
Let's start assessing if all transactions are well-formed:
\end_layout

\begin_layout Standard
S1=
\color red
l1(A)
\color blue
l1(B)
\color red
r1(A)
\color blue
w1(B)
\color teal
l2(B)
\color red
u1(A)
\color blue
u1(B)
\color teal
r2(B)w2(B)u2(B)
\color purple
l3(B)r3(B)u3(B)
\end_layout

\begin_layout Standard
As we can see, all actions of each transaction are preceded by a lock to
 the pertinent object and an unlock afterwards, so all transactions are
 well formed.
\end_layout

\begin_layout Standard
Regarding legality:
\end_layout

\begin_layout Standard
S1=l1(A)
\color blue
l1(B)
\color inherit
r1(A)
\color blue
w1(B)
\color red
l2(B)
\color inherit
u1(A)
\color blue
u1(B)
\color inherit
r2(B)w2(B)u2(B)l3(B)r3(B)u3(B)
\end_layout

\begin_layout Standard
We can see how object B is locked by transaction 2 before being unlocked
 by transaction 1, so the schedule is not legal.
\end_layout

\end_deeper
\begin_layout Itemize
S2=l1(A)r1(A)w1(B)u1(A)u1(B)l2(B)r2(B)w2(B)l3(B)r3(B)u3(B)
\end_layout

\begin_deeper
\begin_layout Standard
Regarding well-form:
\end_layout

\begin_layout Standard
S2=
\color red
¿?
\color inherit
l1(A)r1(A)
\color red
w1(B)
\color inherit
u1(A)u1(B)
\color blue
l2(B)r2(B)w2(B)
\color teal
l3(B)r3(B)u3(B)
\color blue
¿?
\end_layout

\begin_layout Standard
B is modified by transaction 1 before being locked, so transaction 1 is
 not well formed.
\end_layout

\begin_layout Standard
B is locked, read and written by transaction 2, but it is never unlocked,
 so transaction 2 is also not well formed.
\end_layout

\begin_layout Standard
Transaction 3 is well formed.
\end_layout

\begin_layout Standard
Regarding legality, we can see how B is locked by transaction 3 before being
 unlocked by transacion 2, so the schedule is not legal.
\end_layout

\end_deeper
\begin_layout Itemize
S3=
\color blue
l1(A)r1(A)u1(A)
\color red
l1(B)w1(B)u1(B)
\color teal
l2(B)r2(B)w2(B)u2(B)
\color purple
l3(B)r3(B)u3(B)
\end_layout

\begin_deeper
\begin_layout Standard
This schedule is obviously legal and all transactions are well formed.
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition

\series bold
Rule 3:
\series default
 The 
\series bold
two phase locking (2PL)
\series default
 scheme refers to a strategy for scheduling in which there are no unlocks
 for transaction 
\begin_inset Formula $T_{i}$
\end_inset

 until all locks for 
\begin_inset Formula $T_{i}$
\end_inset

 have been acquired, and there are no locks for 
\begin_inset Formula $T_{i}$
\end_inset

 after any unlock for 
\begin_inset Formula $T_{i}$
\end_inset

, i.e., all locks are acquired before any unlock is performed.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Theorem
All schedules verifying rules 1,2 and 3 are conflict-serializable.
 Meaning, if a schedule has all its transactions well-formed, the schedule
 is legal and it uses the 2PL locking scheme, then the schedule is conflict-seri
alizable.
\end_layout

\end_inset


\end_layout

\begin_layout Remark
Note that the converse is not true: there are conflict-serializable schedules
 that are not 2PL.
\end_layout

\begin_layout Standard
Beyond the 2PL protocol, it is all a matter of improving performance and
 allowing more concurrency, for these, there exist more artifacts, such
 as shared locks, multiple granularity locks,...
\end_layout

\begin_layout Subsection
Shared locks
\end_layout

\begin_layout Standard
Until now, we are locking an object before any action can be applied to
 it, but sometimes it is possible to actually grant access to several transactio
ns to interact with the same object, if the actions that they need to perform
 are not in conflict.
 For example, if two transactions want to read from the same variable, they
 can do it without problem, but with our scheme we don't allow this.
\end_layout

\begin_layout Standard
A way to amend this is to define 
\series bold
shared locks
\series default
 which are locks that can be shared by several transactions, provided they
 only want to read the object.
 
\end_layout

\begin_layout Standard
We define new actions:
\end_layout

\begin_layout Itemize
EXCLUSIVE-LOCK(A), 
\begin_inset Formula $xl_{i}\left(A\right)$
\end_inset

: lock object A in exclusive mode, i.e., no other transaction can lock it
 until it is unlocked.
\end_layout

\begin_layout Itemize
SHARED-LOCK(A), 
\begin_inset Formula $sl_{i}\left(A\right)$
\end_inset

: lock object A in shared mode, i.e., other transactions can lock it in shared
 mode, but not in exclusive mode.
\end_layout

\begin_layout Itemize
EXCLUSIVE-UNLOCK(A), 
\begin_inset Formula $xu_{i}\left(A\right)$
\end_inset

: unlock A from exclusive lock.
\end_layout

\begin_layout Itemize
SHARED-UNLOCK(A), 
\begin_inset Formula $su_{i}\left(A\right)$
\end_inset

: unlock A from shared lock.
\end_layout

\begin_layout Standard
Note that it is usual to just represent both unlocks by 
\begin_inset Formula $u_{i}\left(A\right)$
\end_inset

, assuming the computer will execute the correct action depending on the
 state of the object.
\end_layout

\begin_layout Standard
Now, we have to redefine our rules:
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition

\series bold
Rule 1:
\series default
 a transaction is 
\series bold
well-formed
\series default
 if:
\end_layout

\begin_deeper
\begin_layout Itemize
Before performing a read action on an object, it has been previously locked,
 exclusively or shared (but better if it is shared locked, allowing for
 increased performance).
\end_layout

\begin_layout Itemize
Before performing a write action on an object, it has been previously exclusivel
y locked.
\end_layout

\end_deeper
\begin_layout Definition

\series bold
Rule 2:
\series default
 a schedule is 
\series bold
legal
\series default
 if:
\end_layout

\begin_deeper
\begin_layout Itemize
No exclusive lock is performed on a locked (exclusive or shared) object,
 until it has been unlocked.
\end_layout

\begin_layout Itemize
No lock (exclusive or shared) is performed on a exclusively locked object,
 until it has been unlocked.
\end_layout

\end_deeper
\begin_layout Definition
This rule can be summarize in a 
\series bold
compatibility matrix
\series default
, which shows which state changes are allowed:
\end_layout

\begin_layout Definition
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $T_{j}$
\end_inset

 asks for
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="3" alignment="center" valignment="middle" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $T_{i}$
\end_inset

 holds
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
S
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
S
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
True
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
False
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
False
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
False
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Definition

\series bold
Rule 3:
\series default
 a schedule respect the 
\series bold
2PL protocol
\series default
 if for any two-phase locked transaction 
\begin_inset Formula $T_{i}$
\end_inset

, no action 
\begin_inset Formula $xl_{i}\left(A\right)$
\end_inset

 or 
\begin_inset Formula $sl_{i}\left(A\right)$
\end_inset

 is preceded by an action 
\begin_inset Formula $u_{i}\left(B\right)$
\end_inset

 for any object 
\begin_inset Formula $B$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Notice that there are transactions that read and write the same object,
 so what should we do about this? There are two main options:
\end_layout

\begin_layout Enumerate
We can just request an exclusive lock from the beginning.
\end_layout

\begin_layout Enumerate
We can use an 
\series bold
upgrade
\series default
 scheme, in which a shared lock is acquired if we are unsure if we will
 need to write the object later.
 When we need to write it, we '
\emph on
upgrade
\emph default
' the shared lock to be an exclusive lock.
 This can be technically achieved by allowing transactions to have two locks
 on the same object: one shared and one exclusive; or by releasing the shared
 lock and getting the exclusive lock
\begin_inset Foot
status open

\begin_layout Plain Layout
Note that in this case we have to slightly modify Rule 3 to let transactions
 release shared locks to get exclusive locks in the locking phase.
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
More types of locks
\end_layout

\begin_layout Subsubsection
Increment lock
\end_layout

\begin_layout Standard
We can define a new action, which is an 
\series bold
atomic increment action
\series default
, as
\begin_inset Formula 
\[
IN_{i}\left(A,k\right)\equiv\left\{ Read\left(A\right);A\leftarrow A+k;Write\left(A\right)\right\} .
\]

\end_inset

 A property of these actions is that they are commutative, so they do not
 conflict between each other, even though they involve writing the objects.
 This allows for more flexibility, because we can define a new lock, the
 
\series bold
increment lock
\series default
:
\end_layout

\begin_layout Itemize
INCREMENT-LOCK(A), 
\begin_inset Formula $il_{i}\left(A\right)$
\end_inset

: lock object 
\begin_inset Formula $A$
\end_inset

 to perform increment actions on it.
\end_layout

\begin_layout Standard
And we have to, again, redefine the rules:
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition

\series bold
Rule 1:
\series default
 a transaction is 
\series bold
well-formed
\series default
 if:
\end_layout

\begin_deeper
\begin_layout Itemize
Before performing a read action on an object, it has been previously locked,
 exclusively or shared (but better if it is shared locked, allowing for
 increased performance).
\end_layout

\begin_layout Itemize
Before performing a write action on an object, it has been previously exclusivel
y locked.
\end_layout

\begin_layout Itemize
Before performing an increment action on an object, it has been previously
 increment-locked.
\end_layout

\end_deeper
\begin_layout Definition

\series bold
Rule 2:
\series default
 a schedule is 
\series bold
legal
\series default
 if:
\end_layout

\begin_deeper
\begin_layout Itemize
No exclusive lock is performed on a locked (exclusive, increase or shared)
 object, until it has been unlocked.
\end_layout

\begin_layout Itemize
No lock (exclusive, increase or shared) is performed on a exclusively locked
 object, until it has been unlocked.
\end_layout

\begin_layout Itemize
An increase lock can only be performed on unlocked objects or increase-locked
 objects.
\end_layout

\end_deeper
\begin_layout Definition
This rule can be summarize in a 
\series bold
compatibility matrix
\series default
, which shows which state changes are allowed:
\end_layout

\begin_layout Definition
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $T_{j}$
\end_inset

 asks for
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="3" alignment="center" valignment="middle" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $T_{i}$
\end_inset

 holds
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
S
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
I
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
S
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
True
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
False
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
False
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
False
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
False
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
False
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
I
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
False
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
False
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
True
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Definition

\series bold
Rule 3:
\series default
 a schedule respect the 
\series bold
2PL protocol
\series default
 if for any two-phase locked transaction 
\begin_inset Formula $T_{i}$
\end_inset

, no action 
\begin_inset Formula $xl_{i}\left(A\right)$
\end_inset

, 
\begin_inset Formula $sl_{i}\left(A\right)$
\end_inset

 or 
\begin_inset Formula $il_{i}\left(A\right)$
\end_inset

 is preceded by an action 
\begin_inset Formula $u_{i}\left(B\right)$
\end_inset

 for any object 
\begin_inset Formula $B$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Update lock
\end_layout

\begin_layout Standard
A common deadlock problem that arises when we use upgrading shared locks
 is depicted below:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $sl_{1}\left(A\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $sl_{2}\left(A\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color red
\begin_inset Formula $lx_{1}\left(A\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color red
\begin_inset Formula $lx_{2}\left(A\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
In this case, both transactions are waiting for the other to release the
 object 
\begin_inset Formula $A$
\end_inset

 to be able to lock it exclusively, so there is a deadlock.
\end_layout

\begin_layout Standard
The 
\series bold
solution
\series default
 implies decreasing the level of concurrency, but it is worthy to avoid
 such problematic cases.
 We define a new lock, in which a transaction which is unsure about if it
 will need to write an object, it acquire an 
\series bold
update lock
\series default
 instead of the shared lock, and upgrades can only be made from this lock:
\end_layout

\begin_layout Itemize
UPDATE-LOCK(A), 
\begin_inset Formula $ul_{i}\left(A\right)$
\end_inset

: lock object 
\begin_inset Formula $A$
\end_inset

 and might upgrade later.
\end_layout

\begin_layout Standard
Note that if an object is shared-locked, it can be update-locked, but not
 the other way round (if we allow this, the behavior would not change).
\end_layout

\begin_layout Standard
Let's redefine our three rules for this case:
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition

\series bold
Rule 1:
\series default
 a transaction is 
\series bold
well-formed
\series default
 if:
\end_layout

\begin_deeper
\begin_layout Itemize
Before performing a read action on an object, it has been previously locked,
 exclusively, update or shared (but better if it is shared locked, allowing
 for increased performance).
\end_layout

\begin_layout Itemize
Before performing a write action on an object, it has been previously exclusivel
y locked.
\end_layout

\begin_layout Itemize
Before upgrading a lock, it has been previously update-locked.
\end_layout

\end_deeper
\begin_layout Definition

\series bold
Rule 2:
\series default
 a schedule is 
\series bold
legal
\series default
 if:
\end_layout

\begin_deeper
\begin_layout Itemize
No exclusive lock is performed on a locked (exclusive, update or shared)
 object, until it has been unlocked.
\end_layout

\begin_layout Itemize
No lock (exclusive, update or shared) is performed on a exclusively locked
 object, until it has been unlocked.
\end_layout

\begin_layout Itemize
An update lock can only be performed on unlocked objects or shared-locked
 objects.
\end_layout

\end_deeper
\begin_layout Definition
This rule can be summarize in a 
\series bold
compatibility matrix
\series default
, which shows which state changes are allowed:
\end_layout

\begin_layout Definition
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $T_{j}$
\end_inset

 asks for
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="3" alignment="center" valignment="middle" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $T_{i}$
\end_inset

 holds
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
S
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
U
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
S
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
True
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
False
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
True
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
False
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
False
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
False
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
U
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
False
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
False
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
False
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Definition
Note that in this case, an object can be locked in several modes (for instance,
 it can be locked in shared and update mode at the same time), so transitions
 are based on the most restrictive lock mode.
\end_layout

\begin_layout Definition

\series bold
Rule 3:
\series default
 a schedule respect the 
\series bold
2PL protocol
\series default
 if for any two-phase locked transaction 
\begin_inset Formula $T_{i}$
\end_inset

, no action 
\begin_inset Formula $xl_{i}\left(A\right)$
\end_inset

 or 
\begin_inset Formula $sl_{i}\left(A\right)$
\end_inset

 is preceded by an action 
\begin_inset Formula $u_{i}\left(B\right)$
\end_inset

 for any object 
\begin_inset Formula $B$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Lock granularity
\end_layout

\begin_layout Standard
We have been talking about locking objects, but we have not specified which
 are these objects.
 They can be tuples, pages, relations,...
 In all cases the scheme works, but choosing the appropriate size for what
 we are locking is obviously going to affect performance.
 For instance:
\end_layout

\begin_layout Itemize
If we lock at tuple level, we gain in concurrency capabilities, but we will
 need to increase the efforts to control the concurrent access.
 For example, the memory needed to store all locks would increase.
\end_layout

\begin_layout Itemize
If we lock at relation level, it is easier to address the concurrency issues,
 but we lose many concurrency capabilities because as soon as some transaction
 is trying to modify one tuple of one relation, the whole relation would
 be inaccessible for other transactions.
\end_layout

\begin_layout Standard
We can define 
\series bold
multi-granular locks
\series default
, which can specify at what level they want to lock the objects involved.
\end_layout

\begin_layout Standard
For this, we define 
\series bold
intentional locks
\series default
, which can be of any of the types we have seen, but with a slightly different
 meaning:
\end_layout

\begin_layout Itemize
An intentional lock on an object, 
\begin_inset Formula $A$
\end_inset

, is trying to obtain a lock on a subobject, 
\begin_inset Formula $A_{s}$
\end_inset

.
\end_layout

\begin_layout Itemize
Intentional locks indicate the type of the lock of the subobjects.
\end_layout

\begin_layout Example
Imagine we have the relation 
\begin_inset Formula $R_{1}$
\end_inset

 which has four tuples.
 If transaction 1, 
\begin_inset Formula $T_{1}$
\end_inset

, wants to shared-lock the second tuple, 
\begin_inset Formula $t_{2}$
\end_inset

, we need to obtain an intentional shared-lock on 
\begin_inset Formula $R_{1}$
\end_inset

 and then a shared-lock on 
\begin_inset Formula $t_{2}$
\end_inset

.
 This is depicted below:
\end_layout

\begin_layout Example
\begin_inset Graphics
	filename intentional_locks_0.png
	scale 60

\end_inset


\end_layout

\begin_layout Example
Now, imagine 
\begin_inset Formula $T_{2}$
\end_inset

 wants a shared-lock in the whole relation, then, it will can be acquired,
 because the compatibility matrix allows it.
 But it wanted an exclusive-lock in the whole relation, it would need to
 wait until the locked tuple is unlocked.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Example
Another example is starting with the previous one:
\end_layout

\begin_layout Example
\begin_inset Graphics
	filename intentional_locks_0.png
	scale 60

\end_inset


\end_layout

\begin_layout Example
Now, imagine 
\begin_inset Formula $T_{2}$
\end_inset

 wants to exclusively lock 
\begin_inset Formula $t_{4}$
\end_inset

: this can be done, because 
\begin_inset Formula $t_{4}$
\end_inset

 is unlocked.
 In this case, 
\begin_inset Formula $T_{2}$
\end_inset

 needs to ask for an intentional exclusive lock on 
\begin_inset Formula $R_{1}$
\end_inset

, which would be granted because the relation 
\begin_inset Formula $R_{1}$
\end_inset

 is not fully locked.
 Then at tuple level, 
\begin_inset Formula $T_{2}$
\end_inset

 would ask for an exclusive lock for 
\begin_inset Formula $t_{4}$
\end_inset

, an it would be granted because it is unlocked:
\end_layout

\begin_layout Example
\begin_inset Graphics
	filename intentional_locks_1.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
Again, we can build the compatibility matrix for this new kind of locks:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="7">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $T_{j}$
\end_inset

 asks for
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="3" alignment="center" valignment="middle" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $T_{i}$
\end_inset

 holds
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
IS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
IX
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
S
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SIX
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
IS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
True
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
True
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
True
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
True
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
False
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
IX
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
True
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
True
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
False
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
False
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
False
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
S
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
True
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
False
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
True
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
False
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
False
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SIX
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
True
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
False
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
False
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
False
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
False
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
False
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
False
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
False
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
False
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
False
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Itemize
IS, intentional shared lock: lock some subobjects in share mode.
\end_layout

\begin_layout Itemize
IX, intentional exclusive lock: lock some subobjects in exclusive mode.
\end_layout

\begin_layout Itemize
S, shared lock: lock an object in shared mode.
\end_layout

\begin_layout Itemize
SIX, shared intentional exclusive lock: lock an object in shared mode and
 some subobjects in exclusive mode.
\end_layout

\begin_layout Itemize
X, exclusive lock: lock an object in exclusive mode.
\end_layout

\begin_layout Standard
Also, there are restrictions in which states can subobjects have in terms
 of the states of the parent object:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Parent state
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Child possible states
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
IS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
IS,S
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
IX
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
IS,S,IX,X,SIX
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
S
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
none
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SIX
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X,IX
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
none
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
The rules to follow are the following:
\end_layout

\begin_layout Enumerate
Follow the multiple granularity compatibility matrix.
\end_layout

\begin_layout Enumerate
Lock root of tree first.
\end_layout

\begin_layout Enumerate
Node 
\begin_inset Formula $Q$
\end_inset

 can be locked by 
\begin_inset Formula $T_{i}$
\end_inset

 in S or IS only if 
\begin_inset Formula $parent\left(Q\right)$
\end_inset

 is locked by 
\begin_inset Formula $T_{i}$
\end_inset

 in IX or IS.
\end_layout

\begin_layout Enumerate
Node 
\begin_inset Formula $Q$
\end_inset

 can be locked by 
\begin_inset Formula $T_{i}$
\end_inset

 in X,SIX,IX only if 
\begin_inset Formula $parent\left(Q\right)$
\end_inset

 is locked by 
\begin_inset Formula $T_{i}$
\end_inset

 in IX,SIX.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $T_{i}$
\end_inset

 is two-phase.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $T_{i}$
\end_inset

 can unlock node 
\begin_inset Formula $Q$
\end_inset

 only if none of 
\begin_inset Formula $Q$
\end_inset

's children are locked by 
\begin_inset Formula $T_{i}$
\end_inset

.
\end_layout

\begin_layout Example
Let's do some practice.
\end_layout

\begin_layout Example

\series bold
1) 
\series default
Start with this setup:
\end_layout

\begin_layout Example
\begin_inset Graphics
	filename intentional_locks_2.png
	scale 40

\end_inset


\end_layout

\begin_layout Example
Can 
\begin_inset Formula $T_{2}$
\end_inset

 access object 
\begin_inset Formula $f_{22}$
\end_inset

 in mode X? If so, what locks would 
\begin_inset Formula $T_{2}$
\end_inset

 get?
\end_layout

\begin_layout Example
Yes, it can, because all the locks in the sequence are compatible with another
 IX lock and 
\begin_inset Formula $f_{2,2}$
\end_inset

 is unlocked:
\end_layout

\begin_layout Example
\begin_inset Graphics
	filename intentional_locks_3.png
	scale 40

\end_inset


\end_layout

\begin_layout Example

\series bold
2) 
\series default
Start with this setup:
\end_layout

\begin_layout Example
\begin_inset Graphics
	filename intentional_locks_4.png
	scale 40

\end_inset


\end_layout

\begin_layout Example
Can 
\begin_inset Formula $T_{2}$
\end_inset

 access object 
\begin_inset Formula $f_{22}$
\end_inset

 in mode X? If so, what locks would 
\begin_inset Formula $T_{2}$
\end_inset

 get?
\end_layout

\begin_layout Example
No, it cannot, because parent 
\begin_inset Formula $t_{2}$
\end_inset

 is in X mode, so it cannot be locked in IX mode by 
\begin_inset Formula $T_{2}$
\end_inset

.
\end_layout

\begin_layout Example

\series bold
3)
\series default
 From the last setup: can 
\begin_inset Formula $T_{2}$
\end_inset

 access object 
\begin_inset Formula $f_{3,1}$
\end_inset

 in X mode? What locks would 
\begin_inset Formula $T_{2}$
\end_inset

 get?
\end_layout

\begin_layout Example
Yes, it can, because 
\begin_inset Formula $f_{3,1}$
\end_inset

 is unlocked, its parent 
\begin_inset Formula $t_{3}$
\end_inset

 is unlocked, and its parent is in IX state, compatible with another IX
 state:
\end_layout

\begin_layout Example
\begin_inset Graphics
	filename intentional_locks_5.png
	scale 40

\end_inset


\end_layout

\begin_layout Example

\series bold
4)
\series default
 Start with this setup:
\end_layout

\begin_layout Example
\begin_inset Graphics
	filename intentional_locks_6.png
	scale 40

\end_inset


\end_layout

\begin_layout Example
Can 
\begin_inset Formula $T_{2}$
\end_inset

 access object 
\begin_inset Formula $f_{2,2}$
\end_inset

 in S mode? What locks would 
\begin_inset Formula $T_{2}$
\end_inset

 get?
\end_layout

\begin_layout Example
Yes, because SIX and IX and compatible with IS:
\end_layout

\begin_layout Example
\begin_inset Graphics
	filename intentional_locks_7.png
	scale 40

\end_inset


\end_layout

\begin_layout Example

\series bold
5)
\series default
 In the previous setup: can 
\begin_inset Formula $T_{2}$
\end_inset

 access object 
\begin_inset Formula $f_{2,2}$
\end_inset

 in X mode? What locks would 
\begin_inset Formula $T_{2}$
\end_inset

 get?
\end_layout

\begin_layout Example
No, because SIX is not compatible with IX.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Distributed Databases
\end_layout

\begin_layout Section
Distributed databases
\end_layout

\begin_layout Standard
Distributed database management systems distribute and replicate data over
 multiple machines to try to meet the availability, durability, performance,
 regulatory amd scale requirements of large organizations, subject to physics.
\end_layout

\begin_layout Standard
A distributed database does two things:
\end_layout

\begin_layout Itemize

\series bold
Distribution
\series default
: place partitions of data on different machines.
\end_layout

\begin_layout Itemize

\series bold
Replication
\series default
: place copies of data on different machines.
\end_layout

\begin_layout Standard
The 
\series bold
goal
\series default
 is to offer the same functionality and transactional semantics as a RDBMS
 with distributed features.
\end_layout

\begin_layout Standard
The 
\series bold
reality
\series default
 is that there need to be done concessions in terms of functionality, transactio
nal semantics and performance.
\end_layout

\begin_layout Standard
There are three main challenges in distributed databases, which are how
 to distribute the data, how to access the data and how to perform distributed
 transactions.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
A 
\series bold
shard
\series default
 is a horizontal partition of data in a database.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Data distribution
\end_layout

\begin_layout Standard
There are several ways to distribute the data:
\end_layout

\begin_layout Itemize

\series bold
Range distribution
\series default
: tables are partitioned by a 
\emph on
distribution key
\emph default
, which is usualy part of a primary key.
 Each shard contains a range of the values.
\end_layout

\begin_deeper
\begin_layout Example
Imagine a CUSTOMER table that is distributed in two servers: in one server
 we maintain all names starting by a letter in the range A-N and in the
 other server all starting with a letter in the range M-Z.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Hash distribution
\series default
: there two ways to implement this:
\end_layout

\begin_deeper
\begin_layout Itemize
Each shard contains a modulo of a hash value.
 
\end_layout

\begin_layout Itemize
Each shard contains a range of hash values.
\end_layout

\end_deeper
\begin_layout Standard
In the context of data distribution, it is usually desirable to maintain
 approximately the same amount of data in each node.
 To achieve this, 
\series bold
rebalancing
\series default
 is used.
 Rebalancing encompasses:
\end_layout

\begin_layout Itemize
Moving shards to achieve better data distribution across nodes.
\end_layout

\begin_layout Itemize
Splitting shards to achieve better data distributions across nodes.
\end_layout

\begin_layout Standard
Another important concept is that of 
\series bold
co-location
\series default
, which makes use of the fact that some tables share some attributes.
 If a shared attribute is related to the distribution key, then we can store
 different tables in a distributed manner, in such a way that if we perform
 a join between these tables using this attribute, we minimize the interaction
 between tables from different nodes.
 
\end_layout

\begin_layout Standard
Other times, for the same purpose of increasing the efficiency of distributed
 joins it is useful to replicate small tables to enable fast joins, foreign
 keys and other operations.
 This technique is called 
\series bold
reference tables
\series default
.
\end_layout

\begin_layout Standard
There are more ways to tackle data distribution:
\end_layout

\begin_layout Itemize
Use random distributions to distribute the data.
\end_layout

\begin_layout Itemize
Use list distribution, assigning labels to the different partitions.
\end_layout

\begin_layout Itemize
Use spatial distribution, locating data in the servers where it will be
 of use.
\end_layout

\begin_layout Subsection
Distributed data access: distributed SQL
\end_layout

\begin_layout Standard
To scale query throughput linearly with the number of nodes, queries should
 only access one node.
 The techniques of co-location and reference table enable relatively complex
 queries.
 This idea of using the nodes information inside the queries to only access
 the desired nodes is called 
\series bold
routing queries
\series default
.
\end_layout

\begin_layout Example
A routing query trying to access only the node where the distribution key
 is 36:
\end_layout

\begin_layout Example
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

INSERT INTO dist1(dist_key,value) VALUES(36, 11);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

SELECT *
\end_layout

\begin_layout Plain Layout

FROM dist1
\end_layout

\begin_layout Plain Layout

WHERE dist_key=36 AND value<11;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

UPDATE dist1
\end_layout

\begin_layout Plain Layout

SET value=3
\end_layout

\begin_layout Plain Layout

WHERE dist_key=36 AND value<11;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nonetheless, the relational algebra can be extended to work in distributed
 system: it is called the 
\series bold
multi-relational algebra
\series default
, and it adds to the usual relational algebra the operations
\begin_inset Foot
status open

\begin_layout Plain Layout
The definitions have been taken from 
\begin_inset CommandInset href
LatexCommand href
name "MSQLS Docs"
target "https://learn.microsoft.com/en-us/sql/relational-databases/showplan-logical-and-physical-operators-reference?view=sql-server-ver16"
literal "false"

\end_inset

, but the names are different.
\end_layout

\end_inset

:
\end_layout

\begin_layout Itemize
COLLECT: takes data from several nodes and single output data stream combining
 all of them.
\end_layout

\begin_layout Itemize
REPARTITION: takes data from some nodes and sends it to other nodes.
\end_layout

\begin_layout Itemize
BROADCAST: sends its input rows to multiple consumers on demand.
 Each consumer gets all of the rows.
\end_layout

\begin_layout Standard
As in standard SQL, in distributed SQL it is needed to perform logical planning
 of the queries before executing them, with the need that the final result
 is the same as it would be if all data were in one node.
\end_layout

\begin_layout Example
Imagine we want to compute the mean of an attribute in a table which is
 distributed in different nodes.
 The steps to follow would be:
\end_layout

\begin_layout Enumerate
In each node: SUM(A) and COUNT(A)
\end_layout

\begin_layout Enumerate
In requesting node:
\end_layout

\begin_deeper
\begin_layout Enumerate
COLLECT all data: sum_ = SUM(SUM(N->T.A), N in Nodes), count_ = SUM(COUNT(N->T.A),
 N in Nodes)
\end_layout

\begin_layout Enumerate
mean = sum_ / count_
\end_layout

\end_deeper
\begin_layout Standard
Also, different plans can be defined and the best one should be chosen following
 some optimization criteria.
\end_layout

\begin_layout Subsubsection*
Co-located joins
\end_layout

\begin_layout Standard
Imagine we have the query:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT dist1.dist_key, count(*)
\end_layout

\begin_layout Plain Layout

FROM dist1 
\end_layout

\begin_layout Plain Layout

JOIN dist2 ON (dist1.dist_key = dist1.dist_key)
\end_layout

\begin_layout Plain Layout

WHERE dist2.value < 44
\end_layout

\begin_layout Plain Layout

GROUP BY dist1.
 dist_key;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
One way to do this is:
\end_layout

\begin_layout Enumerate
In each node: 
\end_layout

\begin_deeper
\begin_layout Enumerate
Scan dist1
\end_layout

\begin_layout Enumerate
Scan dist2 and filter dist2.value < 44
\end_layout

\end_deeper
\begin_layout Enumerate
In requesting node:
\end_layout

\begin_deeper
\begin_layout Enumerate
Collect all dist1
\end_layout

\begin_layout Enumerate
Collect all filtered dist2
\end_layout

\begin_layout Enumerate
Perform the join
\end_layout

\begin_layout Enumerate
Aggregate
\end_layout

\end_deeper
\begin_layout Standard
But as we are using the distribution key for joining, we know that the tables
 that will join are stored together, so we can make use of the co-location
 by changing the plan to:
\end_layout

\begin_layout Enumerate
In each node:
\end_layout

\begin_deeper
\begin_layout Enumerate
Scan dist1
\end_layout

\begin_layout Enumerate
Scan dist2 and filter dist2.value < 44
\end_layout

\begin_layout Enumerate
Perform the join
\end_layout

\begin_layout Enumerate
Aggregate
\end_layout

\end_deeper
\begin_layout Enumerate
In requesting node:
\end_layout

\begin_deeper
\begin_layout Enumerate
Collect the values
\end_layout

\end_deeper
\begin_layout Standard
For this changes to work, we are using that: filter is commutative with
 collect, group by dist_key is commutative with collect and join is co-located,
 so it is commutative with collect.
\end_layout

\begin_layout Standard
When we do this, we are working with much smaller tables, thus reducing
 the response time.
\end_layout

\begin_layout Subsubsection*
Re-partition joins
\end_layout

\begin_layout Standard
Now imagine the query:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT dist1.dist_key, count(*)
\end_layout

\begin_layout Plain Layout

FROM dist1 
\end_layout

\begin_layout Plain Layout

JOIN dist2 ON (dist1.dist_key = dist2.other_key
\end_layout

\begin_layout Plain Layout

WHERE dist2.value < 44
\end_layout

\begin_layout Plain Layout

GROUP BY dist1.dist_key;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this case, the initial plan also work, but again we can do better repartition
ing the dist2 tables to the nodes where they will be needed.
 This might seem like too heavy work to do, but if the tables are large
 enough, the whole relations might not even fit in only one node, so this
 can be the only way to be able to produce the response.
 The alternative plan is:
\end_layout

\begin_layout Enumerate
In each node:
\end_layout

\begin_deeper
\begin_layout Enumerate
Scan dist2
\end_layout

\begin_layout Enumerate
Filter dist2.value < 44
\end_layout

\end_deeper
\begin_layout Enumerate
In each node:
\end_layout

\begin_deeper
\begin_layout Enumerate
Repartition filtered tuples from dist2 with corresponding other_key to dist_key
 of this node
\end_layout

\begin_layout Enumerate
Scan dist1
\end_layout

\begin_layout Enumerate
Perform the join
\end_layout

\begin_layout Enumerate
Aggregate
\end_layout

\end_deeper
\begin_layout Enumerate
In requesting node:
\end_layout

\begin_deeper
\begin_layout Enumerate
Collect the values
\end_layout

\end_deeper
\begin_layout Subsubsection*
Broadcast joins
\end_layout

\begin_layout Standard
Now, imagine the query:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

WITH top10 AS (
\end_layout

\begin_layout Plain Layout

	SELECT dist_key, count(*)
\end_layout

\begin_layout Plain Layout

	FROM dist1 
\end_layout

\begin_layout Plain Layout

	GROUP BY 1 
\end_layout

\begin_layout Plain Layout

	ORDER BY 2
\end_layout

\begin_layout Plain Layout

	LIMIT 10
\end_layout

\begin_layout Plain Layout

	)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

SELECT *
\end_layout

\begin_layout Plain Layout

FROM dist2
\end_layout

\begin_layout Plain Layout

WHERE other_key IN (SELECT dist_key FROM top10);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The naïve plan is:
\end_layout

\begin_layout Enumerate
In each node:
\end_layout

\begin_deeper
\begin_layout Enumerate
Scan dist1
\end_layout

\begin_layout Enumerate
Scan dist2
\end_layout

\end_deeper
\begin_layout Enumerate
In requesting node
\end_layout

\begin_deeper
\begin_layout Enumerate
Collect dist1
\end_layout

\begin_layout Enumerate
Aggregate dist1
\end_layout

\begin_layout Enumerate
Sort/limit dist1
\end_layout

\begin_layout Enumerate
Collect dist2
\end_layout

\begin_layout Enumerate
Perform the join
\end_layout

\end_deeper
\begin_layout Standard
But this can be improved by creating a subplan that handles order/limit
 under join and broadcasting the subplan to pull the collect above the join.
 The idea is that TOP10 among all the data is the same that the TOP10 among
 all the TOP10s in each node:
\end_layout

\begin_layout Enumerate
In each node:
\end_layout

\begin_deeper
\begin_layout Enumerate
Scan dist1
\end_layout

\begin_layout Enumerate
Preaggregate: get TOP10 of the node
\end_layout

\end_deeper
\begin_layout Enumerate
In requesting node:
\end_layout

\begin_deeper
\begin_layout Enumerate
Collect TOP10 of each node
\end_layout

\begin_layout Enumerate
Merge all TOP10
\end_layout

\begin_layout Enumerate
Sort/limit and get final TOP10
\end_layout

\begin_layout Enumerate
Broadcast this TOP10 to all nodes
\end_layout

\end_deeper
\begin_layout Enumerate
In each node:
\end_layout

\begin_deeper
\begin_layout Enumerate
Scan dist2
\end_layout

\begin_layout Enumerate
Join dist2 with broadcasted TOP10
\end_layout

\end_deeper
\begin_layout Enumerate
In requesting node:
\end_layout

\begin_deeper
\begin_layout Enumerate
Collect the values
\end_layout

\end_deeper
\begin_layout Subsubsection*
Observations
\end_layout

\begin_layout Standard
As we have seen, the query plans depend heavily on the distribution key.
\end_layout

\begin_layout Standard
Runtime also depends on the query, data, the data size, network speed,...
\end_layout

\begin_layout Standard
This menas distributed databases require adjusting the distribution keys
 and queries to each other to achieve high performance.
\end_layout

\begin_layout Subsection
Distributed transactions
\end_layout

\begin_layout Standard
Ideally, we have ACID transactions: Atomicity, Consistency, Isolation and
 Durability.
\end_layout

\begin_layout Standard
The main distribution challenges are:
\end_layout

\begin_layout Itemize
Atomicity: commit on all nodes or none of them.
\end_layout

\begin_layout Itemize
Isolation: see other distributed transactions as commited/aborted
\end_layout

\begin_layout Standard
Additionally, it is important to have a mechanism for distributed deadlock
 detection.
\end_layout

\begin_layout Subsubsection
Atomicity
\end_layout

\begin_layout Standard
Atomicity is achieved through 2PC (2-Phase Commit):
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
Phase 1:
\end_layout

\end_inset

 Store transactions on all nodes
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
Phase 2:
\end_layout

\end_inset

 Store final commit decision and
\end_layout

\begin_deeper
\begin_layout Enumerate
If success: commit all stored transactions
\end_layout

\begin_layout Enumerate
If error: abort all prepared transactions
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
Secret phase 3 (Recovery phase):
\end_layout

\end_inset

 Commit/abort prepared transactions after system failure
\end_layout

\begin_layout Subsubsection
Isolation
\end_layout

\begin_layout Standard
If we query different nodes at different times, we may see a concurrent
 transaction as commited on one node, but not yet committed on another one.
\end_layout

\begin_layout Standard

\series bold
Distributed snapshot isolation
\series default
 means we have the same view of what is commited and what not on all nodes.
\end_layout

\begin_layout Standard
We must also ensure 
\series bold
consistency
\series default
: any preceding write is seen as committed.
\end_layout

\begin_layout Standard
A common approach is to add a timestamp to each query, so queries see all
 commits with lower timestamps.
\end_layout

\begin_layout Standard
There are different ways of dealing with clock synchronization:
\end_layout

\begin_layout Itemize

\series bold
TrueTime
\series default
: synchronize clocks using GPS/atomic clocks.
 Commits pause until all clock move past commit time.
\end_layout

\begin_layout Itemize

\series bold
Clock-SI
\series default
: queries collect current time from all nodes involved, pick the highest
 timestamp and wait for it to pass.
\end_layout

\begin_layout Itemize

\series bold
HLC (Hybrid Logical Clocks)
\series default
: they are increased whenever an event occurs or a message from another
 node is received with a higher timestamp.
\end_layout

\begin_layout Subsubsection
Considerations
\end_layout

\begin_layout Standard
Fully resolving a 2PC might take time in case of system failure.
\end_layout

\begin_layout Standard
Distributed deadlock detection is essential to stability, but not always
 implemented.
\end_layout

\begin_layout Standard
Snapshot isolation avoids seeing partially committed transactions, but at
 a cost, and read-your-writes consistency can be at risk.
\end_layout

\begin_layout Subsection
Replication
\end_layout

\begin_layout Standard
Replication means to store the same data in different nodes.
 It can be useful for:
\end_layout

\begin_layout Itemize
Availability: resume from replica in case of node failure.
\end_layout

\begin_layout Itemize
Durability: restore from replica in case of disk failure.
\end_layout

\begin_layout Itemize
Read throughput: divide reads across read replicas.
\end_layout

\begin_layout Itemize
Read latency: local/nearby replica gives lower read latency.
\end_layout

\begin_layout Itemize
Write latency: local/nearby replica gives lower write latency.
\end_layout

\begin_layout Subsubsection
Quorums
\end_layout

\begin_layout Standard
The basic idea is to read from R nodes and write to W nodes, where R+W>N,
 being N the total number of nodes.
\end_layout

\begin_layout Standard
The challenge is to apply events in the same order wverywhere.
\end_layout

\begin_layout Subsubsection
Follow the leader
\end_layout

\begin_layout Standard
We can also assign a temporary leader to serialize writes efficiently.
 This leader would then feed the rest of the nodes with the new data.
\end_layout

\begin_layout Standard
If one node fails (
\series bold
standby fail
\series default
), the leader will continue writing to other replica.
\end_layout

\begin_layout Standard
If the leader fails (
\series bold
primary fail
\series default
), a failover is initiated, a replica is promoted to leader and the rest
 of the replicas follow the new leader.
\end_layout

\begin_layout Subsubsection
N-directional
\end_layout

\begin_layout Standard
All nodes accept writes and then decide how to reconcile conflicting changes.
\end_layout

\begin_layout Subsection
CAP theorem
\end_layout

\begin_layout Standard
Basically, the CAP theorem states that a database can only have two out
 of the three properties: 
\series bold
C
\series default
onsistency, 
\series bold
A
\series default
vailability and 
\series bold
P
\series default
artitioning.
 In the case of distributed databases, partitioning is a must, so one must
 decide between C and A (note, nonetheless, that even though the theorem
 ensure that one cannot get the three properties in their most strict form,
 it is possible to have them in relaxed, yet good, ways).
 So, basically, according to this theorem, we need to decide between:
\end_layout

\begin_layout Itemize
Availability (AP): keep writing to a minority of nodes, and the majority
 does not see it.
\end_layout

\begin_layout Itemize
Consistency (CP): make writes/reads temporary unavailable because consistency
 must be preserved.
\end_layout

\begin_layout Standard
But this is an incomplete picture of the trade-offs that appear in a distributed
 database.
\end_layout

\begin_layout Subsection
PACELC theorem
\end_layout

\begin_layout Standard
This is an improved version of the CAP theorem, but is still oversimplified:
\end_layout

\begin_layout Itemize
If network 
\series bold
P
\series default
artition: choose 
\series bold
A
\series default
vailability or 
\series bold
C
\series default
onsistency.
\end_layout

\begin_layout Itemize

\series bold
E
\series default
lse: choose 
\series bold
L
\series default
atency or 
\series bold
C
\series default
onsistency.
\end_layout

\begin_layout Subsection
More trade-offs
\end_layout

\begin_layout Itemize
Consistency: read-your-writes, no lost updates, linearizability
\end_layout

\begin_layout Itemize
Availability: for reads, for writes, handle availability zone failure
\end_layout

\begin_layout Itemize
Partition-tolerance: for reads, for writes.
\end_layout

\begin_layout Itemize
Durability: node failure does not result in data loss, writes are archived
 in a timely manner.
\end_layout

\begin_layout Itemize
Low latency: low read latency, low write latency, global latency VS local
 latency.
\end_layout

\begin_layout Itemize
Complexity: dependencies on other systems, multiple node types, optimizations.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintCited"
bibfiles "dbsa_bib"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
