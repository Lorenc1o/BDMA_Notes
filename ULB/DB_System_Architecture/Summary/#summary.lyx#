#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage[all]{xy}
\end_preamble
\use_default_options true
\begin_modules
tcolorbox
customHeadersFooters
theorems-ams-bytype
theorems-sec-bytype
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=blue, urlcolor=blue, citecolor=blue, pdfstartview={FitH}, unicode=true"
\papersize a4paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\boxbgcolor #62a0ea
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 3cm
\rightmargin 2cm
\bottommargin 3cm
\headheight 2cm
\headsep 1cm
\footskip 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
INFOH417 - Database Systems Architecture
\end_layout

\begin_layout Date
Fall 2022
\end_layout

\begin_layout Author
Jose Antonio Lorencio Abril
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename ../../Data_Mining/Summary/1200px-Université_libre_de_Bruxelles_(logo).svg.png
	scale 10

\end_inset


\end_layout

\begin_layout Standard
\align right
Professor: Mahmoud Sakr
\end_layout

\begin_layout Standard
\align right
Student e-mail: jose.lorencio.abril@ulb.be
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Address
This is a summary of the course 
\emph on
Database Systems Architecture
\emph default
, taught at the Université Libre de Bruxelles by Professor Mahmoud Sakr
 in the academic year 22/23.
 Most of the content of this document is adapted from the course notes by
 Sakr, 
\begin_inset CommandInset citation
LatexCommand cite
key "Sakr2022"
literal "false"

\end_inset

, so I won't be citing it all the time.
 Other references will be provided when used.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList table

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList algorithm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Query Planning: Translating SQL into Relational Algebra
\end_layout

\begin_layout Section
Relational Algebra
\end_layout

\begin_layout Standard
We are going to start with some definitions:
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
A 
\series bold
relation
\series default
 is a table whose columns have names, called 
\series bold
attributes
\series default
.
 The set of all attributes is called the 
\series bold
schema of the relation
\series default
.
 The rows of the table are tuples of values for each of the attributes,
 and are called simply 
\series bold
tuples
\series default
.
 We are going to denote 
\begin_inset Formula $R$
\end_inset

 a relation, and we will express it as 
\begin_inset Formula $R\sim\left[A_{1},...,A_{n}\right]$
\end_inset

 to indicate the schema of the relation, 
\begin_inset Formula $A_{i},i=1,...,n$
\end_inset

 are the attributes of the schema.
 If two relations, 
\begin_inset Formula $R$
\end_inset

 and 
\begin_inset Formula $R'$
\end_inset

, share the same schema, we will simply write 
\begin_inset Formula $R\simeq R'$
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
Note that the relationship 
\begin_inset Formula $\simeq$
\end_inset

 defines an equivalence relationship whose equivalence groups are all relations
 with the same schema.
\end_layout

\end_inset

.
\end_layout

\begin_layout Definition
A relation is 
\series bold
set-based
\series default
 if there are no duplicate tuples in it.
 If this is not the case, the relation is 
\series bold
bag-based
\series default
.
\end_layout

\begin_layout Definition
A 
\series bold
relational algebra operator
\series default
 takes as input 1 or more relations and produces as output a new relation.
 More formally, if we have a set of relations 
\begin_inset Formula $\Sigma=\left\{ R_{1},...,R_{n}\right\} \subset\mathcal{U}$
\end_inset

, where 
\begin_inset Formula $\mathcal{U}$
\end_inset

 identifies the set of all possible relations, a relational algebra operator
 is a function
\begin_inset Formula 
\[
Op:\mathcal{P}\left(\Sigma\right)\rightarrow\mathcal{U},
\]

\end_inset

 being 
\begin_inset Formula $\mathcal{P}\left(\Sigma\right)$
\end_inset

 the power set of 
\begin_inset Formula $\Sigma$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Example
\begin_inset CommandInset label
LatexCommand label
name "ex:1-1"

\end_inset

As an example, we can take 
\begin_inset Formula $\Sigma=\left\{ StarsIn,MovieStar\right\} $
\end_inset

, 
\begin_inset Formula $StartsIn=\left[starName,filmName\right]$
\end_inset

, 
\begin_inset Formula $MovieStar=\left[name,birthDate\right]$
\end_inset

.
 In this case, an operator 
\begin_inset Formula $Op$
\end_inset

 could be such that produces the relation that contains all names of films
 in which some movie stars in 
\begin_inset Formula $MovieStar$
\end_inset

 born in 1960 participated.
\end_layout

\begin_layout Standard
In this example, we have explained what we would like our operator to do,
 but we need some way to actually compute this.
 For this, there are some basic operators that can be combined to create
 complex operators.
\end_layout

\begin_layout Subsection
The extended relational algebra
\end_layout

\begin_layout Standard
Let's define a set of operators that are useful:
\end_layout

\begin_layout Standard
The 
\series bold
union
\series default
 of two relations with the same schema returns another relation with the
 same schema and all tuples in any of the two input relations: Let 
\begin_inset Formula $R_{i},R_{j}\in\Sigma$
\end_inset

 such that 
\begin_inset Formula $R_{i}\simeq R_{j}$
\end_inset

, then
\begin_inset Formula 
\[
R_{i}\cup R_{j}=\left\{ x|x\in R_{i}\ \lor\ x\in R_{j}\right\} \simeq R_{i}\simeq R_{j}.
\]

\end_inset


\end_layout

\begin_layout Standard
Note, nonetheless, that the result of the operator 
\begin_inset Formula $\cup$
\end_inset

 is different in set-based relations than in bag-based relations.
\end_layout

\begin_layout Example
An example of the operator 
\begin_inset Formula $\cup$
\end_inset

:
\end_layout

\begin_layout Example
\begin_inset Formula 
\[
\left[\begin{array}{cc}
A & B\\
1 & 2\\
3 & 4\\
5 & 6
\end{array}\right]\bigcup\left[\begin{array}{cc}
A & B\\
3 & 4\\
1 & 5
\end{array}\right]=\left\{ \overset{set-based}{\left[\begin{array}{cc}
A & B\\
1 & 2\\
3 & 4\\
5 & 6\\
1 & 5
\end{array}\right]},\overset{bag-based}{\left[\begin{array}{cc}
A & B\\
1 & 2\\
3 & 4\\
5 & 6\\
1 & 5\\
3 & 4
\end{array}\right]}\right\} 
\]

\end_inset


\end_layout

\begin_layout Standard
The 
\series bold
intersection
\series default
 of two relations with the same schema returns another relation with the
 same schema and all tuples in both of the two input relations: Let 
\begin_inset Formula $R_{i},R_{j}\in\Sigma$
\end_inset

 such that 
\begin_inset Formula $R_{i}\simeq R_{j}$
\end_inset

, then
\begin_inset Formula 
\[
R_{i}\cap R_{j}=\left\{ x|x\in R_{i}\ \land\ x\in R_{j}\right\} \simeq R_{i}\simeq R_{j}.
\]

\end_inset


\end_layout

\begin_layout Example
An example of the operator 
\begin_inset Formula $\cap$
\end_inset

:
\begin_inset Formula 
\[
\left[\begin{array}{cc}
A & B\\
1 & 2\\
3 & 4\\
5 & 6
\end{array}\right]\bigcap\left[\begin{array}{cc}
A & B\\
3 & 4\\
1 & 5
\end{array}\right]=\left[\begin{array}{cc}
A & B\\
3 & 4
\end{array}\right].
\]

\end_inset


\end_layout

\begin_layout Standard
The 
\series bold
difference
\series default
 of two relations with the same schema returns another relation with the
 same schema and all tuples in the first input relations which don't appear
 in the second input relation: Let 
\begin_inset Formula $R_{i},R_{j}\in\Sigma$
\end_inset

 such that 
\begin_inset Formula $R_{i}\simeq R_{j}$
\end_inset

, then
\begin_inset Formula 
\[
R_{i}-R_{j}=\left\{ x|x\in R_{i}\ \land\ x\notin R_{j}\right\} \simeq R_{i}\simeq R_{j}.
\]

\end_inset


\end_layout

\begin_layout Example
An example of the operator 
\begin_inset Formula $-$
\end_inset

:
\begin_inset Formula 
\[
\left[\begin{array}{cc}
A & B\\
1 & 2\\
3 & 4\\
5 & 6
\end{array}\right]-\left[\begin{array}{cc}
A & B\\
3 & 4\\
1 & 5
\end{array}\right]=\left[\begin{array}{cc}
A & B\\
1 & 2\\
5 & 6
\end{array}\right].
\]

\end_inset


\end_layout

\begin_layout Standard
The 
\series bold
selection
\series default
 operator applies a condition on the values of the tuples of the input relation
 and returns only those tuples that fullfil the condition: Let 
\begin_inset Formula $R\in\Sigma$
\end_inset

 and 
\begin_inset Formula $P$
\end_inset

 a condition, then
\begin_inset Formula 
\[
\sigma_{P}\left(R\right)=\left\{ x|x\in R\ \land\ P\left(R\right)==true\right\} .
\]

\end_inset


\end_layout

\begin_layout Example
An example of the operator 
\begin_inset Formula $\sigma_{P}$
\end_inset

:
\begin_inset Formula 
\[
\sigma_{A\geq3}\left(\left[\begin{array}{cc}
A & B\\
1 & 2\\
3 & 4\\
5 & 6
\end{array}\right]\right)=\left[\begin{array}{cc}
A & B\\
3 & 4\\
5 & 6
\end{array}\right].
\]

\end_inset

 In this case, the condition 
\begin_inset Formula $P$
\end_inset

 is: '
\emph on
the value of 
\begin_inset Formula $A$
\end_inset

 is bigger than or equal than 3
\emph default
'.
\end_layout

\begin_layout Standard
The 
\series bold
projection
\series default
 operator returns all tuples of the input relation, but deleting all unspecified
 attributes: Let 
\begin_inset Formula $R\in\Sigma$
\end_inset

 and 
\begin_inset Formula $A_{j_{1}},...,A_{j_{k}}\in\left[A_{1},...,A_{n}\right]\sim R$
\end_inset

, then
\begin_inset Formula 
\[
\Pi_{A_{j_{1}},...,A_{j_{k}}}\left(R\right)=R_{\left[A_{j_{1}},...,A_{j_{k}}\right]}^{'}=\left\{ y|\exists x\in R\ s.t.\ x\left(A_{j_{1}},...,A_{j_{k}}\right)=y\right\} .
\]

\end_inset


\end_layout

\begin_layout Standard
The result of this operation also depends on the type of relations used.
\end_layout

\begin_layout Example
An example of the operator 
\begin_inset Formula $\Pi_{\left[A_{j_{1}},...,A_{j_{k}}\right]}$
\end_inset

:
\begin_inset Formula 
\[
\Pi_{A,C}\left(\left[\begin{array}{cccc}
A & B & C & D\\
1 & 2 & 3 & 5\\
3 & 4 & 3 & 6\\
5 & 6 & 5 & 9\\
1 & 6 & 3 & 5
\end{array}\right]\right)=\left\{ \overset{set-based}{\left[\begin{array}{cc}
A & C\\
1 & 3\\
3 & 3\\
5 & 5
\end{array}\right]},\overset{bag-based}{\left[\begin{array}{cc}
A & C\\
1 & 3\\
3 & 3\\
5 & 5\\
1 & 3
\end{array}\right]}\right\} .
\]

\end_inset


\end_layout

\begin_layout Standard
The 
\series bold
cartesian product
\series default
 of two relations with disjoint schemas returns a relation with the schema
 resulting of combining both schemas and with all possible tuples made out
 of tuples from the first relation and tuples from the second relation:
 Let 
\begin_inset Formula $R_{i},R_{j}\in\Sigma$
\end_inset

 such that their schemas are disjoint, then
\begin_inset Formula 
\[
R_{i}\times R_{j}=\left\{ z=\left(x,y\right)|x\in R_{i}\ \land\ y\in R_{j}\right\} .
\]

\end_inset


\end_layout

\begin_layout Example
An example of the operator 
\begin_inset Formula $\times$
\end_inset

:
\begin_inset Formula 
\[
\left[\begin{array}{cc}
A & B\\
1 & 2\\
3 & 4
\end{array}\right]\times\left[\begin{array}{cc}
C & D\\
2 & 6\\
3 & 7\\
4 & 9
\end{array}\right]=\left[\begin{array}{cccc}
A & B & C & D\\
1 & 2 & 2 & 6\\
1 & 2 & 3 & 7\\
1 & 2 & 4 & 9\\
3 & 4 & 2 & 6\\
3 & 4 & 3 & 7\\
3 & 4 & 4 & 9
\end{array}\right].
\]

\end_inset


\end_layout

\begin_layout Standard
The 
\series bold
natural join
\series default
 of two tuples whose schemas share at most one attribute returns a relation
 with the schema resulting of combining both schemas and with all possible
 tuples made out of tuples from the first relation and tuples from the second
 relation with the condition that they have the same value for the shared
 attribute: Let 
\begin_inset Formula $R_{i},R_{j}\in\Sigma$
\end_inset

 such that their schemas share at most one attribute, 
\begin_inset Formula $A$
\end_inset

, then
\begin_inset Formula 
\[
R_{i}\bowtie R_{j}=\left\{ z=\left(x,y\right)|x\in R_{i}\ \land\ y\in R_{j}\ \land x\left(A\right)=y\left(A\right)\right\} .
\]

\end_inset


\end_layout

\begin_layout Standard
Note that if the relations are disjoint, the natural join gives the same
 results as the cartesian product.
\end_layout

\begin_layout Example
An example of the operator 
\begin_inset Formula $\bowtie$
\end_inset

:
\begin_inset Formula 
\[
\left[\begin{array}{cc}
A & B\\
1 & 2\\
3 & 4
\end{array}\right]\bowtie\left[\begin{array}{cc}
B & D\\
2 & 6\\
3 & 7\\
4 & 9
\end{array}\right]=\left[\begin{array}{ccc}
A & B & D\\
1 & 2 & 6\\
3 & 4 & 9
\end{array}\right].
\]

\end_inset


\end_layout

\begin_layout Standard
The 
\series bold
theta join
\series default
 of two relations given a condition 
\begin_inset Formula $P$
\end_inset

 returns all the tuples in the cartesian product of the two relations that
 fullfil the condition 
\begin_inset Formula $P$
\end_inset

: Let 
\begin_inset Formula $R_{i},R_{j}\in\Sigma$
\end_inset

 and 
\begin_inset Formula $P$
\end_inset

 a condition, then
\begin_inset Formula 
\[
R_{i}\bowtie_{P}R_{j}=\left\{ x|x\in R_{i}\times R_{j}\ \land\ P\left(x\right)==true\right\} =\sigma_{P}\left(R_{i}\times R_{j}\right).
\]

\end_inset


\end_layout

\begin_layout Example
An example of the operator 
\begin_inset Formula $\bowtie_{P}$
\end_inset

:
\begin_inset Formula 
\[
\left[\begin{array}{cc}
A & B\\
1 & 2\\
3 & 4
\end{array}\right]\bowtie_{B=C}\left[\begin{array}{cc}
C & D\\
2 & 6\\
3 & 7\\
4 & 9
\end{array}\right]=\left[\begin{array}{cccc}
A & B & C & D\\
1 & 2 & 2 & 6\\
3 & 4 & 4 & 9
\end{array}\right].
\]

\end_inset


\end_layout

\begin_layout Standard
The 
\series bold
left/right/full outer join
\series default
 operators are similar to the theta join, but for those tuples in the left/right
/both relation that does not find a match in the other relation, it returns
 a new tuples with the values of the tuple and the rest of the attributes
 empty.
\end_layout

\begin_layout Example
An example of 
\begin_inset Formula $=\bowtie,\ \bowtie=,=\bowtie=$
\end_inset

:
\begin_inset Formula 
\[
\left[\begin{array}{cc}
A & B\\
1 & 2\\
3 & 4\\
5 & 5
\end{array}\right]=\bowtie_{B=C}\left[\begin{array}{cc}
C & D\\
2 & 6\\
3 & 7\\
4 & 9
\end{array}\right]=\left[\begin{array}{cccc}
A & B & C & D\\
1 & 2 & 2 & 6\\
3 & 4 & 4 & 9\\
5 & 5
\end{array}\right]
\]

\end_inset


\begin_inset Formula 
\[
\left[\begin{array}{cc}
A & B\\
1 & 2\\
3 & 4\\
5 & 5
\end{array}\right]\bowtie=_{B=C}\left[\begin{array}{cc}
C & D\\
2 & 6\\
3 & 7\\
4 & 9
\end{array}\right]=\left[\begin{array}{cccc}
A & B & C & D\\
1 & 2 & 2 & 6\\
3 & 4 & 4 & 9\\
 &  & 3 & 7
\end{array}\right]
\]

\end_inset


\begin_inset Formula 
\[
\left[\begin{array}{cc}
A & B\\
1 & 2\\
3 & 4\\
5 & 5
\end{array}\right]=\bowtie=_{B=C}\left[\begin{array}{cc}
C & D\\
2 & 6\\
3 & 7\\
4 & 9
\end{array}\right]=\left[\begin{array}{cccc}
A & B & C & D\\
1 & 2 & 2 & 6\\
3 & 4 & 4 & 9\\
5 & 5\\
 &  & 3 & 7
\end{array}\right]
\]

\end_inset


\end_layout

\begin_layout Standard
The 
\series bold
renaming operator 
\series default
changes the name of a relation, 
\begin_inset Formula $\rho\left(R\right)=R'$
\end_inset

.
 The 
\series bold
feature rename operator
\series default
 changes the name of an attribute in a relation, 
\begin_inset Formula $A\rightarrow A'$
\end_inset

.
\end_layout

\begin_layout Standard
The 
\series bold
aggregation operator 
\series default
of a relation returns another relation in which the tuples that share the
 value of the aggregating attribute are merged using an 
\series bold
aggregate function
\series default
: Let 
\begin_inset Formula $R\in\Sigma$
\end_inset

, with 
\begin_inset Formula $R\sim\left[A_{1},...,A_{n},A\right]$
\end_inset

, 
\begin_inset Formula $A$
\end_inset

 the aggregating attribute and 
\begin_inset Formula $f_{1},...,f_{n}$
\end_inset

 the aggregating functions for the rest of the attributes, then
\begin_inset Formula 
\[
\gamma_{A,f_{1}\left(A_{1}\right),...,f_{n}\left(A_{n}\right)}\left(R\right)=\left\{ z=\left(v_{A},f_{1}\left(A_{1}^{v_{A}}\right),...f_{n}\left(A_{n}^{v_{A}}\right)\right)|v_{A}\in R\left(A\right)\right\} ,
\]

\end_inset

 where 
\begin_inset Formula $A_{j}^{v_{A}}$
\end_inset

 is a short notation for
\begin_inset Formula 
\[
A_{j}^{v_{A}}=\Pi_{A_{j}}\left(\sigma_{A=v_{A}}\left(R\right)\right),
\]

\end_inset

 i.e.
 all values in 
\begin_inset Formula $R\left(A_{j}^{v_{A}}\right)$
\end_inset

 such that come from a tuple whose values for the attribute 
\begin_inset Formula $A$
\end_inset

 is 
\begin_inset Formula $v$
\end_inset

.
\end_layout

\begin_layout Example
An example of the operator 
\begin_inset Formula $\gamma_{A,f_{1}\left(A_{1}\right),...,f_{n}\left(A_{n}\right)\left(R\right)}$
\end_inset

:
\begin_inset Formula 
\[
\gamma_{A,min\left(B\right)}\left[\begin{array}{cc}
A & B\\
1 & 2\\
1 & 1\\
3 & 7\\
3 & 9\\
4 & 4
\end{array}\right]=\left[\begin{array}{cc}
A & min\left(B\right)\\
1 & 1\\
3 & 7\\
4 & 4
\end{array}\right].
\]

\end_inset


\end_layout

\begin_layout Subsection
Relational algebra expressions
\end_layout

\begin_layout Standard
Now, we can build expressions in relational algebra to get new relations
 from current ones.
 Let's return to Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "ex:1-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we can define the operator 
\begin_inset Formula $Op$
\end_inset

 such that produces the relation that contains all names of films in which
 some movie stars in 
\begin_inset Formula $MovieStar$
\end_inset

 born in 1960 participated as:
\begin_inset Formula 
\[
R'=Op\left(MovieStar,StarsIn\right)=\Pi_{filmName}\left(\sigma_{birthDate.year=1960}\left(MovieStar\bowtie_{name=starName}StarsIn\right)\right).
\]

\end_inset


\end_layout

\begin_layout Standard
Relational algebra is the theoretical basis of the 
\series bold
SQL language
\series default
, meaning SQL is designed as an implementation of the relational algebra
 operators that we have seen so far.
 The equivalent SQL sentence to the last RA operator, 
\begin_inset Formula $OP$
\end_inset

, is
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

SELECT filmName
\end_layout

\begin_layout Plain Layout

FROM StarsIn
\end_layout

\begin_layout Plain Layout

JOIN MovieStar ON name=starName
\end_layout

\begin_layout Plain Layout

WHERE birthDate.year = 1960;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As explained in 
\begin_inset CommandInset citation
LatexCommand cite
key "SQLtoRA"
literal "false"

\end_inset

, translating an arbitrary SQL query into a 
\series bold
logical query plan
\series default
, or, equivalently, a relational algebra expression, is a complex task.
 Let's first give some examples.
\end_layout

\begin_layout Example
We are going to work with some examples now.
 Let's our database have the following relations:
\end_layout

\begin_deeper
\begin_layout Itemize
Movie(title: string, year: int, length: int, genre: string, studioName:
 string, producerCERT: int)
\end_layout

\begin_layout Itemize
MovieStar(name: string, address: string, gender: char, birthdate:date)
\end_layout

\begin_layout Itemize
StarsIn(movieTitle: string, movieYear: string, starName: string)
\end_layout

\begin_layout Itemize
MovieExec(name: string, address: string, CERT: int, netWorth: int)
\end_layout

\begin_layout Itemize
Studio(name: string, address: string, presCERT: int)
\end_layout

\begin_layout Standard
SQL:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT movieTitle, count(S.starName) AS numStars
\end_layout

\begin_layout Plain Layout

FROM StarsIn S, MovieStar M
\end_layout

\begin_layout Plain Layout

WHERE S.starName = M.name
\end_layout

\begin_layout Plain Layout

GROUP BY movieTitle;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
RA:
\begin_inset Formula 
\[
\gamma_{M.movieTitle,\ count\left(S.starName\right)\rightarrow numStars}\left(\rho_{S}\left(StarsIn\right)\bowtie_{S.starName=M.name}\rho_{M}\left(MovieStar\right)\right).
\]

\end_inset


\end_layout

\begin_layout Standard
SQL:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT movieTitle, count(S.starName) AS numStars
\end_layout

\begin_layout Plain Layout

FROM StarsIn S, MovieStar M
\end_layout

\begin_layout Plain Layout

WHERE S.starName = M.name
\end_layout

\begin_layout Plain Layout

GROUP BY movieTitle
\end_layout

\begin_layout Plain Layout

HAVING count(S.starName) > 5;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
RA:
\begin_inset Formula 
\[
\sigma_{numStars>5}\left(\gamma_{M.movieTitle,\ count\left(S.starName\right)\rightarrow numStars}\left(\rho_{S}\left(StarsIn\right)\bowtie_{S.starName=M.name}\rho_{M}\left(MovieStar\right)\right)\right).
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
At this point, one can understand that it is not easy at all to automatize
 this procedure of translating from SQL to RA.
 Not only the process is not trivial as is, but it is also needed to take
 into consideration that one SQL sentence can be translated into several
 equivalent RA expressions, which will ultimately be executed in a computer
 and the election of the translation to execute will affect the efficiency
 of the program.
 Let's review the paper 
\begin_inset CommandInset citation
LatexCommand cite
key "SQLtoRA"
literal "false"

\end_inset

, explaining each of the translations, assuming set-based relations.
\end_layout

\begin_layout Section
Translating SQL into Relational Algebra
\end_layout

\begin_layout Subsection
SELECT-FROM-WHERE statemets without subqueries
\begin_inset CommandInset label
LatexCommand label
name "subsec:SELECT-FROM-WHERE-statemets-without-SUB"

\end_inset


\end_layout

\begin_layout Standard
A query of the form:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT select-list
\end_layout

\begin_layout Plain Layout

FROM R1 T1,..., Rn Tn
\end_layout

\begin_layout Plain Layout

WHERE condition;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
in which the condition does not involve subqueries, we can translate it
 as
\begin_inset Formula 
\[
\Pi_{select-list}\left(\sigma_{condition}\left(\rho_{T1}\left(R1\right)\times...\times\rho_{Tn}\left(Rn\right)\right)\right).
\]

\end_inset


\end_layout

\begin_layout Subsection
Normalizing WHERE-subqueries into EXISTS and NOT EXISTS form
\end_layout

\begin_layout Standard
In general, queries in which there are subqueries in the WHERE clause can
 arise, and they need to be translated, too.
 The property used in these cases is that subqueries occurring in the WHERE
 clause that use the operators 
\begin_inset Formula $=,<,>,<=,>=,<>,EXISTS,IN,NOT\ EXISTS,NOT\ IN$
\end_inset

 or the quantifiers 
\begin_inset Formula $ANY$
\end_inset

 or 
\begin_inset Formula $ALL$
\end_inset

 can all be rewritten to use the operators 
\begin_inset Formula $EXISTS$
\end_inset

 and 
\begin_inset Formula $NOT\ EXISTS$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Proposition
All conditions using a subquery can be rewritten using only 
\begin_inset Formula $EXISTS$
\end_inset

 and 
\begin_inset Formula $NOT\ EXISTS$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Proof
Let's proof some of the results:
\end_layout

\begin_deeper
\begin_layout Itemize
The result using the 
\begin_inset Formula $EXISTS$
\end_inset

 and 
\begin_inset Formula $NOT\ EXISTS$
\end_inset

 operators is obvious.
\end_layout

\begin_layout Itemize
Case 
\begin_inset Formula $=ANY$
\end_inset

: a query would look like the following:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT select-list
\end_layout

\begin_layout Plain Layout

FROM R1
\end_layout

\begin_layout Plain Layout

WHERE R1.A = ANY (SELECT B
\end_layout

\begin_layout Plain Layout

		  FROM R2
\end_layout

\begin_layout Plain Layout

		  WHERE cond);
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Proof
An equivalent query is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT select-list
\end_layout

\begin_layout Plain Layout

FROM R1
\end_layout

\begin_layout Plain Layout

WHERE EXISTS(SELECT B
\end_layout

\begin_layout Plain Layout

		 FROM R2
\end_layout

\begin_layout Plain Layout

		 WHERE cond AND R2.B = R1.A);
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Case 
\begin_inset Formula $=ALL$
\end_inset

:
\end_layout

\end_deeper
\begin_layout Proof
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT select-list
\end_layout

\begin_layout Plain Layout

FROM R1
\end_layout

\begin_layout Plain Layout

WHERE R1.A = ALL (SELECT B
\end_layout

\begin_layout Plain Layout

			FROM R2
\end_layout

\begin_layout Plain Layout

			WHERE cond);
\end_layout

\end_inset


\end_layout

\begin_layout Proof
An equivalent query is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT select-list
\end_layout

\begin_layout Plain Layout

FROM R1
\end_layout

\begin_layout Plain Layout

WHERE NOT EXISTS(SELECT B
\end_layout

\begin_layout Plain Layout

			FROM R2
\end_layout

\begin_layout Plain Layout

			WHERE cond AND R2.B <> R1.A);
\end_layout

\end_inset


\end_layout

\begin_layout Proof
The rest of the cases 
\begin_inset Formula $binaryOP+ANY|ALL$
\end_inset

 is similar.
\end_layout

\begin_deeper
\begin_layout Itemize
Case 
\begin_inset Formula $IN$
\end_inset

:
\end_layout

\end_deeper
\begin_layout Proof
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT select-list
\end_layout

\begin_layout Plain Layout

FROM R1
\end_layout

\begin_layout Plain Layout

WHERE R1.A IN (SELECT B
\end_layout

\begin_layout Plain Layout

		   FROM R2
\end_layout

\begin_layout Plain Layout

		   WHERE cond);
\end_layout

\end_inset


\end_layout

\begin_layout Proof
An equivalent query is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT select-list
\end_layout

\begin_layout Plain Layout

FROM R1
\end_layout

\begin_layout Plain Layout

WHERE EXISTS(SELECT B
\end_layout

\begin_layout Plain Layout

		 FROM R2
\end_layout

\begin_layout Plain Layout

		 WHERE cond AND R2.B = R1.A);
\end_layout

\end_inset


\end_layout

\begin_layout Proof
The case 
\begin_inset Formula $NOT\ IN$
\end_inset

 is analogous.
\end_layout

\begin_layout Example
Let's see some examples from the paper:
\end_layout

\begin_layout Example
The query
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT movieTitle FROM StarsIn
\end_layout

\begin_layout Plain Layout

WHERE starName IN (SELECT name
\end_layout

\begin_layout Plain Layout

		   FROM MovieStar
\end_layout

\begin_layout Plain Layout

		   WHERE birthdate = 1960);
\end_layout

\end_inset

is equivalent to:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT movieTitle FROM StarsIn
\end_layout

\begin_layout Plain Layout

WHERE EXISTS (SELECT name
\end_layout

\begin_layout Plain Layout

	  FROM MovieStar
\end_layout

\begin_layout Plain Layout

	  WHERE birthdate = 1960 AND name = starName);
\end_layout

\end_inset


\end_layout

\begin_layout Example
The query
\end_layout

\begin_layout Example
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT name FROM MovieExec
\end_layout

\begin_layout Plain Layout

WHERE netWorth >= ALL (SELECT E.networth
\end_layout

\begin_layout Plain Layout

			FROM MovieExec E);
\end_layout

\end_inset

is equivalent to:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT name FROM MovieExec
\end_layout

\begin_layout Plain Layout

WHERE NOT EXISTS (SELECT E.networth
\end_layout

\begin_layout Plain Layout

		  FROM MovieExec E
\end_layout

\begin_layout Plain Layout

		  WHERE netWorth < E.netWorth);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Without loss of generality, we can now assume that all subqueries in the
 where clause are of the form 
\begin_inset Formula $EXISTS$
\end_inset

 or 
\begin_inset Formula $NOT\ EXISTS$
\end_inset

.
\end_layout

\begin_layout Standard
Now, to translate a query with subqueries, in which an arbitrary number
 of subqueries inside the subqueries may arise, it seems logical to proceed
 recursively.
 The idea is to translate into RA from inner queries to outer queries.
 For subqueries that do not contain more subqueries, we could translate
 them as in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:SELECT-FROM-WHERE-statemets-without-SUB"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The problem in this case is that the subqueries can refer to attributes
 of relations appearing in the FROM clause of the outer queries.
 This is known as 
\series bold
correlated queries
\series default
.
\end_layout

\begin_layout Example
\begin_inset CommandInset label
LatexCommand label
name "ex:A-correlated-query."

\end_inset

A correlated query.
\end_layout

\begin_layout Example
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT movieTitle
\end_layout

\begin_layout Plain Layout

FROM StarsIn
\end_layout

\begin_layout Plain Layout

WHERE EXISTS (SELECT name
\end_layout

\begin_layout Plain Layout

		FROM MovieStar
\end_layout

\begin_layout Plain Layout

		WHERE birthdate = 1960 AND name = starName);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The outer relations from which a correlated subquery uses certain attributes
 are called 
\series bold
context relations
\series default
.
 The attributes of the context relations are the 
\series bold
parameters
\series default
 of the subquery
\begin_inset Foot
status open

\begin_layout Plain Layout
Note that not all the parameters must appear in the subquery.
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Translating SELECT-FROM-WHERE subqueries
\begin_inset CommandInset label
LatexCommand label
name "subsec:Translating-SELECT-FROM-WHERE-suB"

\end_inset


\end_layout

\begin_layout Standard
To translate a SELECT-FROM-WHERE statement that is used as a subquery, we
 must make the following modifications to the method from Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:SELECT-FROM-WHERE-statemets-without-SUB"
plural "false"
caps "false"
noprefix "false"

\end_inset

:
\end_layout

\begin_layout Itemize
We must add all context relations to the cartesian product of the relations
 in the FROM list.
\end_layout

\begin_layout Itemize
We must add all parameters as attributes to the projection 
\begin_inset Formula $\pi$
\end_inset

.
\end_layout

\begin_layout Example
The subquery from Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "ex:A-correlated-query."
plural "false"
caps "false"
noprefix "false"

\end_inset

:
\end_layout

\begin_layout Example
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT name
\end_layout

\begin_layout Plain Layout

FROM MovieStar
\end_layout

\begin_layout Plain Layout

WHERE birthdate = 1960 AND name = starName
\end_layout

\end_inset


\end_layout

\begin_layout Example
is translated into
\begin_inset Formula 
\[
\Pi_{movieTitle,movieYear,starName,name}\left(\sigma_{birthdate=1960\ \land\ name=starName}\left(StarsIn\times MovieStar\right)\right).
\]

\end_inset


\end_layout

\begin_layout Subsection
De-correlation of subqueries appearing in a conjunctive WHERE condition
\end_layout

\begin_layout Standard
Now, let's focus on a particular case:
\end_layout

\begin_layout Standard
Suppose we have a query of the general form:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT Select-list
\end_layout

\begin_layout Plain Layout

FROM from-list
\end_layout

\begin_layout Plain Layout

WHERE condition;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
And the following assumption: 
\emph on
the condition is a conjunction (AND) of SELECT-FROM-WHERE subqueries, possibly
 with an additional condition that does not contain subqueries
\emph default
, i.e., the condition is of the form
\begin_inset Formula 
\[
\phi\ AND\ EXISTS(Q_{1})\ AND\ EXISTS\left(Q_{2}\right)\ AND...\ AND\ NOT\ EXISTS\ \left(P_{1}\right)\ AND...
\]

\end_inset

 where 
\begin_inset Formula $\phi$
\end_inset

 denotes the subquery-free condition and 
\begin_inset Formula $Q_{1},...,Q_{n},P_{1},...,P_{m}$
\end_inset

 are select statements.
 The translation is done in four steps:
\end_layout

\begin_layout Enumerate
Translate 
\begin_inset Formula $\phi$
\end_inset

.
\end_layout

\begin_layout Enumerate
De-correlate the EXISTS subqueries.
\end_layout

\begin_layout Enumerate
De-correlate the NOT EXISTS subqueries.
\end_layout

\begin_layout Enumerate
Apply the projection 
\begin_inset Formula $\Pi_{Select-list}.$
\end_inset


\end_layout

\begin_layout Subsubsection
Translating 
\begin_inset Formula $\phi$
\end_inset


\end_layout

\begin_layout Standard
It is translated using the method of Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:SELECT-FROM-WHERE-statemets-without-SUB"
plural "false"
caps "false"
noprefix "false"

\end_inset

, but the following context relations must be included:
\end_layout

\begin_layout Itemize
All context relations for which parameters occur in 
\begin_inset Formula $\phi$
\end_inset

.
\end_layout

\begin_layout Itemize
All context relations for which parameters only occur in NOT EXISTS subqueries.
\end_layout

\begin_layout Standard
We will obtain a expression of the form
\begin_inset Formula 
\[
\sigma_{\phi}\left(E\right),
\]

\end_inset

 where 
\begin_inset Formula $E$
\end_inset

 is a cartesian product of all the context relations involved.
 From now on, we are going to adapt and refine 
\begin_inset Formula $E$
\end_inset

 gradually when de-correlating the subqueries.
\end_layout

\begin_layout Example
\begin_inset CommandInset label
LatexCommand label
name "ex:decorr-ex1"

\end_inset

Consider the following query, with relations 
\begin_inset Formula $R\left(A,B\right)$
\end_inset

 and 
\begin_inset Formula $S\left(C\right)$
\end_inset

:
\end_layout

\begin_layout Example
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT R1.A, R1.B
\end_layout

\begin_layout Plain Layout

FROM R R1, S
\end_layout

\begin_layout Plain Layout

WHERE EXISTS
\end_layout

\begin_layout Plain Layout

	(SELECT R2.A, R2.B
\end_layout

\begin_layout Plain Layout

	FROM R R2
\end_layout

\begin_layout Plain Layout

	WHERE R2.A = R1.B AND EXISTS
\end_layout

\begin_layout Plain Layout

			(SELECT R3.A, R3.B
\end_layout

\begin_layout Plain Layout

			FROM R R3
\end_layout

\begin_layout Plain Layout

			WHERE R3.A = R2.B AND R3.B = S.C));
\end_layout

\end_inset


\end_layout

\begin_layout Example
Let's denote the queries, from outer to inner: 
\begin_inset Formula $Q_{1},Q_{2}$
\end_inset

 and 
\begin_inset Formula $Q_{3}$
\end_inset

.
 
\begin_inset Formula $Q_{1}$
\end_inset

 does not have a subquery-free part, so we continue with 
\begin_inset Formula $Q_{2}$
\end_inset

.
 The subquery-free part of 
\begin_inset Formula $Q_{2}$
\end_inset

 is:
\end_layout

\begin_layout Example
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT *
\end_layout

\begin_layout Plain Layout

FROM R R2
\end_layout

\begin_layout Plain Layout

WHERE R2.A = R1.B;
\end_layout

\end_inset


\end_layout

\begin_layout Example
So it can be translated as
\begin_inset Formula 
\[
\sigma_{R2.A=R1.B}\left(\rho_{R2}\left(R\right)\times\rho_{R1}\left(R\right)\right).
\]

\end_inset

 Note that 
\begin_inset Formula $S$
\end_inset

 is a context relation for this subquery-free part, but no parameter from
 it is needed and it is not only used in NOT EXISTS clauses, so it is not
 added.
\end_layout

\begin_layout Subsubsection
De-correlating EXISTS subqueries
\end_layout

\begin_layout Standard
After translating the subquery-free part, we translate all the subqueries
 
\begin_inset Formula $EXISTS\left(Q_{i}\right)$
\end_inset

 as explained in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Translating-SELECT-FROM-WHERE-suB"
plural "false"
caps "false"
noprefix "false"

\end_inset

, obtaining an algebra expression 
\begin_inset Formula $E_{Q_{i}}$
\end_inset

.
 
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $A_{1},...,A_{p}$
\end_inset

 be the list of parameters of context relations of 
\begin_inset Formula $Q_{i}$
\end_inset

.
 We can translate 
\begin_inset Formula $EXISTS\left(Q_{i}\right)$
\end_inset

 by joining 
\begin_inset Formula $E$
\end_inset

 with the space of parameters for 
\begin_inset Formula $E_{Q_{i}}$
\end_inset

, namely 
\begin_inset Formula $\Pi_{A_{1},...,A_{p}}\left(E_{Q_{i}}\right):$
\end_inset


\begin_inset Formula 
\[
E:=E\bowtie\pi_{A_{1},...,A_{p}}\left(E_{Q_{i}}\right).
\]

\end_inset


\end_layout

\begin_layout Example
Let's continue the translation of 
\begin_inset Formula $Q_{2}$
\end_inset

 from Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "ex:decorr-ex1"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Now, we have to translate 
\begin_inset Formula $Q_{3}$
\end_inset

 as:
\begin_inset Formula 
\[
\sigma_{R3.A=R2.B\ \land\ R3.B=S.C}\left(\rho_{R3}\left(R\right)\times\rho_{R2}\left(R\right)\times S\right).
\]

\end_inset


\end_layout

\begin_layout Example
At this point, we have
\begin_inset Formula 
\[
E=\rho_{R_{2}}\left(R\right)\times\rho_{R_{1}}\left(R\right),
\]

\end_inset


\begin_inset Formula 
\[
E_{Q_{3}}=\sigma_{R3.A=R2.B\ \land\ R3.B=S.C}\left(\rho_{R3}\left(R\right)\times\rho_{R2}\left(R\right)\times S\right),
\]

\end_inset

 and by joining 
\begin_inset Formula $E$
\end_inset

 and 
\begin_inset Formula $E_{Q_{3}}$
\end_inset

 on the parameters of 
\begin_inset Formula $Q_{3}$
\end_inset

 we ensure that we are taking the correct tuples from 
\begin_inset Formula $E$
\end_inset

 and 
\begin_inset Formula $E_{Q_{3}}$
\end_inset

.
 In particular, we are taking the tuples in 
\begin_inset Formula $R_{1}$
\end_inset

 for which tuples in 
\begin_inset Formula $R_{2},R_{3}$
\end_inset

 and 
\begin_inset Formula $S$
\end_inset

 exist that satisfy the requirements of 
\begin_inset Formula $Q_{2}$
\end_inset

:
\begin_inset Formula 
\[
\rho_{R_{2}}\left(R\right)\times\rho_{R_{1}}\left(R\right)\bowtie\Pi_{R_{2}.A,R_{2}.B,S.C}\left(\sigma_{R3.A=R2.B\ \land\ R3.B=S.C}\left(\rho_{R3}\left(R\right)\times\rho_{R2}\left(R\right)\times S\right)\right).
\]

\end_inset

 Note that this expression can be simplified:
\begin_inset Formula 
\[
E:=\rho_{R_{1}}\left(R\right)\bowtie\Pi_{R_{2}.A,R_{2}.B,S.C}\left(\sigma_{R3.A=R2.B\ \land\ R3.B=S.C}\left(\rho_{R3}\left(R\right)\times\rho_{R2}\left(R\right)\times S\right)\right),
\]

\end_inset

 because we are joining 
\begin_inset Formula $R_{2}$
\end_inset

 with a subset of itself, so we will obtain the entire subset.
\end_layout

\begin_layout Remark
This simplification can always be done.
 Before joining with 
\begin_inset Formula $\Pi_{A_{1},...,A_{p}}\left(E_{Q_{i}}\right),$
\end_inset

 we can remove from 
\begin_inset Formula $E$
\end_inset

 all context relations for 
\begin_inset Formula $Q_{i}$
\end_inset

, because they are already present in the parameter space.
 This way, denoting by 
\begin_inset Formula $\hat{E}$
\end_inset

 the adapted 
\begin_inset Formula $E$
\end_inset

, we can change what we explained later for
\begin_inset Formula 
\[
E:=\hat{E}\bowtie\Pi_{A_{1},...,A_{p}}\left(E_{Q_{i}}\right).
\]

\end_inset


\end_layout

\begin_layout Example
Now we can translate 
\begin_inset Formula $Q_{2}$
\end_inset

 as follows:
\begin_inset Formula 
\[
E_{2}:=\sigma_{R_{2}.A=R_{1}.B}\left(E\right)=
\]

\end_inset


\begin_inset Formula 
\[
\sigma_{R_{2}.A=R_{1}.B}\left(\rho_{R_{1}}\left(R\right)\bowtie\Pi_{R_{2}.A,R_{2}.B,S.C}\left(\sigma_{R3.A=R2.B\ \land\ R3.B=S.C}\left(\rho_{R3}\left(R\right)\times\rho_{R2}\left(R\right)\times S\right)\right)\right).
\]

\end_inset

 Notice how 
\begin_inset Formula $R_{2}$
\end_inset

 has been removed from the cartesian product of the subquery-free part of
 
\begin_inset Formula $Q_{2}$
\end_inset

 that we translated in the first of the examples.
\end_layout

\begin_layout Example
Finally, the translation of the entire 
\begin_inset Formula $Q_{1}$
\end_inset

 is
\begin_inset Formula 
\[
\Pi_{R_{1}.A,R_{1}.B}\left(E_{2}\right),
\]

\end_inset

 where 
\begin_inset Formula $\rho_{R_{1}}\left(R\right)$
\end_inset

 and 
\begin_inset Formula $S$
\end_inset

 have been removed from the cartesian product originating from the translation
 of the subquery-free part of 
\begin_inset Formula $Q_{1}$
\end_inset

 (the FROM clause).
\end_layout

\begin_layout Subsubsection
De-correlating NOT EXISTS subqueries
\end_layout

\begin_layout Standard
Now we can de-correlate the 
\begin_inset Formula $NOT\ EXISTS\left(P_{j}\right)$
\end_inset

 subqueries.
 We start translating 
\begin_inset Formula $P_{j}$
\end_inset

 into a RA expression 
\begin_inset Formula $E_{P_{j}}$
\end_inset

.
 Again, we consider the parameters 
\begin_inset Formula $A_{1},...,A_{p}$
\end_inset

 of the context relations of 
\begin_inset Formula $P_{j}$
\end_inset

.
 The difference now is that we don't join 
\begin_inset Formula $E$
\end_inset

 and 
\begin_inset Formula $E_{P_{j}}$
\end_inset

, but we perform an anti-join:
\begin_inset Formula 
\[
E:=E\overline{\bowtie}\Pi_{A_{1},...,A_{p}}\left(E_{P_{j}}\right),
\]

\end_inset

 where
\begin_inset Formula 
\[
R\overline{\bowtie}S=R-\left(R\bowtie S\right).
\]

\end_inset

 In this anti-join, it necessary that 
\begin_inset Formula $R$
\end_inset

 contains all attributes of 
\begin_inset Formula $S$
\end_inset

, and this is the reason why it is needed to add all context relations appearing
 only in NOT EXISTS clauses to the cartesian product of the subquery-free
 part of the query.
\end_layout

\begin_layout Subsubsection
Translating the Select-list
\end_layout

\begin_layout Standard
Finally, we apply the projection 
\begin_inset Formula $\Pi_{Select-list}$
\end_inset

.
\end_layout

\begin_layout Subsection
Flattening subqueries in bag-based relations
\end_layout

\begin_layout Standard
Until now, we have supposed that all relations involved are set-based, but
 this is not the case in real databases, where duplicates can occur.
 In this case, the requirements for flattening into a normal join are:
\end_layout

\begin_layout Itemize
There is a uniqueness condition that ensures that the subquery does not
 introduce any duplicates if it is flattened into the outer query block.
 
\end_layout

\begin_layout Itemize
Each table in the subquery's FROM list (after any view, derived table, or
 subquery flattening) must be a base table.
 
\end_layout

\begin_layout Itemize
The subquery is not under an OR.
 
\end_layout

\begin_layout Itemize
The subquery is not in the SELECT list of the outer query block.
 
\end_layout

\begin_layout Itemize
The subquery type is EXISTS, IN, or ANY, or it is an expression subquery
 on the right side of a comparison operator.
 
\end_layout

\begin_layout Itemize
There are no aggregates in the SELECT list of the subquery.
 
\end_layout

\begin_layout Itemize
The subquery does not have a GROUP BY clause.
 
\end_layout

\begin_layout Itemize
The subquery does not have an ORDER BY, result offset, or fetch first clause.
 
\end_layout

\begin_layout Itemize
If there is a WHERE clause in the subquery, there is at least one table
 in the subquery whose columns are in equality predicates with expressions
 that do not include any column references from the subquery block.
 These columns must be a superset of the key columns for any unique index
 on the table.
 For all other tables in the subquery, the columns in equality predicates
 with expressions that do not include columns from the same table are a
 superset of the unique columns for any unique index on the table.
 
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Query Optimization
\end_layout

\begin_layout Section
System-R
\end_layout

\begin_layout Standard
In this section, we are going to explain System R, which is a pioneering
 SQL system developed by IBM Research and which was released in 1976, with
 an accompanying paper, 
\begin_inset CommandInset citation
LatexCommand cite
key "systemR"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
System R was an experimental prototype database management system, with
 complete capability, including application programming, query capability,
 conccurent access support, system recovery, etc.
\end_layout

\begin_layout Subsection
Architecture Components
\end_layout

\begin_layout Standard
System R is composed by several parts:
\end_layout

\begin_layout Itemize

\series bold
Relational Storage Interface
\series default
 
\series bold
(RSI)
\series default
: internal interface which handles access to single tuples of base relations.
\end_layout

\begin_layout Itemize

\series bold
Relational Storage System (RSS)
\series default
: the supporting system of the RSI.
 It is a complete storage subsystem in the sense that it manages devices,
 space allocation, deadlock detection,...
 It maintain indexes on selected fields of base relations, and pointer chains
 across relations.
\end_layout

\begin_layout Itemize

\series bold
Relational Data Interface (RDI)
\series default
: the external interface that can be called directly from a programming
 language.
 The 
\series bold
SQL language
\series default
 is embedded within the RDI, and is used as the basis for all data definition
 and manipulation.
\end_layout

\begin_layout Itemize

\series bold
Relational Data System (RDS)
\series default
: supports the RDI, provides authorization, integrity enforcement and support
 for alternative views of data.
 The RDS contains an 
\series bold
optimizer
\series default
 which plans the execution of each RDI command, choosing a low cost access
 path to data from among those provided by the RSS.
 The RDS also maintains a set of 
\series bold
catalog relations
\series default
 which describe the other relations, views, images, links, assertions, and
 triggers known to the system.
\end_layout

\begin_layout Standard
A logical diagram of this architecture is depicted in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Architecture-of-System-R"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename systemR.drawio.png
	scale 65

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Architecture-of-System-R"

\end_inset

Architecture of System R
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Query language
\end_layout

\begin_layout Subsubsection
Data manipulation
\end_layout

\begin_layout Standard
The RDI interfaces SQL to a host programming language by means of a concept
 called a 
\series bold
cursor
\series default
, which is a name used at the RDI to identify a set of tuples called its
 
\series bold
active set
\series default
, and to maintain a position on one tuple of the set.
 The cursor is associted with a set of tuples by means of the RDI operator
 
\series bold
SEQUEL
\series default
; the tuples may then be retrieved, one at a time, by the RDI operator 
\series bold
FETCH
\series default
.
 The program must first give the system the addresses of the program variables
 to be used by means of the RDI operator 
\series bold
BIND
\series default
.
\end_layout

\begin_layout Example
Here, the host program identifies variables X and Y to the system and then
 issues a query whose results are to be placed in these variables:
\end_layout

\begin_layout Example
\begin_inset listings
lstparams "language={PL/I},showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

CALL BIND('X', ADDR(X));
\end_layout

\begin_layout Plain Layout

CALL BIND('Y', ADDR(Y));
\end_layout

\begin_layout Plain Layout

CALL SEQUEL(C1, 'SELECT NAME:X, SAL:Y
\end_layout

\begin_layout Plain Layout

		FROM EMP
\end_layout

\begin_layout Plain Layout

		WHERE JOB = 
\begin_inset Quotes eld
\end_inset

PROGRAMMER
\begin_inset Quotes erd
\end_inset

');
\end_layout

\begin_layout Plain Layout

CALL FETCH(C1);
\end_layout

\end_inset


\end_layout

\begin_layout Example
The SEQUEL operator is associating the cursor C1 with the set of tuples
 which satisfy the query and positioning it just before the first such tuple.
 The optimizer is invoked to choose an access path whereby the tuples may
 be materialized, but no tuples are actually materialized in response to
 the SEQUEL call.
 The materialization is done as they are called for, one at a time, by the
 FETCH operator.
 Each call to FETCH deliver the next tuple of the active set into program
 variables X and Y.
 In Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:exampleSystemR"
plural "false"
caps "false"
noprefix "false"

\end_inset

 we can see an example of the stored data in the relation EMP and the resulting
 Active Set.
 In this case, after calling FETCH(C1), the values of the variables would
 be X=
\begin_inset Quotes erd
\end_inset

Mike
\begin_inset Quotes erd
\end_inset

 and Y=800.
 If another call to FECTH(C1) were made, then the variables would be overrided
 to X=
\begin_inset Quotes erd
\end_inset

Sarah
\begin_inset Quotes erd
\end_inset

 and Y=810.
\end_layout

\begin_layout Example
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
EMP
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
NAME
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SAL
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
JOB
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

John
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

CEO
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

Mike
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
800
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

PROGRAMMER
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

Sarah
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
810
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

PROGRAMMER
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Active Set
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
NAME
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SAL
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

Mike
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
800
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

Sarah
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
810
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:exampleSystemR"

\end_inset

Result of the program.
 Stored data in EMP (left).
 Active Set (right).
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\series bold
DESCRIBE
\series default
 operator returns the degree and the data types of the active set.
 The degree is the number of attributes.
 It is useful when this information is not known in advanced, so it can
 be inputted to the FETCH operator.
\end_layout

\begin_layout Standard
The operator 
\series bold
OPEN
\series default
 is used to associate a cursor with an entire relation.
\end_layout

\begin_layout Standard
Each cursor remains active until an RDI operator 
\series bold
CLOSE
\series default
 or 
\series bold
KEEP
\series default
 is issued on it.
 CLOSE deactivates the cursor, while KEEP causes the tuples identified by
 a cursor to be copied to form a new permanent relation in the database.
\end_layout

\begin_layout Standard
The operator 
\series bold
FETCH_HOLD
\series default
 is as FETCH, but it also acquires a 
\emph on
hold
\emph default
 on the tuple returned, which prevents other users from updating or deleting
 it until it is explicitly released by the 
\series bold
RELEASE
\series default
 operator or until the holding transaction has ended.
\end_layout

\begin_layout Subsubsection
Data definition
\end_layout

\begin_layout Standard
The SQL statement 
\series bold
CREATE TABLE
\series default
 is used to create a new base relation.
 For each field, the field name and data type are specified.
 When a relation is no longer useful, it may be deleted by issuing a 
\series bold
DROP TABLE
\series default
 statement.
\end_layout

\begin_layout Standard
Access paths include images and binary links.
 
\series bold
Images
\series default
 are value orderings maintained on base relations by the RSS, using multilevel
 index structures
\begin_inset Foot
status open

\begin_layout Plain Layout
Images are today called just indexes.
\end_layout

\end_inset

, associating a value with one or more 
\series bold
tuple identifiers (TIDs)
\series default
, which are internal addresses allowing rapid access to a tuple.
 One image per relation can have the 
\series bold
clustering property
\series default
, which causes tuples whose sort field values are close to be physically
 stored near each other.
 
\series bold
Binary paths
\series default
 are access paths in the RSS which link tuples in one relation to related
 tuples of another relation through pointer chains.
 They are employed in a value dependent manner: the user specifies that
 each tuple of Relation 1 is to be linked to the tuples in Relation 2 which
 have matching values in some field/s, and that the tuples on the link are
 to be ordered in some way
\begin_inset Foot
status open

\begin_layout Plain Layout
So, binary paths are essentialy join indexes.
\end_layout

\end_inset

.
 A link may be declared to have the clustering property.
\end_layout

\begin_layout Standard
A 
\series bold
view
\series default
 is a relation derived from one or more relations, and can be used in the
 same way as a base table.
 It can be defined using the 
\series bold
DEFINE VIEW 
\series default
statement.
 Views are updated automatically when changes are made to the base tables
 on which they are defined.
 When the statement 
\series bold
DROP VIEW
\series default
 is issued, the indicated view and all other views defined in terms of it
 disappear from the system.
 Modifications to views are only allowed if the tuples of the view are associate
d one-to-one with tuples of an underlying base relation.
\end_layout

\begin_layout Standard
The statement 
\series bold
KEEP TABLE
\series default
 causes a temporary table to become permanent.
\end_layout

\begin_layout Standard
The statement 
\series bold
EXPAND TABLE
\series default
 is used to add a new field to an existing table.
\end_layout

\begin_layout Subsubsection
Data Control
\end_layout

\begin_layout Standard
A 
\series bold
transaction
\series default
 is a series of RDI calls which the user wishes to be processed as an atomic
 act.
 A transaction starts when the user issues a 
\series bold
BEGIN_TRANS
\series default
 statement and ends when 
\series bold
END_TRANS
\series default
 is called.
 Save points may be specified by means of the operator 
\series bold
SAVE
\series default
.
 When a transaction is active, the user may go back to the beginning of
 it, or to any save point using 
\series bold
RESTORE
\series default
.
\end_layout

\begin_layout Standard
Regarding 
\series bold
authorization
\series default
, System R does not require a particular individual to be the DB administrator,
 but allows each user to create his own data objects by executing the create
 staatements.
 The creator of an object has full authorization on it.
 The user can gran selected capabilities for his objects to other users
 with the statement 
\series bold
GRANT
\series default
.
\end_layout

\begin_layout Standard
About 
\series bold
integrity assertions
\series default
, any SQL predicate may be stated as an assertion about the integrity of
 data in a base table or view.
 When an assertion is made by an 
\series bold
ASSERT 
\series default
statement, its truth is checked.
 If true, the assertion is atuomatically enforced until it is explicitly
 dropped by a 
\series bold
DROP ASSERTION
\series default
 statement.
 Assertions may describe the permissible states of the database or the permissib
le transitions in the database.
 For this latter purpose, the keywords 
\series bold
OLD
\series default
 and 
\series bold
NEW
\series default
 are used in SQL to denote data values before and after modification.
\end_layout

\begin_layout Standard
If an assertion is 
\series bold
IMMEDIATE
\series default
, it cannot be suspended within a transaction, but is enforced after each
 data modification.
 Also, 
\emph on
integrity
\emph default
 
\emph on
points 
\emph default
may be established by the SQL 
\series bold
ENFORCE INTEGRITY
\series default
.
\end_layout

\begin_layout Standard

\series bold
Triggers
\series default
 are a generalization of the concept of assertion, causing a prespecified
 sequence of SQL statements to be executed when some triggering event occurs.
\end_layout

\begin_layout Subsection
Catalogues
\end_layout

\begin_layout Standard
Catalogues are maintained by the RDS, and they describe the information
 of the relations, views, images, links, assertions and triggers known to
 the system.
 Each user may access a set of views of the system catalogs which contain
 information pertinent to him.
 Users cannot modify a catalog directly, but it is modified indirectly,
 when tables are created, an image is dropped, etc.
 A user can enter commments into his various catalog entries by means of
 the 
\series bold
COMMENT
\series default
 statement.
\end_layout

\begin_layout Subsection
Cursors
\end_layout

\begin_layout Standard
As we have seen, 
\series bold
cursors
\series default
 are pointers to specific tuples on a resulting table from a query.
 They can be used to retrieve the values of the tuples individually or to
 store the tables into the database as permanent relations.
 Cursors are still used, although they are often a low level feature that
 is not directly used by users, by it is used by the DBMS to provide higher
 level features to the user.
\end_layout

\begin_layout Standard
In addition, SQL can be used to maniputale either one tuple at a time or
 a set of tuples with a single command.
 The current tuple of a particular cursor may be selected for some operation
 using the predicate 
\series bold
CURRENT TUPLE OF CURSOR
\series default
.
\end_layout

\begin_layout Example
Give a 10% raise to all employees in Dept.
 50.
\end_layout

\begin_layout Example
\begin_inset listings
lstparams "language={PL/I},showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

CALL SEQUEL('UPDATE EMP
\end_layout

\begin_layout Plain Layout

		SET SAL = SAL*1.1
\end_layout

\begin_layout Plain Layout

		WHERE DNO = 50');
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Example
Individual update.
\end_layout

\begin_layout Example
\begin_inset listings
lstparams "language={PL/I},showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

CALL BIND('NEWSAL', ADDR(NEWSAL));
\end_layout

\begin_layout Plain Layout

CALL SEQUEL('UPDATE EMP
\end_layout

\begin_layout Plain Layout

		SET SAL=NEWSAL
\end_layout

\begin_layout Plain Layout

		WHERE CURRENT TUPLE OF CURSOR C');
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Clustering images
\end_layout

\begin_layout Standard
Clustering images, as we have explained, are images (indexes) that can be
 used to physically store the data in the same order as it is indexed.
 At most one image per relation can have the clustering property.
 The reason is simple: it is not possible to store the same data physically
 in two different orders.
\end_layout

\begin_layout Subsection
Optimizer
\end_layout

\begin_layout Standard
The objective of the optimizer is to find a low cost means of executing
 a SQL statement, given the data structures and access paths available.
 For this, it attempts to minimize the expected number of pages to be fetches
 from disk into the RSS buffers.
 The cost of CPU instructions is also taken into account by means of an
 adjustable coefficient, 
\begin_inset Formula $H$
\end_inset

, which is multiplied by the number of tuple comparison operations to convert
 equivalent page accesses.
 
\begin_inset Formula $H$
\end_inset

 is useful to adjust the metric for compute-bounded systems or disk access-bound
ed systems.
\end_layout

\begin_layout Standard
The optimizers follows some steps when it receives a SQL statement:
\end_layout

\begin_layout Enumerate
Classify the SQL statement into one of several statement types.
\end_layout

\begin_layout Enumerate
Examine the system catalogs to find the set of images and links which are
 pertinent to the given statement.
\end_layout

\begin_layout Enumerate
A rough decision procedure is executed to find the set of reasonable methods
 of executing the statement.
\end_layout

\begin_layout Enumerate
If there is more than one reasonable method, the 
\series bold
expected cost formula
\series default
 is evaluated for each method, and the minimizing method is choosing.
\end_layout

\begin_layout Standard
The following parameters, available in the system catalogues, are taken
 into account:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
R
\end_layout

\end_inset

 
\series bold
relation cardinality
\series default
: number of tuples
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
D
\end_layout

\end_inset

 
\series bold
number of pages occupied by the relation
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
T
\end_layout

\end_inset

 
\series bold
average number of tuples per page:
\begin_inset Formula 
\[
T=\frac{R}{D}.
\]

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
I
\end_layout

\end_inset

 
\series bold
image cardinality
\series default
: number of distinct sort fields values in a given image.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
H
\end_layout

\end_inset

 
\series bold
coefficient of CPU cost
\series default
: 
\begin_inset Formula $\frac{1}{H}$
\end_inset

 is the number of tuple comparisons which are considered equivalent in cost
 to one disk page access.
\end_layout

\begin_layout Standard
An image 
\series bold
match
\series default
 a predicate if the sort field of the image is the field which is tested
 by the predicate.
\end_layout

\begin_layout Subsubsection
Simple query optimization
\end_layout

\begin_layout Standard
In the case of a simple query on a single relation, the optimizer compares
 the available images with the predicates of the query, in order to determine
 which of the following eight methods are available:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
Method 1
\end_layout

\end_inset

: use a clustering image which matches a predicate whose comparison operator
 is '='.
 The expected cost, 
\begin_inset Formula $C$
\end_inset

 is
\begin_inset Formula 
\[
C=\frac{R}{T\times I},
\]

\end_inset

 that is: from 
\begin_inset Formula $I$
\end_inset

 values, we want one, so we need to retrieve 
\begin_inset Formula $\frac{R}{I}$
\end_inset

 tuples on average.
 These fit in 
\begin_inset Formula $\frac{R}{T\times I}$
\end_inset

 pages.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
Method 2
\end_layout

\end_inset

: use a clustering image which matches a predicate whose comparison operator
 is not '='.
 Assuming half the tuples satisfy the predicate, we have
\begin_inset Formula 
\[
C=\frac{R}{T\times2}.
\]

\end_inset

 The idea is the same as before, but now we are assuming to retrieve 
\begin_inset Formula $\frac{R}{2}$
\end_inset

 tuples on average.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
Method 3
\end_layout

\end_inset

: use a non-clustering image which matches a predicate whose comparison
 operator is '='.
 In this case, we have
\begin_inset Formula 
\[
C=\frac{R}{I},
\]

\end_inset

 because now we might find only one correct tuple per page.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
Method 4
\end_layout

\end_inset

: use a non-clustering image which matches a predicate whose comparison
 operator is not '='.
 It is
\begin_inset Formula 
\[
C=\frac{R}{2}.
\]

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
Method 5
\end_layout

\end_inset

: use a clustering image which does not match any predicate.
 We would scan the image and test each tuple against all predicates.
 The expected cost is
\begin_inset Formula 
\[
C=\frac{R}{T}+H\times R\times N,
\]

\end_inset

 where 
\begin_inset Formula $N$
\end_inset

 is the number of predicates.
 So, we recover 
\begin_inset Formula $R$
\end_inset

 tuples, distributed in 
\begin_inset Formula $\frac{R}{T}$
\end_inset

 pages.
 In addition to this, we need to perform 
\begin_inset Formula $R\times N$
\end_inset

 comparisons (
\begin_inset Formula $N$
\end_inset

 predicates per tuple), which are weighted by the coefficient of CPU, 
\begin_inset Formula $H$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
Method 6
\end_layout

\end_inset

: use a non-clustering image which does not match any predicate:
\begin_inset Formula 
\[
C=R+H\times R\times N.
\]

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
Method 7
\end_layout

\end_inset

: use a relation scan, where this relation is the only one in its segment
 and test each tupple agains all predicates:
\begin_inset Formula 
\[
C=\frac{R}{T}+H\times R\times N.
\]

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
Method 8
\end_layout

\end_inset

: use a relation scan, where there are other relations sharing the segment.
 The cost is unknown, but is greater than 
\begin_inset Formula $\frac{R}{T}+H\times R\times N$
\end_inset

.
\end_layout

\begin_layout Standard
The optimizer then chooses a method from this set, according to the following
 rules:
\end_layout

\begin_layout Enumerate
If 
\series bold
Method 1
\series default
 is available, it is chose.
\end_layout

\begin_layout Enumerate
If exactly one among 
\series bold
Methods 2,3,5 and 7
\series default
 are available, it is chosen.
 If more than one method is available in this class, the expected cost formulas
 for these methods are evaluated and the method of minimum cost is chosen.
\end_layout

\begin_layout Enumerate
If none of the above methods are available, the optimizer chooses 
\series bold
Method 4
\series default
, if available.
\end_layout

\begin_layout Enumerate
Else, 
\series bold
Method 6
\series default
, if available.
\end_layout

\begin_layout Enumerate
Else, 
\series bold
Method 8
\series default
.
\end_layout

\begin_layout Subsubsection
Join query optimization
\end_layout

\begin_layout Standard
In the release paper, only 4 methods are explained, although they say the
 system takes more methods into account.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
Method 1
\end_layout

\end_inset

: use images on join fields.
 A simultaneous scan of the image on 
\begin_inset Formula $R1.A$
\end_inset

 and the image of 
\begin_inset Formula $R2.A$
\end_inset

.
 The idea is having two pointers, and advance them coordinately, using the
 fact that images are ordered to find matches.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
Method 2
\end_layout

\end_inset

: sort both relations.
 
\begin_inset Formula $R1$
\end_inset

 and 
\begin_inset Formula $R2$
\end_inset

 are ordered using their cluster images and two files, 
\begin_inset Formula $F1$
\end_inset

 and 
\begin_inset Formula $F2$
\end_inset

 are created.
 
\begin_inset Formula $F1$
\end_inset

 and 
\begin_inset Formula $F2$
\end_inset

 are sorted on field 
\begin_inset Formula $A$
\end_inset

.
 The resulting sorted files are scanned simultaneously and the join is performed.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
Method 3
\end_layout

\end_inset

: multiple passes.
 
\begin_inset Formula $R1$
\end_inset

 is scanned, storing the pertinent fields into a main memory data structure,
 
\begin_inset Formula $W$
\end_inset

.
 If space in main memory is available to insert a subtuple, 
\begin_inset Formula $S$
\end_inset

, it is inserted.
 If there is no space and 
\begin_inset Formula $S.A$
\end_inset

 is less than the current highest value of 
\begin_inset Formula $A$
\end_inset

 in 
\begin_inset Formula $W$
\end_inset

, 
\begin_inset Formula $S$
\end_inset

 is discarded.
 After completing the scan of 
\begin_inset Formula $R1$
\end_inset

, 
\begin_inset Formula $R2$
\end_inset

 is scanned using its clustering image and a tuple 
\begin_inset Formula $S'$
\end_inset

 of 
\begin_inset Formula $R2$
\end_inset

 is obtained.
 Then, 
\begin_inset Formula $W$
\end_inset

 is checked for the presence of 
\begin_inset Formula $S'.A$
\end_inset

.
 If present, 
\begin_inset Formula $S'$
\end_inset

 is joined to the appropriate subtuple in 
\begin_inset Formula $W$
\end_inset

.
 This process continues until all tuples of 
\begin_inset Formula $R2$
\end_inset

 have been examined.
 If any 
\begin_inset Formula $R1$
\end_inset

 subtuples were discarded, another scan of 
\begin_inset Formula $R1$
\end_inset

 is made to form a new 
\begin_inset Formula $W$
\end_inset

 consisting of subtuples with 
\begin_inset Formula $A$
\end_inset

 value greater than the current highest.
 
\begin_inset Formula $R2$
\end_inset

 is scanned again and the process is repeated.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
Method 4
\end_layout

\end_inset

: the TID algorithm.
 Basically, it works as follows:
\end_layout

\begin_deeper
\begin_layout Enumerate
Obtain the TIDs of tuples from 
\begin_inset Formula $R1$
\end_inset

 which satisfy additional restrictions to the join.
 Sort them and store the TIDs in a file 
\begin_inset Formula $F1$
\end_inset

.
 Do the same with 
\begin_inset Formula $R2$
\end_inset

, storing the TIDs in 
\begin_inset Formula $F2$
\end_inset

.
\end_layout

\begin_layout Enumerate
Perform a simultaneous scan over the images on 
\begin_inset Formula $R1.A$
\end_inset

 and 
\begin_inset Formula $R2.A$
\end_inset

, finding the TID pairs of tuples whose values for 
\begin_inset Formula $A$
\end_inset

 match.
\end_layout

\begin_layout Enumerate
Check each pair 
\begin_inset Formula $\left(TID1,TID2\right)$
\end_inset

 to see if 
\begin_inset Formula $TID1$
\end_inset

 is present in 
\begin_inset Formula $W1$
\end_inset

 and 
\begin_inset Formula $TID2$
\end_inset

 is present in 
\begin_inset Formula $W2$
\end_inset

.
 If they are, the tuples are fetched and joined.
\end_layout

\end_deeper
\begin_layout Standard
A method cannot be applied unless the appropriate access paths are available.
 The 
\series bold
performance of a method
\series default
 depends strongly on the clustering of the relations with respect to the
 access paths.
 In the paper, four situation are presented in which the optimizer would
 decide between the four methods, but they claim to detail the cost formulas
 on a later paper:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
Situation 1
\end_layout

\end_inset

: there are clustering images on both 
\begin_inset Formula $R1.A$
\end_inset

 and 
\begin_inset Formula $R2.A$
\end_inset

, but not no images on 
\begin_inset Formula $R1.B$
\end_inset

 or 
\begin_inset Formula $R2.C$
\end_inset

, which are additional conditions.
 
\series bold
Method 1
\series default
 is always chosen.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
Situation 2
\end_layout

\end_inset

: there are non-clustering images on 
\begin_inset Formula $R1.A$
\end_inset

 and 
\begin_inset Formula $R2.A$
\end_inset

, but no images on 
\begin_inset Formula $R1.B$
\end_inset

 or 
\begin_inset Formula $R2.C$
\end_inset

.
 
\series bold
Method 3
\series default
 is chosen if 
\begin_inset Formula $W$
\end_inset

 fits into the main memory buffer at once.
 Otherwise, 
\series bold
Method 2
\series default
 is chosen.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
Situation 3
\end_layout

\end_inset

: there are clustering images on 
\begin_inset Formula $R1.A$
\end_inset

 and 
\begin_inset Formula $R2.A$
\end_inset

 and non-clustering images on 
\begin_inset Formula $R1.B$
\end_inset

 or 
\begin_inset Formula $R2.C$
\end_inset

.
 
\series bold
Method 4 
\series default
is always chosen.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
Situation 4
\end_layout

\end_inset

: there are non-clustering images on 
\begin_inset Formula $R1.A,R2.A,R1.B$
\end_inset

 and 
\begin_inset Formula $R2.C$
\end_inset

.
 
\series bold
Method 3
\series default
 is chosen if 
\begin_inset Formula $W$
\end_inset

 fits into the main memory buffer.
 Otherwise, 
\series bold
Method 2
\series default
 is chosen if more than one tuple per disk page is expected to satisfy the
 restriction predicates.
 In other cases, 
\series bold
Method 4
\series default
 is chosen.
\end_layout

\begin_layout Subsubsection
Optimized Packages
\end_layout

\begin_layout Standard
After analyzing a SQL statement, the optimizer produces an 
\series bold
Optimized Package (OP)
\series default
 containing the parse tree and a plan for executing the statement.
 
\end_layout

\begin_layout Itemize
If the statement is a query, the OP is used to materialize tuples as they
 are called for by the FECTH command.
\end_layout

\begin_layout Itemize
If the statement is a view definition, the OP is stored in the form of a
 
\series bold
Pre-Optimized Package (POP)
\series default
, which can be fetched and utilized whenever an access is made via the specified
 view.
 If any change is made to the structure of a base relation or to the access
 paths maintained on it, the POPs of all views defined on that relation
 are invalidated, and each view must be reoptimized to form a new POP.
\end_layout

\begin_layout Itemize
When a view is accessed via the RDI operators OPEN and FETCH, the POP for
 the view can be used directly to materialize the tuples of the view.
\end_layout

\begin_layout Subsection
PostgreSQL in relation to System R
\end_layout

\begin_layout Standard
Here, we are going to examine how PostgreSQL is similar or different to
 the characteristics of System R:
\end_layout

\begin_layout Itemize

\series bold
Catalog
\series default
: PostgreSQL also maintains a catalog, with similar information about the
 relations, indexes, views,...
 of the system.
\end_layout

\begin_layout Itemize

\series bold
Tuple Identifier (TID)
\series default
: PostgreSQL also has the concept of TID, being it a pair 
\begin_inset Formula $\left(b,e\right)$
\end_inset

, where 
\begin_inset Formula $b$
\end_inset

 indicates the memory block in which the tuple is stored, and 
\begin_inset Formula $e$
\end_inset

 is the position where the tuple starts.
\end_layout

\begin_layout Itemize

\series bold
Image / Clustering image
\series default
: the concept of image is called just index in PostgreSQL, but they are
 extended.
 PostgreSQL defines several types of indexes, and not all of them are ordered.
 For instance, a Hash Index is an unordered index, but a BTree index is
 an ordered index, which would be the most similar one to the concept of
 image in System R.
 PostgreSQL also allows to cluster, but the clustering is made at one point
 in time, using a particular index: this means that subsequent insertions
 will not be done to maintain the clustering property
\begin_inset Foot
status open

\begin_layout Plain Layout
If one wishes to do this, the clustering would need to be redone.
\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize

\series bold
View
\series default
: views in PostgreSQL are very similar to views in System R.
 They can be thought as a stored query, very similar to what happens in
 System R.
 Views are automatically updated when the underlying tables are updated.
 The difference comes when one tries to directly modify a view.
 PostgreSQL has the concept of 
\series bold
Updatable view
\series default
, which are views that can be modified with INSERT, UPDATE or DELETE.
 This views are views that meet the conditions:
\end_layout

\begin_deeper
\begin_layout Itemize
The defining query of the view must have exactly one entry in the FROM clause,
 which can be a table or another updatable view.
\end_layout

\begin_layout Itemize
The defining query must not contain one of the following clauses at the
 top level: GROUP BY, HAVING, LIMIT, OFFSET, DISTINCT, WITH, UNION, INTERSECT,
 and EXCEPT.
 
\end_layout

\begin_layout Itemize
The selection list must not contain any window function , any set-returning
 function, or any aggregate function such as SUM, COUNT, AVG, MIN, and MAX.
\end_layout

\begin_layout Standard
If one tries to modify a updatable view, the system will automatically generate
 the query that performs the appropriate modification in the base table.
 Note that there are some columns that are not modifiable: if one tried
 to modify one of these columns, an error would be raised.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Cost-based query optimization
\series default
: PostgreSQL also has an optimizer that select the best execution plan among
 several equivalent plans with the objective of minimizing the expected
 cost.
\end_layout

\begin_layout Itemize

\series bold
Access path
\series default
: access path specify the path chosen by the system to retrieve the requested
 tuples from a relation.
 As we have seen so far, System R has basically five types of access paths:
 sequential scan, images, binary paths, order-and-scan and TID-scan.
 PostgreSQL defines a wider variety of access path: sequential scan, order-and-s
can, TID-scan, hash indexes, BTree indexes, BitMap indexes,...
\end_layout

\begin_layout Section
Query Optimization
\end_layout

\begin_layout Standard
As we have seen until now, there are alternative ways to evaluate a given
 query: there are equivalent RA expression for the same query, and also
 there are different methods that can physically execute a given query.
\end_layout

\begin_layout Standard
An 
\series bold
evaluation plan 
\series default
defines exactly what algorithm is ued for each operation and how the execution
 of the operations is coordinated.
\end_layout

\begin_layout Subsection
Cost-based query optimization
\end_layout

\begin_layout Standard
Cost difference between evaluation plans for a query can be enormous.
 The general steps in cost-based query optimization are as in System R:
\end_layout

\begin_layout Enumerate
Generate logically equivalent expressions using equivalence rules.
\end_layout

\begin_layout Enumerate
Annotate resultant expressions to get alternative query plans.
\end_layout

\begin_layout Enumerate
Choose the cheapest plan based on the estimated cost.
\end_layout

\begin_layout Standard
The 
\series bold
estimation of the cost
\series default
 is based on:
\end_layout

\begin_layout Itemize
Statistical information about relations.
\end_layout

\begin_layout Itemize
Statistics estimation for intermediate result.
\end_layout

\begin_layout Itemize
Cost formulae for algorithms, computed using statistics.
\end_layout

\begin_layout Subsection
Viewing query evaluation plans
\end_layout

\begin_layout Standard
Most database support the 
\series bold
EXPLAIN <QUERY>
\series default
 statement, which displays the plan chosen by the optimizer, along with
 the cost estimates that it uses for decision.
\end_layout

\begin_layout Standard
Some databases also support 
\series bold
EXPLAIN ANALYSE <QUERY>
\series default
, which shows actual runtime statistics found by running the query, in addition
 to showing the plan.
\end_layout

\begin_layout Standard
Some databases show the cost as
\begin_inset Formula 
\[
f..l
\]

\end_inset

 where 
\begin_inset Formula $f$
\end_inset

 is the cost of delivering the first tuple and 
\begin_inset Formula $l$
\end_inset

 is the cost of delivering all results.
\end_layout

\begin_layout Subsection
Generating equivalent expressions
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
Two relational algebra expressions are 
\series bold
equivalent
\series default
 if the two expressions generate the same set/bag of tuples on every legal
 database instance.
\end_layout

\begin_layout Definition
An 
\series bold
equivalence rule
\series default
 between two expressions ensure that both expressions are equivalent.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now, we are going to list some equivalence rules:
\end_layout

\begin_layout Enumerate
Conjunctive selection can be deconstructed into a sequence of individual
 selections:
\begin_inset Formula 
\[
\sigma_{P_{1}\land P_{2}}\left(E\right)\equiv\sigma_{P_{1}}\left(\sigma_{P_{2}}\left(E\right)\right).
\]

\end_inset


\end_layout

\begin_layout Enumerate
Selection is commutative:
\begin_inset Formula 
\[
\sigma_{P_{1}}\left(\sigma_{P_{2}}\left(E\right)\right)\equiv\sigma_{P_{2}}\left(\sigma_{P_{1}}\left(E\right)\right).
\]

\end_inset


\end_layout

\begin_layout Enumerate
In a sequence of projections, where 
\begin_inset Formula $L_{1}\subset L_{2}\subset...\subset L_{n}$
\end_inset

, only the outermost one is needed:
\begin_inset Formula 
\[
\Pi_{L_{1}}\left(\pi_{L_{2}}\left(...\left(\pi_{L_{n}}\left(E\right)\right)\right)\right)\equiv\Pi_{L_{1}}\left(E\right).
\]

\end_inset


\end_layout

\begin_layout Enumerate
Selections can be combined with cartesian products and theta joins:
\begin_inset Formula 
\[
\sigma_{P}\left(E_{1}\times E_{2}\right)\equiv E_{1}\bowtie_{P}E_{2},
\]

\end_inset


\begin_inset Formula 
\[
\sigma_{P_{1}}\left(E_{1}\bowtie_{P_{2}}E_{2}\right)\equiv E_{1}\bowtie_{P_{1}\land P_{2}}E_{2}.
\]

\end_inset


\end_layout

\begin_layout Enumerate
Theta join operations are commutative
\begin_inset Formula 
\[
E_{1}\bowtie E_{2}\equiv E_{2}\bowtie E_{1}.
\]

\end_inset


\end_layout

\begin_layout Enumerate
And they are associative, in a soft manner:
\end_layout

\begin_deeper
\begin_layout Enumerate
The natural join is associative:
\begin_inset Formula 
\[
\left(E_{1}\bowtie E_{2}\right)\bowtie E_{3}\equiv E_{1}\bowtie\left(E_{2}\bowtie E_{3}\right).
\]

\end_inset


\end_layout

\begin_layout Enumerate
The thetha join is associative in a soft sense:
\begin_inset Formula 
\[
\left(E_{1}\bowtie_{P_{1}}E_{2}\right)\bowtie_{P_{2}\land P_{3}}E_{3}\equiv E_{1}\bowtie_{P_{1}\land P_{3}}\left(E_{2}\bowtie_{P_{2}}E_{3}\right),
\]

\end_inset

 where 
\begin_inset Formula $P_{3}$
\end_inset

 involves attributes that are present in the three relations.
\end_layout

\begin_layout Standard
When we can decide the order of the joins, we would choose the smaller join
 to be performed before, so that we compute and store a smaller temporary
 relation.
\end_layout

\end_deeper
\begin_layout Enumerate
The selection operation distributes over the theta join operation in the
 following two situations:
\end_layout

\begin_deeper
\begin_layout Enumerate
When all the attributes in 
\begin_inset Formula $P_{0}$
\end_inset

 involve only the attributes of one of the expressions being joined:
\begin_inset Formula 
\[
\sigma_{P_{0}}\left(E_{1}\bowtie_{P}E_{2}\right)\equiv\sigma_{P_{0}}\left(E_{1}\right)\bowtie_{P}E_{2}.
\]

\end_inset


\end_layout

\begin_layout Enumerate
When 
\begin_inset Formula $P_{1}$
\end_inset

 involves only the attributes of 
\begin_inset Formula $E_{1}$
\end_inset

 and 
\begin_inset Formula $P_{2}$
\end_inset

 involves only the attributes of 
\begin_inset Formula $E_{2}$
\end_inset

:
\begin_inset Formula 
\[
\sigma_{P_{1}\land P_{2}}\left(E_{1}\bowtie_{P}E_{2}\right)\equiv\sigma_{P_{1}}\left(E_{1}\right)\bowtie_{P}\sigma_{P_{2}}\left(E_{2}\right).
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
The projection operation distributes over the theta join operation as follows:
 If 
\begin_inset Formula $P$
\end_inset

 involves only attributes from 
\begin_inset Formula $L_{1}\cup L_{2}$
\end_inset

:
\begin_inset Formula 
\[
\Pi_{L_{1}\cup L_{2}}\left(E_{1}\bowtie_{P}E_{2}\right)\equiv\Pi_{L_{1}}\left(E_{1}\right)\bowtie_{P}\Pi_{L_{2}}\left(E_{2}\right).
\]

\end_inset

 Similar equivalences hold for outerjoin operations.
\end_layout

\begin_layout Enumerate
Union and intersection are commutative:
\begin_inset Formula 
\[
E_{1}\cup E_{2}\equiv E_{2}\cup E_{1},
\]

\end_inset


\begin_inset Formula 
\[
E_{1}\cap E_{2}\equiv E_{2}\cap E_{1}.
\]

\end_inset


\end_layout

\begin_layout Enumerate
Union and intersection are associative:
\begin_inset Formula 
\[
\left(E_{1}\cup E_{2}\right)\cup E_{3}\equiv E_{1}\cup\left(E_{2}\cup E_{3}\right),
\]

\end_inset


\begin_inset Formula 
\[
\left(E_{1}\cap E_{2}\right)\cap E_{3}\equiv E_{1}\cap\left(E_{2}\cap E_{3}\right).
\]

\end_inset


\end_layout

\begin_layout Enumerate
The selection operation distributes over 
\begin_inset Formula $\cup,\cap$
\end_inset

 and 
\begin_inset Formula $-$
\end_inset

:
\begin_inset Formula 
\[
\sigma_{P}\left(E_{1}\cup E_{2}\right)\equiv\sigma_{P}\left(E_{1}\right)\cup\sigma_{P}\left(E_{2}\right),
\]

\end_inset


\begin_inset Formula 
\[
\sigma_{P}\left(E_{1}\cap E_{2}\right)\equiv\sigma_{P}\left(E_{1}\right)\cap\sigma_{P}\left(E_{2}\right),
\]

\end_inset


\begin_inset Formula 
\[
\sigma_{P}\left(E_{1}-E_{2}\right)\equiv\sigma_{P}\left(E_{1}\right)-\sigma_{P}\left(E_{2}\right),
\]

\end_inset


\begin_inset Formula 
\[
\sigma_{P}\left(E_{1}\cap E_{2}\right)\equiv\sigma_{P}\left(E_{1}\right)\cap E_{2},
\]

\end_inset


\begin_inset Formula 
\[
\sigma_{P}\left(E_{1}-E_{2}\right)\equiv\sigma_{P}\left(E_{1}\right)-E_{2}.
\]

\end_inset


\end_layout

\begin_layout Enumerate
The projection operation distributes over union:
\begin_inset Formula 
\[
\Pi_{L}\left(E_{1}\cup E_{2}\right)\equiv\Pi_{L}\left(E_{1}\right)\cup\Pi_{L}\left(E_{2}\right).
\]

\end_inset

 
\end_layout

\begin_layout Example
Pushing selections.
\end_layout

\begin_layout Example
Query: find the names of all instructors in the Music department, along
 with the title of the courses that they teach.
\end_layout

\begin_layout Example
A first RA expression could be the following:
\begin_inset Formula 
\[
\Pi_{name,title}\left(\sigma_{dpt\_name='Music'}\left(Instructor\bowtie\left(Teaches\bowtie\Pi_{course\_id,title}\left(Course\right)\right)\right)\right).
\]

\end_inset

 It can be transformed using rule 7a:
\begin_inset Formula 
\[
\Pi_{name,title}\left(\left(\sigma_{dpt\_name='Music'}\left(Instructor\right)\right)\bowtie\left(Teaches\right)\bowtie\Pi_{course\_id,title}\left(Course\right)\right).
\]

\end_inset

 The advantage of doing this is taht by performing the selection as early
 as possible we are reducing the size of the relation to be joined.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Example
Pushing projections.
\end_layout

\begin_layout Example
We start with the RA expression:
\begin_inset Formula 
\[
\Pi_{name,title}\left(\left(\sigma_{dpt\_name='Music'}\left(Instructor\right)\bowtie Teaches\right)\bowtie\Pi_{course\_id,title}\left(Course\right)\right).
\]

\end_inset

 When we compute 
\begin_inset Formula 
\[
\sigma_{dpt\_name='Music'}\left(Instructor\right)\bowtie Teaches,
\]

\end_inset

 we obtain a relation with schema 
\begin_inset Formula $\left(ID,name,dpt\_name,salary,course\_id,sec\_id,semester,year\right)$
\end_inset

.
 Equivalence rule 8 allows to push projections, eeliminating unneeded attributes
 from intermediate results to get:
\begin_inset Formula 
\[
\Pi_{name,title}\left(\left(\Pi_{name,course\_id}\left(\sigma_{dpt\_name='Music'}\left(Instructor\right)\bowtie Teaches\right)\right)\bowtie\Pi_{course\_id,title}\left(Course\right)\right).
\]

\end_inset

 This is useful because performing the projection as early as possible reduces
 the size of the relation to be joined.
 Note that 
\begin_inset Formula $course\_id$
\end_inset

 needs to be projected because it is needed for the join.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Example
Join ordering.
\end_layout

\begin_layout Example
Consider the expression
\begin_inset Formula 
\[
\Pi_{name,title}\left(\left(\sigma_{dpt\_name='Music'}\left(Instructor\right)\bowtie Teaches\right)\bowtie\Pi_{course\_id,title}\left(Course\right)\right).
\]

\end_inset

 In this case, we could compute
\begin_inset Formula 
\[
Teaches\bowtie\Pi_{course\_id,title}\left(Course\right)
\]

\end_inset

 first, and then join the result with the left relation.
 The problem with this approach is that doing this join first seems more
 likely to be large, as only a small fraction of the university's instructor
 are going to be from the Music department.
 So it is better to leave the query as is.
\end_layout

\begin_layout Subsection
Enumeration of equivalent expressions
\end_layout

\begin_layout Standard
Query optimizers use equivalence rules to systematically generate expressions
 equivalent to the given expression, which is a first translation of the
 query.
\end_layout

\begin_layout Standard
All the equivalent expressions can be generated with the following approach:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "morekeywords={REPEAT,APPLY,ADD,ON,UNTIL,TO}"
inline false
status open

\begin_layout Plain Layout

REPEAT
\end_layout

\begin_layout Plain Layout

	APPLY all applicable equivalence rules 
\end_layout

\begin_layout Plain Layout

		ON every subexpression of every equivalent expression found so far
\end_layout

\begin_layout Plain Layout

	ADD newly generated expressions 
\end_layout

\begin_layout Plain Layout

		TO the set of equivalent expressions
\end_layout

\begin_layout Plain Layout

UNTIL no new equivalent expressions are generated
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Cost estimation
\end_layout

\begin_layout Standard
The optimizer takes into account the cost of each operator and the statistics
 of the input relations, such as the number of tuples and the sizes of the
 tuples.
 Also, inputs can be results of sub-expressions, so we need to estimate
 estatistics of these results.
 For this purpose, more statistics, such as the number of distinct values
 for an attribute, are used.
\end_layout

\begin_layout Subsection
Choice of execution plan
\end_layout

\begin_layout Standard
Once we have generated different equivalent expressions, we need to decide
 which one to use to execute the query and get the results.
 For this, we must consider the interaction of evaluation techniques, because
 choosing the cheapest algorithm for each operation disregarding the others
 may not yield best overall algorithm.
 For example, a merge-join may be costlier than a hash-join, but may provide
 a sorted output which could reduce the cost for an outer level aggregation.
\end_layout

\begin_layout Standard
Practical query optimizers incorporate elements of two broad approaches:
\end_layout

\begin_layout Enumerate
Search all the plans and choose the best plan in a cost-based fashion.
\end_layout

\begin_layout Enumerate
Uses heuristics to choose a plan.
\end_layout

\begin_layout Subsubsection
Best join-order problem
\end_layout

\begin_layout Standard

\series bold
Problem:
\series default
 find the best join-order for
\begin_inset Formula 
\[
R_{1}\bowtie R_{2}\bowtie...\bowtie R_{n}.
\]

\end_inset


\end_layout

\begin_layout Standard
A first idea could be to check all possibilities and choose the cheapest
 one.
 But...
\end_layout

\begin_layout Proposition
For the best join-order problem, with 
\begin_inset Formula $n$
\end_inset

 relations involved, there are
\begin_inset Formula 
\[
\frac{\left(2\left(n-1\right)\right)!}{n-1}
\]

\end_inset

 different possible join orders.
\end_layout

\begin_layout Proof
First, we need to count all possible orderings, i.e.
 the number of permutations, which is known to be 
\begin_inset Formula $n!$
\end_inset

.
 Now, we have to count all possible ways to assign the 
\begin_inset Formula $n-1$
\end_inset

 needed parenthesis.
 This is known to be the Catalan number
\begin_inset Foot
status open

\begin_layout Plain Layout
See 
\begin_inset CommandInset href
LatexCommand href
name "Catalan Numbers"
target "https://en.wikipedia.org/wiki/Catalan_number#Applications_in_combinatorics"
literal "false"

\end_inset

.
\end_layout

\end_inset


\begin_inset Formula 
\[
\#()_{n-1}=C_{n-1}=\frac{\left(2\left(n-1\right)\right)!}{n!\left(n-1\right)!}.
\]

\end_inset


\end_layout

\begin_layout Proof
Thus, the total amount is
\begin_inset Formula 
\[
n!\cdot C_{n-1}=n!\times\frac{\left(2\left(n-1\right)\right)!}{n!\left(n-1\right)!}=\frac{\left(2\left(n-1\right)\right)!}{\left(n-1\right)!}.
\]

\end_inset


\end_layout

\begin_layout Standard
This number is huge, and it is unfeasable to check the whole search space.
 Thus, a different approach is needed.
\end_layout

\begin_layout Subsubsection*
Dynamic programming approach
\end_layout

\begin_layout Standard
Using dynamic programming, the least-cost join for any subset of 
\begin_inset Formula $\left\{ R_{1},...,R_{n}\right\} $
\end_inset

 is computed only once and stored for future use.
 The algorithm works as follows:
\end_layout

\begin_layout Itemize
Consider all possible plans of the form
\begin_inset Formula 
\[
S_{1}\bowtie\left(S-S_{1}\right),
\]

\end_inset

 where 
\begin_inset Formula $S_{1}$
\end_inset

 is any non-empty subset of 
\begin_inset Formula $S$
\end_inset

.
\end_layout

\begin_layout Itemize
Recursively compute costs for joinin subsets of 
\begin_inset Formula $S$
\end_inset

 to find the cost of each plan.
 Choose the cheapest of the 
\begin_inset Formula $2^{n}-2$
\end_inset

 alternatives.
\end_layout

\begin_layout Itemize

\series bold
Base case
\series default
: single relation access plan.
\end_layout

\begin_deeper
\begin_layout Itemize
Apply all selections on 
\begin_inset Formula $R_{i}$
\end_inset

 using best choice of indices on 
\begin_inset Formula $R_{i}$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize
When the plan for any subset is computed, we store it and reuse it when
 it is required again, instead of recomputing it.
\end_layout

\begin_layout Standard
The pseudocode is shown in Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:procedure-findbestplan(S)"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "morekeywords={if, return, set, and, else, for, each, of}"
inline false
status open

\begin_layout Plain Layout

if (bestplan[S].cost != infty)
\end_layout

\begin_layout Plain Layout

	return bestplan[S]¯
\end_layout

\begin_layout Plain Layout

// else it has not been computed yet
\end_layout

\begin_layout Plain Layout

if (S contains only 1 relation)
\end_layout

\begin_layout Plain Layout

	set bestplan[S].plan and bestplan[S].cost 
\end_layout

\begin_layout Plain Layout

		based on the best way to access S
\end_layout

\begin_layout Plain Layout

else for each non-empty proper subset S1 of S
\end_layout

\begin_layout Plain Layout

	P1 = findbestplan(S1)
\end_layout

\begin_layout Plain Layout

	P2 = findbestplan(S - S1)
\end_layout

\begin_layout Plain Layout

	A = best algorithm for joining P1 and P2
\end_layout

\begin_layout Plain Layout

	cost = P1.cost + P2.cost + A.cost
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	if cost < bestplan[S].cost
\end_layout

\begin_layout Plain Layout

		bestplan[S].cost = cost
\end_layout

\begin_layout Plain Layout

		bestplan[S].plan = plan
\end_layout

\begin_layout Plain Layout

	return bestplan[S]
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout

\series bold
\begin_inset CommandInset label
LatexCommand label
name "alg:procedure-findbestplan(S)"

\end_inset

procedure 
\series default
findbestplan(S)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The time complexity of this algorithm is 
\begin_inset Formula $O\left(3^{n}\right)$
\end_inset

 and the space complexity is 
\begin_inset Formula $O\left(2^{n}\right)$
\end_inset

.
 This is a huge gain with respect to checking the whole search space, but
 it is still a very high cost.
\end_layout

\begin_layout Subsubsection*
Left-deep join trees
\end_layout

\begin_layout Standard
In left-deep join trees, the right-hand-side input for each join is a relation,
 not the result of an intermediate join.
 In Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:A-left-deep-join"
plural "false"
caps "false"
noprefix "false"

\end_inset

 we can see an example of what is a left-deep join tree, and what is not.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula 
\[
\xymatrix{ &  &  &  & \bowtie\ar@{-}[dl]\ar@{-}[dr]\\
 &  &  & \bowtie\ar@{-}[dl]\ar@{-}[dr] &  & R_{5}\\
 &  & \bowtie\ar@{-}[dl]\ar@{-}[dr] &  & R_{4}\\
 & \bowtie\ar@{-}[dl]\ar@{-}[dr] &  & R_{3}\\
R_{1} &  & R_{2}
}
\]

\end_inset

 
\begin_inset Formula 
\[
\xymatrix{ &  &  & \bowtie\ar@{-}[dl]\ar@{-}[dr]\\
 &  & \bowtie\ar@{-}[dl]\ar@{-}[dr] &  & \bowtie\ar@{-}[d]\ar@{-}[dr]\\
 & \bowtie\ar@{-}[dl]\ar@{-}[dr] &  & R_{3} & R_{4} & R_{5}\\
R_{1} &  & R_{2}\\
\\
}
\]

\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:A-left-deep-join"

\end_inset

A left-deep join tree (top) and not a left-deep join tree (bottom).
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
With this structure, we can reduce the cost of the optimization problem.
\end_layout

\begin_layout Standard
For a set of 
\begin_inset Formula $n$
\end_inset

 relations, we can consider 
\begin_inset Formula $n$
\end_inset

 alternatives with one relation as right-hand-side input and the other relations
 as left-hand-side input.
\end_layout

\begin_layout Standard
The time complexity of finding the best join order is in this case 
\begin_inset Formula $O\left(n2^{n}\right)$
\end_inset

 and the space complexity remains the same.
\end_layout

\begin_layout Standard
At this points, one might think that it is of no use bothering with optimizing
 the order of queries, if it so costful, but, in reality, typical queries
 have a small 
\begin_inset Formula $n$
\end_inset

, usually less than 10, and a good ordering can change a query from being
 unfeasable to being executed in an acceptable time.
\end_layout

\begin_layout Subsubsection*
Heuristic optimization
\end_layout

\begin_layout Standard
As we have seen, cost-based optimization is expensive, even using dynamic
 programming.
\end_layout

\begin_layout Standard

\series bold
Heuristic optimization
\series default
 transforms the query-tree by using a set of rules that typically improve
 execution performance.
 These rules can include:
\end_layout

\begin_layout Itemize
Perform selection early.
\end_layout

\begin_layout Itemize
Perform projection early.
\end_layout

\begin_layout Itemize
Peform most restrictive selection and join operations before other similar
 operations.
\end_layout

\begin_layout Standard
Some systems use only heuristics, while others combine the two approaches.
 A frequently used approach is the following:
\end_layout

\begin_layout Enumerate
Heuristic rewriting of nested block structure and aggregation.
\end_layout

\begin_layout Enumerate
A cost-based join-order optimization for each block.
\end_layout

\begin_layout Standard
There is usually an 
\series bold
optimization cost budget
\series default
 to stop optimization early if the cost of the plan is less than the cost
 of the optimizations to be made.
\end_layout

\begin_layout Standard
Also, it can be useful to implement 
\series bold
plan caching
\series default
 to reuse previouly computed plans if queries are resubmitted.
\end_layout

\begin_layout Standard
It is worth to note that even with the use of heuristics, cost-based query
 optimization imposes a substantial overhead in the computations, but it
 is worthy for expensive queries.
 For this reason, optimizers often use simple heristics for cheap queries,
 and perform a more exhaustive enumeration for more expensive queries.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Indexing
\end_layout

\begin_layout Section
Conventional indexes
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
An 
\series bold
index
\series default
 is a data structure that facilitates the recovering of data.
 The idea is to maintain pointers to the specific directions where some
 data is stored.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As we know, the disk can be logically seen as a sequence of pages of a certain
 size.
 Every file that we store in a computer must be stored in one or more pages.
 Now, imagine we want to retrieve a file's content.
 For this, we need to fetch the data from where it is stored.
 If we don't use indexes, we would need to sequentially traverse the disk
 until we find the desired file.
\end_layout

\begin_layout Example
Imagine a simplified setup with a disk of 
\begin_inset Formula $N$
\end_inset

 pages and with files that occupy one page.
 If we need to recover a specific file that is stored in memory, without
 further information, it would take an average of 
\begin_inset Formula $\frac{N}{2}$
\end_inset

 pages to be fetched.
\end_layout

\begin_layout Standard
An index can be used to mitigate this impact.
 There are multiple types of indexes, but the simplest form of an index
 is just a map in which each file identifier is associated to the direction
 of its first byte in memory.
 This way, only knowing which file we want to recover, we can access it
 directly using the index.
\end_layout

\begin_layout Example
In the previous setup, imagine we store an index in the first page.
 In this scenario, to recover a specific file we need to fetch the first
 page, look the index to get the direction of our file, and directly fetch
 the correct page.
 In total, we would fetch 2 pages.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
A 
\series bold
dense index
\series default
 is an index that maintains one pointer per key.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Properties of dense indexes:
\end_layout

\begin_layout Itemize
If a key is not listed, the key does not exist.
\end_layout

\begin_layout Itemize
They can be used in sequential and non-sequential files.
\end_layout

\begin_layout Itemize
Querying a dense index is more efficient than querying a sequential file
 because we will likely retrieve less pages from disk to memory.
\end_layout

\begin_layout Itemize
They are usually ordered, so searchs can be done using the binary search
 algorithm.
\end_layout

\begin_layout Example
A dense index.
\end_layout

\begin_layout Example
A dense index on a sequential file looks like this:
\end_layout

\begin_layout Example
\begin_inset Graphics
	filename dense_idx_seq.png
	scale 60

\end_inset


\end_layout

\begin_layout Example
And on a non-sequential file like this:
\end_layout

\begin_layout Example
\begin_inset Graphics
	filename dense_idx_nonseq.png
	scale 60

\end_inset


\end_layout

\begin_layout Example
If we want to retrieve the segment with key=30, we would do binary search
 in the index and then we would get the disk direction of this segment.
\end_layout

\begin_layout Example
If we are asked to retrieve a segment with a key that is not in the index,
 we would directly return an error after searching for it and not finding
 it, because we are sure there is no segment with that key in the disk.
 For example, there is no segment with key 25, and so there is no entry
 in the index with key 25.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
A 
\series bold
sparse index
\series default
 maintains a pointer per page/block.
 This means that only the first key on the each block.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Properties of sparse index:
\end_layout

\begin_layout Itemize
They are also sorted, so binary search can be conducted to find the requested
 key.
 In this case, we are looking for the biggest key that is less than the
 requested key.
 We then would go to the page where this key is and scan sequentially until
 we reach the requested key or a key bigger than it, in which case we would
 return an error.
\end_layout

\begin_layout Itemize
They need less space than dense indexes.
\end_layout

\begin_layout Itemize
Can only be used in sequential files, because the basic idea for sparse
 indexes to work is that data is sorted in the same way as the index.
\end_layout

\begin_layout Example
Sparse index.
\end_layout

\begin_layout Example
A sparse index looks like this:
\end_layout

\begin_layout Example
\begin_inset Graphics
	filename sparse_idx_seq.png
	scale 60

\end_inset


\end_layout

\begin_layout Example
If we want to retrieve the segment with key=30, the procedure is exactly
 as with a dense index.
\end_layout

\begin_layout Example
If we want to retrieve the segment with key=40, then we would search for
 30 (the biggest key smaller than 40), we would go to where it is.
 Then, we would advance until we found the segment with key=40.
\end_layout

\begin_layout Example
If we want to retrieve the segment with key=25, we would search for 10,
 we would go to where it is.
 Then, we would advance until we reached the end of the page, and we would
 return an error, because now we are sure there is no segment with key=25.
\end_layout

\begin_layout Subsection
Sparse second level index
\end_layout

\begin_layout Standard
When an index becomes very big, the searchs start to slow down, because
 the binary search needs to be done over a bigger index, which can even
 occupy several pages, which would need to be fetched.
 
\end_layout

\begin_layout Standard
When this happen, a possible way to speed up the search is to add a sparse
 index that points to the already defined index.
\end_layout

\begin_layout Example
A second level sparse index.
\end_layout

\begin_layout Example
In this diagram we can see a second level sparse index on a sparse index:
\end_layout

\begin_layout Example
\begin_inset Graphics
	filename sparse_idx_2nd_lvl.png
	scale 50

\end_inset


\end_layout

\begin_layout Example
If we wanted to retrieve the segment with key=30, we would check the 2nd
 level sparse index, we would get the page where the index should have this
 key stored.
 We would go to this page, and we would find the key=30 already in the index,
 so we would go to the indicated direction.
\end_layout

\begin_layout Standard

\series bold
Question:
\series default
 does it make sense to use a second level dense index?
\end_layout

\begin_layout Standard
No, it would be a copy of the first level index, so we would not gain anything.
 Second level indexes are sparse.
 Note, nonetheless, that the first level index can indeed be of any kind.
\end_layout

\begin_layout Standard

\series bold
Question:
\series default
 what is the tradeoff between sparse and dense indexes?
\end_layout

\begin_layout Standard
Sparse indexes needs less space to be stored and this also allows to have
 a bigger part of the index in memory when we need it.
 On the other hand, dense indexes can tell if any record exists without
 accessing the files.
\end_layout

\begin_layout Subsection
How to deal with duplicate keys.
\end_layout

\begin_layout Standard
Imagine we have a disk with the following data:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename dup_keys_disk.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
A naïve solution would be to just use a dense index, where all the keys
 are listed repeatedly:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename dup_keys_dense_idx.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
In this case, we are solving the problem of duplicate keys...
 but we are probably using more space that we wanted.
 It would be better to have unique keys in the indexes.
 Thus, a second approach could be to only store the first appearance of
 each key, and use it to fetch the data, scanning sequentially until all
 records with the same key have been retrieved.
 This is illustrated below:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename dup_keys_2ndway.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
See, nonetheless, that this solution requires that the file is sequentially
 stored in memory, because when we recover the second segment with key=10,
 in order to recover the third one, the only possible way is to continue
 a sequential scan.
\end_layout

\begin_layout Standard
Now, a third approach is an intermediate approach: we can use a sparse index
 with duplicate keys, meaning we index the first key in each page:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename dup_keys_sparse.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
In this case, when we want to search for a key, we always need to go to
 the biggest key that is smaller than the requested one, even if the requested
 one is in the index keyset.
 For example, if in the example above we used the indexed direction for
 key=20, we would miss the first record of this key.
\end_layout

\begin_layout Standard
An improved version of this solution is to index only the first new key
 in each page:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename dup_keys_sparse_v2.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
Note that in this case, all keys will be listed once, so we don't need to
 retrieve the file for inexistent keys, but sequentially ios required.
\end_layout

\begin_layout Subsection
How to delete records
\end_layout

\begin_layout Subsubsection
Deletion from sparse index with no duplicates
\end_layout

\begin_layout Standard
If we want to delete a record, we need to make sure that the index is updated
 if needed.
 The steps to delete a record are the following:
\end_layout

\begin_layout Enumerate
To delete key 
\begin_inset Formula $K$
\end_inset

, do a binary search in the index.
\end_layout

\begin_layout Enumerate
Depending if 
\begin_inset Formula $K$
\end_inset

 is in the index or not:
\end_layout

\begin_deeper
\begin_layout Enumerate
If 
\begin_inset Formula $K$
\end_inset

 is not in the index we visit the direction of the biggest key that is smaller
 than the requested one.
 We advance until we find the record with key 
\begin_inset Formula $K$
\end_inset

 and we delete it.
\end_layout

\begin_layout Enumerate
If 
\begin_inset Formula $K$
\end_inset

 is in the index, we visit its direction and we delete it.
 Now, two possibilities arise:
\end_layout

\begin_deeper
\begin_layout Enumerate
If there are more records in the same page, we shift them up, and we update
 the key.
\end_layout

\begin_layout Enumerate
If there no more records in the same page, we delete the key from the index
 and we shift the rest of the keys up.
\end_layout

\end_deeper
\end_deeper
\begin_layout Example
Case 2.(a): DELETE 40
\end_layout

\begin_layout Example
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Initial state
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Final state
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename sparse_idx_seq.png
	scale 40

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename sparse_idx_delete40.png
	scale 40

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Legend
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Red
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Delete
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Example
Case 2.(b).i.: DELETE 30
\end_layout

\begin_layout Example
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Initial state
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Second state
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Final state
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename sparse_idx_seq.png
	scale 25

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename sparse_idx_delete30_1.png
	scale 25

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename sparse_idx_delete30_2.png
	scale 25

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Legend
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Red
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Delete
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yellow
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Update
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Example
Case 2.(b).ii.: DELETE 30 and 40
\end_layout

\begin_layout Example
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Initial state
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Second state
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Final state
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename sparse_idx_seq.png
	scale 25

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename sparse_idx_delete3040_1.png
	scale 25

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename sparse_idx_delete3040_2.png
	scale 25

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Legend
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Red
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Delete
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yellow
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Update
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Subsubsection
Deletion from dense index
\end_layout

\begin_layout Standard
In this case, we will always find the keys to delete in the index, so the
 steps are easier:
\end_layout

\begin_layout Enumerate
To delete key 
\begin_inset Formula $K$
\end_inset

, do a binary search on the index.
\end_layout

\begin_layout Enumerate
Delete records in the corresponding page, shifting up the rest of the records
 to not leave holes.
\end_layout

\begin_layout Enumerate
Update all shifted records.
\end_layout

\begin_layout Example
Deletion from dense index: DELETE 30
\end_layout

\begin_layout Example
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Initial state
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Second state
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Final state
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename dense_idx_seq.png
	scale 25

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename dense_idx_delete30_1.png
	scale 25

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename dense_idx_delete30_2.png
	scale 25

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Legend
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Red
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Delete
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yellow
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Update
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
How to insert records
\end_layout

\begin_layout Standard
We need to follow the next steps
\begin_inset Foot
status open

\begin_layout Plain Layout
The steps are analogous for sparse and dense indexes.
\end_layout

\end_inset

:
\end_layout

\begin_layout Enumerate
We want to insert record with key 
\begin_inset Formula $K$
\end_inset

.
 First, we do a binary search to see where it should be located.
\end_layout

\begin_layout Enumerate
Now, in the first page that it can be located according to the index, two
 things can happen:
\end_layout

\begin_deeper
\begin_layout Enumerate
If there is space for the record: we insert it.
\end_layout

\begin_layout Enumerate
If there is not space for the record: we need to shift the following records
 down, updating the necessary index entries.
\end_layout

\end_deeper
\begin_layout Example
INSERT 15
\end_layout

\begin_layout Example
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Initial state
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Second state
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Final state
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename sparse_idx_insert_0.png
	scale 25

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename sparse_idx_insert_1.png
	scale 25

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename sparse_idx_insert_2.png
	scale 25

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Legend
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Red
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Delete
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yellow
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Update
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Green
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Insert
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
Secondary indexes
\end_layout

\begin_layout Standard
Imagine we have an unordered file in memory, which we would like to be able
 to traverse in order without implying great costs.
 If we try to do this by sequentially scanning the disk, we would need to
 fetch several times each page and it would be highly inneficient, so we
 could think on using indexes to solve this problem.
\end_layout

\begin_layout Standard
As we have seen, sparse indexes cannot be used with unordered files (some
 records would be lost), so our only option here is to use an ordered dense
 index that enables us to recover each record in the desired order.
 Now, as we are indexing the whole file with an dense index, it is likely
 that the index is huge, so it seems convenient to add a second level sparse
 index to speed things up even more.
\end_layout

\begin_layout Standard
This is a secondary index:
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
A 
\series bold
secondary index
\series default
 is a 
\begin_inset Formula $N$
\end_inset

-level index structure, composed by a first-level dense index and the rest
 of the levels are sparse.
 All this indexes are ordered to make use of binary search, in order to
 be capable of recovering unsequentially stored records from disk efficiently.
 
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Duplicate values and secondary indexes
\end_layout

\begin_layout Standard
Again, duplicate keys pose a problem to secondary indexes.
 Think in the following setup:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename second_index_disk.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
Here, the solutions that we proposed before don't work, because for them
 we needed sequentially stored files.
 In this case, again, the naïve solution is a dense index:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename second_index_0.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
The problem with this solution is that this cause an excessive overhead,
 both in disk space (we are storing repeatedly the same keys) and in search
 time (because the index keyset needs to be accessed several times per key).
 An alternative is to store only once each key, and associate a list of
 pointers:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename second_index_1.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
But this has the problem that the index entries can have different sizes,
 which difficult the search.
\end_layout

\begin_layout Standard
Another idea is to use buckets of pointers:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename second_index_2.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
This structure is very helpful in some situations, for example when we want
 to get data with some conditions that involves different fields indexed.
\end_layout

\begin_layout Example
Imagine the relation EMP(name,dept,floor), with a primary index on name
 and two secondary indexes with bucket structure in dept and floor.
\end_layout

\begin_layout Example
Now, let's say we want to retrieve all employees in the department 'Toy'
 and in floor 2.
 Our structure make this query very easy:
\end_layout

\begin_layout Example
\begin_inset Graphics
	filename bucket_intersection.png
	scale 50

\end_inset


\end_layout

\begin_layout Example
As we
\end_layout

\begin_layout Section
BTrees
\end_layout

\begin_layout Section
Hashing schemes
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintCited"
bibfiles "dbsa_bib"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
