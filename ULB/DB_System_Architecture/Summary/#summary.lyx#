#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble

\end_preamble
\use_default_options true
\begin_modules
tcolorbox
customHeadersFooters
theorems-ams-bytype
theorems-sec-bytype
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=blue, urlcolor=blue, citecolor=blue, pdfstartview={FitH}, unicode=true"
\papersize a4paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\boxbgcolor #62a0ea
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 3cm
\rightmargin 2cm
\bottommargin 3cm
\headheight 2cm
\headsep 1cm
\footskip 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
INFOH417 - Database Systems Architecture
\end_layout

\begin_layout Date
Fall 2022
\end_layout

\begin_layout Author
Jose Antonio Lorencio Abril
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename ../../Data_Mining/Summary/1200px-Université_libre_de_Bruxelles_(logo).svg.png
	scale 10

\end_inset


\end_layout

\begin_layout Standard
\align right
Professor: Mahmoud Sakr
\end_layout

\begin_layout Standard
\align right
Student e-mail: jose.lorencio.abril@ulb.be
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Address
This is a summary of the course 
\emph on
Database Systems Architecture
\emph default
, taught at the Université Libre de Bruxelles by Professor Mahmoud Sakr
 in the academic year 22/23.
 Most of the content of this document is adapted from the course notes by
 Sakr, 
\begin_inset CommandInset citation
LatexCommand cite
key "Sakr2022"
literal "false"

\end_inset

, so I won't be citing it all the time.
 Other references will be provided when used.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList table

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList algorithm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Query Planning: Translating SQL into Relational Algebra
\end_layout

\begin_layout Section
Relational Algebra
\end_layout

\begin_layout Standard
We are going to start with some definitions:
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
A 
\series bold
relation
\series default
 is a table whose columns have names, called 
\series bold
attributes
\series default
.
 The set of all attributes is called the 
\series bold
schema of the relation
\series default
.
 The rows of the table are tuples of values for each of the attributes,
 and are called simply 
\series bold
tuples
\series default
.
 We are going to denote 
\begin_inset Formula $R$
\end_inset

 a relation, and we will express it as 
\begin_inset Formula $R\sim\left[A_{1},...,A_{n}\right]$
\end_inset

 to indicate the schema of the relation, 
\begin_inset Formula $A_{i},i=1,...,n$
\end_inset

 are the attributes of the schema.
 If two relations, 
\begin_inset Formula $R$
\end_inset

 and 
\begin_inset Formula $R'$
\end_inset

, share the same schema, we will simply write 
\begin_inset Formula $R\simeq R'$
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
Note that the relationship 
\begin_inset Formula $\simeq$
\end_inset

 defines an equivalence relationship whose equivalence groups are all relations
 with the same schema.
\end_layout

\end_inset

.
\end_layout

\begin_layout Definition
A relation is 
\series bold
set-based
\series default
 if there are no duplicate tuples in it.
 If this is not the case, the relation is 
\series bold
bag-based
\series default
.
\end_layout

\begin_layout Definition
A 
\series bold
relational algebra operator
\series default
 takes as input 1 or more relations and produces as output a new relation.
 More formally, if we have a set of relations 
\begin_inset Formula $\Sigma=\left\{ R_{1},...,R_{n}\right\} \subset\mathcal{U}$
\end_inset

, where 
\begin_inset Formula $\mathcal{U}$
\end_inset

 identifies the set of all possible relations, a relational algebra operator
 is a function
\begin_inset Formula 
\[
Op:\mathcal{P}\left(\Sigma\right)\rightarrow\mathcal{U},
\]

\end_inset

 being 
\begin_inset Formula $\mathcal{P}\left(\Sigma\right)$
\end_inset

 the power set of 
\begin_inset Formula $\Sigma$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Example
\begin_inset CommandInset label
LatexCommand label
name "ex:1-1"

\end_inset

As an example, we can take 
\begin_inset Formula $\Sigma=\left\{ StarsIn,MovieStar\right\} $
\end_inset

, 
\begin_inset Formula $StartsIn=\left[starName,filmName\right]$
\end_inset

, 
\begin_inset Formula $MovieStar=\left[name,birthDate\right]$
\end_inset

.
 In this case, an operator 
\begin_inset Formula $Op$
\end_inset

 could be such that produces the relation that contains all names of films
 in which some movie stars in 
\begin_inset Formula $MovieStar$
\end_inset

 born in 1960 participated.
\end_layout

\begin_layout Standard
In this example, we have explained what we would like our operator to do,
 but we need some way to actually compute this.
 For this, there are some basic operators that can be combined to create
 complex operators.
\end_layout

\begin_layout Subsection
The extended relational algebra
\end_layout

\begin_layout Standard
Let's define a set of operators that are useful:
\end_layout

\begin_layout Standard
The 
\series bold
union
\series default
 of two relations with the same schema returns another relation with the
 same schema and all tuples in any of the two input relations: Let 
\begin_inset Formula $R_{i},R_{j}\in\Sigma$
\end_inset

 such that 
\begin_inset Formula $R_{i}\simeq R_{j}$
\end_inset

, then
\begin_inset Formula 
\[
R_{i}\cup R_{j}=\left\{ x|x\in R_{i}\ \lor\ x\in R_{j}\right\} \simeq R_{i}\simeq R_{j}.
\]

\end_inset


\end_layout

\begin_layout Standard
Note, nonetheless, that the result of the operator 
\begin_inset Formula $\cup$
\end_inset

 is different in set-based relations than in bag-based relations.
\end_layout

\begin_layout Example
An example of the operator 
\begin_inset Formula $\cup$
\end_inset

:
\end_layout

\begin_layout Example
\begin_inset Formula 
\[
\left[\begin{array}{cc}
A & B\\
1 & 2\\
3 & 4\\
5 & 6
\end{array}\right]\bigcup\left[\begin{array}{cc}
A & B\\
3 & 4\\
1 & 5
\end{array}\right]=\left\{ \overset{set-based}{\left[\begin{array}{cc}
A & B\\
1 & 2\\
3 & 4\\
5 & 6\\
1 & 5
\end{array}\right]},\overset{bag-based}{\left[\begin{array}{cc}
A & B\\
1 & 2\\
3 & 4\\
5 & 6\\
1 & 5\\
3 & 4
\end{array}\right]}\right\} 
\]

\end_inset


\end_layout

\begin_layout Standard
The 
\series bold
intersection
\series default
 of two relations with the same schema returns another relation with the
 same schema and all tuples in both of the two input relations: Let 
\begin_inset Formula $R_{i},R_{j}\in\Sigma$
\end_inset

 such that 
\begin_inset Formula $R_{i}\simeq R_{j}$
\end_inset

, then
\begin_inset Formula 
\[
R_{i}\cap R_{j}=\left\{ x|x\in R_{i}\ \land\ x\in R_{j}\right\} \simeq R_{i}\simeq R_{j}.
\]

\end_inset


\end_layout

\begin_layout Example
An example of the operator 
\begin_inset Formula $\cap$
\end_inset

:
\begin_inset Formula 
\[
\left[\begin{array}{cc}
A & B\\
1 & 2\\
3 & 4\\
5 & 6
\end{array}\right]\bigcap\left[\begin{array}{cc}
A & B\\
3 & 4\\
1 & 5
\end{array}\right]=\left[\begin{array}{cc}
A & B\\
3 & 4
\end{array}\right].
\]

\end_inset


\end_layout

\begin_layout Standard
The 
\series bold
difference
\series default
 of two relations with the same schema returns another relation with the
 same schema and all tuples in the first input relations which don't appear
 in the second input relation: Let 
\begin_inset Formula $R_{i},R_{j}\in\Sigma$
\end_inset

 such that 
\begin_inset Formula $R_{i}\simeq R_{j}$
\end_inset

, then
\begin_inset Formula 
\[
R_{i}-R_{j}=\left\{ x|x\in R_{i}\ \land\ x\notin R_{j}\right\} \simeq R_{i}\simeq R_{j}.
\]

\end_inset


\end_layout

\begin_layout Example
An example of the operator 
\begin_inset Formula $-$
\end_inset

:
\begin_inset Formula 
\[
\left[\begin{array}{cc}
A & B\\
1 & 2\\
3 & 4\\
5 & 6
\end{array}\right]-\left[\begin{array}{cc}
A & B\\
3 & 4\\
1 & 5
\end{array}\right]=\left[\begin{array}{cc}
A & B\\
1 & 2\\
5 & 6
\end{array}\right].
\]

\end_inset


\end_layout

\begin_layout Standard
The 
\series bold
selection
\series default
 operator applies a condition on the values of the tuples of the input relation
 and returns only those tuples that fullfil the condition: Let 
\begin_inset Formula $R\in\Sigma$
\end_inset

 and 
\begin_inset Formula $P$
\end_inset

 a condition, then
\begin_inset Formula 
\[
\sigma_{P}\left(R\right)=\left\{ x|x\in R\ \land\ P\left(R\right)==true\right\} .
\]

\end_inset


\end_layout

\begin_layout Example
An example of the operator 
\begin_inset Formula $\sigma_{P}$
\end_inset

:
\begin_inset Formula 
\[
\sigma_{A\geq3}\left(\left[\begin{array}{cc}
A & B\\
1 & 2\\
3 & 4\\
5 & 6
\end{array}\right]\right)=\left[\begin{array}{cc}
A & B\\
3 & 4\\
5 & 6
\end{array}\right].
\]

\end_inset

 In this case, the condition 
\begin_inset Formula $P$
\end_inset

 is: '
\emph on
the value of 
\begin_inset Formula $A$
\end_inset

 is bigger than or equal than 3
\emph default
'.
\end_layout

\begin_layout Standard
The 
\series bold
projection
\series default
 operator returns all tuples of the input relation, but deleting all unspecified
 attributes: Let 
\begin_inset Formula $R\in\Sigma$
\end_inset

 and 
\begin_inset Formula $A_{j_{1}},...,A_{j_{k}}\in\left[A_{1},...,A_{n}\right]\sim R$
\end_inset

, then
\begin_inset Formula 
\[
\pi_{A_{j_{1}},...,A_{j_{k}}}\left(R\right)=R_{\left[A_{j_{1}},...,A_{j_{k}}\right]}^{'}=\left\{ y|\exists x\in R\ s.t.\ x\left(A_{j_{1}},...,A_{j_{k}}\right)=y\right\} .
\]

\end_inset


\end_layout

\begin_layout Standard
The result of this operation also depends on the type of relations used.
\end_layout

\begin_layout Example
An example of the operator 
\begin_inset Formula $\pi_{\left[A_{j_{1}},...,A_{j_{k}}\right]}$
\end_inset

:
\begin_inset Formula 
\[
\pi_{A,C}=\left(\left[\begin{array}{cccc}
A & B & C & D\\
1 & 2 & 3 & 5\\
3 & 4 & 3 & 6\\
5 & 6 & 5 & 9\\
1 & 6 & 3 & 5
\end{array}\right]\right)=\left\{ \overset{set-based}{\left[\begin{array}{cc}
A & C\\
1 & 3\\
3 & 3\\
5 & 5
\end{array}\right]},\overset{bag-based}{\left[\begin{array}{cc}
A & C\\
1 & 3\\
3 & 3\\
5 & 5\\
1 & 3
\end{array}\right]}\right\} .
\]

\end_inset


\end_layout

\begin_layout Standard
The 
\series bold
cartesian product
\series default
 of two relations with disjoint schemas returns a relation with the schema
 resulting of combining both schemas and with all possible tuples made out
 of tuples from the first relation and tuples from the second relation:
 Let 
\begin_inset Formula $R_{i},R_{j}\in\Sigma$
\end_inset

 such that their schemas are disjoint, then
\begin_inset Formula 
\[
R_{i}\times R_{j}=\left\{ z=\left(x,y\right)|x\in R_{i}\ \land\ y\in R_{j}\right\} .
\]

\end_inset


\end_layout

\begin_layout Example
An example of the operator 
\begin_inset Formula $\times$
\end_inset

:
\begin_inset Formula 
\[
\left[\begin{array}{cc}
A & B\\
1 & 2\\
3 & 4
\end{array}\right]\times\left[\begin{array}{cc}
C & D\\
2 & 6\\
3 & 7\\
4 & 9
\end{array}\right]=\left[\begin{array}{cccc}
A & B & C & D\\
1 & 2 & 2 & 6\\
1 & 2 & 3 & 7\\
1 & 2 & 4 & 9\\
3 & 4 & 2 & 6\\
3 & 4 & 3 & 7\\
3 & 4 & 4 & 9
\end{array}\right].
\]

\end_inset


\end_layout

\begin_layout Standard
The 
\series bold
natural join
\series default
 of two tuples whose schemas share at most one attribute returns a relation
 with the schema resulting of combining both schemas and with all possible
 tuples made out of tuples from the first relation and tuples from the second
 relation with the condition that they have the same value for the shared
 attribute: Let 
\begin_inset Formula $R_{i},R_{j}\in\Sigma$
\end_inset

 such that their schemas share at most one attribute, 
\begin_inset Formula $A$
\end_inset

, then
\begin_inset Formula 
\[
R_{i}\bowtie R_{j}=\left\{ z=\left(x,y\right)|x\in R_{i}\ \land\ y\in R_{j}\ \land x\left(A\right)=y\left(A\right)\right\} .
\]

\end_inset


\end_layout

\begin_layout Standard
Note that if the relations are disjoint, the natural join gives the same
 results as the cartesian product.
\end_layout

\begin_layout Example
An example of the operator 
\begin_inset Formula $\bowtie$
\end_inset

:
\begin_inset Formula 
\[
\left[\begin{array}{cc}
A & B\\
1 & 2\\
3 & 4
\end{array}\right]\bowtie\left[\begin{array}{cc}
B & D\\
2 & 6\\
3 & 7\\
4 & 9
\end{array}\right]=\left[\begin{array}{ccc}
A & B & D\\
1 & 2 & 6\\
3 & 4 & 9
\end{array}\right].
\]

\end_inset


\end_layout

\begin_layout Standard
The 
\series bold
theta join
\series default
 of two relations given a condition 
\begin_inset Formula $P$
\end_inset

 returns all the tuples in the cartesian product of the two relations that
 fullfil the condition 
\begin_inset Formula $P$
\end_inset

: Let 
\begin_inset Formula $R_{i},R_{j}\in\Sigma$
\end_inset

 and 
\begin_inset Formula $P$
\end_inset

 a condition, then
\begin_inset Formula 
\[
R_{i}\bowtie_{P}R_{j}=\left\{ x|x\in R_{i}\times R_{j}\ \land\ P\left(x\right)==true\right\} =\sigma_{P}\left(R_{i}\times R_{j}\right).
\]

\end_inset


\end_layout

\begin_layout Example
An example of the operator 
\begin_inset Formula $\bowtie_{P}$
\end_inset

:
\begin_inset Formula 
\[
\left[\begin{array}{cc}
A & B\\
1 & 2\\
3 & 4
\end{array}\right]\bowtie_{B=C}\left[\begin{array}{cc}
C & D\\
2 & 6\\
3 & 7\\
4 & 9
\end{array}\right]=\left[\begin{array}{cccc}
A & B & C & D\\
1 & 2 & 2 & 6\\
3 & 4 & 4 & 9
\end{array}\right].
\]

\end_inset


\end_layout

\begin_layout Standard
The 
\series bold
left/right/full outer join
\series default
 operators are similar to the theta join, but for those tuples in the left/right
/both relation that does not find a match in the other relation, it returns
 a new tuples with the values of the tuple and the rest of the attributes
 empty.
\end_layout

\begin_layout Example
An example of 
\begin_inset Formula $=\bowtie,\ \bowtie=,=\bowtie=$
\end_inset

:
\begin_inset Formula 
\[
\left[\begin{array}{cc}
A & B\\
1 & 2\\
3 & 4\\
5 & 5
\end{array}\right]=\bowtie_{B=C}\left[\begin{array}{cc}
C & D\\
2 & 6\\
3 & 7\\
4 & 9
\end{array}\right]=\left[\begin{array}{cccc}
A & B & C & D\\
1 & 2 & 2 & 6\\
3 & 4 & 4 & 9\\
5 & 5
\end{array}\right]
\]

\end_inset


\begin_inset Formula 
\[
\left[\begin{array}{cc}
A & B\\
1 & 2\\
3 & 4\\
5 & 5
\end{array}\right]\bowtie=_{B=C}\left[\begin{array}{cc}
C & D\\
2 & 6\\
3 & 7\\
4 & 9
\end{array}\right]=\left[\begin{array}{cccc}
A & B & C & D\\
1 & 2 & 2 & 6\\
3 & 4 & 4 & 9\\
 &  & 3 & 7
\end{array}\right]
\]

\end_inset


\begin_inset Formula 
\[
\left[\begin{array}{cc}
A & B\\
1 & 2\\
3 & 4\\
5 & 5
\end{array}\right]=\bowtie=_{B=C}\left[\begin{array}{cc}
C & D\\
2 & 6\\
3 & 7\\
4 & 9
\end{array}\right]=\left[\begin{array}{cccc}
A & B & C & D\\
1 & 2 & 2 & 6\\
3 & 4 & 4 & 9\\
5 & 5\\
 &  & 3 & 7
\end{array}\right]
\]

\end_inset


\end_layout

\begin_layout Standard
The 
\series bold
renaming operator 
\series default
changes the name of a relation, 
\begin_inset Formula $\rho\left(R\right)=R'$
\end_inset

.
 The 
\series bold
feature rename operator
\series default
 changes the name of an attribute in a relation, 
\begin_inset Formula $A\rightarrow A'$
\end_inset

.
\end_layout

\begin_layout Standard
The 
\series bold
aggregation operator 
\series default
of a relation returns another relation in which the tuples that share the
 value of the aggregating attribute are merged using an 
\series bold
aggregate function
\series default
: Let 
\begin_inset Formula $R\in\Sigma$
\end_inset

, with 
\begin_inset Formula $R\sim\left[A_{1},...,A_{n},A\right]$
\end_inset

, 
\begin_inset Formula $A$
\end_inset

 the aggregating attribute and 
\begin_inset Formula $f_{1},...,f_{n}$
\end_inset

 the aggregating functions for the rest of the attributes, then
\begin_inset Formula 
\[
\gamma_{A,f_{1}\left(A_{1}\right),...,f_{n}\left(A_{n}\right)}\left(R\right)=\left\{ z=\left(v_{A},f_{1}\left(A_{1}^{v_{A}}\right),...f_{n}\left(A_{n}^{v_{A}}\right)\right)|v_{A}\in R\left(A\right)\right\} ,
\]

\end_inset

 where 
\begin_inset Formula $A_{j}^{v_{A}}$
\end_inset

 is a short notation for
\begin_inset Formula 
\[
A_{j}^{v_{A}}=\pi_{A_{j}}\left(\sigma_{A=v_{A}}\left(R\right)\right),
\]

\end_inset

 i.e.
 all values in 
\begin_inset Formula $R\left(A_{j}^{v_{A}}\right)$
\end_inset

 such that come from a tuple whose values for the attribute 
\begin_inset Formula $A$
\end_inset

 is 
\begin_inset Formula $v$
\end_inset

.
\end_layout

\begin_layout Example
An example of the operator 
\begin_inset Formula $\gamma_{A,f_{1}\left(A_{1}\right),...,f_{n}\left(A_{n}\right)\left(R\right)}$
\end_inset

:
\begin_inset Formula 
\[
\gamma_{A,min\left(B\right)}\left[\begin{array}{cc}
A & B\\
1 & 2\\
1 & 1\\
3 & 7\\
3 & 9\\
4 & 4
\end{array}\right]=\left[\begin{array}{cc}
A & min\left(B\right)\\
1 & 1\\
3 & 7\\
4 & 4
\end{array}\right].
\]

\end_inset


\end_layout

\begin_layout Subsection
Relational algebra expressions
\end_layout

\begin_layout Standard
Now, we can build expressions in relational algebra to get new relations
 from current ones.
 Let's return to Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "ex:1-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we can define the operator 
\begin_inset Formula $Op$
\end_inset

 such that produces the relation that contains all names of films in which
 some movie stars in 
\begin_inset Formula $MovieStar$
\end_inset

 born in 1960 participated as:
\begin_inset Formula 
\[
R'=Op\left(MovieStar,StarsIn\right)=\pi_{filmName}\left(\sigma_{birthDate.year=1960}\left(MovieStar\bowtie_{name=starName}StarsIn\right)\right).
\]

\end_inset


\end_layout

\begin_layout Standard
Relational algebra is the theoretical basis of the 
\series bold
SQL language
\series default
, meaning SQL is designed as an implementation of the relational algebra
 operators that we have seen so far.
 The equivalent SQL sentence to the last RA operator, 
\begin_inset Formula $OP$
\end_inset

, is
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

SELECT filmName
\end_layout

\begin_layout Plain Layout

FROM StarsIn
\end_layout

\begin_layout Plain Layout

JOIN MovieStar ON name=starName
\end_layout

\begin_layout Plain Layout

WHERE birthDate.year = 1960;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As explained in 
\begin_inset CommandInset citation
LatexCommand cite
key "SQLtoRA"
literal "false"

\end_inset

, translating an arbitrary SQL query into a 
\series bold
logical query plan
\series default
, or, equivalently, a relational algebra expression, is a complex task.
 Let's first give some examples.
\end_layout

\begin_layout Example
We are going to work with some examples now.
 Let's our database have the following relations:
\end_layout

\begin_deeper
\begin_layout Itemize
Movie(title: string, year: int, length: int, genre: string, studioName:
 string, producerCERT: int)
\end_layout

\begin_layout Itemize
MovieStar(name: string, address: string, gender: char, birthdate:date)
\end_layout

\begin_layout Itemize
StarsIn(movieTitle: string, movieYear: string, starName: string)
\end_layout

\begin_layout Itemize
MovieExec(name: string, address: string, CERT: int, netWorth: int)
\end_layout

\begin_layout Itemize
Studio(name: string, address: string, presCERT: int)
\end_layout

\begin_layout Standard
SQL:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT movieTitle, count(S.starName) AS numStars
\end_layout

\begin_layout Plain Layout

FROM StarsIn S, MovieStar M
\end_layout

\begin_layout Plain Layout

WHERE S.starName = M.name
\end_layout

\begin_layout Plain Layout

GROUP BY movieTitle;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
RA:
\begin_inset Formula 
\[
\gamma_{M.movieTitle,\ count\left(S.starName\right)\rightarrow numStars}\left(\rho_{S}\left(StarsIn\right)\bowtie_{S.starName=M.name}\rho_{M}\left(MovieStar\right)\right).
\]

\end_inset


\end_layout

\begin_layout Standard
SQL:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT movieTitle, count(S.starName) AS numStars
\end_layout

\begin_layout Plain Layout

FROM StarsIn S, MovieStar M
\end_layout

\begin_layout Plain Layout

WHERE S.starName = M.name
\end_layout

\begin_layout Plain Layout

GROUP BY movieTitle
\end_layout

\begin_layout Plain Layout

HAVING count(S.starName) > 5;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
RA:
\begin_inset Formula 
\[
\sigma_{numStars>5}\left(\gamma_{M.movieTitle,\ count\left(S.starName\right)\rightarrow numStars}\left(\rho_{S}\left(StarsIn\right)\bowtie_{S.starName=M.name}\rho_{M}\left(MovieStar\right)\right)\right).
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
At this point, one can understand that it is not easy at all to automatize
 this procedure of translating from SQL to RA.
 Not only the process is not trivial as is, but it is also needed to take
 into consideration that one SQL sentence can be translated into several
 equivalent RA expressions, which will ultimately be executed in a computer
 and the election of the translation to execute will affect the efficiency
 of the program.
 Let's review the paper 
\begin_inset CommandInset citation
LatexCommand cite
key "SQLtoRA"
literal "false"

\end_inset

, explaining each of the translations, assuming set-based relations.
\end_layout

\begin_layout Section
Translating SQL into Relational Algebra
\end_layout

\begin_layout Subsection
SELECT-FROM-WHERE statemets without subqueries
\begin_inset CommandInset label
LatexCommand label
name "subsec:SELECT-FROM-WHERE-statemets-without-SUB"

\end_inset


\end_layout

\begin_layout Standard
A query of the form:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT select-list
\end_layout

\begin_layout Plain Layout

FROM R1 T1,..., Rn Tn
\end_layout

\begin_layout Plain Layout

WHERE condition;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
in which the condition does not involve subqueries, we can translate it
 as
\begin_inset Formula 
\[
\pi_{select-list}\left(\sigma_{condition}\left(\rho_{T1}\left(R1\right)\times...\times\rho_{Tn}\left(Rn\right)\right)\right).
\]

\end_inset


\end_layout

\begin_layout Subsection
Normalizing WHERE-subqueries into EXISTS and NOT EXISTS form
\end_layout

\begin_layout Standard
In general, queries in which there are subqueries in the WHERE clause can
 arise, and they need to be translated, too.
 The property used in these cases is that subqueries occurring in the WHERE
 clause that use the operators 
\begin_inset Formula $=,<,>,<=,>=,<>,EXISTS,IN,NOT\ EXISTS,NOT\ IN$
\end_inset

 or the quantifiers 
\begin_inset Formula $ANY$
\end_inset

 or 
\begin_inset Formula $ALL$
\end_inset

 can all be rewritten to use the operators 
\begin_inset Formula $EXISTS$
\end_inset

 and 
\begin_inset Formula $NOT\ EXISTS$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Proposition
All conditions using a subquery can be rewritten using only 
\begin_inset Formula $EXISTS$
\end_inset

 and 
\begin_inset Formula $NOT\ EXISTS$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Proof
Let's proof some of the results:
\end_layout

\begin_deeper
\begin_layout Itemize
The result using the 
\begin_inset Formula $EXISTS$
\end_inset

 and 
\begin_inset Formula $NOT\ EXISTS$
\end_inset

 operators is obvious.
\end_layout

\begin_layout Itemize
Case 
\begin_inset Formula $=ANY$
\end_inset

: a query would look like the following:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT select-list
\end_layout

\begin_layout Plain Layout

FROM R1
\end_layout

\begin_layout Plain Layout

WHERE R1.A = ANY (SELECT B
\end_layout

\begin_layout Plain Layout

		  FROM R2
\end_layout

\begin_layout Plain Layout

		  WHERE cond);
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Proof
An equivalent query is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT select-list
\end_layout

\begin_layout Plain Layout

FROM R1
\end_layout

\begin_layout Plain Layout

WHERE EXISTS(SELECT B
\end_layout

\begin_layout Plain Layout

		 FROM R2
\end_layout

\begin_layout Plain Layout

		 WHERE cond AND R2.B = R1.A);
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Case 
\begin_inset Formula $=ALL$
\end_inset

:
\end_layout

\end_deeper
\begin_layout Proof
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT select-list
\end_layout

\begin_layout Plain Layout

FROM R1
\end_layout

\begin_layout Plain Layout

WHERE R1.A = ALL (SELECT B
\end_layout

\begin_layout Plain Layout

			FROM R2
\end_layout

\begin_layout Plain Layout

			WHERE cond);
\end_layout

\end_inset


\end_layout

\begin_layout Proof
An equivalent query is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT select-list
\end_layout

\begin_layout Plain Layout

FROM R1
\end_layout

\begin_layout Plain Layout

WHERE NOT EXISTS(SELECT B
\end_layout

\begin_layout Plain Layout

			FROM R2
\end_layout

\begin_layout Plain Layout

			WHERE cond AND R2.B <> R1.A);
\end_layout

\end_inset


\end_layout

\begin_layout Proof
The rest of the cases 
\begin_inset Formula $binaryOP+ANY|ALL$
\end_inset

 is similar.
\end_layout

\begin_deeper
\begin_layout Itemize
Case 
\begin_inset Formula $IN$
\end_inset

:
\end_layout

\end_deeper
\begin_layout Proof
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT select-list
\end_layout

\begin_layout Plain Layout

FROM R1
\end_layout

\begin_layout Plain Layout

WHERE R1.A IN (SELECT B
\end_layout

\begin_layout Plain Layout

		   FROM R2
\end_layout

\begin_layout Plain Layout

		   WHERE cond);
\end_layout

\end_inset


\end_layout

\begin_layout Proof
An equivalent query is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT select-list
\end_layout

\begin_layout Plain Layout

FROM R1
\end_layout

\begin_layout Plain Layout

WHERE EXISTS(SELECT B
\end_layout

\begin_layout Plain Layout

		 FROM R2
\end_layout

\begin_layout Plain Layout

		 WHERE cond AND R2.B = R1.A);
\end_layout

\end_inset


\end_layout

\begin_layout Proof
The case 
\begin_inset Formula $NOT\ IN$
\end_inset

 is analogous.
\end_layout

\begin_layout Example
Let's see some examples from the paper:
\end_layout

\begin_layout Example
The query
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT movieTitle FROM StarsIn
\end_layout

\begin_layout Plain Layout

WHERE starName IN (SELECT name
\end_layout

\begin_layout Plain Layout

		   FROM MovieStar
\end_layout

\begin_layout Plain Layout

		   WHERE birthdate = 1960);
\end_layout

\end_inset

is equivalent to:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT movieTitle FROM StarsIn
\end_layout

\begin_layout Plain Layout

WHERE EXISTS (SELECT name
\end_layout

\begin_layout Plain Layout

	  FROM MovieStar
\end_layout

\begin_layout Plain Layout

	  WHERE birthdate = 1960 AND name = starName);
\end_layout

\end_inset


\end_layout

\begin_layout Example
The query
\end_layout

\begin_layout Example
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT name FROM MovieExec
\end_layout

\begin_layout Plain Layout

WHERE netWorth >= ALL (SELECT E.networth
\end_layout

\begin_layout Plain Layout

			FROM MovieExec E);
\end_layout

\end_inset

is equivalent to:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT name FROM MovieExec
\end_layout

\begin_layout Plain Layout

WHERE NOT EXISTS (SELECT E.networth
\end_layout

\begin_layout Plain Layout

		  FROM MovieExec E
\end_layout

\begin_layout Plain Layout

		  WHERE netWorth < E.netWorth);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Without loss of generality, we can now assume that all subqueries in the
 where clause are of the form 
\begin_inset Formula $EXISTS$
\end_inset

 or 
\begin_inset Formula $NOT\ EXISTS$
\end_inset

.
\end_layout

\begin_layout Standard
Now, to translate a query with subqueries, in which an arbitrary number
 of subqueries inside the subqueries may arise, it seems logical to proceed
 recursively.
 The idea is to translate into RA from inner queries to outer queries.
 For subqueries that do not contain more subqueries, we could translate
 them as in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:SELECT-FROM-WHERE-statemets-without-SUB"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The problem in this case is that the subqueries can refer to attributes
 of relations appearing in the FROM clause of the outer queries.
 This is known as 
\series bold
correlated queries
\series default
.
\end_layout

\begin_layout Example
\begin_inset CommandInset label
LatexCommand label
name "ex:A-correlated-query."

\end_inset

A correlated query.
\end_layout

\begin_layout Example
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT movieTitle
\end_layout

\begin_layout Plain Layout

FROM StarsIn
\end_layout

\begin_layout Plain Layout

WHERE EXISTS (SELECT name
\end_layout

\begin_layout Plain Layout

		FROM MovieStar
\end_layout

\begin_layout Plain Layout

		WHERE birthdate = 1960 AND name = starName);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The outer relations from which a correlated subquery uses certain attributes
 are called 
\series bold
context relations
\series default
.
 The attributes of the context relations are the 
\series bold
parameters
\series default
 of the subquery
\begin_inset Foot
status open

\begin_layout Plain Layout
Note that not all the parameters must appear in the subquery.
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Translating SELECT-FROM-WHERE subqueries
\begin_inset CommandInset label
LatexCommand label
name "subsec:Translating-SELECT-FROM-WHERE-suB"

\end_inset


\end_layout

\begin_layout Standard
To translate a SELECT-FROM-WHERE statement that is used as a subquery, we
 must make the following modifications to the method from Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:SELECT-FROM-WHERE-statemets-without-SUB"
plural "false"
caps "false"
noprefix "false"

\end_inset

:
\end_layout

\begin_layout Itemize
We must add all context relations to the cartesian product of the relations
 in the FROM list.
\end_layout

\begin_layout Itemize
We must add all parameters as attributes to the projection 
\begin_inset Formula $\pi$
\end_inset

.
\end_layout

\begin_layout Example
The subquery from Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "ex:A-correlated-query."
plural "false"
caps "false"
noprefix "false"

\end_inset

:
\end_layout

\begin_layout Example
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT name
\end_layout

\begin_layout Plain Layout

FROM MovieStar
\end_layout

\begin_layout Plain Layout

WHERE birthdate = 1960 AND name = starName
\end_layout

\end_inset


\end_layout

\begin_layout Example
is translated into
\begin_inset Formula 
\[
\pi_{movieTitle,movieYear,starName,name}\left(\sigma_{birthdate=1960\ \land\ name=starName}\left(StarsIn\times MovieStar\right)\right).
\]

\end_inset


\end_layout

\begin_layout Subsection
De-correlation of subqueries appearing in a conjunctive WHERE condition
\end_layout

\begin_layout Standard
Now, let's focus on a particular case:
\end_layout

\begin_layout Standard
Suppose we have a query of the general form:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT Select-list
\end_layout

\begin_layout Plain Layout

FROM from-list
\end_layout

\begin_layout Plain Layout

WHERE condition;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
And the following assumption: 
\emph on
the condition is a conjunction (AND) of SELECT-FROM-WHERE subqueries, possibly
 with an additional condition that does not contain subqueries
\emph default
, i.e., the condition is of the form
\begin_inset Formula 
\[
\phi\ AND\ EXISTS(Q_{1})\ AND\ EXISTS\left(Q_{2}\right)\ AND...\ AND\ NOT\ EXISTS\ \left(P_{1}\right)\ AND...
\]

\end_inset

 where 
\begin_inset Formula $\phi$
\end_inset

 denotes the subquery-free condition and 
\begin_inset Formula $Q_{1},...,Q_{n},P_{1},...,P_{m}$
\end_inset

 are select statements.
 The translation is done in four steps:
\end_layout

\begin_layout Enumerate
Translate 
\begin_inset Formula $\phi$
\end_inset

.
\end_layout

\begin_layout Enumerate
De-correlate the EXISTS subqueries.
\end_layout

\begin_layout Enumerate
De-correlate the NOT EXISTS subqueries.
\end_layout

\begin_layout Enumerate
Apply the projection 
\begin_inset Formula $\pi_{Select-list}.$
\end_inset


\end_layout

\begin_layout Subsubsection
Translating 
\begin_inset Formula $\phi$
\end_inset


\end_layout

\begin_layout Standard
It is translated using the method of Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:SELECT-FROM-WHERE-statemets-without-SUB"
plural "false"
caps "false"
noprefix "false"

\end_inset

, but the following context relations must be included:
\end_layout

\begin_layout Itemize
All context relations for which parameters occur in 
\begin_inset Formula $\phi$
\end_inset

.
\end_layout

\begin_layout Itemize
All context relations for which parameters only occur in NOT EXISTS subqueries.
\end_layout

\begin_layout Standard
We will obtain a expression of the form
\begin_inset Formula 
\[
\sigma_{\phi}\left(E\right),
\]

\end_inset

 where 
\begin_inset Formula $E$
\end_inset

 is a cartesian product of all the context relations involved.
 From now on, we are going to adapt and refine 
\begin_inset Formula $E$
\end_inset

 gradually when de-correlating the subqueries.
\end_layout

\begin_layout Example
\begin_inset CommandInset label
LatexCommand label
name "ex:decorr-ex1"

\end_inset

Consider the following query, with relations 
\begin_inset Formula $R\left(A,B\right)$
\end_inset

 and 
\begin_inset Formula $S\left(C\right)$
\end_inset

:
\end_layout

\begin_layout Example
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT R1.A, R1.B
\end_layout

\begin_layout Plain Layout

FROM R R1, S
\end_layout

\begin_layout Plain Layout

WHERE EXISTS
\end_layout

\begin_layout Plain Layout

	(SELECT R2.A, R2.B
\end_layout

\begin_layout Plain Layout

	FROM R R2
\end_layout

\begin_layout Plain Layout

	WHERE R2.A = R1.B AND EXISTS
\end_layout

\begin_layout Plain Layout

			(SELECT R3.A, R3.B
\end_layout

\begin_layout Plain Layout

			FROM R R3
\end_layout

\begin_layout Plain Layout

			WHERE R3.A = R2.B AND R3.B = S.C));
\end_layout

\end_inset


\end_layout

\begin_layout Example
Let's denote the queries, from outer to inner: 
\begin_inset Formula $Q_{1},Q_{2}$
\end_inset

 and 
\begin_inset Formula $Q_{3}$
\end_inset

.
 
\begin_inset Formula $Q_{1}$
\end_inset

 does not have a subquery-free part, so we continue with 
\begin_inset Formula $Q_{2}$
\end_inset

.
 The subquery-free part of 
\begin_inset Formula $Q_{2}$
\end_inset

 is:
\end_layout

\begin_layout Example
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT *
\end_layout

\begin_layout Plain Layout

FROM R R2
\end_layout

\begin_layout Plain Layout

WHERE R2.A = R1.B;
\end_layout

\end_inset


\end_layout

\begin_layout Example
So it can be translated as
\begin_inset Formula 
\[
\sigma_{R2.A=R1.B}\left(\rho_{R2}\left(R\right)\times\rho_{R1}\left(R\right)\right).
\]

\end_inset

 Note that 
\begin_inset Formula $S$
\end_inset

 is a context relation for this subquery-free part, but no parameter from
 it is needed and it is not only used in NOT EXISTS clauses, so it is not
 added.
\end_layout

\begin_layout Subsubsection
De-correlating EXISTS subqueries
\end_layout

\begin_layout Standard
After translating the subquery-free part, we translate all the subqueries
 
\begin_inset Formula $EXISTS\left(Q_{i}\right)$
\end_inset

 as explained in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Translating-SELECT-FROM-WHERE-suB"
plural "false"
caps "false"
noprefix "false"

\end_inset

, obtaining an algebra expression 
\begin_inset Formula $E_{Q_{i}}$
\end_inset

.
 
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $A_{1},...,A_{p}$
\end_inset

 be the list of parameters of context relations of 
\begin_inset Formula $Q_{i}$
\end_inset

.
 We can translate 
\begin_inset Formula $EXISTS\left(Q_{i}\right)$
\end_inset

 by joining 
\begin_inset Formula $E$
\end_inset

 with the space of parameters for 
\begin_inset Formula $E_{Q_{i}}$
\end_inset

, namely 
\begin_inset Formula $\pi_{A_{1},...,A_{p}}\left(E_{Q_{i}}\right):$
\end_inset


\begin_inset Formula 
\[
E:=E\bowtie\pi_{A_{1},...,A_{p}}\left(E_{Q_{i}}\right).
\]

\end_inset


\end_layout

\begin_layout Example
Let's continue the translation of 
\begin_inset Formula $Q_{2}$
\end_inset

 from Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "ex:decorr-ex1"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Now, we have to translate 
\begin_inset Formula $Q_{3}$
\end_inset

 as:
\begin_inset Formula 
\[
\sigma_{R3.A=R2.B\ \land\ R3.B=S.C}\left(\rho_{R3}\left(R\right)\times\rho_{R2}\left(R\right)\times S\right).
\]

\end_inset


\end_layout

\begin_layout Example
At this point, we have
\begin_inset Formula 
\[
E=\rho_{R_{2}}\left(R\right)\times\rho_{R_{1}}\left(R\right),
\]

\end_inset


\begin_inset Formula 
\[
E_{Q_{3}}=\sigma_{R3.A=R2.B\ \land\ R3.B=S.C}\left(\rho_{R3}\left(R\right)\times\rho_{R2}\left(R\right)\times S\right),
\]

\end_inset

 and by joining 
\begin_inset Formula $E$
\end_inset

 and 
\begin_inset Formula $E_{Q_{3}}$
\end_inset

 on the parameters of 
\begin_inset Formula $Q_{3}$
\end_inset

 we ensure that we are taking the correct tuples from 
\begin_inset Formula $E$
\end_inset

 and 
\begin_inset Formula $E_{Q_{3}}$
\end_inset

.
 In particular, we are taking the tuples in 
\begin_inset Formula $R_{1}$
\end_inset

 for which tuples in 
\begin_inset Formula $R_{2},R_{3}$
\end_inset

 and 
\begin_inset Formula $S$
\end_inset

 exist that satisfy the requirements of 
\begin_inset Formula $Q_{2}$
\end_inset

:
\begin_inset Formula 
\[
\rho_{R_{2}}\left(R\right)\times\rho_{R_{1}}\left(R\right)\bowtie\pi_{R_{2}.A,R_{2}.B,S.C}\left(\sigma_{R3.A=R2.B\ \land\ R3.B=S.C}\left(\rho_{R3}\left(R\right)\times\rho_{R2}\left(R\right)\times S\right)\right).
\]

\end_inset

 Note that this expression can be simplified:
\begin_inset Formula 
\[
E:=\rho_{R_{1}}\left(R\right)\bowtie\pi_{R_{2}.A,R_{2}.B,S.C}\left(\sigma_{R3.A=R2.B\ \land\ R3.B=S.C}\left(\rho_{R3}\left(R\right)\times\rho_{R2}\left(R\right)\times S\right)\right),
\]

\end_inset

 because we are joining 
\begin_inset Formula $R_{2}$
\end_inset

 with a subset of itself, so we will obtain the entire subset.
\end_layout

\begin_layout Remark
This simplification can always be done.
 Before joining with 
\begin_inset Formula $\pi_{A_{1},...,A_{p}}\left(E_{Q_{i}}\right),$
\end_inset

 we can remove from 
\begin_inset Formula $E$
\end_inset

 all context relations for 
\begin_inset Formula $Q_{i}$
\end_inset

, because they are already present in the parameter space.
 This way, denoting by 
\begin_inset Formula $\hat{E}$
\end_inset

 the adapted 
\begin_inset Formula $E$
\end_inset

, we can change what we explained later for
\begin_inset Formula 
\[
E:=\hat{E}\bowtie\pi_{A_{1},...,A_{p}}\left(E_{Q_{i}}\right).
\]

\end_inset


\end_layout

\begin_layout Example
Now we can translate 
\begin_inset Formula $Q_{2}$
\end_inset

 as follows:
\begin_inset Formula 
\[
E_{2}:=\sigma_{R_{2}.A=R_{1}.B}\left(E\right)=
\]

\end_inset


\begin_inset Formula 
\[
\sigma_{R_{2}.A=R_{1}.B}\left(\rho_{R_{1}}\left(R\right)\bowtie\pi_{R_{2}.A,R_{2}.B,S.C}\left(\sigma_{R3.A=R2.B\ \land\ R3.B=S.C}\left(\rho_{R3}\left(R\right)\times\rho_{R2}\left(R\right)\times S\right)\right)\right).
\]

\end_inset

 Notice how 
\begin_inset Formula $R_{2}$
\end_inset

 has been removed from the cartesian product of the subquery-free part of
 
\begin_inset Formula $Q_{2}$
\end_inset

 that we translated in the first of the examples.
\end_layout

\begin_layout Example
Finally, the translation of the entire 
\begin_inset Formula $Q_{1}$
\end_inset

 is
\begin_inset Formula 
\[
\pi_{R_{1}.A,R_{1}.B}\left(E_{2}\right),
\]

\end_inset

 where 
\begin_inset Formula $\rho_{R_{1}}\left(R\right)$
\end_inset

 and 
\begin_inset Formula $S$
\end_inset

 have been removed from the cartesian product originating from the translation
 of the subquery-free part of 
\begin_inset Formula $Q_{1}$
\end_inset

 (the FROM clause).
\end_layout

\begin_layout Subsubsection
De-correlating NOT EXISTS subqueries
\end_layout

\begin_layout Standard
Now we can de-correlate the 
\begin_inset Formula $NOT\ EXISTS\left(P_{j}\right)$
\end_inset

 subqueries.
 We start translating 
\begin_inset Formula $P_{j}$
\end_inset

 into a RA expression 
\begin_inset Formula $E_{P_{j}}$
\end_inset

.
 Again, we consider the parameters 
\begin_inset Formula $A_{1},...,A_{p}$
\end_inset

 of the context relations of 
\begin_inset Formula $P_{j}$
\end_inset

.
 The difference now is that we don't join 
\begin_inset Formula $E$
\end_inset

 and 
\begin_inset Formula $E_{P_{j}}$
\end_inset

, but we perform an anti-join:
\begin_inset Formula 
\[
E:=E\overline{\bowtie}\pi_{A_{1},...,A_{p}}\left(E_{P_{j}}\right),
\]

\end_inset

 where
\begin_inset Formula 
\[
R\overline{\bowtie}S=R-\left(R\bowtie S\right).
\]

\end_inset

 In this anti-join, it necessary that 
\begin_inset Formula $R$
\end_inset

 contains all attributes of 
\begin_inset Formula $S$
\end_inset

, and this is the reason why it is needed to add all context relations appearing
 only in NOT EXISTS clauses to the cartesian product of the subquery-free
 part of the query.
\end_layout

\begin_layout Subsubsection
Translating the Select-list
\end_layout

\begin_layout Standard
Finally, we apply the projection 
\begin_inset Formula $\pi_{Select-list}$
\end_inset

.
\end_layout

\begin_layout Subsection
Flattening subqueries in bag-based relations
\end_layout

\begin_layout Standard
Until now, we have supposed that all relations involved are set-based, but
 this is not the case in real databases, where duplicates can occur.
 In this case, the requirements for flattening into a normal join are:
\end_layout

\begin_layout Itemize
There is a uniqueness condition that ensures that the subquery does not
 introduce any duplicates if it is flattened into the outer query block.
 
\end_layout

\begin_layout Itemize
Each table in the subquery's FROM list (after any view, derived table, or
 subquery flattening) must be a base table.
 
\end_layout

\begin_layout Itemize
The subquery is not under an OR.
 
\end_layout

\begin_layout Itemize
The subquery is not in the SELECT list of the outer query block.
 
\end_layout

\begin_layout Itemize
The subquery type is EXISTS, IN, or ANY, or it is an expression subquery
 on the right side of a comparison operator.
 
\end_layout

\begin_layout Itemize
There are no aggregates in the SELECT list of the subquery.
 
\end_layout

\begin_layout Itemize
The subquery does not have a GROUP BY clause.
 
\end_layout

\begin_layout Itemize
The subquery does not have an ORDER BY, result offset, or fetch first clause.
 
\end_layout

\begin_layout Itemize
If there is a WHERE clause in the subquery, there is at least one table
 in the subquery whose columns are in equality predicates with expressions
 that do not include any column references from the subquery block.
 These columns must be a superset of the key columns for any unique index
 on the table.
 For all other tables in the subquery, the columns in equality predicates
 with expressions that do not include columns from the same table are a
 superset of the unique columns for any unique index on the table.
 
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Query Optimization
\end_layout

\begin_layout Section
System-R
\end_layout

\begin_layout Standard
In this section, we are going to explain System R, which is a pioneering
 SQL system developed by IBM Research and which was released in 1976, with
 an accompanying paper, 
\begin_inset CommandInset citation
LatexCommand cite
key "systemR"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
System R was an experimental prototype database management system, with
 complete capability, including application programming, query capability,
 conccurent access support, system recovery, etc.
\end_layout

\begin_layout Subsection
Architecture Components
\end_layout

\begin_layout Standard
System R is composed by several parts:
\end_layout

\begin_layout Itemize

\series bold
Relational Storage Interface
\series default
 
\series bold
(RSI)
\series default
: internal interface which handles access to single tuples of base relations.
\end_layout

\begin_layout Itemize

\series bold
Relational Storage System (RSS)
\series default
: the supporting system of the RSI.
 It is a complete storage subsystem in the sense that it manages devices,
 space allocation, deadlock detection,...
 It maintain indexes on selected fields of base relations, and pointer chains
 across relations.
\end_layout

\begin_layout Itemize

\series bold
Relational Data Interface (RDI)
\series default
: the external interface that can be called directly from a programming
 language.
 The 
\series bold
SQL language
\series default
 is embedded within the RDI, and is used as the basis for all data definition
 and manipulation.
\end_layout

\begin_layout Itemize

\series bold
Relational Data System (RDS)
\series default
: supports the RDI, provides authorization, integrity enforcement and support
 for alternative views of data.
 The RDS contains an 
\series bold
optimizer
\series default
 which plans the execution of each RDI command, choosing a low cost access
 path to data from among those provided by the RSS.
 The RDS also maintains a set of 
\series bold
catalog relations
\series default
 which describe the other relations, views, images, links, assertions, and
 triggers known to the system.
\end_layout

\begin_layout Standard
A logical diagram of this architecture is depicted in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Architecture-of-System-R"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename systemR.drawio.png
	scale 65

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Architecture-of-System-R"

\end_inset

Architecture of System R
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Query language
\end_layout

\begin_layout Subsubsection
Data manipulation
\end_layout

\begin_layout Standard
The RDI interfaces SQL to a host programming language by means of a concept
 called a 
\series bold
cursor
\series default
, which is a name used at the RDI to identify a set of tuples called its
 
\series bold
active set
\series default
, and to maintain a position on one tuple of the set.
 The cursor is associted with a set of tuples by means of the RDI operator
 
\series bold
SEQUEL
\series default
; the tuples may then be retrieved, one at a time, by the RDI operator 
\series bold
FETCH
\series default
.
 The program must first give the system the addresses of the program variables
 to be used by means of the RDI operator 
\series bold
BIND
\series default
.
\end_layout

\begin_layout Example
Here, the host program identifies variables X and Y to the system and then
 issues a query whose results are to be placed in these variables:
\end_layout

\begin_layout Example
\begin_inset listings
lstparams "language={PL/I},showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

CALL BIND('X', ADDR(X));
\end_layout

\begin_layout Plain Layout

CALL BIND('Y', ADDR(Y));
\end_layout

\begin_layout Plain Layout

CALL SEQUEL(C1, 'SELECT NAME:X, SAL:Y
\end_layout

\begin_layout Plain Layout

		FROM EMP
\end_layout

\begin_layout Plain Layout

		WHERE JOB = 
\begin_inset Quotes eld
\end_inset

PROGRAMMER
\begin_inset Quotes erd
\end_inset

');
\end_layout

\begin_layout Plain Layout

CALL FETCH(C1);
\end_layout

\end_inset


\end_layout

\begin_layout Example
The SEQUEL operator is associating the cursor C1 with the set of tuples
 which satisfy the query and positioning it just before the first such tuple.
 The optimizer is invoked to choose an access path whereby the tuples may
 be materialized, but no tuples are actually materialized in response to
 the SEQUEL call.
 The materialization is done as they are called for, one at a time, by the
 FETCH operator.
 Each call to FETCH deliver the next tuple of the active set into program
 variables X and Y.
 In Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:exampleSystemR"
plural "false"
caps "false"
noprefix "false"

\end_inset

 we can see an example of the stored data in the relation EMP and the resulting
 Active Set.
 In this case, after calling FETCH(C1), the values of the variables would
 be X=
\begin_inset Quotes erd
\end_inset

Mike
\begin_inset Quotes erd
\end_inset

 and Y=800.
 If another call to FECTH(C1) were made, then the variables would be overrided
 to X=
\begin_inset Quotes erd
\end_inset

Sarah
\begin_inset Quotes erd
\end_inset

 and Y=810.
\end_layout

\begin_layout Example
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
EMP
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
NAME
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SAL
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
JOB
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

John
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

CEO
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

Mike
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
800
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

PROGRAMMER
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

Sarah
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
810
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

PROGRAMMER
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Active Set
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
NAME
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SAL
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

Mike
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
800
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

Sarah
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
810
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:exampleSystemR"

\end_inset

Result of the program.
 Stored data in EMP (left).
 Active Set (right).
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\series bold
DESCRIBE
\series default
 operator returns the degree and the data types of the active set.
 The degree is the number of attributes.
 It is useful when this information is not known in advanced, so it can
 be inputted to the FETCH operator.
\end_layout

\begin_layout Standard
The operator 
\series bold
OPEN
\series default
 is used to associate a cursor with an entire relation.
\end_layout

\begin_layout Standard
Each cursor remains active until an RDI operator 
\series bold
CLOSE
\series default
 or 
\series bold
KEEP
\series default
 is issued on it.
 CLOSE deactivates the cursor, while KEEP causes the tuples identified by
 a cursor to be copied to form a new permanent relation in the database.
\end_layout

\begin_layout Standard
The operator 
\series bold
FETCH_HOLD
\series default
 is as FETCH, but it also acquires a 
\emph on
hold
\emph default
 on the tuple returned, which prevents other users from updating or deleting
 it until it is explicitly released by the 
\series bold
RELEASE
\series default
 operator or until the holding transaction has ended.
\end_layout

\begin_layout Subsubsection
Data definition
\end_layout

\begin_layout Standard
The SQL statement 
\series bold
CREATE TABLE
\series default
 is used to create a new base relation.
 For each field, the field name and data type are specified.
 When a relation is no longer useful, it may be deleted by issuing a 
\series bold
DROP TABLE
\series default
 statement.
\end_layout

\begin_layout Standard
Access paths include images and binary links.
 
\series bold
Images
\series default
 are value orderings maintained on base relations by the RSS, using multilevel
 index structures
\begin_inset Foot
status open

\begin_layout Plain Layout
Images are today called just indexes.
\end_layout

\end_inset

, associating a value with one or more 
\series bold
tuple identifiers (TIDs)
\series default
, which are internal addresses allowing rapid access to a tuple.
 One image per relation can have the 
\series bold
clustering property
\series default
, which causes tuples whose sort field values are close to be physically
 stored near each other.
 
\series bold
Binary paths
\series default
 are access paths in the RSS which link tuples in one relation to related
 tuples of another relation through pointer chains.
 They are employed in a value dependent manner: the user specifies that
 each tuple of Relation 1 is to be linked to the tuples in Relation 2 which
 have matching values in some field/s, and that the tuples on the link are
 to be ordered in some way
\begin_inset Foot
status open

\begin_layout Plain Layout
So, binary paths are essentialy join indexes.
\end_layout

\end_inset

.
 A link may be declared to have the clustering property.
\end_layout

\begin_layout Standard
A 
\series bold
view
\series default
 is a relation derived from one or more relations, and can be used in the
 same way as a base table.
 It can be defined using the 
\series bold
DEFINE VIEW 
\series default
statement.
 Views are updated automatically when changes are made to the base tables
 on which they are defined.
 When the statement 
\series bold
DROP VIEW
\series default
 is issued, the indicated view and all other views defined in terms of it
 disappear from the system.
 Modifications to views are only allowed if the tuples of the view are associate
d one-to-one with tuples of an underlying base relation.
\end_layout

\begin_layout Standard
The statement 
\series bold
KEEP TABLE
\series default
 causes a temporary table to become permanent.
\end_layout

\begin_layout Standard
The statement 
\series bold
EXPAND TABLE
\series default
 is used to add a new field to an existing table.
\end_layout

\begin_layout Subsubsection
Data Control
\end_layout

\begin_layout Standard
A 
\series bold
transaction
\series default
 is a series of RDI calls which the user wishes to be processed as an atomic
 act.
 A transaction starts when the user issues a 
\series bold
BEGIN_TRANS
\series default
 statement and ends when 
\series bold
END_TRANS
\series default
 is called.
 Save points may be specified by means of the operator 
\series bold
SAVE
\series default
.
 When a transaction is active, the user may go back to the beginning of
 it, or to any save point using 
\series bold
RESTORE
\series default
.
\end_layout

\begin_layout Standard
Regarding 
\series bold
authorization
\series default
, System R does not require a particular individual to be the DB administrator,
 but allows each user to create his own data objects by executing the create
 staatements.
 The creator of an object has full authorization on it.
 The user can gran selected capabilities for his objects to other users
 with the statement 
\series bold
GRANT
\series default
.
\end_layout

\begin_layout Standard
About 
\series bold
integrity assertions
\series default
, any SQL predicate may be stated as an assertion about the integrity of
 data in a base table or view.
 When an assertion is made by an 
\series bold
ASSERT 
\series default
statement, its truth is checked.
 If true, the assertion is atuomatically enforced until it is explicitly
 dropped by a 
\series bold
DROP ASSERTION
\series default
 statement.
 Assertions may describe the permissible states of the database or the permissib
le transitions in the database.
 For this latter purpose, the keywords 
\series bold
OLD
\series default
 and 
\series bold
NEW
\series default
 are used in SQL to denote data values before and after modification.
\end_layout

\begin_layout Standard
If an assertion is 
\series bold
IMMEDIATE
\series default
, it cannot be suspended within a transaction, but is enforced after each
 data modification.
 Also, 
\emph on
integrity
\emph default
 
\emph on
points 
\emph default
may be established by the SQL 
\series bold
ENFORCE INTEGRITY
\series default
.
\end_layout

\begin_layout Standard

\series bold
Triggers
\series default
 are a generalization of the concept of assertion, causing a prespecified
 sequence of SQL statements to be executed when some triggering event occurs.
\end_layout

\begin_layout Subsection
Catalogues
\end_layout

\begin_layout Standard
Catalogues are maintained by the RDS, and they describe the information
 of the relations, views, images, links, assertions and triggers known to
 the system.
 Each user may access a set of views of the system catalogs which contain
 information pertinent to him.
 Users cannot modify a catalog directly, but it is modified indirectly,
 when tables are created, an image is dropped, etc.
 A user can enter commments into his various catalog entries by means of
 the 
\series bold
COMMENT
\series default
 statement.
\end_layout

\begin_layout Subsection
Cursors
\end_layout

\begin_layout Standard
As we have seen, 
\series bold
cursors
\series default
 are pointers to specific tuples on a resulting table from a query.
 They can be used to retrieve the values of the tuples individually or to
 store the tables into the database as permanent relations.
 Cursors are still used, although they are often a low level feature that
 is not directly used by users, by it is used by the DBMS to provide higher
 level features to the user.
\end_layout

\begin_layout Standard
In addition, SQL can be used to maniputale either one tuple at a time or
 a set of tuples with a single command.
 The current tuple of a particular cursor may be selected for some operation
 using the predicate 
\series bold
CURRENT TUPLE OF CURSOR
\series default
.
\end_layout

\begin_layout Example
Give a 10% raise to all employees in Dept.
 50.
\end_layout

\begin_layout Example
\begin_inset listings
lstparams "language={PL/I},showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

CALL SEQUEL('UPDATE EMP
\end_layout

\begin_layout Plain Layout

		SET SAL = SAL*1.1
\end_layout

\begin_layout Plain Layout

		WHERE DNO = 50');
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Example
Individual update.
\end_layout

\begin_layout Example
\begin_inset listings
lstparams "language={PL/I},showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

CALL BIND('NEWSAL', ADDR(NEWSAL));
\end_layout

\begin_layout Plain Layout

CALL SEQUEL('UPDATE EMP
\end_layout

\begin_layout Plain Layout

		SET SAL=NEWSAL
\end_layout

\begin_layout Plain Layout

		WHERE CURRENT TUPLE OF CURSOR C');
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Clustering images
\end_layout

\begin_layout Standard
Clustering images, as we have explained, are images (indexes) that can be
 used to physically store the data in the same order as it is indexed.
 At most one image per relation can have the clustering property.
 The reason is simple: it is not possible to store the same data physically
 in two different orders.
\end_layout

\begin_layout Subsection
Optimizer
\end_layout

\begin_layout Standard
The objective of the optimizer is to find a low cost means of executing
 a SQL statement, given the data structures and access paths available.
 For this, it attempts to minimize the expected number of pages to be fetches
 from disk into the RSS buffers.
 The cost of CPU instructions is also taken into account by means of an
 adjustable coefficient, 
\begin_inset Formula $H$
\end_inset

, which is multiplied by the number of tuple comparison operations to convert
 equivalent page accesses.
 
\begin_inset Formula $H$
\end_inset

 is useful to adjust the metric for compute-bounded systems or disk access-bound
ed systems.
\end_layout

\begin_layout Standard
The optimizers follows some steps when it receives a SQL statement:
\end_layout

\begin_layout Enumerate
Classify the SQL statement into one of several statement types.
\end_layout

\begin_layout Enumerate
Examine the system catalogs to find the set of images and links which are
 pertinent to the given statement.
\end_layout

\begin_layout Enumerate
A rough decision procedure is executed to find the set of reasonable methods
 of executing the statement.
\end_layout

\begin_layout Enumerate
If there is more than one reasonable method, the 
\series bold
expected cost formula
\series default
 is evaluated for each method, and the minimizing method is choosing.
\end_layout

\begin_layout Standard
The following parameters, available in the system catalogues, are taken
 into account:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
R
\end_layout

\end_inset

 
\series bold
relation cardinality
\series default
: number of tuples
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
D
\end_layout

\end_inset

 
\series bold
number of pages occupied by the relation
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
T
\end_layout

\end_inset

 
\series bold
average number of tuples per page:
\begin_inset Formula 
\[
T=\frac{R}{D}.
\]

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
I
\end_layout

\end_inset

 
\series bold
image cardinality
\series default
: number of distinct sort fields values in a given image.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
H
\end_layout

\end_inset

 
\series bold
coefficient of CPU cost
\series default
: 
\begin_inset Formula $\frac{1}{H}$
\end_inset

 is the number of tuple comparisons which are considered equivalent in cost
 to one disk page access.
\end_layout

\begin_layout Standard
An image 
\series bold
match
\series default
 a predicate if the sort field of the image is the field which is tested
 by the predicate.
\end_layout

\begin_layout Subsubsection
Simple query optimization
\end_layout

\begin_layout Standard
In the case of a simple query on a single relation, the optimizer compares
 the available images with the predicates of the query, in order to determine
 which of the following eight methods are available:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
Method 1
\end_layout

\end_inset

: use a clustering image which matches a predicate whose comparison operator
 is '='.
 The expected cost, 
\begin_inset Formula $C$
\end_inset

 is
\begin_inset Formula 
\[
C=\frac{R}{T\times I},
\]

\end_inset

 that is: from 
\begin_inset Formula $I$
\end_inset

 values, we want one, so we need to retrieve 
\begin_inset Formula $\frac{R}{I}$
\end_inset

 tuples on average.
 These fit in 
\begin_inset Formula $\frac{R}{T\times I}$
\end_inset

 pages.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
Method 2
\end_layout

\end_inset

: use a clustering image which matches a predicate whose comparison operator
 is not '='.
 Assuming half the tuples satisfy the predicate, we have
\begin_inset Formula 
\[
C=\frac{R}{T\times2}.
\]

\end_inset

 The idea is the same as before, but now we are assuming to retrieve 
\begin_inset Formula $\frac{R}{2}$
\end_inset

 tuples on average.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
Method 3
\end_layout

\end_inset

: use a non-clustering image which matches a predicate whose comparison
 operator is '='.
 In this case, we have
\begin_inset Formula 
\[
C=\frac{R}{I},
\]

\end_inset

 because now we might find only one correct tuple per page.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
Method 4
\end_layout

\end_inset

: use a non-clustering image which matches a predicate whose comparison
 operator is not '='.
 It is
\begin_inset Formula 
\[
C=\frac{R}{2}.
\]

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
Method 5
\end_layout

\end_inset

: use a clustering image which does not match any predicate.
 We would scan the image and test each tuple against all predicates.
 The expected cost is
\begin_inset Formula 
\[
C=\frac{R}{T}+H\times R\times N,
\]

\end_inset

 where 
\begin_inset Formula $N$
\end_inset

 is the number of predicates.
 So, we recover 
\begin_inset Formula $R$
\end_inset

 tuples, distributed in 
\begin_inset Formula $\frac{R}{T}$
\end_inset

 pages.
 In addition to this, we need to perform 
\begin_inset Formula $R\times N$
\end_inset

 comparisons (
\begin_inset Formula $N$
\end_inset

 predicates per tuple), which are weighted by the coefficient of CPU, 
\begin_inset Formula $H$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
Method 6
\end_layout

\end_inset

: use a non-clustering image which does not match any predicate:
\begin_inset Formula 
\[
C=R+H\times R\times N.
\]

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
Method 7
\end_layout

\end_inset

: use a relation scan, where this relation is the only one in its segment
 and test each tupple agains all predicates:
\begin_inset Formula 
\[
C=\frac{R}{T}+H\times R\times N.
\]

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
Method 8
\end_layout

\end_inset

: use a relation scan, where there are other relations sharing the segment.
 The cost is unknown, but is greater than 
\begin_inset Formula $\frac{R}{T}+H\times R\times N$
\end_inset

.
\end_layout

\begin_layout Standard
The optimizer then chooses a method from this set, according to the following
 rules:
\end_layout

\begin_layout Enumerate
If 
\series bold
Method 1
\series default
 is available, it is chose.
\end_layout

\begin_layout Enumerate
If exactly one among 
\series bold
Methods 2,3,5 and 7
\series default
 are available, it is chosen.
 If more than one method is available in this class, the expected cost formulas
 for these methods are evaluated and the method of minimum cost is chosen.
\end_layout

\begin_layout Enumerate
If none of the above methods are available, the optimizer chooses 
\series bold
Method 4
\series default
, if available.
\end_layout

\begin_layout Enumerate
Else, 
\series bold
Method 6
\series default
, if available.
\end_layout

\begin_layout Enumerate
Else, 
\series bold
Method 8
\series default
.
\end_layout

\begin_layout Subsubsection
Join query optimization
\end_layout

\begin_layout Standard
In the release paper, only 4 methods are explained, although they say the
 system takes more methods into account.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
Method 1
\end_layout

\end_inset

: use images on join fields.
 A simultaneous scan of the image on 
\begin_inset Formula $R1.A$
\end_inset

 and the image of 
\begin_inset Formula $R2.A$
\end_inset

.
 The idea is having two pointers, and advance them coordinately, using the
 fact that images are ordered to find matches.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
Method 2
\end_layout

\end_inset

: sort both relations.
 
\begin_inset Formula $R1$
\end_inset

 and 
\begin_inset Formula $R2$
\end_inset

 are ordered using their cluster images and two files, 
\begin_inset Formula $F1$
\end_inset

 and 
\begin_inset Formula $F2$
\end_inset

 are created.
 
\begin_inset Formula $F1$
\end_inset

 and 
\begin_inset Formula $F2$
\end_inset

 are sorted on field 
\begin_inset Formula $A$
\end_inset

.
 The resulting sorted files are scanned simultaneously and the join is performed.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
Method 3
\end_layout

\end_inset

: multiple passes.
 
\begin_inset Formula $R1$
\end_inset

 is scanned, storing the pertinent fields into a main memory data structure,
 
\begin_inset Formula $W$
\end_inset

.
 If space in main memory is available to insert a subtuple, 
\begin_inset Formula $S$
\end_inset

, it is inserted.
 If there is no space and 
\begin_inset Formula $S.A$
\end_inset

 is less than the current highest value of 
\begin_inset Formula $A$
\end_inset

 in 
\begin_inset Formula $W$
\end_inset

, 
\begin_inset Formula $S$
\end_inset

 is discarded.
 After completing the scan of 
\begin_inset Formula $R1$
\end_inset

, 
\begin_inset Formula $R2$
\end_inset

 is scanned using its clustering image and a tuple 
\begin_inset Formula $S'$
\end_inset

 of 
\begin_inset Formula $R2$
\end_inset

 is obtained.
 Then, 
\begin_inset Formula $W$
\end_inset

 is checked for the presence of 
\begin_inset Formula $S'.A$
\end_inset

.
 If present, 
\begin_inset Formula $S'$
\end_inset

 is joined to the appropriate subtuple in 
\begin_inset Formula $W$
\end_inset

.
 This process continues until all tuples of 
\begin_inset Formula $R2$
\end_inset

 have been examined.
 If any 
\begin_inset Formula $R1$
\end_inset

 subtuples were discarded, another scan of 
\begin_inset Formula $R1$
\end_inset

 is made to form a new 
\begin_inset Formula $W$
\end_inset

 consisting of subtuples with 
\begin_inset Formula $A$
\end_inset

 value greater than the current highest.
 
\begin_inset Formula $R2$
\end_inset

 is scanned again and the process is repeated.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
Method 4
\end_layout

\end_inset

: the TID algorithm.
 Basically, it works as follows:
\end_layout

\begin_deeper
\begin_layout Enumerate
Obtain the TIDs of tuples from 
\begin_inset Formula $R1$
\end_inset

 which satisfy additional restrictions to the join.
 Sort them and store the TIDs in a file 
\begin_inset Formula $F1$
\end_inset

.
 Do the same with 
\begin_inset Formula $R2$
\end_inset

, storing the TIDs in 
\begin_inset Formula $F2$
\end_inset

.
\end_layout

\begin_layout Enumerate
Perform a simultaneous scan over the images on 
\begin_inset Formula $R1.A$
\end_inset

 and 
\begin_inset Formula $R2.A$
\end_inset

, finding the TID pairs of tuples whose values for 
\begin_inset Formula $A$
\end_inset

 match.
\end_layout

\begin_layout Enumerate
Check each pair 
\begin_inset Formula $\left(TID1,TID2\right)$
\end_inset

 to see if 
\begin_inset Formula $TID1$
\end_inset

 is present in 
\begin_inset Formula $W1$
\end_inset

 and 
\begin_inset Formula $TID2$
\end_inset

 is present in 
\begin_inset Formula $W2$
\end_inset

.
 If they are, the tuples are fetched and joined.
\end_layout

\end_deeper
\begin_layout Standard
A method cannot be applied unless the appropriate access paths are available.
 The 
\series bold
performance of a method
\series default
 depends strongly on the clustering of the relations with respect to the
 access paths.
 In the paper, four situation are presented in which the optimizer would
 decide between the four methods, but they claim to detail the cost formulas
 on a later paper:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
Situation 1
\end_layout

\end_inset

: there are clustering images on both 
\begin_inset Formula $R1.A$
\end_inset

 and 
\begin_inset Formula $R2.A$
\end_inset

, but not no images on 
\begin_inset Formula $R1.B$
\end_inset

 or 
\begin_inset Formula $R2.C$
\end_inset

, which are additional conditions.
 
\series bold
Method 1
\series default
 is always chosen.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
Situation 2
\end_layout

\end_inset

: there are non-clustering images on 
\begin_inset Formula $R1.A$
\end_inset

 and 
\begin_inset Formula $R2.A$
\end_inset

, but no images on 
\begin_inset Formula $R1.B$
\end_inset

 or 
\begin_inset Formula $R2.C$
\end_inset

.
 
\series bold
Method 3
\series default
 is chosen if 
\begin_inset Formula $W$
\end_inset

 fits into the main memory buffer at once.
 Otherwise, 
\series bold
Method 2
\series default
 is chosen.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
Situation 3
\end_layout

\end_inset

: there are clustering images on 
\begin_inset Formula $R1.A$
\end_inset

 and 
\begin_inset Formula $R2.A$
\end_inset

 and non-clustering images on 
\begin_inset Formula $R1.B$
\end_inset

 or 
\begin_inset Formula $R2.C$
\end_inset

.
 
\series bold
Method 4 
\series default
is always chosen.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
Situation 4
\end_layout

\end_inset

: there are non-clustering images on 
\begin_inset Formula $R1.A,R2.A,R1.B$
\end_inset

 and 
\begin_inset Formula $R2.C$
\end_inset

.
 
\series bold
Method 3
\series default
 is chosen if 
\begin_inset Formula $W$
\end_inset

 fits into the main memory buffer.
 Otherwise, 
\series bold
Method 2
\series default
 is chosen if more than one tuple per disk page is expected to satisfy the
 restr 
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintCited"
bibfiles "dbsa_bib"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
