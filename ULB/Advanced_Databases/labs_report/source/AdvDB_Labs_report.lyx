#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble

\usepackage{footmisc}
\usepackage{listings}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{1,0.99,0.94}

\lstdefinestyle{mystyle}{
	language=SQL,
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,  
    frame=single,
    tabsize=2
}

\lstset{style=mystyle}
\end_preamble
\use_default_options true
\begin_modules
tcolorbox
customHeadersFooters
theorems-ams-bytype
theorems-sec-bytype
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=blue, urlcolor=blue, citecolor=blue, pdfstartview={FitH}, unicode=true"
\papersize a4paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\boxbgcolor #62a0ea
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 3cm
\rightmargin 2cm
\bottommargin 3cm
\headheight 2cm
\headsep 1cm
\footskip 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
INFOH415 - Advanced Databases
\end_layout

\begin_layout Date
Fall 2022
\end_layout

\begin_layout Author
Jose Antonio Lorencio Abril
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 1200px-Universit√©_libre_de_Bruxelles_(logo).svg.png
	scale 10

\end_inset


\end_layout

\begin_layout Standard
\align right
Professor: Gilles Dejaegere
\end_layout

\begin_layout Standard
\align right
Student e-mail: jose.lorencio.abril@ulb.be
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList table

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand lstlistoflistings

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Active Databases
\end_layout

\begin_layout Section
Session 1: Exercises 'PhD'
\end_layout

\begin_layout Standard
Consider the following database schema:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado6.png

\end_inset


\end_layout

\begin_layout Standard
Define in SQL Server a set of triggers that ensure the following constraints:
\end_layout

\begin_layout Enumerate
A PhD student must work in the same laboratory as his/her supervisor.
\end_layout

\begin_deeper
\begin_layout Standard
This can be violated by: 
\end_layout

\begin_layout Enumerate
Insert into PhDStudent.
\end_layout

\begin_layout Enumerate
Update of Laboratory or Supervisor in PhDStudent.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

-- For a) and b)
\end_layout

\begin_layout Plain Layout

-- Case Abort:
\end_layout

\begin_layout Plain Layout

create trigger StudSameLabAsSuperv_PhDStud_InsUpd_Abort on PhDStudent after
 insert, update as
\end_layout

\begin_layout Plain Layout

if exists (
\end_layout

\begin_layout Plain Layout

	select * 
\end_layout

\begin_layout Plain Layout

	from Inserted I, Professor P
\end_layout

\begin_layout Plain Layout

	where P.ProfNo = I.Supervisor
\end_layout

\begin_layout Plain Layout

		and P.Laboratory <> I.Laboratory )
\end_layout

\begin_layout Plain Layout

begin
\end_layout

\begin_layout Plain Layout

	raiserror ('Constraint Violation: A PhD student must work in the same laborator
y as his/her supervisor', 1, 1)
\end_layout

\begin_layout Plain Layout

	rollback
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- Case Repair:
\end_layout

\begin_layout Plain Layout

create trigger StudSameLabAsSuperv_PhDStud_InsUpd_Repair on PhDStudent after
 insert, update as
\end_layout

\begin_layout Plain Layout

begin
\end_layout

\begin_layout Plain Layout

	update PhDStudent
\end_layout

\begin_layout Plain Layout

	set Laboratory = (
\end_layout

\begin_layout Plain Layout

		select P.Laboratory
\end_layout

\begin_layout Plain Layout

		from Professor P
\end_layout

\begin_layout Plain Layout

		where P.ProfNo = Supervisor )
\end_layout

\begin_layout Plain Layout

	where StudentNo in (
\end_layout

\begin_layout Plain Layout

		select I.StudentNo
\end_layout

\begin_layout Plain Layout

		from Inserted I )
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Update of Laboratory in Professor.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

-- Abort
\end_layout

\begin_layout Plain Layout

create trigger StudSameLabAsSuperv_Prof_Upd_Abort on Professor after update
 as
\end_layout

\begin_layout Plain Layout

if exists (
\end_layout

\begin_layout Plain Layout

	select * 
\end_layout

\begin_layout Plain Layout

	from Inserted I, PhDStudent S
\end_layout

\begin_layout Plain Layout

	where I.ProfNo = S.Supervisor
\end_layout

\begin_layout Plain Layout

		and I.Laboratory <> S.Laboratory )
\end_layout

\begin_layout Plain Layout

begin
\end_layout

\begin_layout Plain Layout

	raiserror ('Constraint Violation: A PhD student must work in the same laborator
y as his/her supervisor', 1, 1)
\end_layout

\begin_layout Plain Layout

	rollback
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- Repair
\end_layout

\begin_layout Plain Layout

create trigger StudSameLabAsSuperv_Prof_Upd_Repair on Professor after update
 as
\end_layout

\begin_layout Plain Layout

begin
\end_layout

\begin_layout Plain Layout

	update PhDStudent
\end_layout

\begin_layout Plain Layout

	set Laboratory = (
\end_layout

\begin_layout Plain Layout

		select I.Laboratory
\end_layout

\begin_layout Plain Layout

		from Inserted I
\end_layout

\begin_layout Plain Layout

		where Supervisor = I.ProfNo )
\end_layout

\begin_layout Plain Layout

	where Supervisor in (
\end_layout

\begin_layout Plain Layout

		select I2.ProfNo
\end_layout

\begin_layout Plain Layout

		from Inserted I2 )
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Delete from Professor: The professor is deleted and the attributes Laboratory
 and Supervisor of the PhD students who worked for the deleted professor
 are set to null.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

alter table PhDStudent
\end_layout

\begin_layout Plain Layout

drop constraint FK_PhDStudent_Professor -- Because SQL server r does not
 implement the option on delete set null for the referential integrity,
 it is necessary to drop the foreign key constraint in the table PhDStudent.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

create trigger StudSameLabAsSuperv_Prof_Del_Repair on Professor after delete
 as
\end_layout

\begin_layout Plain Layout

begin
\end_layout

\begin_layout Plain Layout

	update PhDStudent
\end_layout

\begin_layout Plain Layout

	set Laboratory = null, Supervisor = null
\end_layout

\begin_layout Plain Layout

	where Supervisor in (
\end_layout

\begin_layout Plain Layout

		select ProfNo
\end_layout

\begin_layout Plain Layout

		from Deleted )
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
A PhD student must take at least one course.
\end_layout

\begin_deeper
\begin_layout Standard
This can be violated by:
\end_layout

\begin_layout Enumerate
Insert into PhDStudent
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

-- This does not work in SQL Server, since a trigger is executed immediately
 after the triggering instruction.
 Thus, embedding several inserts (into PhDStudent and CourseTaken) into
 one transaction would not help.
 Practically, thus, and without any further assumption, it will not be possible
 to ensure that this constraint verified, as the aborting trigger would
 prevent any insertion into the table PhDStudent.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

create trigger PhDStudMinOneCourse_PhDStud_Ins_Abort on PhDStudent after
 insert as
\end_layout

\begin_layout Plain Layout

if exists (
\end_layout

\begin_layout Plain Layout

	select * 
\end_layout

\begin_layout Plain Layout

	from Inserted I
\end_layout

\begin_layout Plain Layout

	where not exists (
\end_layout

\begin_layout Plain Layout

		select *
\end_layout

\begin_layout Plain Layout

		from CourseTaken
\end_layout

\begin_layout Plain Layout

		where StudentNo = I.StudentNo ) )
\end_layout

\begin_layout Plain Layout

begin
\end_layout

\begin_layout Plain Layout

	raiserror ('Constraint Violation: A PhD student must take at least one
 course', 1, 1)
\end_layout

\begin_layout Plain Layout

	rollback
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Update of StudentNo in CourseTaken
\end_layout

\begin_layout Enumerate
Delete from CourseTaken
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

-- For b) and c)
\end_layout

\begin_layout Plain Layout

create trigger PhDStudMinOneCourse_PhDStud_Ins_Abort on CourseTaken after
 update, delete as
\end_layout

\begin_layout Plain Layout

if exists (
\end_layout

\begin_layout Plain Layout

	select * 
\end_layout

\begin_layout Plain Layout

	from Deleted D
\end_layout

\begin_layout Plain Layout

	where D.StudentNo not in (
\end_layout

\begin_layout Plain Layout

		select StudentNo
\end_layout

\begin_layout Plain Layout

		from CourseTaken ) )
\end_layout

\begin_layout Plain Layout

begin
\end_layout

\begin_layout Plain Layout

	raiserror ('Constraint Violation: A PhD student must take at least one
 course', 1, 1)
\end_layout

\begin_layout Plain Layout

	rollback
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Delete from Course: Removing an entry from Course could indirectly affect
 the number of courses taken by one or several PhD students.
 This case, however, should be handled with the 
\emph on
on update cascade
\emph default
 option of the referential integrity constraint on the CourseNo field of
 CourseTaken.
\end_layout

\end_deeper
\begin_layout Enumerate
A PhD student must take all courses taught by his/her supervisor.
\end_layout

\begin_deeper
\begin_layout Standard
This can violated by:
\end_layout

\begin_layout Enumerate
Insert into PhDStudent
\end_layout

\begin_layout Enumerate
Update of Supervisor in PhDStudent
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

-- for a) and b)
\end_layout

\begin_layout Plain Layout

-- Abort
\end_layout

\begin_layout Plain Layout

create trigger StudAllCoursesOfSuperv_Stud_InsUpd_Abort on PhDStudent after
 insert, update as
\end_layout

\begin_layout Plain Layout

if exists (
\end_layout

\begin_layout Plain Layout

	select * 
\end_layout

\begin_layout Plain Layout

	from Inserted I
\end_layout

\begin_layout Plain Layout

	where exists (
\end_layout

\begin_layout Plain Layout

		select *
\end_layout

\begin_layout Plain Layout

		from Course C
\end_layout

\begin_layout Plain Layout

		where C.ProfNo = I.Supervisor
\end_layout

\begin_layout Plain Layout

			and C.CourseNo not in (
\end_layout

\begin_layout Plain Layout

				select T.CourseNo
\end_layout

\begin_layout Plain Layout

				from CourseTaken T
\end_layout

\begin_layout Plain Layout

				where T.StudentNo = I.StudentNo ) ) )
\end_layout

\begin_layout Plain Layout

begin
\end_layout

\begin_layout Plain Layout

	raiserror ('Constraint Violation: A PhD student must take all the courses
 given by his supervisor', 1, 1)
\end_layout

\begin_layout Plain Layout

	rollback
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- Repair
\end_layout

\begin_layout Plain Layout

create trigger StudAllCoursesOfSuperv_Stud_InsUpd_Repair on PhDStudent after
 insert, update as
\end_layout

\begin_layout Plain Layout

begin
\end_layout

\begin_layout Plain Layout

	insert into CourseTaken (StudentNo, CourseNo)
\end_layout

\begin_layout Plain Layout

		select I.StudentNo, C.CourseNo
\end_layout

\begin_layout Plain Layout

		from Inserted I, Professor P, Course C
\end_layout

\begin_layout Plain Layout

		where I.Supervisor = P.ProfNo
\end_layout

\begin_layout Plain Layout

			and C.ProfNo = P.ProfNo
\end_layout

\begin_layout Plain Layout

				and C.CourseNo not in (
\end_layout

\begin_layout Plain Layout

					select T.CourseNo
\end_layout

\begin_layout Plain Layout

					from CoursTaken T
\end_layout

\begin_layout Plain Layout

					where T.StudentNo = I.StudentNo )
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Insert into Course
\end_layout

\begin_layout Enumerate
Update of ProfNo in Course√ß
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

-- Events c) and d)
\end_layout

\begin_layout Plain Layout

-- Aborting the transaction, particularly in SQL Server (where triggers
 are executed immediately after the triggering instruction), would not work
 (well).
 The repairing rule being implicitly defined, or at least suggested, by
 the constraint (namely to automatically enrol the student in the added
 course), it will be the method of choice for this case.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- Repair
\end_layout

\begin_layout Plain Layout

create trigger StudAllCoursesOfSuperv_Course_InsUpd_Repair on Course after
 insert, update as
\end_layout

\begin_layout Plain Layout

begin
\end_layout

\begin_layout Plain Layout

	insert into CourseTaken (StudentNo, CourseNo)
\end_layout

\begin_layout Plain Layout

		select S.StudentNo, I.CourseNo
\end_layout

\begin_layout Plain Layout

		from Inserted I, Professor P, PhDStudent S
\end_layout

\begin_layout Plain Layout

		where C.ProfNo = P.ProfNo
\end_layout

\begin_layout Plain Layout

			and S.Supervisor = P.ProfNo
\end_layout

\begin_layout Plain Layout

			and I.CourseNo not in (
\end_layout

\begin_layout Plain Layout

				select T.CourseNo
\end_layout

\begin_layout Plain Layout

				from CourseTaken T
\end_layout

\begin_layout Plain Layout

				where T.StudentNo = C.StudentNo )
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Update of StudentNo or CourseNo in CourseTaken
\end_layout

\begin_layout Enumerate
Delete from CourseTaken
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

-- Events e) and f)
\end_layout

\begin_layout Plain Layout

create trigger StudAllCoursesOfSuperv_CourseTaken_UpdDel_Abort on CourseTaken
 after update, delete as
\end_layout

\begin_layout Plain Layout

if exists (
\end_layout

\begin_layout Plain Layout

	select *
\end_layout

\begin_layout Plain Layout

	from Deleted D, Course C, PhDStudent S
\end_layout

\begin_layout Plain Layout

	where D.CourseNo = C.CourseNo
\end_layout

\begin_layout Plain Layout

		and C.ProfNo = S.Supervisor
\end_layout

\begin_layout Plain Layout

		and D.StudentNo = S.StudentNo )
\end_layout

\begin_layout Plain Layout

begin
\end_layout

\begin_layout Plain Layout

	raiserror ('Constraint Violation: A PhD student must take all the courses
 given by his supervisor', 1, 1)
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Section
Sessions 2 and 3: Exercises 'Employees department projects'
\end_layout

\begin_layout Standard
We have the schema:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado11.png

\end_inset


\end_layout

\begin_layout Standard
In SQL Server, enforce the following constraints using a set of CHECK constraint
s, referential integrity constraints, or triggers.
\end_layout

\begin_layout Standard

\series bold
Exercise 1.

\series default
 The age of employees must be greater than 18.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

--Using a CHECK constraint
\end_layout

\begin_layout Plain Layout

alter table Employee
\end_layout

\begin_layout Plain Layout

	add constraint employee_Age18
\end_layout

\begin_layout Plain Layout

		check ( dateadd(year,18,BDate) <= getdate() )
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

--Using a trigger
\end_layout

\begin_layout Plain Layout

create trigger age18 on Employee after insert, update as
\end_layout

\begin_layout Plain Layout

if exists (
\end_layout

\begin_layout Plain Layout

	select *
\end_layout

\begin_layout Plain Layout

	from Inserted
\end_layout

\begin_layout Plain Layout

	where dateadd(year,18,BDate) > getdate() )
\end_layout

\begin_layout Plain Layout

begin
\end_layout

\begin_layout Plain Layout

	raiserror('Constraint Violation: The age of an employee must be greater
 than 18', 1, 1)
\end_layout

\begin_layout Plain Layout

	rollback
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Exercise 2.

\series default
 The supervisor of an employee must be older than the employee.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

--Using a trigger
\end_layout

\begin_layout Plain Layout

create trigger supervisorAge on Employee after insert, update as
\end_layout

\begin_layout Plain Layout

if exists (
\end_layout

\begin_layout Plain Layout

	select *
\end_layout

\begin_layout Plain Layout

	from Inserted I, Employee E
\end_layout

\begin_layout Plain Layout

	where ( I.SuperSSN = E.SSN and I.BDate < E.BDate )
\end_layout

\begin_layout Plain Layout

		or ( E.SuperSSN = I.SSN and E.BDate < I.BDate ) )
\end_layout

\begin_layout Plain Layout

begin
\end_layout

\begin_layout Plain Layout

	raiserror( 'Constraint Violation: The age of an employee must be less than
 the age of his/her supervisor', 1, 1)
\end_layout

\begin_layout Plain Layout

	rollback
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Exercise 3.

\series default
 The salary of an employee cannot be greater than the salary of his/her
 supervisor.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

-- Using a trigger
\end_layout

\begin_layout Plain Layout

create trigger supervisorSalary on Employee after insert, update as
\end_layout

\begin_layout Plain Layout

if exists (
\end_layout

\begin_layout Plain Layout

	select *
\end_layout

\begin_layout Plain Layout

	from Inserted I, Employee E
\end_layout

\begin_layout Plain Layout

	where ( I.SuperSSN = E.SSN and I.Salary > E.Salary )
\end_layout

\begin_layout Plain Layout

		or ( E.SuperSSN = I.SSN and E.Salary > I.Salary ) )
\end_layout

\begin_layout Plain Layout

begin
\end_layout

\begin_layout Plain Layout

	raiserror('Constraint Violation: The salary of an employee cannot be greater
 than the salary of his/her supervisor', 1, 1)
\end_layout

\begin_layout Plain Layout

	rollback
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Exercise 4.

\series default
 The manager of a department must be an employee of that department.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

-- Using UNIQUE and foreign key constraints
\end_layout

\begin_layout Plain Layout

alter table Employee
\end_layout

\begin_layout Plain Layout

	add constraint UN_Employee_SSN_DNo unique( SSN, DNO )
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

alter table Department
\end_layout

\begin_layout Plain Layout

	add constraint FK_Employee_SSN_DNo foreign key( MgrSSN, DNumber ) references
 Employee( SSN, DNo )
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Exercise 5.

\series default
 The location of a project must be one of the locations of its department.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

-- Using a foreign key constraint
\end_layout

\begin_layout Plain Layout

alter table Project
\end_layout

\begin_layout Plain Layout

	add constraint FK_Project_DeptLocations foreign key( DNumber, PLocation
 ) references DeptLocations( DNumber, DLocation )
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Exercise 6.
 
\series default
The hire date of employees must be greater than their birth date.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

-- Using a CHECK key constraint
\end_layout

\begin_layout Plain Layout

alter table Employee
\end_layout

\begin_layout Plain Layout

	add constraint HireDate_BDate check( HireDate > BDate )
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Exercise 7.

\series default
 A supervisor must be hired at least 1 year before every employee s/he supervise
s.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

-- Using a trigger
\end_layout

\begin_layout Plain Layout

create trigger hireSuperv on Employee after insert, update as
\end_layout

\begin_layout Plain Layout

if exists (
\end_layout

\begin_layout Plain Layout

	select *
\end_layout

\begin_layout Plain Layout

	from Inserted I, Employee E
\end_layout

\begin_layout Plain Layout

	where ( I.SuperSSN = E.SSN and datediff(year, E.HireDate, I.HireDate) < 1)
\end_layout

\begin_layout Plain Layout

		or ( E.SuperSSN = I.SSN and datediff(year, I.HireDate, E.HireDate) < 1))
\end_layout

\begin_layout Plain Layout

begin
\end_layout

\begin_layout Plain Layout

	raiserror('Constraint Violation: A supervisor must be hired at least 1
 year before every employee s/he supervises', 1, 1)
\end_layout

\begin_layout Plain Layout

	rollback
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Exercise 8.

\series default
 The attribute Department.NbrEmployees is a derived attribute from Employee.DNo.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

-- Using value deriving triggers
\end_layout

\begin_layout Plain Layout

create trigger DeptNbrEmp_Employee_InsUpdDel_Derive on Employee after insert,
 update, delete as
\end_layout

\begin_layout Plain Layout

begin
\end_layout

\begin_layout Plain Layout

	update Department D
\end_layout

\begin_layout Plain Layout

	set NbrEmployees = (
\end_layout

\begin_layout Plain Layout

		select count(*)
\end_layout

\begin_layout Plain Layout

		from Employee E
\end_layout

\begin_layout Plain Layout

		where E.DNo = D.DNumber )
\end_layout

\begin_layout Plain Layout

	where D.DNumber in (
\end_layout

\begin_layout Plain Layout

			select distinct I.DNo
\end_layout

\begin_layout Plain Layout

			from Inserted I )
\end_layout

\begin_layout Plain Layout

		or D.DNumber in (
\end_layout

\begin_layout Plain Layout

			select distinct D.DNo
\end_layout

\begin_layout Plain Layout

			from Deleted D )
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- Incremental version
\end_layout

\begin_layout Plain Layout

create trigger derived_Department_NbrEmployees_Employee on Employee after
 insert, update, delete as
\end_layout

\begin_layout Plain Layout

begin
\end_layout

\begin_layout Plain Layout

	update Department
\end_layout

\begin_layout Plain Layout

	set NbrEmployees = NbrEmployees +
\end_layout

\begin_layout Plain Layout

		( select count(*) from Inserted I where DNumber=I.DNo ) -
\end_layout

\begin_layout Plain Layout

		( select count(*) from Deleted D where DNumber=D.DNo )
\end_layout

\begin_layout Plain Layout

	where DNumber in ( select DNo from Inserted )
\end_layout

\begin_layout Plain Layout

		or DNumber in ( select DNo from Deleted )
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

create trigger derived_Department_NbrEmployees_Department on Department
 after insert, update as
\end_layout

\begin_layout Plain Layout

if exists ( 
\end_layout

\begin_layout Plain Layout

	select *
\end_layout

\begin_layout Plain Layout

	from Inserted
\end_layout

\begin_layout Plain Layout

	where NbrEmployees <> ( 
\end_layout

\begin_layout Plain Layout

		select count(*)
\end_layout

\begin_layout Plain Layout

		from Employee E
\end_layout

\begin_layout Plain Layout

		where E.DNo = DNumber ) )
\end_layout

\begin_layout Plain Layout

begin
\end_layout

\begin_layout Plain Layout

	raiserror('Constraint Violation: The attribute Department.NbrEmployees is
 a derived attribute from Employee.DNo', 1, 1)
\end_layout

\begin_layout Plain Layout

	rollback
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Exercise 9.

\series default
 An employee works at most in 4 projects.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

-- Using a trigger
\end_layout

\begin_layout Plain Layout

create trigger empNbrProj on WorksOn after insert, update as
\end_layout

\begin_layout Plain Layout

if exists (
\end_layout

\begin_layout Plain Layout

	select *
\end_layout

\begin_layout Plain Layout

	from WorksOn W
\end_layout

\begin_layout Plain Layout

	group by W.ESSN
\end_layout

\begin_layout Plain Layout

	having count(*) > 4 )
\end_layout

\begin_layout Plain Layout

begin
\end_layout

\begin_layout Plain Layout

	raiserror('Constraint Violation: An employee works at most in 4 projects',
 1, 1)
\end_layout

\begin_layout Plain Layout

	rollback
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Exercise 10.

\series default
 An employee works at least 30h/week and at most 50 h/week on all its projects.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

-- Using a trigger
\end_layout

\begin_layout Plain Layout

create trigger workson_30_50 on WorksOn after insert, update, delete as
\end_layout

\begin_layout Plain Layout

if exists ( 
\end_layout

\begin_layout Plain Layout

	select *
\end_layout

\begin_layout Plain Layout

	from WorksOn
\end_layout

\begin_layout Plain Layout

	group by ESSN
\end_layout

\begin_layout Plain Layout

	having ( sum(Hours) < 30 )
\end_layout

\begin_layout Plain Layout

		or ( sum(Hours) > 50 ) )
\end_layout

\begin_layout Plain Layout

begin
\end_layout

\begin_layout Plain Layout

	raiserror('Constraint Violation: An employee works at least 30 h/week and
 at most 50 h/week on all its projects', 1, 1)
\end_layout

\begin_layout Plain Layout

	rollback
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Exercise 11.

\series default
 Among all employees working on a project, at most 2 can work for less than
 10 hours.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

-- Using a trigger
\end_layout

\begin_layout Plain Layout

create trigger worksonLess10h on WorksOn after insert, update as
\end_layout

\begin_layout Plain Layout

if exists ( 
\end_layout

\begin_layout Plain Layout

	select *
\end_layout

\begin_layout Plain Layout

	from WorksOn
\end_layout

\begin_layout Plain Layout

	where Hours < 10
\end_layout

\begin_layout Plain Layout

	group by PNo
\end_layout

\begin_layout Plain Layout

	having count(*) > 2 )
\end_layout

\begin_layout Plain Layout

begin
\end_layout

\begin_layout Plain Layout

	raiserror('Constraint Violation: A project can have at most 2 employees
 working on the project less than 10 hours', 1, 1)
\end_layout

\begin_layout Plain Layout

	rollback 
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Exercise 12.

\series default
 Only department managers can work less than 5 hours on a project.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

-- Using a set of triggers
\end_layout

\begin_layout Plain Layout

create trigger worksonLess5h_WorksOn on WorksOn after insert, update as
\end_layout

\begin_layout Plain Layout

if exists ( 
\end_layout

\begin_layout Plain Layout

	select *
\end_layout

\begin_layout Plain Layout

	from Inserted
\end_layout

\begin_layout Plain Layout

	where Hours < 5
\end_layout

\begin_layout Plain Layout

		and ESSN not in (
\end_layout

\begin_layout Plain Layout

			select MgrSSN
\end_layout

\begin_layout Plain Layout

			from Department
\end_layout

\begin_layout Plain Layout

			where MgrSSN is not null ) )
\end_layout

\begin_layout Plain Layout

begin
\end_layout

\begin_layout Plain Layout

	raiserror('Constraint Violation: Only department managers can work less
 than 5 hours on a project', 1, 1)
\end_layout

\begin_layout Plain Layout

	rollback
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

create trigger worksonLess5h_Department on Department after update, delete
 as
\end_layout

\begin_layout Plain Layout

if exists ( 
\end_layout

\begin_layout Plain Layout

	select *
\end_layout

\begin_layout Plain Layout

	from Deleted
\end_layout

\begin_layout Plain Layout

	where MgrSSN not in (
\end_layout

\begin_layout Plain Layout

			select MgrSSN
\end_layout

\begin_layout Plain Layout

			from Department )
\end_layout

\begin_layout Plain Layout

		and MgrSSN in (
\end_layout

\begin_layout Plain Layout

			select ESSN
\end_layout

\begin_layout Plain Layout

			from WorksOn
\end_layout

\begin_layout Plain Layout

			where Hours < 5 ) )
\end_layout

\begin_layout Plain Layout

begin
\end_layout

\begin_layout Plain Layout

	raiserror('Constraint Violation: Only department managers can work less
 than 5 hours on a project', 1, 1)
\end_layout

\begin_layout Plain Layout

	rollback
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Exercise 13.

\series default
 Employees that are not supervisors must work at least 10 hours on every
 project they work.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

-- Using a set of triggers
\end_layout

\begin_layout Plain Layout

create trigger workson10h_WorksOn on WorksOn after insert, update as
\end_layout

\begin_layout Plain Layout

if exists ( 
\end_layout

\begin_layout Plain Layout

	select *
\end_layout

\begin_layout Plain Layout

	from Inserted
\end_layout

\begin_layout Plain Layout

	where Hours < 10
\end_layout

\begin_layout Plain Layout

		and ESSN not in (
\end_layout

\begin_layout Plain Layout

			select SuperSSN
\end_layout

\begin_layout Plain Layout

			from Employee
\end_layout

\begin_layout Plain Layout

			where SuperSSN is not null ) )
\end_layout

\begin_layout Plain Layout

begin
\end_layout

\begin_layout Plain Layout

	raiserror('Constraint Violation: Employees that are not supervisors must
 work at least 10 hours on every project they work', 1, 1)
\end_layout

\begin_layout Plain Layout

	rollback
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

create trigger workson10h_Employee on Employee after update, delete as
\end_layout

\begin_layout Plain Layout

if exists ( 
\end_layout

\begin_layout Plain Layout

	select *
\end_layout

\begin_layout Plain Layout

	from Deleted
\end_layout

\begin_layout Plain Layout

	where SuperSSN not in (
\end_layout

\begin_layout Plain Layout

			select SuperSSN
\end_layout

\begin_layout Plain Layout

			from Employee
\end_layout

\begin_layout Plain Layout

			where SuperSSN is not null )
\end_layout

\begin_layout Plain Layout

		and SuperSSN in (
\end_layout

\begin_layout Plain Layout

			select ESSN
\end_layout

\begin_layout Plain Layout

			from WorksOn
\end_layout

\begin_layout Plain Layout

			where Hours < 10 ) )
\end_layout

\begin_layout Plain Layout

begin
\end_layout

\begin_layout Plain Layout

	raiserror('Constraint Violation: Employees that are not supervisors must
 work at least 10 hours on every project they work', 1, 1)
\end_layout

\begin_layout Plain Layout

	rollback
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Exercise 14.

\series default
 The manager of a department must work at least 5 hours on all projects
 controlled by the department.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

-- Using a set of triggers
\end_layout

\begin_layout Plain Layout

create trigger mgrProj_Department on Department after insert, update as
\end_layout

\begin_layout Plain Layout

if exists ( 
\end_layout

\begin_layout Plain Layout

	select *
\end_layout

\begin_layout Plain Layout

	from ( Inserted I join Project P on I.DNumber = P.DNumber )
\end_layout

\begin_layout Plain Layout

		left outer join WorksOn on MgrSSN = ESSN and PNumber = PNo
\end_layout

\begin_layout Plain Layout

	where Hours is null
\end_layout

\begin_layout Plain Layout

		or Hours < 5 )
\end_layout

\begin_layout Plain Layout

begin
\end_layout

\begin_layout Plain Layout

	raiserror('Constraint Violation: A manager must work at least 5 hours on
 all projects controlled by his/her department', 1, 1)
\end_layout

\begin_layout Plain Layout

	rollback
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

create trigger mgrProj_Project on Project after insert, update as
\end_layout

\begin_layout Plain Layout

if exists ( 
\end_layout

\begin_layout Plain Layout

	select *
\end_layout

\begin_layout Plain Layout

	from ( Project P join Department D on D.DNumber = P.DNumber )
\end_layout

\begin_layout Plain Layout

		left outer join WorksOn on MgrSSN = ESSN and PNumber = PNo
\end_layout

\begin_layout Plain Layout

	where P.PNumber in ( 
\end_layout

\begin_layout Plain Layout

			select PNumber
\end_layout

\begin_layout Plain Layout

			from Inserted )
\end_layout

\begin_layout Plain Layout

		and ( Hours is null
\end_layout

\begin_layout Plain Layout

		or Hours < 5 ) )
\end_layout

\begin_layout Plain Layout

begin
\end_layout

\begin_layout Plain Layout

	raiserror('Constraint Violation: A manager must work at least 5 hours on
 all projects controlled by his/her department', 1, 1)
\end_layout

\begin_layout Plain Layout

	rollback
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

create trigger mgrProj_WorksOn on WorksOn after update, delete as
\end_layout

\begin_layout Plain Layout

if exists ( 
\end_layout

\begin_layout Plain Layout

	select *
\end_layout

\begin_layout Plain Layout

	from ( Department D join Project P on D.DNumber=P.DNumber)
\end_layout

\begin_layout Plain Layout

		left outer join WorksOn on MgrSSN = ESSN and PNumber = PNo
\end_layout

\begin_layout Plain Layout

	where D.MgrSSN in ( 
\end_layout

\begin_layout Plain Layout

			select ESSN
\end_layout

\begin_layout Plain Layout

			from Deleted )
\end_layout

\begin_layout Plain Layout

		and ( Hours is null
\end_layout

\begin_layout Plain Layout

		or Hours < 5 ) )
\end_layout

\begin_layout Plain Layout

begin
\end_layout

\begin_layout Plain Layout

	raiserror('Constraint Violation: A manager must work at least 5 hours on
 all projects controlled by his/her department', 1, 1)
\end_layout

\begin_layout Plain Layout

	rollback
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Exercise 15.

\series default
 The attribute Employee.SuperSSN is a derived attribute computed as follows.
 Department managers are supervised by the manager of Department 1 (Headquarters
).
 Employees that are not managers are supervised by the manager of their
 department.
 Finally, the manager of Department 1 has a null value in attribute SuperSSN.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

-- Using a set of triggers
\end_layout

\begin_layout Plain Layout

create trigger derived_Employee_SuperSSN_Department on Department after
 insert, update as
\end_layout

\begin_layout Plain Layout

if update(MgrSSN)
\end_layout

\begin_layout Plain Layout

begin
\end_layout

\begin_layout Plain Layout

	update Employee
\end_layout

\begin_layout Plain Layout

	set SuperSSN = (
\end_layout

\begin_layout Plain Layout

		select case when SSN != D.MgrSSN
\end_layout

\begin_layout Plain Layout

				then D.MgrSSN
\end_layout

\begin_layout Plain Layout

			when SSN = D.MgrSSN and DNo != 1
\end_layout

\begin_layout Plain Layout

				then ( 
\end_layout

\begin_layout Plain Layout

					select MgrSSN
\end_layout

\begin_layout Plain Layout

					from Department
\end_layout

\begin_layout Plain Layout

					where DNumber = 1 )
\end_layout

\begin_layout Plain Layout

			else null
\end_layout

\begin_layout Plain Layout

			end
\end_layout

\begin_layout Plain Layout

from Department D
\end_layout

\begin_layout Plain Layout

where DNo = D.DNumber )
\end_layout

\begin_layout Plain Layout

-- if the department manager changes all employees of the department
\end_layout

\begin_layout Plain Layout

-- must be updated
\end_layout

\begin_layout Plain Layout

	where ( DNo in (
\end_layout

\begin_layout Plain Layout

			select DNumber
\end_layout

\begin_layout Plain Layout

			from Inserted ) )
\end_layout

\begin_layout Plain Layout

-- if the manager of department 1 changes, all department managers
\end_layout

\begin_layout Plain Layout

-- must be updated
\end_layout

\begin_layout Plain Layout

		or ( 1 in (
\end_layout

\begin_layout Plain Layout

				select DNumber
\end_layout

\begin_layout Plain Layout

				from Inserted )
\end_layout

\begin_layout Plain Layout

			and SSN in (
\end_layout

\begin_layout Plain Layout

				select MgrSSN
\end_layout

\begin_layout Plain Layout

				from Department ) )
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

create trigger derived_Employee_SuperSSN_Employee on Employee after insert,
 update as
\end_layout

\begin_layout Plain Layout

if update(DNo)
\end_layout

\begin_layout Plain Layout

begin
\end_layout

\begin_layout Plain Layout

	update Employee
\end_layout

\begin_layout Plain Layout

	set SuperSSN = (
\end_layout

\begin_layout Plain Layout

		select case when SSN != MgrSSN
\end_layout

\begin_layout Plain Layout

				then D.MgrSSN
\end_layout

\begin_layout Plain Layout

			when SSN = MgrSSN and I.DNo != 1
\end_layout

\begin_layout Plain Layout

				then ( 
\end_layout

\begin_layout Plain Layout

					select MgrSSN
\end_layout

\begin_layout Plain Layout

					from Department
\end_layout

\begin_layout Plain Layout

					where DNumber = 1 )
\end_layout

\begin_layout Plain Layout

			else null
\end_layout

\begin_layout Plain Layout

			end
\end_layout

\begin_layout Plain Layout

		from Inserted I, Department D
\end_layout

\begin_layout Plain Layout

		where SSN = I.SSN and I.DNo = D.DNumber )
\end_layout

\begin_layout Plain Layout

	where SSN in (
\end_layout

\begin_layout Plain Layout

		select SSN
\end_layout

\begin_layout Plain Layout

		from Inserted )
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Exercise 16.
 
\series default
The supervision relationship defined by Employee.SuperSSN must not be cyclic.
 (It is supposed that attribute Employee.SuperSSN is not derived as stated
 above.)
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

-- Using a trigger
\end_layout

\begin_layout Plain Layout

create trigger noncyclic_subordinates on Employee after insert, update as
\end_layout

\begin_layout Plain Layout

begin
\end_layout

\begin_layout Plain Layout

	create table #Supervision (
\end_layout

\begin_layout Plain Layout

		SSN char(9),
\end_layout

\begin_layout Plain Layout

		SuperSSN char(9)
\end_layout

\begin_layout Plain Layout

		primary key (SSN,SuperSSN) )
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

	insert into #Supervision
\end_layout

\begin_layout Plain Layout

		select SSN, SuperSSN
\end_layout

\begin_layout Plain Layout

		from Employee
\end_layout

\begin_layout Plain Layout

		where SuperSSN is not null
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	while @@rowcount != 0 -- while previous operation affected some rows
\end_layout

\begin_layout Plain Layout

	begin
\end_layout

\begin_layout Plain Layout

	if exists ( 
\end_layout

\begin_layout Plain Layout

		select *
\end_layout

\begin_layout Plain Layout

		from #Supervision
\end_layout

\begin_layout Plain Layout

		where SSN = SuperSSN )
\end_layout

\begin_layout Plain Layout

	begin
\end_layout

\begin_layout Plain Layout

		raiserror('Constraint Violation: The supervision relationship is cyclic',
 1, 1)
\end_layout

\begin_layout Plain Layout

		rollback
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	insert into #Supervision
\end_layout

\begin_layout Plain Layout

		select distinct S1.SSN, S2.SuperSSN
\end_layout

\begin_layout Plain Layout

		from #Supervision S1 join #Supervision S2 on S1.SuperSSN = S2.SSN
\end_layout

\begin_layout Plain Layout

		where not exists (
\end_layout

\begin_layout Plain Layout

			select *
\end_layout

\begin_layout Plain Layout

			from #Supervision S
\end_layout

\begin_layout Plain Layout

			where S.SSN = S1.SSN and S.SuperSSN = S2.SuperSSN )
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Graph databases
\end_layout

\begin_layout Section
Session 4: Relational graphs
\end_layout

\begin_layout Standard
Google released, in 2002, a subset of the structure of the WWW.
 In this dataset, web pages are represented by graph nodes such that when
 a web page A contains a hyperlink to web page B, a directed edge is created
 from node A to node B.
 
\end_layout

\begin_layout Standard
In this activity, we will focus on the performance of different queries.
 Therefore, we will use three PostgreSQL tables, which are subsets of different
 sizes of the web structure released by Google: 
\end_layout

\begin_layout Itemize
webgraph1 table: 605 nodes (web pages) and 1521 edges (hyperlinks) 
\end_layout

\begin_layout Itemize
webgraph2 table: 1622 nodes (web pages) and 6288 edges (hyperlinks) 
\end_layout

\begin_layout Itemize
webgraph3 table: 4122 nodes (web pages) and 14356 edges (hyperlinks)
\end_layout

\begin_layout Standard
Below, we show the list of different uses cases we want to analyze:
\end_layout

\begin_layout Exercise
For each pair of connected nodes, find the 1-hop paths.
 Include four columns in the resultset: fromNode, toNode, length, path,
 which correspond to the source node, target node, length of the path, and
 visited nodes, respectively.
 Exclude repeated nodes in the path.
 That is, if there is an edges A -> A, do not consider that A, A, 1, A-A
 is a valid 1-path from A to A.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT fromNode, toNode, 1 as length, fromNode || '-' || toNode as Path
\end_layout

\begin_layout Plain Layout

FROM webgraph1
\end_layout

\begin_layout Plain Layout

WHERE fromNode <> toNode;
\end_layout

\end_inset


\end_layout

\begin_layout Exercise
For each pair of connected nodes, find the 2-hop paths.
 Include four columns in the resultset: fromNode, toNode, length, path,
 which correspond to the source node, target node, length of the path and
 the visited nodes, respectively.
 Exclude repeated nodes in the path.
 That is, if A -> B and B->A are edges in the graph, do not consider that
 A, A, 2, A-B-A is a valid 2- path from A to A.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT w1.fromNode, w2.toNode, 2 as length, w1.fromNode || '-' || w1.toNode
 || '-' || w2.toNode as Path
\end_layout

\begin_layout Plain Layout

FROM webgraph1 w1 
\end_layout

\begin_layout Plain Layout

JOIN webgraph1 w2 ON w1.toNode = w2.fromNode
\end_layout

\begin_layout Plain Layout

WHERE w1.fromNode <> w1.toNode AND w1.fromNode <> w2.toNode AND w2.fromNode <>
 w2.toNode;
\end_layout

\end_inset


\end_layout

\begin_layout Exercise
For each pair of connected nodes, find the 3-hop paths.
 Include four columns in the resultset: fromNode, toNode, length, path,
 which correspond to the source node, target node, length of the path and
 the visited nodes, respectively.
 Exclude repeated nodes in the path.
 That is, if A -> B, A->C and B->A, are edges in the graph, do not consider
 that A, C, 3, A-B-A-C is a valid 3-path from A to C.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT w1.fromNode, w2.toNode, 2 as length, w1.fromNode || '-' || w1.toNode
 || '-' || w2.toNode as Path
\end_layout

\begin_layout Plain Layout

FROM webgraph1 w1 
\end_layout

\begin_layout Plain Layout

JOIN webgraph1 w2 ON w1.toNode = w2.fromNode
\end_layout

\begin_layout Plain Layout

JOIN webgraph1 w3 ON w2.toNode = w3.fromNode
\end_layout

\begin_layout Plain Layout

WHERE w1.fromNode <> w3.toNode AND w1.fromNode <> w2.toNode AND w2.fromNode <>
 w3.toNode;
\end_layout

\end_inset


\end_layout

\begin_layout Exercise
for each pair of connected nodes, find the N-hop paths (the value of N is
 not known in advance).
 Include four columns in the result set: fromNode, toNode, length, path,
 which correspond to the source node, target node, length of the path and
 the visited nodes, respectively.
 Exclude repeated nodes in the path like in case ‚ÄúC‚Äù.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

with recursive auxi(fromnode, tonode, long, path) as (
\end_layout

\begin_layout Plain Layout

	select wg.fromnode, wg.tonode, 1, '-'|| wg.fromnode ||'-'|| wg.tonode
\end_layout

\begin_layout Plain Layout

	from webgraph1 wg
\end_layout

\begin_layout Plain Layout

	where wg.fromnode <> wg.tonode
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	union
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	select auxi.fromnode, wg.tonode, 1 + long , path ||'-'|| wg.tonode
\end_layout

\begin_layout Plain Layout

	from auxi, webgraph1 wg
\end_layout

\begin_layout Plain Layout

	where auxi.tonode = wg.fromnode
\end_layout

\begin_layout Plain Layout

		AND wg.fromnode <> wg.tonode
\end_layout

\begin_layout Plain Layout

		AND position('-'|| wg.tonode || '-' in auxi.path ) = 0)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

select * from auxi
\end_layout

\end_inset


\end_layout

\begin_layout Section
Sessions 5 and 6: Neo4j and Cypher
\end_layout

\begin_layout Subsection
Session 5: Cypher Part I
\end_layout

\begin_layout Standard
We will express queries over graph databases using Cypher, the high-level
 query language for Neo4J.
 To be able to easily check the correctness of the results, we will start
 with a small graph representing a subset of the web structure, as shown
 below:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado1.png

\end_inset


\end_layout

\begin_layout Exercise

\series bold
Vertex Degree
\end_layout

\begin_layout Exercise
For each vertex compute its in-degree and out-degree.
 The result set is a list of vertices and both values.
 Those vertices that do not have outgoing edges and/or incoming edges, must
 not appear in the answer.
 (Note that the result set is not a graph).
\end_layout

\begin_layout Standard
I have solved this in two equivalent ways:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

--1--
\end_layout

\begin_layout Plain Layout

MATCH (p:URL)
\end_layout

\begin_layout Plain Layout

WHERE size((:URL)-->(p))+size((p)-->(:URL))>0
\end_layout

\begin_layout Plain Layout

RETURN p.name as url, size((:URL)-->(p)) as in_degree, size((p)-->(:URL))
 as out_degree
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

--2--
\end_layout

\begin_layout Plain Layout

MATCH (p:URL)
\end_layout

\begin_layout Plain Layout

WITH p, size((:URL)-->(p)) AS in_degree, size((p)-->(:URL)) AS out_degree
\end_layout

\begin_layout Plain Layout

WHERE in_degree+out_degree>0
\end_layout

\begin_layout Plain Layout

RETURN p.name as url, in_degree, out_degree
\end_layout

\end_inset


\end_layout

\begin_layout Exercise

\series bold
Vertex Degree variation
\end_layout

\begin_layout Exercise
For each vertex calculate its in-degree and out-degree.
 The result set is a list of all vertices in the graph, together with the
 two values above, for each vertex.
 Those vertices that do not have outgoing edges and/or incoming edges, must
 appear in the answer with value ‚Äú0‚Äù.
 
\end_layout

\begin_layout Standard
The way I solve the first exercise makes this question trivial:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (p:URL)
\end_layout

\begin_layout Plain Layout

RETURN p.name as url, size((:URL)-->(p)) as in_degree, size((p)-->(:URL))
 as out_degree
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- Another
\end_layout

\begin_layout Plain Layout

MATCH (n)
\end_layout

\begin_layout Plain Layout

OPTIONAL MATCH ()-[r1]->(n)
\end_layout

\begin_layout Plain Layout

OPTIONAL MATCH (n)-[r2]->()
\end_layout

\begin_layout Plain Layout

RETURN n.name, COUNT(distinct r1) as indegree, COUNT (distinct r2) as outdegree
\end_layout

\begin_layout Plain Layout

ORDER BY n.name
\end_layout

\end_inset


\end_layout

\begin_layout Exercise

\series bold
Calculating a maximum value
\end_layout

\begin_layout Exercise
Find the maximum vertex in-degree.
 (the result set is not a graph).
\end_layout

\begin_layout Standard
I have solved this also in two different ways.
 I prefer the second solution, because it matches all nodes with maximum
 in-degree and is independent of the order done by the order by.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

--1--
\end_layout

\begin_layout Plain Layout

MATCH (p:URL)
\end_layout

\begin_layout Plain Layout

RETURN p.name as url, size((:URL)-->(p)) as in_degree
\end_layout

\begin_layout Plain Layout

ORDER BY in_degree DESC LIMIT 1
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

--2--
\end_layout

\begin_layout Plain Layout

MATCH (p:URL)
\end_layout

\begin_layout Plain Layout

WITH size((:URL)-->(p)) as in_degree
\end_layout

\begin_layout Plain Layout

WITH max(in_degree) as mx
\end_layout

\begin_layout Plain Layout

MATCH (q:URL)
\end_layout

\begin_layout Plain Layout

WHERE size((:URL)-->(q)) = mx 
\end_layout

\begin_layout Plain Layout

RETURN q.name as url, mx
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

--3--
\end_layout

\begin_layout Plain Layout

MATCH (n)
\end_layout

\begin_layout Plain Layout

OPTIONAL MATCH (src)-->(n)
\end_layout

\begin_layout Plain Layout

WITH n, COUNT(distinct src) as indegree
\end_layout

\begin_layout Plain Layout

RETURN MAX(indegree)
\end_layout

\end_inset


\end_layout

\begin_layout Exercise

\series bold
Find influencial nodes
\end_layout

\begin_layout Exercise
Find the subgraph which contains nodes whose in-degree is maximal in the
 graph (you should obtain only one node).
 Do the same for the out-degree (you should obtain four nodes).
\end_layout

\begin_layout Standard
For the in-degree:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (n:URL)
\end_layout

\begin_layout Plain Layout

WITH size((:URL)-->(n)) as in_degree, n
\end_layout

\begin_layout Plain Layout

WITH max(in_degree) as mx
\end_layout

\begin_layout Plain Layout

MATCH (n2:URL)
\end_layout

\begin_layout Plain Layout

WITH n2, size(()-->(n2)) as in_degree
\end_layout

\begin_layout Plain Layout

WHERE in_degree = mx
\end_layout

\begin_layout Plain Layout

RETURN n2.name
\end_layout

\end_inset


\end_layout

\begin_layout Standard
And for the out-degree:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (n:URL)
\end_layout

\begin_layout Plain Layout

WITH size((n)-->(:URL)) as out_degree, n
\end_layout

\begin_layout Plain Layout

WITH max(out_degree) as mx
\end_layout

\begin_layout Plain Layout

MATCH (n2:URL)
\end_layout

\begin_layout Plain Layout

WITH n2, size((n2)-->(:URL)) as out_degree
\end_layout

\begin_layout Plain Layout

WHERE out_degree = mx
\end_layout

\begin_layout Plain Layout

RETURN n2.name
\end_layout

\end_inset


\end_layout

\begin_layout Exercise

\series bold
Distance between nodes
\end_layout

\begin_layout Exercise
For each pair of vertices, calculate the distance, i.e.
 the shortest simple path between them (without repeated edges in the path).
 Do not show the distance between two disconnected nodes (infinite distance).
 Exclude paths when source and target are the same node.
\end_layout

\begin_layout Standard
Although there is a specific function for this in Neo4j
\begin_inset Foot
status open

\begin_layout Plain Layout
See next exercise.
\end_layout

\end_inset

, we can manually do this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH path=(a:URL)-[*]->(b:URL)
\end_layout

\begin_layout Plain Layout

WHERE a.name <> b.name
\end_layout

\begin_layout Plain Layout

RETURN a.name, b.name, min(length(path)) as dist
\end_layout

\end_inset


\end_layout

\begin_layout Exercise

\series bold
Distance between nodes using Cypher function
\end_layout

\begin_layout Exercise
Solve the query in Use Case 5, but using the shortestPath built-in Cypher
 function.
 It has one parameter that represents a pattern path and returns the shortest
 path that matches this pattern.
 If there exists more than one shortest path, it returns any of them.
\end_layout

\begin_layout Standard
This one is an easier version of the previous exercise.
 Also, we see another way of computing the length of a path as 
\emph on
size(relationships(path))
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (a:URL), (b:URL), sp=shortestpath((a)-[*]->(b))
\end_layout

\begin_layout Plain Layout

WHERE a.name <> b.name
\end_layout

\begin_layout Plain Layout

RETURN a.name, b.name, size(relationships(sp)) as dist
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- Another
\end_layout

\begin_layout Plain Layout

MATCH path= shortestPath((n)-[*]->(p) )
\end_layout

\begin_layout Plain Layout

WHERE n <> p
\end_layout

\begin_layout Plain Layout

WITH nodes(path) as listanodos
\end_layout

\begin_layout Plain Layout

RETURN [n in listanodos|n.name]
\end_layout

\end_inset


\end_layout

\begin_layout Exercise

\series bold
Diameter
\end_layout

\begin_layout Exercise
Compute the diameter of the graph, i.e.
 the longest distance between two nodes in the graph (excluding disconnected
 pairs of nodes).
\end_layout

\begin_layout Standard
This one's easy:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH path=(:URL)-[*]->(:URL)
\end_layout

\begin_layout Plain Layout

RETURN max(length(path)) as diameter
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- Another
\end_layout

\begin_layout Plain Layout

MATCH p=(n1)-[*1..]->(n2)
\end_layout

\begin_layout Plain Layout

WHERE n1 <> n2
\end_layout

\begin_layout Plain Layout

WITH n1, n2, MIN(length(p)) as distance
\end_layout

\begin_layout Plain Layout

RETURN MAX(distance)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- Another
\end_layout

\begin_layout Plain Layout

MATCH p=(n1)-[*1..]->(n2)
\end_layout

\begin_layout Plain Layout

WHERE n1 <> n2
\end_layout

\begin_layout Plain Layout

WITH n1.name, n2.name, MIN(length(p)) as distance
\end_layout

\begin_layout Plain Layout

RETURN distance
\end_layout

\begin_layout Plain Layout

ORDER BY distance DESC
\end_layout

\begin_layout Plain Layout

LIMIT 1
\end_layout

\end_inset


\end_layout

\begin_layout Exercise

\series bold
webgraph3
\end_layout

\begin_layout Exercise
Repeat use cases 1 to 7 using the webgraph3 database, which represents the
 same information as the corresponding relational database in Activity 1
 (Session 4).
\end_layout

\begin_layout Standard
We just have to execute the same queries in the webgraph3 database.
\end_layout

\begin_layout Exercise

\series bold
Paths
\end_layout

\begin_layout Exercise
Compute all the 1, 2, 3, and n-hops in the graph, and compare against the
 results obtained using PostgreSQL in Activity 1.
 Note: start with ‚Äúlimit X‚Äù, increasing ‚ÄúX‚Äù to prevent that the algorithm
 runs indefinitely.
\end_layout

\begin_layout Exercise
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH path = (end)<-[*1..]-(start)
\end_layout

\begin_layout Plain Layout

WHERE ALL (n in nodes(path) where 1 = size([m in nodes(path) where m=n]))
\end_layout

\begin_layout Plain Layout

RETURN start.name, LENGTH(path) AS length, [p in NODES(path) | p.name], end.name
\end_layout

\begin_layout Plain Layout

ORDER BY length
\end_layout

\begin_layout Plain Layout

MATCH path = (end)<-[*1..]-(start:URL{name:745315})
\end_layout

\begin_layout Plain Layout

WHERE ALL (n in nodes(path) where
\end_layout

\begin_layout Plain Layout

1 = size([m in nodes(path) where m=n]))
\end_layout

\begin_layout Plain Layout

RETURN LENGTH(path) AS length, [p in NODES(path) | p.name]
\end_layout

\begin_layout Plain Layout

ORDER BY length desc
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Session 6: Cypher Part II
\end_layout

\begin_layout Exercise
Consider the Northwind database, whose schema is:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado2.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado4.png

\end_inset


\end_layout

\end_deeper
\begin_layout Exercise
Write in Cypher the following queries over the northwindhg.db database:
\end_layout

\begin_deeper
\begin_layout Enumerate
List products and their unit price.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH(v:Product)
\end_layout

\begin_layout Plain Layout

RETURN v.productID, v.unitPrice
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
List information about products 'Chocolade' & 'Pavlova'.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (p:Product)
\end_layout

\begin_layout Plain Layout

WHERE p.productName IN ['Chocolade','Pavlova']
\end_layout

\begin_layout Plain Layout

RETURN p
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
List information about products with names starting with a "C‚Äù, whose unit
 price is greater than 50.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (p:Product)
\end_layout

\begin_layout Plain Layout

WHERE p.productName STARTS WITH "C" AND tofloat(p.unitPrice) > 50
\end_layout

\begin_layout Plain Layout

RETURN p.productName, p.unitPrice
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Same as 3, but considering the sales price, not the product‚Äôs price.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (p:Product) <- [c:Contains] - (o:Order)
\end_layout

\begin_layout Plain Layout

WHERE p.productName STARTS WITH "C" AND tofloat(c.unitPrice) > 50
\end_layout

\begin_layout Plain Layout

RETURN distinct p.productName, p.unitPrice, c.unitPrice
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Total amount purchased by customer and product.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (c:Customer)
\end_layout

\begin_layout Plain Layout

OPTIONAL MATCH (p:Product)<-[pu:Contains]-(:Order)-[:Purchased]->(c)
\end_layout

\begin_layout Plain Layout

RETURN c.customerName, p.productName,tofloat(sum(pu.unitPrice) * pu.quantity)
 as volume
\end_layout

\begin_layout Plain Layout

ORDER BY volume desc
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Top ten employees, considering the number of orders sold.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (:Order)<-[:Sold]-(e:Employee)
\end_layout

\begin_layout Plain Layout

RETURN e.firstName,e.lastName, count(*) AS Ordenes
\end_layout

\begin_layout Plain Layout

ORDER BY Ordenes DESC LIMIT 10
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
For each employee, list the assigned territories.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (t:Territory)<-[:AssignedTo]-(e:Employee)
\end_layout

\begin_layout Plain Layout

RETURN e.lastName, COLLECT(t.name)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
For each city, list the companies settled in that city.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (c:City)<-[:locatedIn]-(c1:Customer)
\end_layout

\begin_layout Plain Layout

RETURN c.cityname, COLLECT(c1.customerName)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
How many persons an employee reports to, either directly or transitively?
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (report:Employee)
\end_layout

\begin_layout Plain Layout

OPTIONAL MATCH (e)<-[rel:ReportsTo*]-(report)
\end_layout

\begin_layout Plain Layout

RETURN report.lastName AS e1, COUNT(rel) AS reports
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
To whom do persons called ‚ÄúRobert‚Äù report to?
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (e:Employee)<-[:ReportsTo*]-(sub:Employee)
\end_layout

\begin_layout Plain Layout

WHERE sub.firstName = 'Robert'
\end_layout

\begin_layout Plain Layout

RETURN e.firstName,e.lastName,sub.lastName
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Who does not report to anybody? 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (e:Employee)
\end_layout

\begin_layout Plain Layout

WHERE NOT (e)-[:ReportsTo]->()
\end_layout

\begin_layout Plain Layout

RETURN e.firstName as TopBossFirst, e.lastName as TopBossLast
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Suppliers, number of categories they supply, and a list of such categories
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (s:Supplier)-->(:Product)-->(c:Category)
\end_layout

\begin_layout Plain Layout

WITH s.supplierName as Supplier, collect(distinct c.categoryName) as Categories
\end_layout

\begin_layout Plain Layout

WITH Supplier, Categories, size(Categories) AS Cantidad ORDER BY Cantidad
 DESC
\end_layout

\begin_layout Plain Layout

RETURN Supplier, Cantidad, Categories
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Suppliers who supply beverages 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (c:Category {categoryName:"Beverages"})<--(:Product)<--(s:Supplier)
\end_layout

\begin_layout Plain Layout

RETURN DISTINCT s.supplierName as ProduceSuppliers
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Customer who purchases the largest amount of beverages 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (cust:Customer)<-[:Purchased]-(:Order)-[o:Contains]->(p:Product),
 (p)-[:hasCategory]->
\end_layout

\begin_layout Plain Layout

(c:Category{categoryName:"Beverages"})
\end_layout

\begin_layout Plain Layout

RETURN cust.customerName as CustomerName, SUM(o.quantity)
\end_layout

\begin_layout Plain Layout

LIMIT 1
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
List the five most popular products (considering number of orders) 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (c:Customer)<-[:Purchased]-(o:Order)-[o1:Contains]->(p:Product)
\end_layout

\begin_layout Plain Layout

RETURN c.customerName, p.productName, count(o1) as orders
\end_layout

\begin_layout Plain Layout

ORDER BY orders desc LIMIT 5
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Products ordered by customers from the same country than their suppliers
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (c:Customer) -[r:locatedIn]->(cy:City)-[:belongsTo]->(:Region)-[:isIn]->(c
o:Country)
\end_layout

\begin_layout Plain Layout

WITH co, c MATCH (s:Supplier) WHERE co.countryname = s.country
\end_layout

\begin_layout Plain Layout

WITH s, co, c MATCH(s)-[su:Supplies]-(p:Product)<-[:Contains]-(o:Order)-[:Purcha
sed]->(c)
\end_layout

\begin_layout Plain Layout

RETURN c.customerName,s.supplierName,co.countryname,p.productName
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Exercise
Switch to the MusicBrainz database, doing the same steps as in Assignment
 2.
 Now, the database is musicbrainz.
 The schema is:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado5.png

\end_inset


\end_layout

\begin_layout Enumerate
Compute the total number of releases per artist.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (r:ReleaseFact)-[rb:RELEASED_BY]->(ac:ArtistCredit)-[inc:INCLUDES]->(a:Art
ist)
\end_layout

\begin_layout Plain Layout

RETURN a.name, COUNT(r)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Compute the total number of releases per artist and per year.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (d:Date)<-[ro:RELEASED_ON]-(r:ReleaseFact)-[rb:RELEASED_BY]->(ac:ArtistCre
dit)-[inc:INCLUDES]->(a:Artist)
\end_layout

\begin_layout Plain Layout

RETURN a.name, d.year, COUNT(r)
\end_layout

\begin_layout Plain Layout

ORDER BY a.name, d.year
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Compute the total number of events per artist.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (e:Event)<-[rt:REFERS_TO]-(ef:EventFact)-[pb:PERFORMED_BY]->(a:Artist)
\end_layout

\begin_layout Plain Layout

RETURN a.name, COUNT(e)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Compute the number of times the artist performed in each event.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (e:Event)<-[rt:REFERS_TO]-(ef:EventFact)-[pb:PERFORMED_BY]->(a:Artist)
\end_layout

\begin_layout Plain Layout

RETURN a.name, e.name, COUNT(ef)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
For each (event, artist, year) triple, compute the number of times the artist
 performed in an event on an year.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (e:Event)<-[rt:REFERS_TO]-(ef:EventFact)-[pb:PERFORMED_BY]->(a:Artist)
\end_layout

\begin_layout Plain Layout

MATCH (d:Date)<-[ho:HAPPENED_ON]-(ef)
\end_layout

\begin_layout Plain Layout

RETURN a.name, e.name, d.year, COUNT(ef)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Same as Query 5, for artists in the United Kingdom and events happened after
 year 2006.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (d:Date)<-[ho:HAPPENED_ON]-(ef)
\end_layout

\begin_layout Plain Layout

WHERE d.year > 2006
\end_layout

\begin_layout Plain Layout

MATCH (e:Event)<-[rt:REFERS_TO]-(ef:EventFact)-[pb:PERFORMED_BY]->(a:Artist)-[is
f:IS_FROM]->(c:Country)
\end_layout

\begin_layout Plain Layout

WHERE c.name = 'United Kingdom'
\end_layout

\begin_layout Plain Layout

RETURN a.name, e.name, d.year, COUNT(ef)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Compute the number of releases, per language, in the UK.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (r:Release)<-[rt:REFERS_TO]-(rf:ReleaseFact)-[ri:RELEASED_IN]->(c:Country)
\end_layout

\begin_layout Plain Layout

WHERE c.name='United Kingdom'
\end_layout

\begin_layout Plain Layout

RETURN r.language, count(r)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Compute, for each pair of artists, the number of times they have performed
 together at least twice in an event.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (a1:Artist)<-[pb1:PERFORMED_BY]-(ef:EventFact)-[pb2:PERFORMED_BY]->(a2:Art
ist)
\end_layout

\begin_layout Plain Layout

WHERE a1.name < a2.name
\end_layout

\begin_layout Plain Layout

MATCH (e:Event)<-[rt:REFERS_TO]-(ef)
\end_layout

\begin_layout Plain Layout

WITH a1.name as artist1, a2.name as artist2, COUNT(e) as times
\end_layout

\begin_layout Plain Layout

WHERE times>=2
\end_layout

\begin_layout Plain Layout

RETURN artist1, artist2, times
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Compute the triples of artists, and the number of times they have performed
 together in an event, if this number is at least 3.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (a1:Artist)<-[pb1:PERFORMED_BY]-(ef:EventFact)-[pb2:PERFORMED_BY]->(a2:Art
ist)
\end_layout

\begin_layout Plain Layout

MATCH (ef)-[pb3:PERFORMED_BY]->(a3:Artist)
\end_layout

\begin_layout Plain Layout

WHERE a1.name < a2.name < a3.name
\end_layout

\begin_layout Plain Layout

MATCH (e:Event)<-[rt:REFERS_TO]-(ef)
\end_layout

\begin_layout Plain Layout

WITH a1.name as artist1, a2.name as artist2, a3.name as artist3, COUNT(e) as
 times
\end_layout

\begin_layout Plain Layout

WHERE times>=3
\end_layout

\begin_layout Plain Layout

RETURN artist1, artist2, artist3, times
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Compute the quadruples of artists, and the number of times they have performed
 together in an event, if this number is at least 3.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (a1:Artist)<-[pb1:PERFORMED_BY]-(ef:EventFact)-[pb2:PERFORMED_BY]->(a2:Art
ist)
\end_layout

\begin_layout Plain Layout

MATCH (a4:Artist)<-[pb4:PERFORMED_BY]-(ef)-[pb3:PERFORMED_BY]->(a3:Artist)
\end_layout

\begin_layout Plain Layout

WHERE a1.name < a2.name < a3.name < a4.name
\end_layout

\begin_layout Plain Layout

MATCH (e:Event)<-[rt:REFERS_TO]-(ef)
\end_layout

\begin_layout Plain Layout

WITH a1.name as artist1, a2.name as artist2, a3.name as artist3, a4.name as
 artist4, COUNT(e) as times
\end_layout

\begin_layout Plain Layout

WHERE times>=3
\end_layout

\begin_layout Plain Layout

RETURN artist1, artist2, artist3, artist4, times
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Compute the pairs of artists that have performed together in at least two
 events and that have worked together in at least one release, returning
 the number of events and releases together.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (a1:Artist)<-[pb1:PERFORMED_BY]-(ef:EventFact)-[pb2:PERFORMED_BY]->(a2:Art
ist)
\end_layout

\begin_layout Plain Layout

WHERE a1.name < a2.name
\end_layout

\begin_layout Plain Layout

MATCH (e:Event)<-[rte:REFERS_TO]-(ef)
\end_layout

\begin_layout Plain Layout

WITH a1, a2, COUNT(e) as events
\end_layout

\begin_layout Plain Layout

MATCH (a1)<-[in1:INCLUDES]-(ac:ArtistCredit)-[in2:INCLUDES]->(a2)
\end_layout

\begin_layout Plain Layout

MATCH (ac)<-[rb:RELEASED_BY]-(rf:ReleaseFact)-[rtr:REFERS_TO]->(r:Release)
\end_layout

\begin_layout Plain Layout

WITH a1.name as artist1, a2.name as artist2, events, COUNT(r) as releases
\end_layout

\begin_layout Plain Layout

WHERE events>=2 AND releases>=1
\end_layout

\begin_layout Plain Layout

RETURN artist1, artist2, events, releases
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Compute the number of artists who released a record and performed in at
 least an event, and the year(s) this happened.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (a1:Artist)<-[pb1:PERFORMED_BY]-(ef:EventFact)-[ho:HAPPENED_ON]->(de:Date)
\end_layout

\begin_layout Plain Layout

MATCH (e:Event)<-[rte:REFERS_TO]-(ef)
\end_layout

\begin_layout Plain Layout

WITH a1, COUNT(e) as events, COLLECT(DISTINCT(de.year)) as eventyears
\end_layout

\begin_layout Plain Layout

MATCH (a1)<-[in1:INCLUDES]-(ac:ArtistCredit)<-[rb:RELEASED_BY]-(rf:ReleaseFact)
\end_layout

\begin_layout Plain Layout

MATCH (dr:Date)<-[ro:RELEASED_ON]-(rf)-[rtr:REFERS_TO]->(r:Release)
\end_layout

\begin_layout Plain Layout

WITH a1.name as artist1, events, eventyears, COUNT(r) as releases, COLLECT(DISTIN
CT(dr.year)) as releaseyears
\end_layout

\begin_layout Plain Layout

WHERE events>=1 AND releases>=1
\end_layout

\begin_layout Plain Layout

RETURN artist1, events, releases, eventyears, releaseyears
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Exercise
We will query the Flanders river system depicted in Figure 1.
 The schema and properties are shown in the next figures.
 Segments are represented as nodes, with label :Segment (and their corresponding
 properties), and the relation between the nodes is called :flowsTo, defined
 as follows: there is a relation :flowsTo from node A to node B if the water
 flows to segment B from segment A.
 This is stored in the rivers database.
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado3.png

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Query 1.
 Compute the average segment length.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (n:Segment)
\end_layout

\begin_layout Plain Layout

RETURN avg(n.lengte) AS avglength
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Query 2.
 Compute the average segment length by segment category
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (n:Segment)
\end_layout

\begin_layout Plain Layout

RETURN n.catc as category, avg(n.lengte)
\end_layout

\begin_layout Plain Layout

AS avglength order by category asc
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Query 3.
 Find all segments that have a length within a 10% margin of the length
 of segment with ID 6020612.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (n:Segment {vhas:6020612})
\end_layout

\begin_layout Plain Layout

WITH n.lengte as length
\end_layout

\begin_layout Plain Layout

MATCH (m:Segment)
\end_layout

\begin_layout Plain Layout

WHERE m.lengte < length*1.1 and m.lengte > length*0.9
\end_layout

\begin_layout Plain Layout

RETURN m.vhas, m.lengte;
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Query 4.
 For each segment find the number of incoming and outgoing segments.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (src:Segment)-[:flowsTo]->(n:Segment)-[:flowsTo]->(target:Segment)
\end_layout

\begin_layout Plain Layout

RETURN n.vhas as nodenbr, COUNT(DISTINCT src) as segIn,
\end_layout

\begin_layout Plain Layout

COUNT (DISTINCT target) as segOut
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Query 5.
 Find the segments with the maximum number of incoming segments.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (n:Segment)
\end_layout

\begin_layout Plain Layout

OPTIONAL MATCH (src:Segment)-[:flowsTo]->(n)
\end_layout

\begin_layout Plain Layout

WITH n, COUNT(distinct src) as indegree
\end_layout

\begin_layout Plain Layout

WITH COLLECT ([n, indegree]) as tuples, MAX(indegree) as max
\end_layout

\begin_layout Plain Layout

RETURN [t in tuples WHERE t[1] = max |t]
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Query 6.
 Find the number of splits in the downstream path of segment 6020612.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (n:Segment {vhas:6020612})
\end_layout

\begin_layout Plain Layout

CALL apoc.path.spanningTree(n,{relationshipFilter:"flowsTo>", minLevel: 1})
 YIELD
\end_layout

\begin_layout Plain Layout

path AS pp
\end_layout

\begin_layout Plain Layout

UNWIND NODES(pp) as p
\end_layout

\begin_layout Plain Layout

MATCH (p)-[:flowsTo]->(r:Segment)WITH p, count(DISTINCT r) as co WHERE co
 > 1
\end_layout

\begin_layout Plain Layout

RETURN count(p)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Query 7: Find the number of in-flowing segments in the downstream path of
 segment 6020612.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (n:Segment {vhas:6020612})
\end_layout

\begin_layout Plain Layout

CALL apoc.path.spanningTree(n,{relationshipFilter:"flowsTo>", minLevel: 1})
 YIELD path AS pp
\end_layout

\begin_layout Plain Layout

WITH [p in NODES(pp) | p.vhas] as ids
\end_layout

\begin_layout Plain Layout

UNWIND ids as id
\end_layout

\begin_layout Plain Layout

WITH collect(DISTINCT id) as ids
\end_layout

\begin_layout Plain Layout

MATCH (s:Segment)-[:flowsTo]->(p)
\end_layout

\begin_layout Plain Layout

WHERE NOT s.vhas in ids AND p.vhas <> 6020612 AND p.vhas in ids
\end_layout

\begin_layout Plain Layout

RETURN count(DISTINCT s) as inflows
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Query 8.
 Determine if there is a loop in the downstream path of segment 6031518.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (n:Segment {vhas:6031518})
\end_layout

\begin_layout Plain Layout

CALL apoc.path.spanningTree(n, {relationshipFilter:"flowsTo>", minLevel: 1})
 YIELD path AS pp
\end_layout

\begin_layout Plain Layout

WITH [p in NODES(pp) | p] as nodelist
\end_layout

\begin_layout Plain Layout

UNWIND nodelist as p
\end_layout

\begin_layout Plain Layout

CALL apoc.path.expandConfig(p, {relationshipFilter:"flowsTo>", minLevel: 1,
 terminatorNodes:[p], whitelistNodes:nodelist}) yield path as loop
\end_layout

\begin_layout Plain Layout

RETURN count(loop) >0 as loops
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Query 9.
 Find the length, the # of segments, and the IDs of the segments, of the
 longest branch of upstream flow starting from a given segment.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (n:Segment {vhas:6020612})
\end_layout

\begin_layout Plain Layout

CALL apoc.path.expandConfig(n,{relationshipFilter:"<flowsTo", minLevel: 1})
 YIELD path AS pp
\end_layout

\begin_layout Plain Layout

WITH reduce(longi= tofloat(0), n IN nodes(pp)| longi+ tofloat(n.lengte))
 AS blength,
\end_layout

\begin_layout Plain Layout

Length(pp) as alength, [p in NODES(pp) |p.vhas] AS nodelist
\end_layout

\begin_layout Plain Layout

WITH blength, alength, nodelist[size(nodelist)-1] as id
\end_layout

\begin_layout Plain Layout

WITH id, max(blength) as ml, collect([id,blength,alength]) as coll
\end_layout

\begin_layout Plain Layout

WITH id, ml, [p in coll WHERE p[0]= id AND p[1]=ml|p[2]] AS lhops
\end_layout

\begin_layout Plain Layout

UNWIND lhops as hops
\end_layout

\begin_layout Plain Layout

RETURN id,ml,hops order by id desc;
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Query 10.
 How many paths exist between two given segments X and Y?
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (n:Segment {vhas:6020612}),(m:Segment {vhas: 7036554})
\end_layout

\begin_layout Plain Layout

CALL apoc.path.expandConfig(n,{relationshipFilter:"<flowsTo", minLevel: 1,
 terminatorNodes:[m]}) yield path as pp
\end_layout

\begin_layout Plain Layout

RETURN count(pp) as paths
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Query 11.
 Find all segments reachable from the segment closest to Antwerpen‚Äôs Groenplaats
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

CALL apoc.spatial.geocodeOnce('Groenplaats Antwerpen Flanders Belgium') YIELD
 location as ini
\end_layout

\begin_layout Plain Layout

MATCH (n:Segment)
\end_layout

\begin_layout Plain Layout

WITH n, ini,distance(point({longitude:n.source_long, latitude:n.source_lat}),
 point({longitude:ini.longitude, latitude:ini.latitude}) ) as d
\end_layout

\begin_layout Plain Layout

WITH n, d order by d asc limit 1
\end_layout

\begin_layout Plain Layout

CALL apoc.path.spanningTree(n,{relationshipFilter:"flowsTo>", minLevel: 1})
 YIELD path as pp
\end_layout

\begin_layout Plain Layout

UNWIND NODES(pp) as p
\end_layout

\begin_layout Plain Layout

RETURN p.vhas;
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Temporal databases
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado12.png

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Spatial databases
\end_layout

\begin_layout Section
Lab 10
\end_layout

\begin_layout Standard
In the directory 
\series bold
tp10
\series default
, perform:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// Initialization
\end_layout

\begin_layout Plain Layout

$ createdb infoh415
\end_layout

\begin_layout Plain Layout

$ psql infoh415 -c 
\begin_inset Quotes eld
\end_inset

CREATE EXTENSION postgis;
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Tables creation
\end_layout

\begin_layout Plain Layout

$ psql infoh415
\end_layout

\begin_layout Plain Layout

infoh415$ 
\backslash
i create_tables.sql
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Tables population
\end_layout

\begin_layout Plain Layout

infoh415$ 
\backslash
i insertion.sql
\end_layout

\begin_layout Plain Layout

infoh415$ 
\backslash
i create_index.sql
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Importing and exporting
\end_layout

\begin_layout Plain Layout

infoh415$ quit
\end_layout

\begin_layout Plain Layout

$ cd shapefiles/ 
\end_layout

\begin_layout Plain Layout

$ pgsql2shp infoh415 regions 
\end_layout

\begin_layout Plain Layout

$ pgsql2shp infoh415 cities
\end_layout

\begin_layout Plain Layout

$ shp2pgsql -W "latin1" bel_city.shp >  ../shp_insert.sql
\end_layout

\begin_layout Plain Layout

$ shp2pgsql -W "latin1" bel_dist.shp >> ../shp_insert.sql
\end_layout

\begin_layout Plain Layout

$ shp2pgsql -W "latin1" bel_prov.shp >> ../shp_insert.sql
\end_layout

\begin_layout Plain Layout

$ shp2pgsql -W "latin1" bel_regn.shp >> ../shp_insert.sql
\end_layout

\begin_layout Plain Layout

$ shp2pgsql -W "latin1" belriver.shp >> ../shp_insert.sql
\end_layout

\begin_layout Plain Layout

$ cd ..
\end_layout

\begin_layout Plain Layout

$ psql infoh415
\end_layout

\begin_layout Plain Layout

infoh415$ 
\backslash
i shp_insert.sql
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Specify the SRID to use WGS84
\end_layout

\begin_layout Plain Layout

infoh415$ 
\backslash
i update_srid.sql 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Write down and execute the following queries:
\end_layout

\begin_layout Enumerate
Get the SRID from table cities.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

select st_srid(geom) as SRID 
\end_layout

\begin_layout Plain Layout

from bel_city 
\end_layout

\begin_layout Plain Layout

limit 5;
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Get a textual description for this SRID.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

select srtext 
\end_layout

\begin_layout Plain Layout

from spatial_ref_sys 
\end_layout

\begin_layout Plain Layout

where srid=4326;
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Get the dimension of geographical objects in that table.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

select distinct st_dimension(geom) as dim, st_coorddim(geom) as coorddim
 
\end_layout

\begin_layout Plain Layout

from bel_city;
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Get the geometry type of these objects.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

select distinct st_geometrytype(geom) as type 
\end_layout

\begin_layout Plain Layout

from bel_city;
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Compute the distance between the cities of IXELLES and BRUGGE.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

select st_distance(
\end_layout

\begin_layout Plain Layout

	st_transform((select geom from bel_city where name = 'Ixelles'),3812),
 
\end_layout

\begin_layout Plain Layout

	st_transform((select geom from bel_city where name = 'Brugge'),3812)) as
 dist, 
\end_layout

\begin_layout Plain Layout

st_distancesphere(
\end_layout

\begin_layout Plain Layout

	(select geom from bel_city where name = 'Ixelles'), 
\end_layout

\begin_layout Plain Layout

	(select geom from bel_city where name = 'Brugge')) as dist_sphere
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The number 3812 in the transform function refers to Belgian Lambert 2008,
 which is a conic representation adapted for Belgium.
 If we don't apply this transformation, we get a distance measured in degrees,
 which has little meaning for us.
\end_layout

\end_deeper
\begin_layout Enumerate
Compute the bounding rectangle for the BRABANT province.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

create table boundbox as 
\end_layout

\begin_layout Plain Layout

	select st_envelope(geom) 
\end_layout

\begin_layout Plain Layout

	from bel_prov 
\end_layout

\begin_layout Plain Layout

	where name = 'Brabant';
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We create the table to be able to visualize the result in QGis:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado7.png
	scale 60

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Compute the geographical union of the bel_regn and bel_prov tables.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

create table geom_union as 
\end_layout

\begin_layout Plain Layout

	select st_union(geom) 
\end_layout

\begin_layout Plain Layout

	from (select geom from bel_regn 
\end_layout

\begin_layout Plain Layout

		  union 
\end_layout

\begin_layout Plain Layout

		  select geom from bel_prov) 
\end_layout

\begin_layout Plain Layout

		  as tmp;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado8.png
	scale 60

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Compute the length of each river.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

select st_length2dspheroid(geom, 'SPHEROID["GRS_1980",6378137,298.257222101]')
 
\end_layout

\begin_layout Plain Layout

from belriver;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The second argument is the spheroid that the function should use to compute
 the lengths, as its definition is 
\begin_inset Formula $ST\_Length2DSpheroid(geometry\ geom,spheroid\ sp)$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
Create a table containing all cities that stand less than 1000m from a river.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

select name, dist 
\end_layout

\begin_layout Plain Layout

from 
\end_layout

\begin_layout Plain Layout

	(select c.name as name, min(st_distancesphere(c.geom, r.geom)) as dist 
\end_layout

\begin_layout Plain Layout

	 from bel_city c, belriver r 
\end_layout

\begin_layout Plain Layout

	 group by c.name) as tmp 
\end_layout

\begin_layout Plain Layout

where dist < 1000; 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- or
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

select c.name as name, min(st_distancesphere(c.geom, r.geom)) as dist 
\end_layout

\begin_layout Plain Layout

from bel_city c 
\end_layout

\begin_layout Plain Layout

	 join belriver r on st_distancesphere(c.geom, r.geom) < 1000 
\end_layout

\begin_layout Plain Layout

group by c.name; 
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
For each river, compute the length of its path inside each province it traverses.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

select r.name as river, p.name as province, 
\end_layout

\begin_layout Plain Layout

	st_length2dspheroid(st_intersection(r.geom, p.geom),
\end_layout

\begin_layout Plain Layout

					'SPHEROID["GRS_1980",6378137,298.257222101]') as inside_len 
\end_layout

\begin_layout Plain Layout

from belriver r 
\end_layout

\begin_layout Plain Layout

join bel_prov p on st_intersects(r.geom, p.geom); 
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Section
Lab 11
\end_layout

\begin_layout Standard
Download 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://biogeo.ucdavis.edu/data/climate/worldclim/1_4/grid/cur/alt_10m_bil.zip
\end_layout

\end_inset

 and extract it to 
\series bold
tp11
\series default
.
\end_layout

\begin_layout Standard
In the directory 
\series bold
tp11
\series default
 perform:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

createdb tp11                                 
\end_layout

\begin_layout Plain Layout

psql tp11 -c "CREATE EXTENSION postgis;" 
\end_layout

\begin_layout Plain Layout

psql tp11 -c "CREATE EXTENSION postgis_raster;"        
\end_layout

\begin_layout Plain Layout

psql tp11 -f generate.sql    
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

cd bel_alt/
\end_layout

\begin_layout Plain Layout

raster2pgsql BEL_alt.vrt > insert_bel_alt.sql 
\end_layout

\begin_layout Plain Layout

psql tp11 -f insert_bel_alt.sql
\end_layout

\begin_layout Plain Layout

cd ../alt_10m_bil/
\end_layout

\begin_layout Plain Layout

raster2pgsql alt.bil > insert_alt.sql    
\end_layout

\begin_layout Plain Layout

psql tp11 -f insert_alt.sql               
\end_layout

\begin_layout Plain Layout

cd ..
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# 3.2 Update rasters
\end_layout

\begin_layout Plain Layout

psql tp11
\end_layout

\begin_layout Plain Layout

SELECT UpdateRasterSRID('alt', 'rast', 4326);
\end_layout

\begin_layout Plain Layout

SELECT UpdateRasterSRID('bel_alt', 'rast', 4326);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Write down and execute the following queries:
\end_layout

\begin_layout Enumerate
Compute the difference between the two altitude datasets.
 Try to perform this exercice first without using ST_Resample.
 Export the result and visualize it in QGIS:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

gdal_translate -of GTiff PG:"dbname=tp11 schema=public table=sol1" sol1.tiff
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

create table sol1 as 
\end_layout

\begin_layout Plain Layout

SELECT ST_MapAlgebra( a.rast, 1, b.rast, 1, '[rast2] - [rast1]') AS rast 
\end_layout

\begin_layout Plain Layout

FROM 
\end_layout

\begin_layout Plain Layout

    (select b.RID, ST_Resample(b.rast, a.rast) as rast
\end_layout

\begin_layout Plain Layout

     from bel_alt b,  alt a) 
\end_layout

\begin_layout Plain Layout

as b, alt a;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Once we have the table, we execute the command to export the raster and
 then we import it to QGIS.
 The result is (not very awesome):
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename pegado10.png
	scale 35

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Compute the maximum altitude in Belgium.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

SELECT (ST_SummaryStats(rast)).max as max
\end_layout

\begin_layout Plain Layout

FROM bel_alt;
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Get the altitudes of all cities in Belgium.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

SELECT name, ST_Value(rast, geom) 
\end_layout

\begin_layout Plain Layout

FROM bel_alt 
\end_layout

\begin_layout Plain Layout

JOIN bel_city ON ST_Intersects(geom, rast);
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Compute the maximum and minimum altitudes for each province.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

SELECT name, (stats).max, (stats).min 
\end_layout

\begin_layout Plain Layout

FROM (
\end_layout

\begin_layout Plain Layout

	SELECT name, ST_SummaryStats(ST_Clip(rast, 1, geom, TRUE)) AS stats   
    
\end_layout

\begin_layout Plain Layout

	FROM alt 
\end_layout

\begin_layout Plain Layout

	JOIN bel_prov ON ST_Intersects(geom,rast)) 
\end_layout

\begin_layout Plain Layout

	AS foo;
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Create a new raster table restraining the alt_16 raster to Belgium.
 (Hint: use ST_Intersection.)
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

CREATE TABLE alt_16_belgium AS
\end_layout

\begin_layout Plain Layout

SELECT rid, ST_Clip(rast, 1, geom, TRUE) AS rast
\end_layout

\begin_layout Plain Layout

FROM (SELECT ST_UNION(ARRAY(SELECT geom FROM bel_regn)) AS geom) AS belgium
\end_layout

\begin_layout Plain Layout

JOIN alt ON ST_Intersects(geom, rast);
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Compute the altitude along each river.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

SELECT name, ST_AsText((position).geom), ST_Value(rast, (position).geom)
\end_layout

\begin_layout Plain Layout

FROM (SELECT name, rast, ST_DumpPoints(ST_Segmentize(geom, 0.1)) AS position
\end_layout

\begin_layout Plain Layout

      FROM belriver 
\end_layout

\begin_layout Plain Layout

	  JOIN bel_alt on ST_Intersects(geom, rast)) 
\end_layout

\begin_layout Plain Layout

	  AS dp;
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Section*
Spatial functions reference
\end_layout

\begin_layout Itemize

\series bold
ST_CLIP
\series default
: Returns a raster that is clipped by the input geometry geom.
 If band index is not specified, all bands are processed.
\end_layout

\begin_deeper
\begin_layout Standard
Rasters resulting from ST_Clip must have a nodata value assigned for areas
 clipped, one for each band.
 If none are provided and the input raster do not have a nodata value defined,
 nodata values of the resulting raster are set to ST_MinPossibleValue(ST_BandPix
elType(rast, band)).
 When the number of nodata value in the array is smaller than the number
 of band, the last one in the array is used for the remaining bands.
 If the number of nodata value is greater than the number of band, the extra
 nodata values are ignored.
 All variants accepting an array of nodata values also accept a single value
 which will be assigned to each band.
\end_layout

\begin_layout Standard
If crop is not specified, true is assumed meaning the output raster is cropped
 to the intersection of the geomand rast extents.
 If crop is set to false, the new raster gets the same extent as rast.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

-- Clip the first band of an aerial tile by a 20 meter buffer.
\end_layout

\begin_layout Plain Layout

SELECT ST_Clip(rast, 1,
\end_layout

\begin_layout Plain Layout

        ST_Buffer(ST_Centroid(ST_Envelope(rast)),20)
\end_layout

\begin_layout Plain Layout

    ) from aerials.boston
\end_layout

\begin_layout Plain Layout

WHERE rid = 4;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- Demonstrate effect of crop on final dimensions of raster
\end_layout

\begin_layout Plain Layout

-- Note how final extent is clipped to that of the geometry
\end_layout

\begin_layout Plain Layout

-- if crop = true
\end_layout

\begin_layout Plain Layout

SELECT ST_XMax(ST_Envelope(ST_Clip(rast, 1, clipper, true))) As xmax_w_trim,
\end_layout

\begin_layout Plain Layout

    ST_XMax(clipper) As xmax_clipper,
\end_layout

\begin_layout Plain Layout

    ST_XMax(ST_Envelope(ST_Clip(rast, 1, clipper, false))) As xmax_wo_trim,
\end_layout

\begin_layout Plain Layout

    ST_XMax(ST_Envelope(rast)) As xmax_rast_orig
\end_layout

\begin_layout Plain Layout

FROM (SELECT rast, ST_Buffer(ST_Centroid(ST_Envelope(rast)),6) As clipper
\end_layout

\begin_layout Plain Layout

    FROM aerials.boston
\end_layout

\begin_layout Plain Layout

WHERE rid = 6) As foo;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   xmax_w_trim    |   xmax_clipper   |   xmax_wo_trim   |  xmax_rast_orig
\end_layout

\begin_layout Plain Layout

------------------+------------------+------------------+------------------
\end_layout

\begin_layout Plain Layout

 230657.436173996 | 230657.436173996 | 230666.436173996 | 230666.436173996
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename pegado9.png
	scale 60

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
ST_DUMPPOINTS
\series default
: A set-returning function (SRF) that extracts the coordinates (vertices)
 of a geometry.
 It returns a set of geometry_dump rows, each containing a geometry (geom
 field) and an array of integers (path field).
\end_layout

\begin_deeper
\begin_layout Itemize
the geom field POINTs represent the coordinates of the supplied geometry.
\end_layout

\begin_layout Itemize
the path field (an integer[]) is an index enumerating the coordinate positions
 in the elements of the supplied geometry.
 The indices are 1-based.
 For example, for a LINESTRING the paths are {i} where i is the nth coordinate
 in the LINESTRING.
 For a POLYGON the paths are {i,j} where i is the ring number (1 is outer;
 inner rings follow) and j is the coordinate position in the ring.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT edge_id, (dp).path[1] As index, ST_AsText((dp).geom) As wktnode
\end_layout

\begin_layout Plain Layout

FROM (SELECT 1 As edge_id
\end_layout

\begin_layout Plain Layout

	, ST_DumpPoints(ST_GeomFromText('LINESTRING(1 2, 3 4, 10 10)')) AS dp
\end_layout

\begin_layout Plain Layout

     UNION ALL
\end_layout

\begin_layout Plain Layout

     SELECT 2 As edge_id
\end_layout

\begin_layout Plain Layout

	, ST_DumpPoints(ST_GeomFromText('LINESTRING(3 5, 5 6, 9 10)')) AS dp
\end_layout

\begin_layout Plain Layout

   ) As foo;
\end_layout

\begin_layout Plain Layout

 edge_id | index |    wktnode
\end_layout

\begin_layout Plain Layout

---------+-------+--------------
\end_layout

\begin_layout Plain Layout

       1 |     1 | POINT(1 2)
\end_layout

\begin_layout Plain Layout

       1 |     2 | POINT(3 4)
\end_layout

\begin_layout Plain Layout

       1 |     3 | POINT(10 10)
\end_layout

\begin_layout Plain Layout

       2 |     1 | POINT(3 5)
\end_layout

\begin_layout Plain Layout

       2 |     2 | POINT(5 6)
\end_layout

\begin_layout Plain Layout

       2 |     3 | POINT(9 10)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
ST_INTERSECTS
\series default
: Compares two geometries and returns true if they intersect.
 Geometries intersect if they have any point in common.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT ST_Intersects('POINT(0 0)'::geometry, 'LINESTRING ( 2 0, 0 2 )'::geometry
);
\end_layout

\begin_layout Plain Layout

 st_intersects
\end_layout

\begin_layout Plain Layout

---------------
\end_layout

\begin_layout Plain Layout

 f
\end_layout

\begin_layout Plain Layout

(1 row)
\end_layout

\begin_layout Plain Layout

SELECT ST_Intersects('POINT(0 0)'::geometry, 'LINESTRING ( 0 0, 0 2 )'::geometry
);
\end_layout

\begin_layout Plain Layout

 st_intersects
\end_layout

\begin_layout Plain Layout

---------------
\end_layout

\begin_layout Plain Layout

 t
\end_layout

\begin_layout Plain Layout

(1 row)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- Look up in table.
 Make sure table has a GiST index on geometry column for faster lookup.
\end_layout

\begin_layout Plain Layout

SELECT id, name FROM cities WHERE ST_Intersects(geom, 'SRID=4326;POLYGON((28
 53,27.707 52.293,27 52,26.293 52.293,26 53,26.293 53.707,27 54,27.707 53.707,28
 53))');
\end_layout

\begin_layout Plain Layout

 id | name
\end_layout

\begin_layout Plain Layout

----+-------
\end_layout

\begin_layout Plain Layout

  2 | Minsk
\end_layout

\begin_layout Plain Layout

(1 row)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
ST_MAPALGEBRA
\series default
: Returns a one-band raster given one or two input rasters, band indexes
 and one or more user-specified SQL expressions.
\end_layout

\begin_deeper
\begin_layout Itemize
With one ruster: Creates a new one band raster formed by applying a valid
 PostgreSQL algebraic operation defined by the expression on the input raster
 (rast).
 If nband is not provided, band 1 is assumed.
 The new raster will have the same georeference, width, and height as the
 original raster but will only have one band.
\end_layout

\begin_layout Itemize
With two rusters: Creates a new one band raster formed by applying a valid
 PostgreSQL algebraic operation to the two bands defined by the expression
 on the two input raster bands (rast1, rast2).
 If no band1, band2 is specified band 1 is assumed.
 The resulting raster will be aligned (scale, skew and pixel corners) on
 the grid defined by the first raster.
 The resulting raster will have the extent defined by the extenttype parameter.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

WITH foo AS (
\end_layout

\begin_layout Plain Layout

    SELECT 1 AS rid, ST_AddBand(ST_AddBand(ST_AddBand(ST_MakeEmptyRaster(2,
 2, 0, 0, 1, -1, 0, 0, 0), 1, '16BUI', 1, 0), 2, '8BUI', 10, 0), 3, '32BUI'::tex
t, 100, 0) AS rast UNION ALL
\end_layout

\begin_layout Plain Layout

    SELECT 2 AS rid, ST_AddBand(ST_AddBand(ST_AddBand(ST_MakeEmptyRaster(2,
 2, 0, 1, 1, -1, 0, 0, 0), 1, '16BUI', 2, 0), 2, '8BUI', 20, 0), 3, '32BUI'::tex
t, 300, 0) AS rast
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

SELECT
\end_layout

\begin_layout Plain Layout

    ST_MapAlgebra(
\end_layout

\begin_layout Plain Layout

        t1.rast, 2,
\end_layout

\begin_layout Plain Layout

        t2.rast, 1,
\end_layout

\begin_layout Plain Layout

        '([rast2] + [rast1.val]) / 2'
\end_layout

\begin_layout Plain Layout

    ) AS rast
\end_layout

\begin_layout Plain Layout

FROM foo t1
\end_layout

\begin_layout Plain Layout

CROSS JOIN foo t2
\end_layout

\begin_layout Plain Layout

WHERE t1.rid = 1
\end_layout

\begin_layout Plain Layout

    AND t2.rid = 2;
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
ST_RESAMPLE
\series default
: Resample a raster using a specified resampling algorithm, new dimensions
 (width & height), a grid corner (gridx & gridy) and a set of raster georeferenc
ing attributes (scalex, scaley, skewx & skewy) defined or borrowed from
 another raster.
 If using a reference raster, the two rasters must have the same SRID.
 New pixel values are computed using the NearestNeighbor (English or American
 spelling), Bilinear, Cubic, CubicSpline or Lanczos resampling algorithm.
 Default is NearestNeighbor which is the fastest but produce the worst interpola
tion.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT
\end_layout

\begin_layout Plain Layout

    ST_Width(orig) AS orig_width,
\end_layout

\begin_layout Plain Layout

    ST_Width(reduce_100) AS new_width
\end_layout

\begin_layout Plain Layout

FROM (
\end_layout

\begin_layout Plain Layout

    SELECT
\end_layout

\begin_layout Plain Layout

        rast AS orig,
\end_layout

\begin_layout Plain Layout

        ST_Resample(rast,100,100) AS reduce_100
\end_layout

\begin_layout Plain Layout

    FROM aerials.boston
\end_layout

\begin_layout Plain Layout

    WHERE ST_Intersects(rast,
\end_layout

\begin_layout Plain Layout

        ST_Transform(
\end_layout

\begin_layout Plain Layout

            ST_MakeEnvelope(-71.128, 42.2392,-71.1277, 42.2397, 4326),26986)
\end_layout

\begin_layout Plain Layout

    )
\end_layout

\begin_layout Plain Layout

    LIMIT 1
\end_layout

\begin_layout Plain Layout

) AS foo;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 orig_width | new_width
\end_layout

\begin_layout Plain Layout

------------+-------------
\end_layout

\begin_layout Plain Layout

        200 |         100
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
ST_SEGMENTIZE
\series default
: Returns a modified geometry having no segment longer than the given max_segmen
t_length.
 Distance computation is performed in 2d only.
 For geometry, length units are in units of spatial reference.
 For geography, units are in meters.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT ST_AsText(ST_Segmentize(
\end_layout

\begin_layout Plain Layout

ST_GeomFromText('MULTILINESTRING((-29 -27,-30 -29.7,-36 -31,-45 -33),(-45
 -33,-46 -32))')
\end_layout

\begin_layout Plain Layout

		,5)
\end_layout

\begin_layout Plain Layout

);
\end_layout

\begin_layout Plain Layout

st_astext
\end_layout

\begin_layout Plain Layout

--------------------------------------------------------------------------------
------------------
\end_layout

\begin_layout Plain Layout

MULTILINESTRING((-29 -27,-30 -29.7,-34.886615700134 -30.758766735029,-36 -31,
\end_layout

\begin_layout Plain Layout

-40.8809353009198 -32.0846522890933,-45 -33),
\end_layout

\begin_layout Plain Layout

(-45 -33,-46 -32))
\end_layout

\begin_layout Plain Layout

(1 row)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

SELECT ST_AsText(ST_Segmentize(ST_GeomFromText('POLYGON((-29 28, -30 40,
 -29 28))'),10));
\end_layout

\begin_layout Plain Layout

st_astext
\end_layout

\begin_layout Plain Layout

-----------------------
\end_layout

\begin_layout Plain Layout

POLYGON((-29 28,-29.8304547985374 37.9654575824488,-30 40,-29.1695452014626
 30.0345424175512,-29 28))
\end_layout

\begin_layout Plain Layout

(1 row)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
ST_SUMMARYSTATS
\series default
: Returns summarystats consisting of count, sum, mean, stddev, min, max
 for a given raster band of a raster or raster coverage.
 If no band is specified nband defaults to 1.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT rid, band, (stats).*
\end_layout

\begin_layout Plain Layout

FROM (SELECT rid, band, ST_SummaryStats(rast, band) As stats
\end_layout

\begin_layout Plain Layout

    FROM dummy_rast CROSS JOIN generate_series(1,3) As band
\end_layout

\begin_layout Plain Layout

     WHERE rid=2) As foo;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 rid | band | count | sum  |    mean    |  stddev   | min | max
\end_layout

\begin_layout Plain Layout

-----+------+-------+------+------------+-----------+-----+-----
\end_layout

\begin_layout Plain Layout

   2 |    1 |    23 | 5821 | 253.086957 |  1.248061 | 250 | 254
\end_layout

\begin_layout Plain Layout

   2 |    2 |    25 | 3682 |     147.28 | 59.862188 |  78 | 254
\end_layout

\begin_layout Plain Layout

   2 |    3 |    25 | 3290 |      131.6 | 61.647384 |  62 | 254
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
ST_UNION
\series default
: Unions the input geometries, merging geometry to produce a result geometry
 with no overlaps.
 The output may be an atomic geometry, a MultiGeometry, or a Geometry Collection.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT id,
\end_layout

\begin_layout Plain Layout

       ST_Union(geom) as singlegeom
\end_layout

\begin_layout Plain Layout

FROM sometable f
\end_layout

\begin_layout Plain Layout

GROUP BY id;
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
ST_VALUE
\series default
: Returns the value of a given band in a given columnx, rowy pixel or at
 a given geometry point.
 Band numbers start at 1 and band is assumed to be 1 if not specified.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

-- get raster values at particular postgis geometry points
\end_layout

\begin_layout Plain Layout

-- the srid of your geometry should be same as for your raster
\end_layout

\begin_layout Plain Layout

SELECT rid, ST_Value(rast, foo.pt_geom) As b1pval, ST_Value(rast, 2, foo.pt_geom)
 As b2pval
\end_layout

\begin_layout Plain Layout

FROM dummy_rast CROSS JOIN (SELECT ST_SetSRID(ST_Point(3427927.77, 5793243.76),
 0) As pt_geom) As foo
\end_layout

\begin_layout Plain Layout

WHERE rid=2;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 rid | b1pval | b2pval
\end_layout

\begin_layout Plain Layout

-----+--------+--------
\end_layout

\begin_layout Plain Layout

   2 |    252 |     79
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- general fictitious example using a real table
\end_layout

\begin_layout Plain Layout

SELECT rid, ST_Value(rast, 3, sometable.geom) As b3pval
\end_layout

\begin_layout Plain Layout

FROM sometable
\end_layout

\begin_layout Plain Layout

WHERE ST_Intersects(rast,sometable.geom);
\end_layout

\end_inset


\end_layout

\end_deeper
\end_body
\end_document
