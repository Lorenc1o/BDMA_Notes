#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble

\end_preamble
\use_default_options true
\begin_modules
tcolorbox
customHeadersFooters
theorems-ams-bytype
theorems-sec-bytype
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=blue, urlcolor=blue, citecolor=blue, pdfstartview={FitH}, unicode=true"
\papersize a4paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\boxbgcolor #62a0ea
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 3cm
\rightmargin 2cm
\bottommargin 3cm
\headheight 2cm
\headsep 1cm
\footskip 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
INFOH415 - Advanced Databases
\end_layout

\begin_layout Date
Fall 2022
\end_layout

\begin_layout Author
Jose Antonio Lorencio Abril
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 1200px-Université_libre_de_Bruxelles_(logo).svg.png
	scale 10

\end_inset


\end_layout

\begin_layout Standard
\align right
Professor: Gilles Dejaegere
\end_layout

\begin_layout Standard
\align right
Student e-mail: jose.lorencio.abril@ulb.be
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList table

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand lstlistoflistings

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Active Databases
\end_layout

\begin_layout Section
Session 1: Exercises 'PhD'
\end_layout

\begin_layout Standard
Consider the following database schema:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado6.png

\end_inset


\end_layout

\begin_layout Standard
Define in SQL Server a set of triggers that ensure the following constraints:
\end_layout

\begin_layout Enumerate
A PhD student must work in the same laboratory as his/her supervisor.
\end_layout

\begin_deeper
\begin_layout Standard

\end_layout

\end_deeper
\begin_layout Enumerate
A PhD student must take at least one course.
\end_layout

\begin_layout Enumerate
A PhD student must take all courses taught by his/her supervisor
\end_layout

\begin_layout Section
Sessions 2 and 3: Exercises 'Employees department projects'
\end_layout

\begin_layout Standard
#TODO
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Graph databases
\end_layout

\begin_layout Section
Session 4: Relational graphs
\end_layout

\begin_layout Standard
Google released, in 2002, a subset of the structure of the WWW.
 In this dataset, web pages are represented by graph nodes such that when
 a web page A contains a hyperlink to web page B, a directed edge is created
 from node A to node B.
 
\end_layout

\begin_layout Standard
In this activity, we will focus on the performance of different queries.
 Therefore, we will use three PostgreSQL tables, which are subsets of different
 sizes of the web structure released by Google: 
\end_layout

\begin_layout Itemize
webgraph1 table: 605 nodes (web pages) and 1521 edges (hyperlinks) 
\end_layout

\begin_layout Itemize
webgraph2 table: 1622 nodes (web pages) and 6288 edges (hyperlinks) 
\end_layout

\begin_layout Itemize
webgraph3 table: 4122 nodes (web pages) and 14356 edges (hyperlinks)
\end_layout

\begin_layout Standard
Below, we show the list of different uses cases we want to analyze:
\end_layout

\begin_layout Exercise
For each pair of connected nodes, find the 1-hop paths.
 Include four columns in the resultset: fromNode, toNode, length, path,
 which correspond to the source node, target node, length of the path, and
 visited nodes, respectively.
 Exclude repeated nodes in the path.
 That is, if there is an edges A -> A, do not consider that A, A, 1, A-A
 is a valid 1-path from A to A.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT fromNode, toNode, 1 as length, fromNode || '-' || toNode as Path
\end_layout

\begin_layout Plain Layout

FROM webgraph1
\end_layout

\begin_layout Plain Layout

WHERE fromNode <> toNode;
\end_layout

\end_inset


\end_layout

\begin_layout Exercise
For each pair of connected nodes, find the 2-hop paths.
 Include four columns in the resultset: fromNode, toNode, length, path,
 which correspond to the source node, target node, length of the path and
 the visited nodes, respectively.
 Exclude repeated nodes in the path.
 That is, if A -> B and B->A are edges in the graph, do not consider that
 A, A, 2, A-B-A is a valid 2- path from A to A.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT w1.fromNode, w2.toNode, 2 as length, w1.fromNode || '-' || w1.toNode
 || '-' || w2.toNode as Path
\end_layout

\begin_layout Plain Layout

FROM webgraph1 w1 
\end_layout

\begin_layout Plain Layout

JOIN webgraph1 w2 ON w1.toNode = w2.fromNode
\end_layout

\begin_layout Plain Layout

WHERE w1.fromNode <> w1.toNode AND w1.fromNode <> w2.toNode AND w2.fromNode <>
 w2.toNode;
\end_layout

\end_inset


\end_layout

\begin_layout Exercise
For each pair of connected nodes, find the 3-hop paths.
 Include four columns in the resultset: fromNode, toNode, length, path,
 which correspond to the source node, target node, length of the path and
 the visited nodes, respectively.
 Exclude repeated nodes in the path.
 That is, if A -> B, A->C and B->A, are edges in the graph, do not consider
 that A, C, 3, A-B-A-C is a valid 3-path from A to C.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT w1.fromNode, w2.toNode, 2 as length, w1.fromNode || '-' || w1.toNode
 || '-' || w2.toNode as Path
\end_layout

\begin_layout Plain Layout

FROM webgraph1 w1 
\end_layout

\begin_layout Plain Layout

JOIN webgraph1 w2 ON w1.toNode = w2.fromNode
\end_layout

\begin_layout Plain Layout

JOIN webgraph1 w3 ON w2.toNode = w3.fromNode
\end_layout

\begin_layout Plain Layout

WHERE w1.fromNode <> w3.toNode AND w1.fromNode <> w2.toNode AND w2.fromNode <>
 w3.toNode;
\end_layout

\end_inset


\end_layout

\begin_layout Exercise
for each pair of connected nodes, find the N-hop paths (the value of N is
 not known in advance).
 Include four columns in the result set: fromNode, toNode, length, path,
 which correspond to the source node, target node, length of the path and
 the visited nodes, respectively.
 Exclude repeated nodes in the path like in case “C”.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

WITH RECURSIVE onePaths AS (
\end_layout

\begin_layout Plain Layout

				SELECT fromNode, toNode, 1 as len, fromNode || '-' || toNode as Path
\end_layout

\begin_layout Plain Layout

				FROM webgraph1
\end_layout

\begin_layout Plain Layout

				WHERE fromNode <> toNode
\end_layout

\begin_layout Plain Layout

				
\end_layout

\begin_layout Plain Layout

				UNION ALL
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

				SELECT op.fromNode, w1.toNode, op.len+1 as len, Path || '-' || w1.toNode
\end_layout

\begin_layout Plain Layout

				FROM onePaths op
\end_layout

\begin_layout Plain Layout

				JOIN webgraph1 w1 ON op.toNode = w1.fromNode 
\end_layout

\begin_layout Plain Layout

				WHERE op.fromNode <> w1.toNode AND 
\end_layout

\begin_layout Plain Layout

				-- Finish this by checking the path string!!
\end_layout

\begin_layout Plain Layout

				AND  op.len < 3
\end_layout

\begin_layout Plain Layout

				)
\end_layout

\begin_layout Plain Layout

SELECT *
\end_layout

\begin_layout Plain Layout

FROM onePaths
\end_layout

\begin_layout Plain Layout

WHERE len=3;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
#TODO fix this las exercise (convert Path as array and check if the new
 node to add is already in it)
\end_layout

\begin_layout Section
Sessions 5 and 6: Neo4j and Cypher
\end_layout

\begin_layout Subsection
Session 5: Cypher Part I
\end_layout

\begin_layout Standard
We will express queries over graph databases using Cypher, the high-level
 query language for Neo4J.
 To be able to easily check the correctness of the results, we will start
 with a small graph representing a subset of the web structure, as shown
 below:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado1.png

\end_inset


\end_layout

\begin_layout Exercise

\series bold
Vertex Degree
\end_layout

\begin_layout Exercise
For each vertex compute its in-degree and out-degree.
 The result set is a list of vertices and both values.
 Those vertices that do not have outgoing edges and/or incoming edges, must
 not appear in the answer.
 (Note that the result set is not a graph).
\end_layout

\begin_layout Standard
I have solved this in two equivalent ways:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

--1--
\end_layout

\begin_layout Plain Layout

MATCH (p:URL)
\end_layout

\begin_layout Plain Layout

WHERE size((:URL)-->(p))+size((p)-->(:URL))>0
\end_layout

\begin_layout Plain Layout

RETURN p.name as url, size((:URL)-->(p)) as in_degree, size((p)-->(:URL))
 as out_degree
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

--2--
\end_layout

\begin_layout Plain Layout

MATCH (p:URL)
\end_layout

\begin_layout Plain Layout

WITH p, size((:URL)-->(p)) AS in_degree, size((p)-->(:URL)) AS out_degree
\end_layout

\begin_layout Plain Layout

WHERE in_degree+out_degree>0
\end_layout

\begin_layout Plain Layout

RETURN p.name as url, in_degree, out_degree
\end_layout

\end_inset


\end_layout

\begin_layout Exercise

\series bold
Vertex Degree variation
\end_layout

\begin_layout Exercise
For each vertex calculate its in-degree and out-degree.
 The result set is a list of all vertices in the graph, together with the
 two values above, for each vertex.
 Those vertices that do not have outgoing edges and/or incoming edges, must
 appear in the answer with value “0”.
 
\end_layout

\begin_layout Standard
The way I solve the first exercise makes this question trivial:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (p:URL)
\end_layout

\begin_layout Plain Layout

RETURN p.name as url, size((:URL)-->(p)) as in_degree, size((p)-->(:URL))
 as out_degree
\end_layout

\end_inset


\end_layout

\begin_layout Exercise

\series bold
Calculating a maximum value
\end_layout

\begin_layout Exercise
Find the maximum vertex in-degree.
 (the result set is not a graph).
\end_layout

\begin_layout Standard
I have solved this also in two different ways.
 I prefer the second solution, because it matches all nodes with maximum
 in-degree and is independent of the order done by the order by.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

--1--
\end_layout

\begin_layout Plain Layout

MATCH (p:URL)
\end_layout

\begin_layout Plain Layout

RETURN p.name as url, size((:URL)-->(p)) as in_degree
\end_layout

\begin_layout Plain Layout

ORDER BY in_degree DESC LIMIT 1
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

--2--
\end_layout

\begin_layout Plain Layout

MATCH (p:URL)
\end_layout

\begin_layout Plain Layout

WITH size((:URL)-->(p)) as in_degree
\end_layout

\begin_layout Plain Layout

WITH max(in_degree) as mx
\end_layout

\begin_layout Plain Layout

MATCH (q:URL)
\end_layout

\begin_layout Plain Layout

WHERE size((:URL)-->(q)) = mx 
\end_layout

\begin_layout Plain Layout

RETURN q.name as url, mx
\end_layout

\end_inset


\end_layout

\begin_layout Exercise

\series bold
Find influencial nodes
\end_layout

\begin_layout Exercise
Find the subgraph which contains nodes whose in-degree is maximal in the
 graph (you should obtain only one node).
 Do the same for the out-degree (you should obtain four nodes).
\end_layout

\begin_layout Standard
For the in-degree:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (n:URL)
\end_layout

\begin_layout Plain Layout

WITH size((:URL)-->(n)) as in_degree, n
\end_layout

\begin_layout Plain Layout

WITH max(in_degree) as mx
\end_layout

\begin_layout Plain Layout

MATCH (n2:URL)
\end_layout

\begin_layout Plain Layout

WITH n2, size(()-->(n2)) as in_degree
\end_layout

\begin_layout Plain Layout

WHERE in_degree = mx
\end_layout

\begin_layout Plain Layout

RETURN n2.name
\end_layout

\end_inset


\end_layout

\begin_layout Standard
And for the out-degree:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (n:URL)
\end_layout

\begin_layout Plain Layout

WITH size((n)-->(:URL)) as out_degree, n
\end_layout

\begin_layout Plain Layout

WITH max(out_degree) as mx
\end_layout

\begin_layout Plain Layout

MATCH (n2:URL)
\end_layout

\begin_layout Plain Layout

WITH n2, size((n2)-->(:URL)) as out_degree
\end_layout

\begin_layout Plain Layout

WHERE out_degree = mx
\end_layout

\begin_layout Plain Layout

RETURN n2.name
\end_layout

\end_inset


\end_layout

\begin_layout Exercise

\series bold
Distance between nodes
\end_layout

\begin_layout Exercise
For each pair of vertices, calculate the distance, i.e.
 the shortest simple path between them (without repeated edges in the path).
 Do not show the distance between two disconnected nodes (infinite distance).
 Exclude paths when source and target are the same node.
\end_layout

\begin_layout Standard
Although there is a specific function for this in Neo4j
\begin_inset Foot
status open

\begin_layout Plain Layout
See next exercise.
\end_layout

\end_inset

, we can manually do this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH path=(a:URL)-[*]->(b:URL)
\end_layout

\begin_layout Plain Layout

WHERE a.name <> b.name
\end_layout

\begin_layout Plain Layout

RETURN a.name, b.name, min(length(path)) as dist
\end_layout

\end_inset


\end_layout

\begin_layout Exercise

\series bold
Distance between nodes using Cypher function
\end_layout

\begin_layout Exercise
Solve the query in Use Case 5, but using the shortestPath built-in Cypher
 function.
 It has one parameter that represents a pattern path and returns the shortest
 path that matches this pattern.
 If there exists more than one shortest path, it returns any of them.
\end_layout

\begin_layout Standard
This one is an easier version of the previous exercise.
 Also, we see another way of computing the length of a path as 
\emph on
size(relationships(path))
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (a:URL), (b:URL), sp=shortestpath((a)-[*]->(b))
\end_layout

\begin_layout Plain Layout

WHERE a.name <> b.name
\end_layout

\begin_layout Plain Layout

RETURN a.name, b.name, size(relationships(sp)) as dist
\end_layout

\end_inset


\end_layout

\begin_layout Exercise

\series bold
Diameter
\end_layout

\begin_layout Exercise
Compute the diameter of the graph, i.e.
 the longest distance between two nodes in the graph (excluding disconnected
 pairs of nodes).
\end_layout

\begin_layout Standard
This one's easy:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH path=(:URL)-[*]->(:URL)
\end_layout

\begin_layout Plain Layout

RETURN max(length(path)) as diameter
\end_layout

\end_inset


\end_layout

\begin_layout Exercise

\series bold
webgraph3
\end_layout

\begin_layout Exercise
Repeat use cases 1 to 7 using the webgraph3 database, which represents the
 same information as the corresponding relational database in Activity 1
 (Session 4).
\end_layout

\begin_layout Standard
We just have to execute the same queries in the webgraph3 database.
\end_layout

\begin_layout Exercise

\series bold
Paths
\end_layout

\begin_layout Exercise
Compute all the 1, 2, 3, and n-hops in the graph, and compare against the
 results obtained using PostgreSQL in Activity 1.
 Note: start with “limit X”, increasing “X” to prevent that the algorithm
 runs indefinitely.
\end_layout

\begin_layout Exercise
#TODO
\end_layout

\begin_layout Subsection
Session 6: Cypher Part II
\end_layout

\begin_layout Exercise
Consider the Northwind database, whose schema is:
\end_layout

\begin_layout Exercise
\begin_inset Graphics
	filename pegado2.png
	scale 60

\end_inset


\end_layout

\begin_layout Exercise
\begin_inset Graphics
	filename pegado4.png

\end_inset


\end_layout

\begin_layout Exercise
Write in Cypher the following queries over the northwindhg.db database:
\end_layout

\begin_deeper
\begin_layout Enumerate
List products and their unit price.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH(v:Product)
\end_layout

\begin_layout Plain Layout

RETURN v.productID, v.unitPrice
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
List information about products 'Chocolade' & 'Pavlova'.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (p:Product)
\end_layout

\begin_layout Plain Layout

WHERE p.productName IN ['Chocolade','Pavlova']
\end_layout

\begin_layout Plain Layout

RETURN p
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
List information about products with names starting with a "C”, whose unit
 price is greater than 50.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (p:Product)
\end_layout

\begin_layout Plain Layout

WHERE p.productName STARTS WITH "C" AND tofloat(p.unitPrice) > 50
\end_layout

\begin_layout Plain Layout

RETURN p.productName, p.unitPrice
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Same as 3, but considering the sales price, not the product’s price.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (p:Product) <- [c:Contains] - (o:Order)
\end_layout

\begin_layout Plain Layout

WHERE p.productName STARTS WITH "C" AND tofloat(c.unitPrice) > 50
\end_layout

\begin_layout Plain Layout

RETURN distinct p.productName, p.unitPrice, c.unitPrice
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Total amount purchased by customer and product.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (c:Customer)
\end_layout

\begin_layout Plain Layout

OPTIONAL MATCH (p:Product)<-[pu:Contains]-(:Order)-[:Purchased]->(c)
\end_layout

\begin_layout Plain Layout

RETURN c.customerName, p.productName,tofloat(sum(pu.unitPrice) * pu.quantity)
 as volume
\end_layout

\begin_layout Plain Layout

ORDER BY volume desc
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Top ten employees, considering the number of orders sold.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (:Order)<-[:Sold]-(e:Employee)
\end_layout

\begin_layout Plain Layout

RETURN e.firstName,e.lastName, count(*) AS Ordenes
\end_layout

\begin_layout Plain Layout

ORDER BY Ordenes DESC LIMIT 10
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
For each employee, list the assigned territories.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (t:Territory)<-[:AssignedTo]-(e:Employee)
\end_layout

\begin_layout Plain Layout

RETURN e.lastName, COLLECT(t.name)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
For each city, list the companies settled in that city.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (c:City)<-[:locatedIn]-(c1:Customer)
\end_layout

\begin_layout Plain Layout

RETURN c.cityname, COLLECT(c1.customerName)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
How many persons an employee reports to, either directly or transitively?
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (report:Employee)
\end_layout

\begin_layout Plain Layout

OPTIONAL MATCH (e)<-[rel:ReportsTo*]-(report)
\end_layout

\begin_layout Plain Layout

RETURN report.lastName AS e1, COUNT(rel) AS reports
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
To whom do persons called “Robert” report to?
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (e:Employee)<-[:ReportsTo*]-(sub:Employee)
\end_layout

\begin_layout Plain Layout

WHERE sub.firstName = 'Robert'
\end_layout

\begin_layout Plain Layout

RETURN e.firstName,e.lastName,sub.lastName
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Who does not report to anybody? 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (e:Employee)
\end_layout

\begin_layout Plain Layout

WHERE NOT (e)-[:ReportsTo]->()
\end_layout

\begin_layout Plain Layout

RETURN e.firstName as TopBossFirst, e.lastName as TopBossLast
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Suppliers, number of categories they supply, and a list of such categories
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (s:Supplier)-->(:Product)-->(c:Category)
\end_layout

\begin_layout Plain Layout

WITH s.supplierName as Supplier, collect(distinct c.categoryName) as Categories
\end_layout

\begin_layout Plain Layout

WITH Supplier, Categories, size(Categories) AS Cantidad ORDER BY Cantidad
 DESC
\end_layout

\begin_layout Plain Layout

RETURN Supplier, Cantidad, Categories
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Suppliers who supply beverages 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (c:Category {categoryName:"Beverages"})<--(:Product)<--(s:Supplier)
\end_layout

\begin_layout Plain Layout

RETURN DISTINCT s.supplierName as ProduceSuppliers
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Customer who purchases the largest amount of beverages 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (cust:Customer)<-[:Purchased]-(:Order)-[o:Contains]->(p:Product),
 (p)-[:hasCategory]->
\end_layout

\begin_layout Plain Layout

(c:Category{categoryName:"Beverages"})
\end_layout

\begin_layout Plain Layout

RETURN cust.customerName as CustomerName, SUM(o.quantity)
\end_layout

\begin_layout Plain Layout

LIMIT 1
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
List the five most popular products (considering number of orders) 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (c:Customer)<-[:Purchased]-(o:Order)-[o1:Contains]->(p:Product)
\end_layout

\begin_layout Plain Layout

RETURN c.customerName, p.productName, count(o1) as orders
\end_layout

\begin_layout Plain Layout

ORDER BY orders desc LIMIT 5
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Products ordered by customers from the same country than their suppliers
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (c:Customer) -[r:locatedIn]->(cy:City)-[:belongsTo]->(:Region)-[:isIn]->(c
o:Country)
\end_layout

\begin_layout Plain Layout

WITH co, c MATCH (s:Supplier) WHERE co.countryname = s.country
\end_layout

\begin_layout Plain Layout

WITH s, co, c MATCH(s)-[su:Supplies]-(p:Product)<-[:Contains]-(o:Order)-[:Purcha
sed]->(c)
\end_layout

\begin_layout Plain Layout

RETURN c.customerName,s.supplierName,co.countryname,p.productName
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Exercise
Switch to the MusicBrainz database, doing the same steps as in Assignment
 2.
 Now, the database is musicbrainz.
 The schema is:
\end_layout

\begin_layout Exercise
\begin_inset Graphics
	filename pegado5.png

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Compute the total number of releases per artist.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (r:ReleaseFact)-[rb:RELEASED_BY]->(ac:ArtistCredit)-[inc:INCLUDES]->(a:Art
ist)
\end_layout

\begin_layout Plain Layout

RETURN a.name, COUNT(r)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Compute the total number of releases per artist and per year.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (d:Date)<-[ro:RELEASED_ON]-(r:ReleaseFact)-[rb:RELEASED_BY]->(ac:ArtistCre
dit)-[inc:INCLUDES]->(a:Artist)
\end_layout

\begin_layout Plain Layout

RETURN a.name, d.year, COUNT(r)
\end_layout

\begin_layout Plain Layout

ORDER BY a.name, d.year
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Compute the total number of events per artist.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (e:Event)<-[rt:REFERS_TO]-(ef:EventFact)-[pb:PERFORMED_BY]->(a:Artist)
\end_layout

\begin_layout Plain Layout

RETURN a.name, COUNT(e)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Compute the number of times the artist performed in each event.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (e:Event)<-[rt:REFERS_TO]-(ef:EventFact)-[pb:PERFORMED_BY]->(a:Artist)
\end_layout

\begin_layout Plain Layout

RETURN a.name, e.name, COUNT(ef)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
For each (event, artist, year) triple, compute the number of times the artist
 performed in an event on an year.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (e:Event)<-[rt:REFERS_TO]-(ef:EventFact)-[pb:PERFORMED_BY]->(a:Artist)
\end_layout

\begin_layout Plain Layout

MATCH (d:Date)<-[ho:HAPPENED_ON]-(ef)
\end_layout

\begin_layout Plain Layout

RETURN a.name, e.name, d.year, COUNT(ef)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Same as Query 5, for artists in the United Kingdom and events happened after
 year 2006.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (d:Date)<-[ho:HAPPENED_ON]-(ef)
\end_layout

\begin_layout Plain Layout

WHERE d.year > 2006
\end_layout

\begin_layout Plain Layout

MATCH (e:Event)<-[rt:REFERS_TO]-(ef:EventFact)-[pb:PERFORMED_BY]->(a:Artist)-[is
f:IS_FROM]->(c:Country)
\end_layout

\begin_layout Plain Layout

WHERE c.name = 'United Kingdom'
\end_layout

\begin_layout Plain Layout

RETURN a.name, e.name, d.year, COUNT(ef)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Compute the number of releases, per language, in the UK.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (r:Release)<-[rt:REFERS_TO]-(rf:ReleaseFact)-[ri:RELEASED_IN]->(c:Country)
\end_layout

\begin_layout Plain Layout

WHERE c.name='United Kingdom'
\end_layout

\begin_layout Plain Layout

RETURN r.language, count(r)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Compute, for each pair of artists, the number of times they have performed
 together at least twice in an event.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (a1:Artist)<-[pb1:PERFORMED_BY]-(ef:EventFact)-[pb2:PERFORMED_BY]->(a2:Art
ist)
\end_layout

\begin_layout Plain Layout

WHERE a1.name < a2.name
\end_layout

\begin_layout Plain Layout

MATCH (e:Event)<-[rt:REFERS_TO]-(ef)
\end_layout

\begin_layout Plain Layout

WITH a1.name as artist1, a2.name as artist2, COUNT(e) as times
\end_layout

\begin_layout Plain Layout

WHERE times>=2
\end_layout

\begin_layout Plain Layout

RETURN artist1, artist2, times
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Compute the triples of artists, and the number of times they have performed
 together in an event, if this number is at least 3.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (a1:Artist)<-[pb1:PERFORMED_BY]-(ef:EventFact)-[pb2:PERFORMED_BY]->(a2:Art
ist)
\end_layout

\begin_layout Plain Layout

MATCH (ef)-[pb3:PERFORMED_BY]->(a3:Artist)
\end_layout

\begin_layout Plain Layout

WHERE a1.name < a2.name < a3.name
\end_layout

\begin_layout Plain Layout

MATCH (e:Event)<-[rt:REFERS_TO]-(ef)
\end_layout

\begin_layout Plain Layout

WITH a1.name as artist1, a2.name as artist2, a3.name as artist3, COUNT(e) as
 times
\end_layout

\begin_layout Plain Layout

WHERE times>=3
\end_layout

\begin_layout Plain Layout

RETURN artist1, artist2, artist3, times
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Compute the quadruples of artists, and the number of times they have performed
 together in an event, if this number is at least 3.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (a1:Artist)<-[pb1:PERFORMED_BY]-(ef:EventFact)-[pb2:PERFORMED_BY]->(a2:Art
ist)
\end_layout

\begin_layout Plain Layout

MATCH (a4:Artist)<-[pb4:PERFORMED_BY]-(ef)-[pb3:PERFORMED_BY]->(a3:Artist)
\end_layout

\begin_layout Plain Layout

WHERE a1.name < a2.name < a3.name < a4.name
\end_layout

\begin_layout Plain Layout

MATCH (e:Event)<-[rt:REFERS_TO]-(ef)
\end_layout

\begin_layout Plain Layout

WITH a1.name as artist1, a2.name as artist2, a3.name as artist3, a4.name as
 artist4, COUNT(e) as times
\end_layout

\begin_layout Plain Layout

WHERE times>=3
\end_layout

\begin_layout Plain Layout

RETURN artist1, artist2, artist3, artist4, times
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Compute the pairs of artists that have performed together in at least two
 events and that have worked together in at least one release, returning
 the number of events and releases together.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (a1:Artist)<-[pb1:PERFORMED_BY]-(ef:EventFact)-[pb2:PERFORMED_BY]->(a2:Art
ist)
\end_layout

\begin_layout Plain Layout

WHERE a1.name < a2.name
\end_layout

\begin_layout Plain Layout

MATCH (e:Event)<-[rte:REFERS_TO]-(ef)
\end_layout

\begin_layout Plain Layout

WITH a1, a2, COUNT(e) as events
\end_layout

\begin_layout Plain Layout

MATCH (a1)<-[in1:INCLUDES]-(ac:ArtistCredit)-[in2:INCLUDES]->(a2)
\end_layout

\begin_layout Plain Layout

MATCH (ac)<-[rb:RELEASED_BY]-(rf:ReleaseFact)-[rtr:REFERS_TO]->(r:Release)
\end_layout

\begin_layout Plain Layout

WITH a1.name as artist1, a2.name as artist2, events, COUNT(r) as releases
\end_layout

\begin_layout Plain Layout

WHERE events>=2 AND releases>=1
\end_layout

\begin_layout Plain Layout

RETURN artist1, artist2, events, releases
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Compute the number of artists who released a record and performed in at
 least an event, and the year(s) this happened.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (a1:Artist)<-[pb1:PERFORMED_BY]-(ef:EventFact)-[ho:HAPPENED_ON]->(de:Date)
\end_layout

\begin_layout Plain Layout

MATCH (e:Event)<-[rte:REFERS_TO]-(ef)
\end_layout

\begin_layout Plain Layout

WITH a1, COUNT(e) as events, COLLECT(DISTINCT(de.year)) as eventyears
\end_layout

\begin_layout Plain Layout

MATCH (a1)<-[in1:INCLUDES]-(ac:ArtistCredit)<-[rb:RELEASED_BY]-(rf:ReleaseFact)
\end_layout

\begin_layout Plain Layout

MATCH (dr:Date)<-[ro:RELEASED_ON]-(rf)-[rtr:REFERS_TO]->(r:Release)
\end_layout

\begin_layout Plain Layout

WITH a1.name as artist1, events, eventyears, COUNT(r) as releases, COLLECT(DISTIN
CT(dr.year)) as releaseyears
\end_layout

\begin_layout Plain Layout

WHERE events>=1 AND releases>=1
\end_layout

\begin_layout Plain Layout

RETURN artist1, events, releases, eventyears, releaseyears
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Exercise
We will query the Flanders river system depicted in Figure 1.
 The schema and properties are shown in the next figures.
 Segments are represented as nodes, with label :Segment (and their corresponding
 properties), and the relation between the nodes is called :flowsTo, defined
 as follows: there is a relation :flowsTo from node A to node B if the water
 flows to segment B from segment A.
 This is stored in the rivers database.
\end_layout

\begin_layout Exercise
\begin_inset Graphics
	filename pegado3.png

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Temporal databases
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Spatial databases
\end_layout

\begin_layout Section
Lab 10
\end_layout

\begin_layout Standard
In the directory 
\series bold
tp10
\series default
, perform:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// Initialization
\end_layout

\begin_layout Plain Layout

$ createdb infoh415
\end_layout

\begin_layout Plain Layout

$ psql infoh415 -c 
\begin_inset Quotes eld
\end_inset

CREATE EXTENSION postgis;
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Tables creation
\end_layout

\begin_layout Plain Layout

$ psql infoh415
\end_layout

\begin_layout Plain Layout

infoh415$ 
\backslash
i create_tables.sql
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Tables population
\end_layout

\begin_layout Plain Layout

infoh415$ 
\backslash
i insertion.sql
\end_layout

\begin_layout Plain Layout

infoh415$ 
\backslash
i create_index.sql
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Importing and exporting
\end_layout

\begin_layout Plain Layout

infoh415$ quit
\end_layout

\begin_layout Plain Layout

$ cd shapefiles/ 
\end_layout

\begin_layout Plain Layout

$ pgsql2shp infoh415 regions 
\end_layout

\begin_layout Plain Layout

$ pgsql2shp infoh415 cities
\end_layout

\begin_layout Plain Layout

$ shp2pgsql -W "latin1" bel_city.shp >  ../shp_insert.sql
\end_layout

\begin_layout Plain Layout

$ shp2pgsql -W "latin1" bel_dist.shp >> ../shp_insert.sql
\end_layout

\begin_layout Plain Layout

$ shp2pgsql -W "latin1" bel_prov.shp >> ../shp_insert.sql
\end_layout

\begin_layout Plain Layout

$ shp2pgsql -W "latin1" bel_regn.shp >> ../shp_insert.sql
\end_layout

\begin_layout Plain Layout

$ shp2pgsql -W "latin1" belriver.shp >> ../shp_insert.sql
\end_layout

\begin_layout Plain Layout

$ cd ..
\end_layout

\begin_layout Plain Layout

$ psql infoh415
\end_layout

\begin_layout Plain Layout

infoh415$ 
\backslash
i shp_insert.sql
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Specify the SRID to use WGS84
\end_layout

\begin_layout Plain Layout

infoh415$ 
\backslash
i update_srid.sql 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Write down and execute the following queries:
\end_layout

\begin_layout Enumerate
Get the SRID from table cities.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

select st_srid(geom) as SRID 
\end_layout

\begin_layout Plain Layout

from bel_city 
\end_layout

\begin_layout Plain Layout

limit 5;
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Get a textual description for this SRID.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

select srtext 
\end_layout

\begin_layout Plain Layout

from spatial_ref_sys 
\end_layout

\begin_layout Plain Layout

where srid=4326;
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Get the dimension of geographical objects in that table.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

select distinct st_dimension(geom) as dim, st_coorddim(geom) as coorddim
 
\end_layout

\begin_layout Plain Layout

from bel_city;
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Get the geometry type of these objects.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

select distinct st_geometrytype(geom) as type 
\end_layout

\begin_layout Plain Layout

from bel_city;
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Compute the distance between the cities of IXELLES and BRUGGE.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

select st_distance(
\end_layout

\begin_layout Plain Layout

	st_transform((select geom from bel_city where name = 'Ixelles'),3812),
 
\end_layout

\begin_layout Plain Layout

	st_transform((select geom from bel_city where name = 'Brugge'),3812)) as
 dist, 
\end_layout

\begin_layout Plain Layout

st_distancesphere(
\end_layout

\begin_layout Plain Layout

	(select geom from bel_city where name = 'Ixelles'), 
\end_layout

\begin_layout Plain Layout

	(select geom from bel_city where name = 'Brugge')) as dist_sphere
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The number 3812 in the transform function refers to Belgian Lambert 2008,
 which is a conic representation adapted for Belgium.
 If we don't apply this transformation, we get a distance measured in degrees,
 which has little meaning for us.
\end_layout

\end_deeper
\begin_layout Enumerate
Compute the bounding rectangle for the BRABANT province.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

create table boundbox as 
\end_layout

\begin_layout Plain Layout

	select st_envelope(geom) 
\end_layout

\begin_layout Plain Layout

	from bel_prov 
\end_layout

\begin_layout Plain Layout

	where name = 'Brabant';
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We create the table to be able to visualize the result in QGis:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado7.png
	scale 60

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Compute the geographical union of the bel_regn and bel_prov tables.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

create table geom_union as 
\end_layout

\begin_layout Plain Layout

	select st_union(geom) 
\end_layout

\begin_layout Plain Layout

	from (select geom from bel_regn 
\end_layout

\begin_layout Plain Layout

		  union 
\end_layout

\begin_layout Plain Layout

		  select geom from bel_prov) 
\end_layout

\begin_layout Plain Layout

		  as tmp;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado8.png
	scale 60

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Compute the length of each river.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

select st_length2dspheroid(geom, 'SPHEROID["GRS_1980",6378137,298.257222101]')
 
\end_layout

\begin_layout Plain Layout

from belriver;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The second argument is the spheroid that the function should use to compute
 the lengths, as its definition is 
\begin_inset Formula $ST\_Length2DSpheroid(geometry\ geom,spheroid\ sp)$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
Create a table containing all cities that stand less than 1000m from a river.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

select name, dist 
\end_layout

\begin_layout Plain Layout

from 
\end_layout

\begin_layout Plain Layout

	(select c.name as name, min(st_distancesphere(c.geom, r.geom)) as dist 
\end_layout

\begin_layout Plain Layout

	 from bel_city c, belriver r 
\end_layout

\begin_layout Plain Layout

	 group by c.name) as tmp 
\end_layout

\begin_layout Plain Layout

where dist < 1000; 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- or
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

select c.name as name, min(st_distancesphere(c.geom, r.geom)) as dist 
\end_layout

\begin_layout Plain Layout

from bel_city c 
\end_layout

\begin_layout Plain Layout

	 join belriver r on st_distancesphere(c.geom, r.geom) < 1000 
\end_layout

\begin_layout Plain Layout

group by c.name; 
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
For each river, compute the length of its path inside each province it traverses.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

select r.name as river, p.name as province, 
\end_layout

\begin_layout Plain Layout

	st_length2dspheroid(st_intersection(r.geom, p.geom),
\end_layout

\begin_layout Plain Layout

					'SPHEROID["GRS_1980",6378137,298.257222101]') as inside_len 
\end_layout

\begin_layout Plain Layout

from belriver r 
\end_layout

\begin_layout Plain Layout

join bel_prov p on st_intersects(r.geom, p.geom); 
\end_layout

\end_inset


\end_layout

\end_deeper
\end_body
\end_document
