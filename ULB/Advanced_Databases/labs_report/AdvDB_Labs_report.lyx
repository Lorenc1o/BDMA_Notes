#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble

\end_preamble
\use_default_options true
\begin_modules
tcolorbox
customHeadersFooters
theorems-ams-bytype
theorems-sec-bytype
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=blue, urlcolor=blue, citecolor=blue, pdfstartview={FitH}, unicode=true"
\papersize a4paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\boxbgcolor #62a0ea
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 3cm
\rightmargin 2cm
\bottommargin 3cm
\headheight 2cm
\headsep 1cm
\footskip 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
INFOH415 - Advanced Databases
\end_layout

\begin_layout Date
Fall 2022
\end_layout

\begin_layout Author
Jose Antonio Lorencio Abril
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 1200px-Université_libre_de_Bruxelles_(logo).svg.png
	scale 10

\end_inset


\end_layout

\begin_layout Standard
\align right
Professor: Gilles Dejaegere
\end_layout

\begin_layout Standard
\align right
Student e-mail: jose.lorencio.abril@ulb.be
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList table

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand lstlistoflistings

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Active Databases
\end_layout

\begin_layout Section
Session 1: Exercises 'PhD'
\end_layout

\begin_layout Standard
Consider the following database schema:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado6.png

\end_inset


\end_layout

\begin_layout Standard
Define in SQL Server a set of triggers that ensure the following constraints:
\end_layout

\begin_layout Enumerate
A PhD student must work in the same laboratory as his/her supervisor.
\end_layout

\begin_deeper
\begin_layout Standard

\end_layout

\end_deeper
\begin_layout Enumerate
A PhD student must take at least one course.
\end_layout

\begin_layout Enumerate
A PhD student must take all courses taught by his/her supervisor
\end_layout

\begin_layout Section
Sessions 2 and 3: Exercises 'Employees department projects'
\end_layout

\begin_layout Standard
#TODO
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Graph databases
\end_layout

\begin_layout Section
Session 4: Relational graphs
\end_layout

\begin_layout Standard
Google released, in 2002, a subset of the structure of the WWW.
 In this dataset, web pages are represented by graph nodes such that when
 a web page A contains a hyperlink to web page B, a directed edge is created
 from node A to node B.
 
\end_layout

\begin_layout Standard
In this activity, we will focus on the performance of different queries.
 Therefore, we will use three PostgreSQL tables, which are subsets of different
 sizes of the web structure released by Google: 
\end_layout

\begin_layout Itemize
webgraph1 table: 605 nodes (web pages) and 1521 edges (hyperlinks) 
\end_layout

\begin_layout Itemize
webgraph2 table: 1622 nodes (web pages) and 6288 edges (hyperlinks) 
\end_layout

\begin_layout Itemize
webgraph3 table: 4122 nodes (web pages) and 14356 edges (hyperlinks)
\end_layout

\begin_layout Standard
Below, we show the list of different uses cases we want to analyze:
\end_layout

\begin_layout Exercise
For each pair of connected nodes, find the 1-hop paths.
 Include four columns in the resultset: fromNode, toNode, length, path,
 which correspond to the source node, target node, length of the path, and
 visited nodes, respectively.
 Exclude repeated nodes in the path.
 That is, if there is an edges A -> A, do not consider that A, A, 1, A-A
 is a valid 1-path from A to A.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT fromNode, toNode, 1 as length, fromNode || '-' || toNode as Path
\end_layout

\begin_layout Plain Layout

FROM webgraph1
\end_layout

\begin_layout Plain Layout

WHERE fromNode <> toNode;
\end_layout

\end_inset


\end_layout

\begin_layout Exercise
For each pair of connected nodes, find the 2-hop paths.
 Include four columns in the resultset: fromNode, toNode, length, path,
 which correspond to the source node, target node, length of the path and
 the visited nodes, respectively.
 Exclude repeated nodes in the path.
 That is, if A -> B and B->A are edges in the graph, do not consider that
 A, A, 2, A-B-A is a valid 2- path from A to A.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT w1.fromNode, w2.toNode, 2 as length, w1.fromNode || '-' || w1.toNode
 || '-' || w2.toNode as Path
\end_layout

\begin_layout Plain Layout

FROM webgraph1 w1 
\end_layout

\begin_layout Plain Layout

JOIN webgraph1 w2 ON w1.toNode = w2.fromNode
\end_layout

\begin_layout Plain Layout

WHERE w1.fromNode <> w1.toNode AND w1.fromNode <> w2.toNode AND w2.fromNode <>
 w2.toNode;
\end_layout

\end_inset


\end_layout

\begin_layout Exercise
For each pair of connected nodes, find the 3-hop paths.
 Include four columns in the resultset: fromNode, toNode, length, path,
 which correspond to the source node, target node, length of the path and
 the visited nodes, respectively.
 Exclude repeated nodes in the path.
 That is, if A -> B, A->C and B->A, are edges in the graph, do not consider
 that A, C, 3, A-B-A-C is a valid 3-path from A to C.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT w1.fromNode, w2.toNode, 2 as length, w1.fromNode || '-' || w1.toNode
 || '-' || w2.toNode as Path
\end_layout

\begin_layout Plain Layout

FROM webgraph1 w1 
\end_layout

\begin_layout Plain Layout

JOIN webgraph1 w2 ON w1.toNode = w2.fromNode
\end_layout

\begin_layout Plain Layout

JOIN webgraph1 w3 ON w2.toNode = w3.fromNode
\end_layout

\begin_layout Plain Layout

WHERE w1.fromNode <> w3.toNode AND w1.fromNode <> w2.toNode AND w2.fromNode <>
 w3.toNode;
\end_layout

\end_inset


\end_layout

\begin_layout Exercise
for each pair of connected nodes, find the N-hop paths (the value of N is
 not known in advance).
 Include four columns in the result set: fromNode, toNode, length, path,
 which correspond to the source node, target node, length of the path and
 the visited nodes, respectively.
 Exclude repeated nodes in the path like in case “C”.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

WITH RECURSIVE onePaths AS (
\end_layout

\begin_layout Plain Layout

				SELECT fromNode, toNode, 1 as len, fromNode || '-' || toNode as Path
\end_layout

\begin_layout Plain Layout

				FROM webgraph1
\end_layout

\begin_layout Plain Layout

				WHERE fromNode <> toNode
\end_layout

\begin_layout Plain Layout

				
\end_layout

\begin_layout Plain Layout

				UNION ALL
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

				SELECT op.fromNode, w1.toNode, op.len+1 as len, Path || '-' || w1.toNode
\end_layout

\begin_layout Plain Layout

				FROM onePaths op
\end_layout

\begin_layout Plain Layout

				JOIN webgraph1 w1 ON op.toNode = w1.fromNode 
\end_layout

\begin_layout Plain Layout

				WHERE op.fromNode <> w1.toNode AND 
\end_layout

\begin_layout Plain Layout

				-- Finish this by checking the path string!!
\end_layout

\begin_layout Plain Layout

				AND  op.len < 3
\end_layout

\begin_layout Plain Layout

				)
\end_layout

\begin_layout Plain Layout

SELECT *
\end_layout

\begin_layout Plain Layout

FROM onePaths
\end_layout

\begin_layout Plain Layout

WHERE len=3;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
#TODO fix this las exercise (convert Path as array and check if the new
 node to add is already in it)
\end_layout

\begin_layout Section
Sessions 5 and 6: Neo4j and Cypher
\end_layout

\begin_layout Subsection
Session 5: Cypher Part I
\end_layout

\begin_layout Standard
We will express queries over graph databases using Cypher, the high-level
 query language for Neo4J.
 To be able to easily check the correctness of the results, we will start
 with a small graph representing a subset of the web structure, as shown
 below:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado1.png

\end_inset


\end_layout

\begin_layout Exercise

\series bold
Vertex Degree
\end_layout

\begin_layout Exercise
For each vertex compute its in-degree and out-degree.
 The result set is a list of vertices and both values.
 Those vertices that do not have outgoing edges and/or incoming edges, must
 not appear in the answer.
 (Note that the result set is not a graph).
\end_layout

\begin_layout Standard
I have solved this in two equivalent ways:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

--1--
\end_layout

\begin_layout Plain Layout

MATCH (p:URL)
\end_layout

\begin_layout Plain Layout

WHERE size((:URL)-->(p))+size((p)-->(:URL))>0
\end_layout

\begin_layout Plain Layout

RETURN p.name as url, size((:URL)-->(p)) as in_degree, size((p)-->(:URL))
 as out_degree
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

--2--
\end_layout

\begin_layout Plain Layout

MATCH (p:URL)
\end_layout

\begin_layout Plain Layout

WITH p, size((:URL)-->(p)) AS in_degree, size((p)-->(:URL)) AS out_degree
\end_layout

\begin_layout Plain Layout

WHERE in_degree+out_degree>0
\end_layout

\begin_layout Plain Layout

RETURN p.name as url, in_degree, out_degree
\end_layout

\end_inset


\end_layout

\begin_layout Exercise

\series bold
Vertex Degree variation
\end_layout

\begin_layout Exercise
For each vertex calculate its in-degree and out-degree.
 The result set is a list of all vertices in the graph, together with the
 two values above, for each vertex.
 Those vertices that do not have outgoing edges and/or incoming edges, must
 appear in the answer with value “0”.
 
\end_layout

\begin_layout Standard
The way I solve the first exercise makes this question trivial:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (p:URL)
\end_layout

\begin_layout Plain Layout

RETURN p.name as url, size((:URL)-->(p)) as in_degree, size((p)-->(:URL))
 as out_degree
\end_layout

\end_inset


\end_layout

\begin_layout Exercise

\series bold
Calculating a maximum value
\end_layout

\begin_layout Exercise
Find the maximum vertex in-degree.
 (the result set is not a graph).
\end_layout

\begin_layout Standard
I have solved this also in two different ways.
 I prefer the second solution, because it matches all nodes with maximum
 in-degree and is independent of the order done by the order by.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

--1--
\end_layout

\begin_layout Plain Layout

MATCH (p:URL)
\end_layout

\begin_layout Plain Layout

RETURN p.name as url, size((:URL)-->(p)) as in_degree
\end_layout

\begin_layout Plain Layout

ORDER BY in_degree DESC LIMIT 1
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

--2--
\end_layout

\begin_layout Plain Layout

MATCH (p:URL)
\end_layout

\begin_layout Plain Layout

WITH size((:URL)-->(p)) as in_degree
\end_layout

\begin_layout Plain Layout

WITH max(in_degree) as mx
\end_layout

\begin_layout Plain Layout

MATCH (q:URL)
\end_layout

\begin_layout Plain Layout

WHERE size((:URL)-->(q)) = mx 
\end_layout

\begin_layout Plain Layout

RETURN q.name as url, mx
\end_layout

\end_inset


\end_layout

\begin_layout Exercise

\series bold
Find influencial nodes
\end_layout

\begin_layout Exercise
Find the subgraph which contains nodes whose in-degree is maximal in the
 graph (you should obtain only one node).
 Do the same for the out-degree (you should obtain four nodes).
\end_layout

\begin_layout Standard
For the in-degree:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (n:URL)
\end_layout

\begin_layout Plain Layout

WITH size((:URL)-->(n)) as in_degree, n
\end_layout

\begin_layout Plain Layout

WITH max(in_degree) as mx
\end_layout

\begin_layout Plain Layout

MATCH (n2:URL)
\end_layout

\begin_layout Plain Layout

WITH n2, size(()-->(n2)) as in_degree
\end_layout

\begin_layout Plain Layout

WHERE in_degree = mx
\end_layout

\begin_layout Plain Layout

RETURN n2.name
\end_layout

\end_inset


\end_layout

\begin_layout Standard
And for the out-degree:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (n:URL)
\end_layout

\begin_layout Plain Layout

WITH size((n)-->(:URL)) as out_degree, n
\end_layout

\begin_layout Plain Layout

WITH max(out_degree) as mx
\end_layout

\begin_layout Plain Layout

MATCH (n2:URL)
\end_layout

\begin_layout Plain Layout

WITH n2, size((n2)-->(:URL)) as out_degree
\end_layout

\begin_layout Plain Layout

WHERE out_degree = mx
\end_layout

\begin_layout Plain Layout

RETURN n2.name
\end_layout

\end_inset


\end_layout

\begin_layout Exercise

\series bold
Distance between nodes
\end_layout

\begin_layout Exercise
For each pair of vertices, calculate the distance, i.e.
 the shortest simple path between them (without repeated edges in the path).
 Do not show the distance between two disconnected nodes (infinite distance).
 Exclude paths when source and target are the same node.
\end_layout

\begin_layout Standard
Although there is a specific function for this in Neo4j
\begin_inset Foot
status open

\begin_layout Plain Layout
See next exercise.
\end_layout

\end_inset

, we can manually do this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH path=(a:URL)-[*]->(b:URL)
\end_layout

\begin_layout Plain Layout

WHERE a.name <> b.name
\end_layout

\begin_layout Plain Layout

RETURN a.name, b.name, min(length(path)) as dist
\end_layout

\end_inset


\end_layout

\begin_layout Exercise

\series bold
Distance between nodes using Cypher function
\end_layout

\begin_layout Exercise
Solve the query in Use Case 5, but using the shortestPath built-in Cypher
 function.
 It has one parameter that represents a pattern path and returns the shortest
 path that matches this pattern.
 If there exists more than one shortest path, it returns any of them.
\end_layout

\begin_layout Standard
This one is an easier version of the previous exercise.
 Also, we see another way of computing the length of a path as 
\emph on
size(relationships(path))
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (a:URL), (b:URL), sp=shortestpath((a)-[*]->(b))
\end_layout

\begin_layout Plain Layout

WHERE a.name <> b.name
\end_layout

\begin_layout Plain Layout

RETURN a.name, b.name, size(relationships(sp)) as dist
\end_layout

\end_inset


\end_layout

\begin_layout Exercise

\series bold
Diameter
\end_layout

\begin_layout Exercise
Compute the diameter of the graph, i.e.
 the longest distance between two nodes in the graph (excluding disconnected
 pairs of nodes).
\end_layout

\begin_layout Standard
This one's easy:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH path=(:URL)-[*]->(:URL)
\end_layout

\begin_layout Plain Layout

RETURN max(length(path)) as diameter
\end_layout

\end_inset


\end_layout

\begin_layout Exercise

\series bold
webgraph3
\end_layout

\begin_layout Exercise
Repeat use cases 1 to 7 using the webgraph3 database, which represents the
 same information as the corresponding relational database in Activity 1
 (Session 4).
\end_layout

\begin_layout Standard
We just have to execute the same queries in the webgraph3 database.
\end_layout

\begin_layout Exercise

\series bold
Paths
\end_layout

\begin_layout Exercise
Compute all the 1, 2, 3, and n-hops in the graph, and compare against the
 results obtained using PostgreSQL in Activity 1.
 Note: start with “limit X”, increasing “X” to prevent that the algorithm
 runs indefinitely.
\end_layout

\begin_layout Exercise
#TODO
\end_layout

\begin_layout Subsection
Session 6: Cypher Part II
\end_layout

\begin_layout Exercise
Consider the Northwind database, whose schema is:
\end_layout

\begin_layout Exercise
\begin_inset Graphics
	filename pegado2.png
	scale 60

\end_inset


\end_layout

\begin_layout Exercise
\begin_inset Graphics
	filename pegado4.png

\end_inset


\end_layout

\begin_layout Exercise
Write in Cypher the following queries over the northwindhg.db database:
\end_layout

\begin_deeper
\begin_layout Enumerate
List products and their unit price.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH(v:Product)
\end_layout

\begin_layout Plain Layout

RETURN v.productID, v.unitPrice
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
List information about products 'Chocolade' & 'Pavlova'.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (p:Product)
\end_layout

\begin_layout Plain Layout

WHERE p.productName IN ['Chocolade','Pavlova']
\end_layout

\begin_layout Plain Layout

RETURN p
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
List information about products with names starting with a "C”, whose unit
 price is greater than 50.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (p:Product)
\end_layout

\begin_layout Plain Layout

WHERE p.productName STARTS WITH "C" AND tofloat(p.unitPrice) > 50
\end_layout

\begin_layout Plain Layout

RETURN p.productName, p.unitPrice
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Same as 3, but considering the sales price, not the product’s price.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (p:Product) <- [c:Contains] - (o:Order)
\end_layout

\begin_layout Plain Layout

WHERE p.productName STARTS WITH "C" AND tofloat(c.unitPrice) > 50
\end_layout

\begin_layout Plain Layout

RETURN distinct p.productName, p.unitPrice, c.unitPrice
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Total amount purchased by customer and product.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (c:Customer)
\end_layout

\begin_layout Plain Layout

OPTIONAL MATCH (p:Product)<-[pu:Contains]-(:Order)-[:Purchased]->(c)
\end_layout

\begin_layout Plain Layout

RETURN c.customerName, p.productName,tofloat(sum(pu.unitPrice) * pu.quantity)
 as volume
\end_layout

\begin_layout Plain Layout

ORDER BY volume desc
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Top ten employees, considering the number of orders sold.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (:Order)<-[:Sold]-(e:Employee)
\end_layout

\begin_layout Plain Layout

RETURN e.firstName,e.lastName, count(*) AS Ordenes
\end_layout

\begin_layout Plain Layout

ORDER BY Ordenes DESC LIMIT 10
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
For each employee, list the assigned territories.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (t:Territory)<-[:AssignedTo]-(e:Employee)
\end_layout

\begin_layout Plain Layout

RETURN e.lastName, COLLECT(t.name)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
For each city, list the companies settled in that city.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (c:City)<-[:locatedIn]-(c1:Customer)
\end_layout

\begin_layout Plain Layout

RETURN c.cityname, COLLECT(c1.customerName)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
How many persons an employee reports to, either directly or transitively?
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (report:Employee)
\end_layout

\begin_layout Plain Layout

OPTIONAL MATCH (e)<-[rel:ReportsTo*]-(report)
\end_layout

\begin_layout Plain Layout

RETURN report.lastName AS e1, COUNT(rel) AS reports
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
To whom do persons called “Robert” report to?
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (e:Employee)<-[:ReportsTo*]-(sub:Employee)
\end_layout

\begin_layout Plain Layout

WHERE sub.firstName = 'Robert'
\end_layout

\begin_layout Plain Layout

RETURN e.firstName,e.lastName,sub.lastName
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Who does not report to anybody? 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (e:Employee)
\end_layout

\begin_layout Plain Layout

WHERE NOT (e)-[:ReportsTo]->()
\end_layout

\begin_layout Plain Layout

RETURN e.firstName as TopBossFirst, e.lastName as TopBossLast
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Suppliers, number of categories they supply, and a list of such categories
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (s:Supplier)-->(:Product)-->(c:Category)
\end_layout

\begin_layout Plain Layout

WITH s.supplierName as Supplier, collect(distinct c.categoryName) as Categories
\end_layout

\begin_layout Plain Layout

WITH Supplier, Categories, size(Categories) AS Cantidad ORDER BY Cantidad
 DESC
\end_layout

\begin_layout Plain Layout

RETURN Supplier, Cantidad, Categories
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Suppliers who supply beverages 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (c:Category {categoryName:"Beverages"})<--(:Product)<--(s:Supplier)
\end_layout

\begin_layout Plain Layout

RETURN DISTINCT s.supplierName as ProduceSuppliers
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Customer who purchases the largest amount of beverages 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (cust:Customer)<-[:Purchased]-(:Order)-[o:Contains]->(p:Product),
 (p)-[:hasCategory]->
\end_layout

\begin_layout Plain Layout

(c:Category{categoryName:"Beverages"})
\end_layout

\begin_layout Plain Layout

RETURN cust.customerName as CustomerName, SUM(o.quantity)
\end_layout

\begin_layout Plain Layout

LIMIT 1
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
List the five most popular products (considering number of orders) 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (c:Customer)<-[:Purchased]-(o:Order)-[o1:Contains]->(p:Product)
\end_layout

\begin_layout Plain Layout

RETURN c.customerName, p.productName, count(o1) as orders
\end_layout

\begin_layout Plain Layout

ORDER BY orders desc LIMIT 5
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Products ordered by customers from the same country than their suppliers
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (c:Customer) -[r:locatedIn]->(cy:City)-[:belongsTo]->(:Region)-[:isIn]->(c
o:Country)
\end_layout

\begin_layout Plain Layout

WITH co, c MATCH (s:Supplier) WHERE co.countryname = s.country
\end_layout

\begin_layout Plain Layout

WITH s, co, c MATCH(s)-[su:Supplies]-(p:Product)<-[:Contains]-(o:Order)-[:Purcha
sed]->(c)
\end_layout

\begin_layout Plain Layout

RETURN c.customerName,s.supplierName,co.countryname,p.productName
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Exercise
Switch to the MusicBrainz database, doing the same steps as in Assignment
 2.
 Now, the database is musicbrainz.
 The schema is:
\end_layout

\begin_layout Exercise
\begin_inset Graphics
	filename pegado5.png

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Compute the total number of releases per artist.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (r:ReleaseFact)-[rb:RELEASED_BY]->(ac:ArtistCredit)-[inc:INCLUDES]->(a:Art
ist)
\end_layout

\begin_layout Plain Layout

RETURN a.name, COUNT(r)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Compute the total number of releases per artist and per year.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (d:Date)<-[ro:RELEASED_ON]-(r:ReleaseFact)-[rb:RELEASED_BY]->(ac:ArtistCre
dit)-[inc:INCLUDES]->(a:Artist)
\end_layout

\begin_layout Plain Layout

RETURN a.name, d.year, COUNT(r)
\end_layout

\begin_layout Plain Layout

ORDER BY a.name, d.year
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Compute the total number of events per artist.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (e:Event)<-[rt:REFERS_TO]-(ef:EventFact)-[pb:PERFORMED_BY]->(a:Artist)
\end_layout

\begin_layout Plain Layout

RETURN a.name, COUNT(e)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Compute the number of times the artist performed in each event.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (e:Event)<-[rt:REFERS_TO]-(ef:EventFact)-[pb:PERFORMED_BY]->(a:Artist)
\end_layout

\begin_layout Plain Layout

RETURN a.name, e.name, COUNT(ef)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
For each (event, artist, year) triple, compute the number of times the artist
 performed in an event on an year.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (e:Event)<-[rt:REFERS_TO]-(ef:EventFact)-[pb:PERFORMED_BY]->(a:Artist)
\end_layout

\begin_layout Plain Layout

MATCH (d:Date)<-[ho:HAPPENED_ON]-(ef)
\end_layout

\begin_layout Plain Layout

RETURN a.name, e.name, d.year, COUNT(ef)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Same as Query 5, for artists in the United Kingdom and events happened after
 year 2006.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (d:Date)<-[ho:HAPPENED_ON]-(ef)
\end_layout

\begin_layout Plain Layout

WHERE d.year > 2006
\end_layout

\begin_layout Plain Layout

MATCH (e:Event)<-[rt:REFERS_TO]-(ef:EventFact)-[pb:PERFORMED_BY]->(a:Artist)-[is
f:IS_FROM]->(c:Country)
\end_layout

\begin_layout Plain Layout

WHERE c.name = 'United Kingdom'
\end_layout

\begin_layout Plain Layout

RETURN a.name, e.name, d.year, COUNT(ef)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Compute the number of releases, per language, in the UK.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (r:Release)<-[rt:REFERS_TO]-(rf:ReleaseFact)-[ri:RELEASED_IN]->(c:Country)
\end_layout

\begin_layout Plain Layout

WHERE c.name='United Kingdom'
\end_layout

\begin_layout Plain Layout

RETURN r.language, count(r)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Compute, for each pair of artists, the number of times they have performed
 together at least twice in an event.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (a1:Artist)<-[pb1:PERFORMED_BY]-(ef:EventFact)-[pb2:PERFORMED_BY]->(a2:Art
ist)
\end_layout

\begin_layout Plain Layout

WHERE a1.name < a2.name
\end_layout

\begin_layout Plain Layout

MATCH (e:Event)<-[rt:REFERS_TO]-(ef)
\end_layout

\begin_layout Plain Layout

WITH a1.name as artist1, a2.name as artist2, COUNT(e) as times
\end_layout

\begin_layout Plain Layout

WHERE times>=2
\end_layout

\begin_layout Plain Layout

RETURN artist1, artist2, times
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Compute the triples of artists, and the number of times they have performed
 together in an event, if this number is at least 3.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (a1:Artist)<-[pb1:PERFORMED_BY]-(ef:EventFact)-[pb2:PERFORMED_BY]->(a2:Art
ist)
\end_layout

\begin_layout Plain Layout

MATCH (ef)-[pb3:PERFORMED_BY]->(a3:Artist)
\end_layout

\begin_layout Plain Layout

WHERE a1.name < a2.name < a3.name
\end_layout

\begin_layout Plain Layout

MATCH (e:Event)<-[rt:REFERS_TO]-(ef)
\end_layout

\begin_layout Plain Layout

WITH a1.name as artist1, a2.name as artist2, a3.name as artist3, COUNT(e) as
 times
\end_layout

\begin_layout Plain Layout

WHERE times>=3
\end_layout

\begin_layout Plain Layout

RETURN artist1, artist2, artist3, times
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Compute the quadruples of artists, and the number of times they have performed
 together in an event, if this number is at least 3.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (a1:Artist)<-[pb1:PERFORMED_BY]-(ef:EventFact)-[pb2:PERFORMED_BY]->(a2:Art
ist)
\end_layout

\begin_layout Plain Layout

MATCH (a4:Artist)<-[pb4:PERFORMED_BY]-(ef)-[pb3:PERFORMED_BY]->(a3:Artist)
\end_layout

\begin_layout Plain Layout

WHERE a1.name < a2.name < a3.name < a4.name
\end_layout

\begin_layout Plain Layout

MATCH (e:Event)<-[rt:REFERS_TO]-(ef)
\end_layout

\begin_layout Plain Layout

WITH a1.name as artist1, a2.name as artist2, a3.name as artist3, a4.name as
 artist4, COUNT(e) as times
\end_layout

\begin_layout Plain Layout

WHERE times>=3
\end_layout

\begin_layout Plain Layout

RETURN artist1, artist2, artist3, artist4, times
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Compute the pairs of artists that have performed together in at least two
 events and that have worked together in at least one release, returning
 the number of events and releases together.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (a1:Artist)<-[pb1:PERFORMED_BY]-(ef:EventFact)-[pb2:PERFORMED_BY]->(a2:Art
ist)
\end_layout

\begin_layout Plain Layout

WHERE a1.name < a2.name
\end_layout

\begin_layout Plain Layout

MATCH (e:Event)<-[rte:REFERS_TO]-(ef)
\end_layout

\begin_layout Plain Layout

WITH a1, a2, COUNT(e) as events
\end_layout

\begin_layout Plain Layout

MATCH (a1)<-[in1:INCLUDES]-(ac:ArtistCredit)-[in2:INCLUDES]->(a2)
\end_layout

\begin_layout Plain Layout

MATCH (ac)<-[rb:RELEASED_BY]-(rf:ReleaseFact)-[rtr:REFERS_TO]->(r:Release)
\end_layout

\begin_layout Plain Layout

WITH a1.name as artist1, a2.name as artist2, events, COUNT(r) as releases
\end_layout

\begin_layout Plain Layout

WHERE events>=2 AND releases>=1
\end_layout

\begin_layout Plain Layout

RETURN artist1, artist2, events, releases
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Compute the number of artists who released a record and performed in at
 least an event, and the year(s) this happened.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (a1:Artist)<-[pb1:PERFORMED_BY]-(ef:EventFact)-[ho:HAPPENED_ON]->(de:Date)
\end_layout

\begin_layout Plain Layout

MATCH (e:Event)<-[rte:REFERS_TO]-(ef)
\end_layout

\begin_layout Plain Layout

WITH a1, COUNT(e) as events, COLLECT(DISTINCT(de.year)) as eventyears
\end_layout

\begin_layout Plain Layout

MATCH (a1)<-[in1:INCLUDES]-(ac:ArtistCredit)<-[rb:RELEASED_BY]-(rf:ReleaseFact)
\end_layout

\begin_layout Plain Layout

MATCH (dr:Date)<-[ro:RELEASED_ON]-(rf)-[rtr:REFERS_TO]->(r:Release)
\end_layout

\begin_layout Plain Layout

WITH a1.name as artist1, events, eventyears, COUNT(r) as releases, COLLECT(DISTIN
CT(dr.year)) as releaseyears
\end_layout

\begin_layout Plain Layout

WHERE events>=1 AND releases>=1
\end_layout

\begin_layout Plain Layout

RETURN artist1, events, releases, eventyears, releaseyears
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Exercise
We will query the Flanders river system depicted in Figure 1.
 The schema and properties are shown in the next figures.
 Segments are represented as nodes, with label :Segment (and their corresponding
 properties), and the relation between the nodes is called :flowsTo, defined
 as follows: there is a relation :flowsTo from node A to node B if the water
 flows to segment B from segment A.
 This is stored in the rivers database.
\end_layout

\begin_layout Exercise
\begin_inset Graphics
	filename pegado3.png

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Temporal databases
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Spatial databases
\end_layout

\begin_layout Section
Lab 10
\end_layout

\begin_layout Standard
In the directory 
\series bold
tp10
\series default
, perform:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// Initialization
\end_layout

\begin_layout Plain Layout

$ createdb infoh415
\end_layout

\begin_layout Plain Layout

$ psql infoh415 -c 
\begin_inset Quotes eld
\end_inset

CREATE EXTENSION postgis;
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Tables creation
\end_layout

\begin_layout Plain Layout

$ psql infoh415
\end_layout

\begin_layout Plain Layout

infoh415$ 
\backslash
i create_tables.sql
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Tables population
\end_layout

\begin_layout Plain Layout

infoh415$ 
\backslash
i insertion.sql
\end_layout

\begin_layout Plain Layout

infoh415$ 
\backslash
i create_index.sql
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Importing and exporting
\end_layout

\begin_layout Plain Layout

infoh415$ quit
\end_layout

\begin_layout Plain Layout

$ cd shapefiles/ 
\end_layout

\begin_layout Plain Layout

$ pgsql2shp infoh415 regions 
\end_layout

\begin_layout Plain Layout

$ pgsql2shp infoh415 cities
\end_layout

\begin_layout Plain Layout

$ shp2pgsql -W "latin1" bel_city.shp >  ../shp_insert.sql
\end_layout

\begin_layout Plain Layout

$ shp2pgsql -W "latin1" bel_dist.shp >> ../shp_insert.sql
\end_layout

\begin_layout Plain Layout

$ shp2pgsql -W "latin1" bel_prov.shp >> ../shp_insert.sql
\end_layout

\begin_layout Plain Layout

$ shp2pgsql -W "latin1" bel_regn.shp >> ../shp_insert.sql
\end_layout

\begin_layout Plain Layout

$ shp2pgsql -W "latin1" belriver.shp >> ../shp_insert.sql
\end_layout

\begin_layout Plain Layout

$ cd ..
\end_layout

\begin_layout Plain Layout

$ psql infoh415
\end_layout

\begin_layout Plain Layout

infoh415$ 
\backslash
i shp_insert.sql
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Specify the SRID to use WGS84
\end_layout

\begin_layout Plain Layout

infoh415$ 
\backslash
i update_srid.sql 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Write down and execute the following queries:
\end_layout

\begin_layout Enumerate
Get the SRID from table cities.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

select st_srid(geom) as SRID 
\end_layout

\begin_layout Plain Layout

from bel_city 
\end_layout

\begin_layout Plain Layout

limit 5;
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Get a textual description for this SRID.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

select srtext 
\end_layout

\begin_layout Plain Layout

from spatial_ref_sys 
\end_layout

\begin_layout Plain Layout

where srid=4326;
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Get the dimension of geographical objects in that table.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

select distinct st_dimension(geom) as dim, st_coorddim(geom) as coorddim
 
\end_layout

\begin_layout Plain Layout

from bel_city;
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Get the geometry type of these objects.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

select distinct st_geometrytype(geom) as type 
\end_layout

\begin_layout Plain Layout

from bel_city;
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Compute the distance between the cities of IXELLES and BRUGGE.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

select st_distance(
\end_layout

\begin_layout Plain Layout

	st_transform((select geom from bel_city where name = 'Ixelles'),3812),
 
\end_layout

\begin_layout Plain Layout

	st_transform((select geom from bel_city where name = 'Brugge'),3812)) as
 dist, 
\end_layout

\begin_layout Plain Layout

st_distancesphere(
\end_layout

\begin_layout Plain Layout

	(select geom from bel_city where name = 'Ixelles'), 
\end_layout

\begin_layout Plain Layout

	(select geom from bel_city where name = 'Brugge')) as dist_sphere
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The number 3812 in the transform function refers to Belgian Lambert 2008,
 which is a conic representation adapted for Belgium.
 If we don't apply this transformation, we get a distance measured in degrees,
 which has little meaning for us.
\end_layout

\end_deeper
\begin_layout Enumerate
Compute the bounding rectangle for the BRABANT province.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

create table boundbox as 
\end_layout

\begin_layout Plain Layout

	select st_envelope(geom) 
\end_layout

\begin_layout Plain Layout

	from bel_prov 
\end_layout

\begin_layout Plain Layout

	where name = 'Brabant';
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We create the table to be able to visualize the result in QGis:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado7.png
	scale 60

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Compute the geographical union of the bel_regn and bel_prov tables.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

create table geom_union as 
\end_layout

\begin_layout Plain Layout

	select st_union(geom) 
\end_layout

\begin_layout Plain Layout

	from (select geom from bel_regn 
\end_layout

\begin_layout Plain Layout

		  union 
\end_layout

\begin_layout Plain Layout

		  select geom from bel_prov) 
\end_layout

\begin_layout Plain Layout

		  as tmp;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado8.png
	scale 60

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Compute the length of each river.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

select st_length2dspheroid(geom, 'SPHEROID["GRS_1980",6378137,298.257222101]')
 
\end_layout

\begin_layout Plain Layout

from belriver;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The second argument is the spheroid that the function should use to compute
 the lengths, as its definition is 
\begin_inset Formula $ST\_Length2DSpheroid(geometry\ geom,spheroid\ sp)$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
Create a table containing all cities that stand less than 1000m from a river.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

select name, dist 
\end_layout

\begin_layout Plain Layout

from 
\end_layout

\begin_layout Plain Layout

	(select c.name as name, min(st_distancesphere(c.geom, r.geom)) as dist 
\end_layout

\begin_layout Plain Layout

	 from bel_city c, belriver r 
\end_layout

\begin_layout Plain Layout

	 group by c.name) as tmp 
\end_layout

\begin_layout Plain Layout

where dist < 1000; 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- or
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

select c.name as name, min(st_distancesphere(c.geom, r.geom)) as dist 
\end_layout

\begin_layout Plain Layout

from bel_city c 
\end_layout

\begin_layout Plain Layout

	 join belriver r on st_distancesphere(c.geom, r.geom) < 1000 
\end_layout

\begin_layout Plain Layout

group by c.name; 
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
For each river, compute the length of its path inside each province it traverses.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

select r.name as river, p.name as province, 
\end_layout

\begin_layout Plain Layout

	st_length2dspheroid(st_intersection(r.geom, p.geom),
\end_layout

\begin_layout Plain Layout

					'SPHEROID["GRS_1980",6378137,298.257222101]') as inside_len 
\end_layout

\begin_layout Plain Layout

from belriver r 
\end_layout

\begin_layout Plain Layout

join bel_prov p on st_intersects(r.geom, p.geom); 
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Section
Lab 11
\end_layout

\begin_layout Standard
Download 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://biogeo.ucdavis.edu/data/climate/worldclim/1_4/grid/cur/alt_10m_bil.zip
\end_layout

\end_inset

 and extract it to 
\series bold
tp11
\series default
.
\end_layout

\begin_layout Standard
In the directory 
\series bold
tp11
\series default
 perform:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

createdb tp11                                 
\end_layout

\begin_layout Plain Layout

psql tp11 -c "CREATE EXTENSION postgis;" 
\end_layout

\begin_layout Plain Layout

psql tp11 -c "CREATE EXTENSION postgis_raster;"        
\end_layout

\begin_layout Plain Layout

psql tp11 -f generate.sql    
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

cd bel_alt/
\end_layout

\begin_layout Plain Layout

raster2pgsql BEL_alt.vrt > insert_bel_alt.sql 
\end_layout

\begin_layout Plain Layout

psql tp11 -f insert_bel_alt.sql
\end_layout

\begin_layout Plain Layout

cd ../alt_10m_bil/
\end_layout

\begin_layout Plain Layout

raster2pgsql alt.bil > insert_alt.sql    
\end_layout

\begin_layout Plain Layout

psql tp11 -f insert_alt.sql               
\end_layout

\begin_layout Plain Layout

cd ..
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# 3.2 Update rasters
\end_layout

\begin_layout Plain Layout

psql tp11
\end_layout

\begin_layout Plain Layout

SELECT UpdateRasterSRID('alt', 'rast', 4326);
\end_layout

\begin_layout Plain Layout

SELECT UpdateRasterSRID('bel_alt', 'rast', 4326);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Write down and execute the following queries:
\end_layout

\begin_layout Enumerate
Compute the difference between the two altitude datasets.
 Try to perform this exercice first without using ST_Resample.
 Export the result and visualize it in QGIS:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

gdal_translate -of GTiff PG:"dbname=tp11 schema=public table=sol1" sol1.tiff
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

create table sol1 as 
\end_layout

\begin_layout Plain Layout

SELECT ST_MapAlgebra( a.rast, 1, b.rast, 1, '[rast2] - [rast1]') AS rast 
\end_layout

\begin_layout Plain Layout

FROM 
\end_layout

\begin_layout Plain Layout

    (select b.RID, ST_Resample(b.rast, a.rast) as rast
\end_layout

\begin_layout Plain Layout

     from bel_alt b,  alt a) 
\end_layout

\begin_layout Plain Layout

as b, alt a;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Once we have the table, we execute the command to export the raster and
 then we import it to QGIS.
 The result is (not very awesome):
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename pegado10.png
	scale 35

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Compute the maximum altitude in Belgium.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

SELECT (ST_SummaryStats(rast)).max as max
\end_layout

\begin_layout Plain Layout

FROM bel_alt;
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Get the altitudes of all cities in Belgium.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

SELECT name, ST_Value(rast, geom) 
\end_layout

\begin_layout Plain Layout

FROM bel_alt 
\end_layout

\begin_layout Plain Layout

JOIN bel_city ON ST_Intersects(geom, rast);
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Compute the maximum and minimum altitudes for each province.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

SELECT name, (stats).max, (stats).min 
\end_layout

\begin_layout Plain Layout

FROM (
\end_layout

\begin_layout Plain Layout

	SELECT name, ST_SummaryStats(ST_Clip(rast, 1, geom, TRUE)) AS stats   
    
\end_layout

\begin_layout Plain Layout

	FROM alt 
\end_layout

\begin_layout Plain Layout

	JOIN bel_prov ON ST_Intersects(geom,rast)) 
\end_layout

\begin_layout Plain Layout

	AS foo;
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Create a new raster table restraining the alt_16 raster to Belgium.
 (Hint: use ST_Intersection.)
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

CREATE TABLE alt_16_belgium AS
\end_layout

\begin_layout Plain Layout

SELECT rid, ST_Clip(rast, 1, geom, TRUE) AS rast
\end_layout

\begin_layout Plain Layout

FROM (SELECT ST_UNION(ARRAY(SELECT geom FROM bel_regn)) AS geom) AS belgium
\end_layout

\begin_layout Plain Layout

JOIN alt ON ST_Intersects(geom, rast);
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Compute the altitude along each river.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

SELECT name, ST_AsText((position).geom), ST_Value(rast, (position).geom)
\end_layout

\begin_layout Plain Layout

FROM (SELECT name, rast, ST_DumpPoints(ST_Segmentize(geom, 0.1)) AS position
\end_layout

\begin_layout Plain Layout

      FROM belriver 
\end_layout

\begin_layout Plain Layout

	  JOIN bel_alt on ST_Intersects(geom, rast)) 
\end_layout

\begin_layout Plain Layout

	  AS dp;
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Section*
Spatial functions reference
\end_layout

\begin_layout Itemize

\series bold
ST_CLIP
\series default
: Returns a raster that is clipped by the input geometry geom.
 If band index is not specified, all bands are processed.
\end_layout

\begin_deeper
\begin_layout Standard
Rasters resulting from ST_Clip must have a nodata value assigned for areas
 clipped, one for each band.
 If none are provided and the input raster do not have a nodata value defined,
 nodata values of the resulting raster are set to ST_MinPossibleValue(ST_BandPix
elType(rast, band)).
 When the number of nodata value in the array is smaller than the number
 of band, the last one in the array is used for the remaining bands.
 If the number of nodata value is greater than the number of band, the extra
 nodata values are ignored.
 All variants accepting an array of nodata values also accept a single value
 which will be assigned to each band.
\end_layout

\begin_layout Standard
If crop is not specified, true is assumed meaning the output raster is cropped
 to the intersection of the geomand rast extents.
 If crop is set to false, the new raster gets the same extent as rast.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

-- Clip the first band of an aerial tile by a 20 meter buffer.
\end_layout

\begin_layout Plain Layout

SELECT ST_Clip(rast, 1,
\end_layout

\begin_layout Plain Layout

        ST_Buffer(ST_Centroid(ST_Envelope(rast)),20)
\end_layout

\begin_layout Plain Layout

    ) from aerials.boston
\end_layout

\begin_layout Plain Layout

WHERE rid = 4;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- Demonstrate effect of crop on final dimensions of raster
\end_layout

\begin_layout Plain Layout

-- Note how final extent is clipped to that of the geometry
\end_layout

\begin_layout Plain Layout

-- if crop = true
\end_layout

\begin_layout Plain Layout

SELECT ST_XMax(ST_Envelope(ST_Clip(rast, 1, clipper, true))) As xmax_w_trim,
\end_layout

\begin_layout Plain Layout

    ST_XMax(clipper) As xmax_clipper,
\end_layout

\begin_layout Plain Layout

    ST_XMax(ST_Envelope(ST_Clip(rast, 1, clipper, false))) As xmax_wo_trim,
\end_layout

\begin_layout Plain Layout

    ST_XMax(ST_Envelope(rast)) As xmax_rast_orig
\end_layout

\begin_layout Plain Layout

FROM (SELECT rast, ST_Buffer(ST_Centroid(ST_Envelope(rast)),6) As clipper
\end_layout

\begin_layout Plain Layout

    FROM aerials.boston
\end_layout

\begin_layout Plain Layout

WHERE rid = 6) As foo;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   xmax_w_trim    |   xmax_clipper   |   xmax_wo_trim   |  xmax_rast_orig
\end_layout

\begin_layout Plain Layout

------------------+------------------+------------------+------------------
\end_layout

\begin_layout Plain Layout

 230657.436173996 | 230657.436173996 | 230666.436173996 | 230666.436173996
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename pegado9.png
	scale 60

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
ST_DUMPPOINTS
\series default
: A set-returning function (SRF) that extracts the coordinates (vertices)
 of a geometry.
 It returns a set of geometry_dump rows, each containing a geometry (geom
 field) and an array of integers (path field).
\end_layout

\begin_deeper
\begin_layout Itemize
the geom field POINTs represent the coordinates of the supplied geometry.
\end_layout

\begin_layout Itemize
the path field (an integer[]) is an index enumerating the coordinate positions
 in the elements of the supplied geometry.
 The indices are 1-based.
 For example, for a LINESTRING the paths are {i} where i is the nth coordinate
 in the LINESTRING.
 For a POLYGON the paths are {i,j} where i is the ring number (1 is outer;
 inner rings follow) and j is the coordinate position in the ring.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT edge_id, (dp).path[1] As index, ST_AsText((dp).geom) As wktnode
\end_layout

\begin_layout Plain Layout

FROM (SELECT 1 As edge_id
\end_layout

\begin_layout Plain Layout

	, ST_DumpPoints(ST_GeomFromText('LINESTRING(1 2, 3 4, 10 10)')) AS dp
\end_layout

\begin_layout Plain Layout

     UNION ALL
\end_layout

\begin_layout Plain Layout

     SELECT 2 As edge_id
\end_layout

\begin_layout Plain Layout

	, ST_DumpPoints(ST_GeomFromText('LINESTRING(3 5, 5 6, 9 10)')) AS dp
\end_layout

\begin_layout Plain Layout

   ) As foo;
\end_layout

\begin_layout Plain Layout

 edge_id | index |    wktnode
\end_layout

\begin_layout Plain Layout

---------+-------+--------------
\end_layout

\begin_layout Plain Layout

       1 |     1 | POINT(1 2)
\end_layout

\begin_layout Plain Layout

       1 |     2 | POINT(3 4)
\end_layout

\begin_layout Plain Layout

       1 |     3 | POINT(10 10)
\end_layout

\begin_layout Plain Layout

       2 |     1 | POINT(3 5)
\end_layout

\begin_layout Plain Layout

       2 |     2 | POINT(5 6)
\end_layout

\begin_layout Plain Layout

       2 |     3 | POINT(9 10)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
ST_INTERSECTS
\series default
: Compares two geometries and returns true if they intersect.
 Geometries intersect if they have any point in common.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT ST_Intersects('POINT(0 0)'::geometry, 'LINESTRING ( 2 0, 0 2 )'::geometry
);
\end_layout

\begin_layout Plain Layout

 st_intersects
\end_layout

\begin_layout Plain Layout

---------------
\end_layout

\begin_layout Plain Layout

 f
\end_layout

\begin_layout Plain Layout

(1 row)
\end_layout

\begin_layout Plain Layout

SELECT ST_Intersects('POINT(0 0)'::geometry, 'LINESTRING ( 0 0, 0 2 )'::geometry
);
\end_layout

\begin_layout Plain Layout

 st_intersects
\end_layout

\begin_layout Plain Layout

---------------
\end_layout

\begin_layout Plain Layout

 t
\end_layout

\begin_layout Plain Layout

(1 row)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- Look up in table.
 Make sure table has a GiST index on geometry column for faster lookup.
\end_layout

\begin_layout Plain Layout

SELECT id, name FROM cities WHERE ST_Intersects(geom, 'SRID=4326;POLYGON((28
 53,27.707 52.293,27 52,26.293 52.293,26 53,26.293 53.707,27 54,27.707 53.707,28
 53))');
\end_layout

\begin_layout Plain Layout

 id | name
\end_layout

\begin_layout Plain Layout

----+-------
\end_layout

\begin_layout Plain Layout

  2 | Minsk
\end_layout

\begin_layout Plain Layout

(1 row)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
ST_MAPALGEBRA
\series default
: Returns a one-band raster given one or two input rasters, band indexes
 and one or more user-specified SQL expressions.
\end_layout

\begin_deeper
\begin_layout Itemize
With one ruster: Creates a new one band raster formed by applying a valid
 PostgreSQL algebraic operation defined by the expression on the input raster
 (rast).
 If nband is not provided, band 1 is assumed.
 The new raster will have the same georeference, width, and height as the
 original raster but will only have one band.
\end_layout

\begin_layout Itemize
With two rusters: Creates a new one band raster formed by applying a valid
 PostgreSQL algebraic operation to the two bands defined by the expression
 on the two input raster bands (rast1, rast2).
 If no band1, band2 is specified band 1 is assumed.
 The resulting raster will be aligned (scale, skew and pixel corners) on
 the grid defined by the first raster.
 The resulting raster will have the extent defined by the extenttype parameter.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

WITH foo AS (
\end_layout

\begin_layout Plain Layout

    SELECT 1 AS rid, ST_AddBand(ST_AddBand(ST_AddBand(ST_MakeEmptyRaster(2,
 2, 0, 0, 1, -1, 0, 0, 0), 1, '16BUI', 1, 0), 2, '8BUI', 10, 0), 3, '32BUI'::tex
t, 100, 0) AS rast UNION ALL
\end_layout

\begin_layout Plain Layout

    SELECT 2 AS rid, ST_AddBand(ST_AddBand(ST_AddBand(ST_MakeEmptyRaster(2,
 2, 0, 1, 1, -1, 0, 0, 0), 1, '16BUI', 2, 0), 2, '8BUI', 20, 0), 3, '32BUI'::tex
t, 300, 0) AS rast
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

SELECT
\end_layout

\begin_layout Plain Layout

    ST_MapAlgebra(
\end_layout

\begin_layout Plain Layout

        t1.rast, 2,
\end_layout

\begin_layout Plain Layout

        t2.rast, 1,
\end_layout

\begin_layout Plain Layout

        '([rast2] + [rast1.val]) / 2'
\end_layout

\begin_layout Plain Layout

    ) AS rast
\end_layout

\begin_layout Plain Layout

FROM foo t1
\end_layout

\begin_layout Plain Layout

CROSS JOIN foo t2
\end_layout

\begin_layout Plain Layout

WHERE t1.rid = 1
\end_layout

\begin_layout Plain Layout

    AND t2.rid = 2;
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
ST_RESAMPLE
\series default
: Resample a raster using a specified resampling algorithm, new dimensions
 (width & height), a grid corner (gridx & gridy) and a set of raster georeferenc
ing attributes (scalex, scaley, skewx & skewy) defined or borrowed from
 another raster.
 If using a reference raster, the two rasters must have the same SRID.
 New pixel values are computed using the NearestNeighbor (English or American
 spelling), Bilinear, Cubic, CubicSpline or Lanczos resampling algorithm.
 Default is NearestNeighbor which is the fastest but produce the worst interpola
tion.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT
\end_layout

\begin_layout Plain Layout

    ST_Width(orig) AS orig_width,
\end_layout

\begin_layout Plain Layout

    ST_Width(reduce_100) AS new_width
\end_layout

\begin_layout Plain Layout

FROM (
\end_layout

\begin_layout Plain Layout

    SELECT
\end_layout

\begin_layout Plain Layout

        rast AS orig,
\end_layout

\begin_layout Plain Layout

        ST_Resample(rast,100,100) AS reduce_100
\end_layout

\begin_layout Plain Layout

    FROM aerials.boston
\end_layout

\begin_layout Plain Layout

    WHERE ST_Intersects(rast,
\end_layout

\begin_layout Plain Layout

        ST_Transform(
\end_layout

\begin_layout Plain Layout

            ST_MakeEnvelope(-71.128, 42.2392,-71.1277, 42.2397, 4326),26986)
\end_layout

\begin_layout Plain Layout

    )
\end_layout

\begin_layout Plain Layout

    LIMIT 1
\end_layout

\begin_layout Plain Layout

) AS foo;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 orig_width | new_width
\end_layout

\begin_layout Plain Layout

------------+-------------
\end_layout

\begin_layout Plain Layout

        200 |         100
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
ST_SEGMENTIZE
\series default
: Returns a modified geometry having no segment longer than the given max_segmen
t_length.
 Distance computation is performed in 2d only.
 For geometry, length units are in units of spatial reference.
 For geography, units are in meters.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT ST_AsText(ST_Segmentize(
\end_layout

\begin_layout Plain Layout

ST_GeomFromText('MULTILINESTRING((-29 -27,-30 -29.7,-36 -31,-45 -33),(-45
 -33,-46 -32))')
\end_layout

\begin_layout Plain Layout

		,5)
\end_layout

\begin_layout Plain Layout

);
\end_layout

\begin_layout Plain Layout

st_astext
\end_layout

\begin_layout Plain Layout

--------------------------------------------------------------------------------
------------------
\end_layout

\begin_layout Plain Layout

MULTILINESTRING((-29 -27,-30 -29.7,-34.886615700134 -30.758766735029,-36 -31,
\end_layout

\begin_layout Plain Layout

-40.8809353009198 -32.0846522890933,-45 -33),
\end_layout

\begin_layout Plain Layout

(-45 -33,-46 -32))
\end_layout

\begin_layout Plain Layout

(1 row)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

SELECT ST_AsText(ST_Segmentize(ST_GeomFromText('POLYGON((-29 28, -30 40,
 -29 28))'),10));
\end_layout

\begin_layout Plain Layout

st_astext
\end_layout

\begin_layout Plain Layout

-----------------------
\end_layout

\begin_layout Plain Layout

POLYGON((-29 28,-29.8304547985374 37.9654575824488,-30 40,-29.1695452014626
 30.0345424175512,-29 28))
\end_layout

\begin_layout Plain Layout

(1 row)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
ST_SUMMARYSTATS
\series default
: Returns summarystats consisting of count, sum, mean, stddev, min, max
 for a given raster band of a raster or raster coverage.
 If no band is specified nband defaults to 1.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT rid, band, (stats).*
\end_layout

\begin_layout Plain Layout

FROM (SELECT rid, band, ST_SummaryStats(rast, band) As stats
\end_layout

\begin_layout Plain Layout

    FROM dummy_rast CROSS JOIN generate_series(1,3) As band
\end_layout

\begin_layout Plain Layout

     WHERE rid=2) As foo;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 rid | band | count | sum  |    mean    |  stddev   | min | max
\end_layout

\begin_layout Plain Layout

-----+------+-------+------+------------+-----------+-----+-----
\end_layout

\begin_layout Plain Layout

   2 |    1 |    23 | 5821 | 253.086957 |  1.248061 | 250 | 254
\end_layout

\begin_layout Plain Layout

   2 |    2 |    25 | 3682 |     147.28 | 59.862188 |  78 | 254
\end_layout

\begin_layout Plain Layout

   2 |    3 |    25 | 3290 |      131.6 | 61.647384 |  62 | 254
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
ST_UNION
\series default
: Unions the input geometries, merging geometry to produce a result geometry
 with no overlaps.
 The output may be an atomic geometry, a MultiGeometry, or a Geometry Collection.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT id,
\end_layout

\begin_layout Plain Layout

       ST_Union(geom) as singlegeom
\end_layout

\begin_layout Plain Layout

FROM sometable f
\end_layout

\begin_layout Plain Layout

GROUP BY id;
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
ST_VALUE
\series default
: Returns the value of a given band in a given columnx, rowy pixel or at
 a given geometry point.
 Band numbers start at 1 and band is assumed to be 1 if not specified.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

-- get raster values at particular postgis geometry points
\end_layout

\begin_layout Plain Layout

-- the srid of your geometry should be same as for your raster
\end_layout

\begin_layout Plain Layout

SELECT rid, ST_Value(rast, foo.pt_geom) As b1pval, ST_Value(rast, 2, foo.pt_geom)
 As b2pval
\end_layout

\begin_layout Plain Layout

FROM dummy_rast CROSS JOIN (SELECT ST_SetSRID(ST_Point(3427927.77, 5793243.76),
 0) As pt_geom) As foo
\end_layout

\begin_layout Plain Layout

WHERE rid=2;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 rid | b1pval | b2pval
\end_layout

\begin_layout Plain Layout

-----+--------+--------
\end_layout

\begin_layout Plain Layout

   2 |    252 |     79
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- general fictitious example using a real table
\end_layout

\begin_layout Plain Layout

SELECT rid, ST_Value(rast, 3, sometable.geom) As b3pval
\end_layout

\begin_layout Plain Layout

FROM sometable
\end_layout

\begin_layout Plain Layout

WHERE ST_Intersects(rast,sometable.geom);
\end_layout

\end_inset


\end_layout

\end_deeper
\end_body
\end_document
