#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage{footmisc}
\usepackage{listings}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{1,0.99,0.94}

\lstdefinestyle{mystyle}{
	language=SQL,
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,  
    frame=single,
    tabsize=2
}

\lstset{style=mystyle}
\end_preamble
\use_default_options true
\begin_modules
tcolorbox
customHeadersFooters
theorems-ams-bytype
theorems-sec-bytype
algorithm2e
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=blue, urlcolor=blue, citecolor=blue, pdfstartview={FitH}, unicode=true"
\papersize a4paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\boxbgcolor #62a0ea
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 3cm
\rightmargin 2cm
\bottommargin 3cm
\headheight 2cm
\headsep 1cm
\footskip 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
INFOH415 - Advanced Databases
\end_layout

\begin_layout Date
Fall 2022
\end_layout

\begin_layout Author
Jose Antonio Lorencio Abril
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 1200px-Université_libre_de_Bruxelles_(logo).svg.png
	scale 10

\end_inset


\end_layout

\begin_layout Standard
\align right
Professor: Esteban Zimanyi
\end_layout

\begin_layout Standard
\align right
Student e-mail: jose.lorencio.abril@ulb.be
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Address
This is a summary of the course 
\emph on
Advanced Databases
\emph default
 taught at the Université Libre de Bruxelles by Professor Esteban Zimanyi
 in the academic year 22/23.
 Most of the content of this document is adapted from the course notes by
 Zimanyi, 
\begin_inset CommandInset citation
LatexCommand cite
key "Zimanyi2022"
literal "false"

\end_inset

, so I won't be citing it all the time.
 Other references will be provided when used.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList table

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList algorithm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Active Databases
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Traditionally, DBMS are 
\series bold
passive
\series default
, meaning that all actions on data result from explicit invocation in applicatio
n programs.
 In contrast, 
\series bold
active DMBS
\series default
 can perform actions automatically, in response to monitored events, such
 as updates in the database, certain points in time or defined events which
 are external to the database.
\end_layout

\begin_layout Standard

\series bold
Integrity constraints
\series default
 are a well-known mechanism that has been used since the early stages of
 SQL to enhance integrity by imposing constraints to the data.
 These constraints will only allow modifications to the database that do
 not violate them.
 Also, it is common for DBMS to provide mechanisms to store procedures,
 in the form of precompiled packets that can be invoked by the user.
 These are usually caled 
\series bold
stored procedure
\series default
.
\end_layout

\begin_layout Standard
The active database technology make an abstraction of these two features:
 the 
\series bold
triggers
\series default
.
 
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
A 
\series bold
trigger
\series default
 or, more generally, an 
\series bold
ECA rule
\series default
, consists of an event, a condition and a set of actions:
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
Event
\series default
: indicates when the trigger must be called.
\end_layout

\begin_layout Itemize

\series bold
Condition
\series default
: indicates the checks that must be done after the trigger is called.
 If the condition is fulfilled, then the set of actions is executed.
 Otherwise, the trigger does not perform any action.
\end_layout

\begin_layout Itemize

\series bold
Actions
\series default
: performed when the condition is fullfilled.
\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Example
A conceptual trigger could be like the following:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Event
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A customer has not paid 3 invoices at the due date.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Condition
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
If the credit limit of the customer is less than 20000€.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Action
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cancel all curernt orders of the customer.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
There are several aspects of the semantics of an applications that can be
 expressed through triggers:
\end_layout

\begin_layout Itemize
Static constraints: refer to referential integrity, cardinality of relations
 or value restrictions.
\end_layout

\begin_layout Itemize
Control, business rules and workflow management rules: refer to restrictions
 imposed by the business requirements.
\end_layout

\begin_layout Itemize
Historical data rules: define how historial data has to be treated.
\end_layout

\begin_layout Itemize
Implementation of generic relationships: with triggers we can define arbitrarily
 complex relationships.
\end_layout

\begin_layout Itemize
Derived data rules: refer to the treatment of materialized attributes, materiali
zed views and replicated data.
\end_layout

\begin_layout Itemize
Access control rules: define which users can access which content and with
 which permissions.
\end_layout

\begin_layout Itemize
Monitoring rules: assess performance and resource usage.
\end_layout

\begin_layout Standard
The benefits of active technology are:
\end_layout

\begin_layout Itemize
Simplification of application programs by embedding part of the functionality
 into the database using triggers.
\end_layout

\begin_layout Itemize
Increased automation by the automatic execution of triggered actions.
\end_layout

\begin_layout Itemize
Higher reliability of data because the checks can be more elaborate and
 the actions to take in each case are precisely defined.
\end_layout

\begin_layout Itemize
Increased flexibility with the possibility of increasing code reuse and
 centralization of the data management.
\end_layout

\begin_layout Section
Representative Systems and Prototypes
\end_layout

\begin_layout Standard
Even though this basic model is simple and intuitive, each vendor proposes
 its own way to implement triggers, which were not in the SQL-92 standard.
 We are going to study Starbust triggers, Oracle triggers and DB2 triggers.
\end_layout

\begin_layout Subsection
Starbust
\end_layout

\begin_layout Standard
Starbust is a Relational DBMS prototype developed by IBM.
 In Starbust, the 
\series bold
triggers
\series default
 are defined with the following definition of their components:
\end_layout

\begin_layout Itemize

\series bold
Event
\series default
: events can refer to data-manipulation operations in SQL, i.e.
 INSERT, DELETE or UPDATE.
\end_layout

\begin_layout Itemize

\series bold
Conditions
\series default
: are boolean predicates in SQL on the current state of the database after
 the event has occurred.
\end_layout

\begin_layout Itemize

\series bold
Actions
\series default
: are SQL statements, rule-manipulation statements or the ROLLBACK operation.
\end_layout

\begin_layout Example

\emph on
'The salary of employees is not larger than the salary of the manager of
 their department.'
\end_layout

\begin_layout Example
The easiest way to maintain this rule is to rollback any action that violates
 it.
 This restriction can be broken (if we focus on modifications on the employees
 only) when a new employee is inserted, when the department of an employee
 is modified or when the salary of an employee is updated.
 Thus, a trigger that solves this could have these actions as events, then
 it can check whether the condition is fullfilled or not.
 If it is not, then the action can be rollback to the previous state, in
 which the condition was fullfilled.
\end_layout

\begin_layout Example
\begin_inset listings
lstparams "language=SQL,morekeywords={CREATE, RULE, ON, WHEN, IF, EXISTS, SELECT, FROM, WHERE, AND, THEN, ROLLBACK}"
inline false
status open

\begin_layout Plain Layout

CREATE RULE Mgrsals ON Emp
\end_layout

\begin_layout Plain Layout

WHEN INSERTED, UPDATED(Dept), UPDATED(Salary)
\end_layout

\begin_layout Plain Layout

IF EXISTS (
\end_layout

\begin_layout Plain Layout

	SELECT *
\end_layout

\begin_layout Plain Layout

	FROM Emp E, Dept D, EMP M
\end_layout

\begin_layout Plain Layout

	WHERE E.Dept = D.Dept --Check the correct department
\end_layout

\begin_layout Plain Layout

		  AND E.Sal > M.Sal --Check the salary condition
\end_layout

\begin_layout Plain Layout

		  AND D.Mgr = M.Name --Check the manager is the correct one
\end_layout

\begin_layout Plain Layout

	)
\end_layout

\begin_layout Plain Layout

THEN ROLLBACK;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The syntax of Starbust's rule definition is as described in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Starbust's-rule-definition"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 As we can see, rules have an unique name and each rule is associated with
 a single relation.
 The events are defined to be only database updates, but one rule can have
 several events defined on the target relation.
 
\end_layout

\begin_layout Standard
The same event can be used in several triggers, so one event can trigger
 different actions to be executed.
 For this not to produce an unwanted outcome, it is possible to establish
 the order in which different triggers must be executed, by using the PRECEDES
 and FOLLOWS declarations.
 The order defined by this operators is partial (not all triggers are comparable
) and must be acyclic to avoid deadlocks.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=SQL,morekeywords={CREATE, RULE, ON, WHEN, IF, EXISTS, SELECT, FROM, WHERE, AND, THEN, ROLLBACK}"
inline false
status open

\begin_layout Plain Layout

CREATE RULE <rule-name> ON <relation-name>
\end_layout

\begin_layout Plain Layout

WHEN <list of trigger-events>
\end_layout

\begin_layout Plain Layout

[IF <condition>]
\end_layout

\begin_layout Plain Layout

THEN <list of SQL-statements>
\end_layout

\begin_layout Plain Layout

[PRECEDES <list of rule-names>]
\end_layout

\begin_layout Plain Layout

[FOLLOWS <list of rule-names>];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

where
\end_layout

\begin_layout Plain Layout

	<trigger-event> := INSERTED | DELETED | UPDATED [<attributes>]
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Starbust's rule definition syntax.
\begin_inset CommandInset label
LatexCommand label
name "tab:Starbust's-rule-definition"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Example

\emph on
'If the average salary of employees gets over 100, reduce the salary of
 all employees by 10%.'
\end_layout

\begin_layout Example
In this case, the condition can be violated when a new employee is inserted,
 when an employee is deleted or when the salary is updated.
 Now, the action is not to rollback the operation, but to reduce the salary
 of every employee by 10%.
\end_layout

\begin_layout Example
First, let's exemplify the cases in which the condition is violated.
 Imagine the following initial state of the table Emp:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sal
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
John
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
50
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mike
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sarah
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
120
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Example
The average salary is 90, so the condition is fullfilled.
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
INSERT INTO Emp VALUES('James', 200)
\end_layout

\begin_deeper
\begin_layout Standard
The average salary would be 117,5 and the condition is not fullfilled.
\end_layout

\end_deeper
\begin_layout Itemize

\family typewriter
DELETE FROM Emp WHERE Name='John'
\end_layout

\begin_deeper
\begin_layout Standard
The average salary would be 110 and the condition is not fullfilled.
\end_layout

\end_deeper
\begin_layout Itemize

\family typewriter
UPDATE Emp SET Sal=110 WHERE Name='John'
\end_layout

\begin_deeper
\begin_layout Standard
The average salary would be 110 and the condition is not fullfilled.
\end_layout

\end_deeper
\end_deeper
\begin_layout Example
The trigger could be defined as:
\end_layout

\begin_layout Example
\begin_inset listings
lstparams "language=SQL,morekeywords={CREATE, RULE, ON, WHEN, IF, EXISTS, SELECT, FROM, WHERE, AND, THEN, ROLLBACK}"
inline false
status open

\begin_layout Plain Layout

CREATE RULE SalaryControl ON Emp
\end_layout

\begin_layout Plain Layout

WHEN INSERTED, DELETED, UPDATED(Sal)
\end_layout

\begin_layout Plain Layout

IF 
\end_layout

\begin_layout Plain Layout

	(SELECT AVG(Sal) FROM Emp) > 100
\end_layout

\begin_layout Plain Layout

THEN 
\end_layout

\begin_layout Plain Layout

	UPDATE Emp
\end_layout

\begin_layout Plain Layout

	SET Sal = 0.9*Sal;
\end_layout

\end_inset


\end_layout

\begin_layout Example
Note, nonetheless, that for the first example, we would get the following
 result:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sal
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
John
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
45
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mike
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
90
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sarah
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
108
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
James
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
180
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Example
Here, the mean is 105.75, still bigger than 100.
 We will see how to solve this issue later.
\end_layout

\begin_layout Subsubsection
Starbust Semantics
\end_layout

\begin_layout Standard
At this point, it is interesting to bring some definitions up to scene:
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
A 
\series bold
transaction
\series default
 is a sequence of statements that is to be treated as an atomic unit of
 work for some aspect of the processing, i.e., a transaction either executes
 from beginning to end, or it does not execute at all.
\end_layout

\begin_layout Plain Layout
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
A 
\series bold
statement
\series default
 is a part of a transaction, which expresses an operation on the database.
\end_layout

\begin_layout Plain Layout
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
En 
\series bold
event
\series default
 (in a more precise way than before) is the occurrence of executing a statement,
 i.e., a request for executing an operation on the database.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Thus, rules are triggered by the execution of operations in statements.
 In Starbust, rules are 
\series bold
statement-level
\series default
, meaning they are executed once per statement, even for statements that
 trigger events on several tuples.
 In addition, the execution mode is 
\series bold
deffered
\series default
.
 This means that all rules triggered during a transaction are placed in
 what is called the 
\series bold
conflict set
\series default
 (i.e.
 the set of triggered rules).
 When the transaction finishes, all rules are executed in triggering order
 or in the defined order, if there is one.
 Nonetheless, if the need for a rule executing during a transaction exists,
 we can use the PROCESS RULES declaration, which executes all rules in the
 conflict set.
 
\end_layout

\begin_layout Standard
The algorithm for executing all rules after the transaction finished or
 PROCESS RULES is called is described in Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Rule-Processing"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 As we can see, rule processing basically involves 3 stages:
\end_layout

\begin_layout Enumerate

\series bold
Activation
\series default
: the event in the rule requests the execution of an operation and this
 is detected by the system.
\end_layout

\begin_layout Enumerate

\series bold
Consideration
\series default
: the condition of the rule is evaluated.
\end_layout

\begin_layout Enumerate

\series bold
Execution
\series default
: if the condition is fullfilled, the action in the rule is executed.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=SQL,morekeywords={while, is, not, select, in, if, execute, delete, from}"
inline false
status open

\begin_layout Plain Layout

while CS is not empty
\end_layout

\begin_layout Plain Layout

	select R in CS with highest priority
\end_layout

\begin_layout Plain Layout

	delete R from CS
\end_layout

\begin_layout Plain Layout

	if R.condition is TRUE
\end_layout

\begin_layout Plain Layout

		execute R.action
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
processRules(conflict set CS)
\begin_inset CommandInset label
LatexCommand label
name "alg:Rule-Processing"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Correctness of rules
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
The 
\series bold
repeatability of the execution
\series default
 is the property that ensures that the system behaves in the same way when
 it receives the same input transaction in the same database state, i.e.,
 the results are deterministic.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As we have seen before, rule definitions specify a partial order for execution,
 but several rules may have highest priority at the moment of selection.
 To achieve repeatability, the system maintains a total order, based on
 the user-defined partial order and the timestamps of the creation of the
 rules.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
The 
\series bold
termination of rule execution
\series default
 is reached when an empty conflict set is obtained.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that the execution of the rules may trigger more rules, this could
 cause 
\series bold
nontermination
\series default
, if two rules call each other in a cycle.
 Thus, ensuring termination is one of the main problems of active-rule design.
\end_layout

\begin_layout Example
Return to the previous example.
 We saw how the first of the examples did not end up fullfilling the condition,
 but it is because we did not take into account that the rule would trigger
 itself because it updates the Salary of Emp.
 Thus, the insertion and subsequent execution of the rule triggered gave
 us:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sal
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
John
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
45
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mike
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
90
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sarah
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
108
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
James
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
180
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Example
As we have updated the salaries, the rule is triggered again.
 The condition would be fullfilled, 105.75>100 and the salaries would be
 modified again, arriving to the table as:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sal
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
John
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
41.5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mike
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
81
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sarah
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
97.2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
James
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
162
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Example
As the salaries ahve been updated again, the rule is triggered once more.
 Now, the mean is 95.425 < 100, so the condition is not met and the actions
 are not executed.
 The rule has terminated.
\end_layout

\begin_layout Example
In this case, termination is ensured because all values are decreased by
 10%.
 This implies that the mean is also decreased by 10%.
 Thus, no matter how high the mean is at the beginning, at some point it
 will go below 100, because 
\begin_inset Formula $0.9x<x,\ \forall x>0$
\end_inset

.
\end_layout

\begin_layout Remark
In general, guaranteeing termination is responsibility of the programmer
 is not an easy task.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
A rule is 
\series bold
correct
\series default
 (or possesses the correctness property) if it ensures repeatability and
 termination, taking into account the rest of factors in the database (other
 rules, domain of the attributes, structure of the tables,...).
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
State transitions and net effect
\end_layout

\begin_layout Standard
A transaction causes a state transition of the database, in the form of
 an addition, suppression of modification of one or more tuples of the database.
\end_layout

\begin_layout Standard
Before the transaction commits, the system stores two temporary 
\series bold
transition relations
\series default
, that contain the tuples affected by the transition.
 This tables are:
\end_layout

\begin_layout Itemize
INSERTED: for each event, it stores newly inserted tuples and the new form
 of tuples that have been modified.
\end_layout

\begin_layout Itemize
DELETED: for each event, it stores deleted tuples and the old form of tuples
 that have been modified.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
The 
\series bold
net effect
\series default
 of a transaction on a tuple is the composed effect of the transaction on
 the tuple, from the starting state to the end of the transaction.
\end_layout

\end_inset


\end_layout

\begin_layout Example
Some simple net effects:
\end_layout

\begin_deeper
\begin_layout Itemize
The sequence 
\family typewriter
INSERT 
\begin_inset Formula $\rightarrow$
\end_inset

 UPDATE 
\begin_inset Formula $\rightarrow$
\end_inset

 ...
 
\begin_inset Formula $\rightarrow$
\end_inset

 UPDATE 
\begin_inset Formula $\rightarrow$
\end_inset

 DELETE 
\family default
on a newl tuple, has null effect: the tuple was not in the database at the
 beginning, and it is not there at the end.
\end_layout

\begin_layout Itemize
The sequence 
\family typewriter
INSERT 
\begin_inset Formula $\rightarrow$
\end_inset

 UPDATE 
\begin_inset Formula $\rightarrow$
\end_inset

 ...
 
\begin_inset Formula $\rightarrow$
\end_inset

 UPDATE 
\family default
on a new tuple, has the same net effect as inserting the tuple with the
 values given in the last update.
\end_layout

\begin_layout Itemize
The sequence
\family typewriter
 UPDATE 
\begin_inset Formula $\rightarrow$
\end_inset

 ...
 
\begin_inset Formula $\rightarrow$
\end_inset

 UPDATE 
\begin_inset Formula $\rightarrow$
\end_inset

 DELETE 
\family default
on an existing tuple, has the same net effect as just deleting it.
\end_layout

\end_deeper
\begin_layout Remark
Rules consider the net effect of transactions between two database states,
 so each tuple appears at most once in each temporary table.
\end_layout

\begin_layout Example
Let's see the INSERTED and DELETED tables of our example.
 We start with the table
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sal
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
John
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
50
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mike
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sarah
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
120
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Example
And perform 
\family typewriter
UPDATE Emp SET Sal=110 WHERE Name='John'.
 
\family default
If we accessed the temporary tables now, we would see:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
INSERTED
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sal
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
John
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
110
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DELETED
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sal
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
John
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
50
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Example
Now, the rule is triggered because salary has been updated.
 The condition is met and the action is launched.
 If we accessed the temporary tables now, we would see:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
INSERTED
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sal
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
John
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
99
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mike
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
90
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sarah
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
108
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DELETED
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sal
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
John
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
50
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mike
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sarah
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
120
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Example
Note how the first tuple in INSERTED shows only the net effect on the tuple.
\end_layout

\begin_layout Standard
With this definitions, we can give a more precise definition of rule triggering:
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
A rule is 
\series bold
triggered
\series default
 if any of the transition relations corresponding to its triggering operations
 is not empty.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A great feature of rules is that it is possible to reference the transition
 tables, which can be very useful in many occasions.
\end_layout

\begin_layout Example
Now, imagine we want to add the rule '
\emph on
If an employee is inserted with a salary greater than 100, add the employee
 to the table of hifh paid employees'
\emph default
.
 This rule could be defined as:
\begin_inset listings
lstparams "language=SQL,morekeywords={CREATE, RULE, ON, WHEN, IF, EXISTS, SELECT, FROM, WHERE, AND, THEN, ROLLBACK}"
inline false
status open

\begin_layout Plain Layout

CREATE RULE HighPaid ON Emp
\end_layout

\begin_layout Plain Layout

WHEN 
\end_layout

\begin_layout Plain Layout

IF 
\end_layout

\begin_layout Plain Layout

	EXISTS (SELECT * FROM INSERTED WHERE Sal > 100)
\end_layout

\begin_layout Plain Layout

THEN 
\end_layout

\begin_layout Plain Layout

	INSERT INTO HighPaidEmp
\end_layout

\begin_layout Plain Layout

	(SELECT * FROM INSERTED WHERE Sal > 100)
\end_layout

\begin_layout Plain Layout

FOLLOWS SalaryControl;
\end_layout

\end_inset


\end_layout

\begin_layout Example
When we insert (James, 200), the tuple is inserted and the rules SalaryControl
 and HighPaid are triggered.
 Because we have defined HighPaid to follow SalaryControl, the latter would
 execute earlier.
 Now, SalaryControl, as we saw, would trigger more instances of the same
 rule, which would be all executed before HighPaid.
 At the end, as all employees would have been modified, all of them with
 a salary bigger than 100 would be added to the table HighPaidEmp because
 of this new rule.
 In this case, only James fullfills the condition.
\end_layout

\begin_layout Subsubsection
More Starbust commands
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=SQL,morekeywords={CREATE, RULE, ON, WHEN, IF, EXISTS, SELECT, FROM, WHERE, AND, THEN, ROLLBACK}"
inline false
status open

\begin_layout Plain Layout

1) DEACTIVATE RULE <rule-name> ON <table-name>
\end_layout

\begin_layout Plain Layout

		Makes the specified rule not to be taken into account.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

2) ACTIVATE RULE <rule-name> ON <table-name>
\end_layout

\begin_layout Plain Layout

		Makes the specified rule to be taken into account.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

3) DROP RULE <rule-name> ON <table-name>
\end_layout

\begin_layout Plain Layout

		Deletes the specified rule.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

4) CREATE RULESET <ruleset-name>
\end_layout

\begin_layout Plain Layout

		Creates a ruleset, i.e., a set of related rules.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

5) ALTER RULESET <ruleset-name> [ADDRULES <rule-names>] [DELRULES <rule-names>]
\end_layout

\begin_layout Plain Layout

		Allows to add or delete rules to/from a ruleset.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

6) DROP RULESET <ruleset-name>
\end_layout

\begin_layout Plain Layout

		Deletes the specified ruleset (but not the rules).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

7) PROCESS RULES
\end_layout

\begin_layout Plain Layout

		Processes all active rules.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

8) PROCESS RULESET <ruleset-name>
\end_layout

\begin_layout Plain Layout

		Process a specified ruleset, if it is active.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

9) PROCESS RULE <rule-name>
\end_layout

\begin_layout Plain Layout

		Process a specified rule, if it is active.
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Starbust's rule commands.
\begin_inset CommandInset label
LatexCommand label
name "tab:Starbust's-commands"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Oracle
\end_layout

\begin_layout Standard
In Oracle, the term used is TRIGGER.
 Triggers in Oracle respond to modification operations (INSERT, DELETE,
 UPDATE) to a relation, just as in Starburst.
\end_layout

\begin_layout Standard
The triggers in Oracle can be defined for different granularities:
\end_layout

\begin_layout Itemize

\series bold
Tuple-level
\series default
: the rule is triggered once for each tuple concerned by the triggering
 event.
\end_layout

\begin_layout Itemize

\series bold
Statement-level
\series default
: the rule is triggered only once even if several tuples are involved.
\end_layout

\begin_layout Standard
Also, the execution mode of triggers in Oracle is 
\series bold
immediate
\series default
, meaning they are executed just after the event has ben requested, in contrast
 to Starburst, in which the execution mode is referred, as we saw.
 This allows for rules to be executed before, after or even instead of the
 operation of the triggering event.
 In 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Oracles's-rule-definition"
plural "false"
caps "false"
noprefix "false"

\end_inset

, the definition syntax of triggers in Oracle is detailed.
 Some notes:
\end_layout

\begin_layout Itemize
The BEFORE or AFTER commands define when the rule should execute in relation
 to the events that trigger it.
\end_layout

\begin_layout Itemize
If FOR EACH ROW is written, then the trigger is a tuple-level trigger, and
 it is activated once for each tuple concerned.
 
\end_layout

\begin_deeper
\begin_layout Itemize
This is useful if the code in the actions depends on data provided by the
 triggering statement or on the tuples affected.
\end_layout

\begin_layout Itemize
The INSERTING, DELETING and UPDATING statements may be used in the action
 to check which triggering event has occurred.
\end_layout

\begin_layout Itemize
OLD and NEW reference the old value of the tuple (if it is update or delete)
 and the new value of the tuple (if it is update or insert).
\end_layout

\begin_layout Itemize
The condition consists of a simple predicate on the current tuple.
\end_layout

\end_deeper
\begin_layout Itemize
If FOR EACH ROW is not written, then the trigger is a statement-level trigger,
 and it is activated once for each triggering statement even if several
 tuples are involved or no tuple is updated.
\end_layout

\begin_deeper
\begin_layout Itemize
In this case, OLD and NEW are meaningless.
\end_layout

\begin_layout Itemize
This is useful if the code of the actions does not depend on the data provided
 by the triggering statement nor the tuples affected.
\end_layout

\begin_layout Itemize
It does not have a condition part
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fn:1"

\end_inset

It is not clear why Oracle engineers made it like this.
\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize
It does not have the possibility to refer to intermediate relations as in
 Starbust
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footref{fn:1}
\end_layout

\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize
Oracle triggers can execute actions containing arbitrary PL/SQL
\begin_inset Foot
status open

\begin_layout Plain Layout
PL/SQL extends SQL by adding the typical constructs of a programming language.
\end_layout

\end_inset

 code (not just SQL as in Starburst).
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=SQL,morekeywords={CREATE, RULE, ON, WHEN, IF, EXISTS, SELECT, FROM, WHERE, AND, THEN, ROLLBACK}"
inline false
status open

\begin_layout Plain Layout

CREATE TRIGGER <trigger-name> {BEFORE|AFTER} <list of trigger-events>
\end_layout

\begin_layout Plain Layout

ON <table-name>
\end_layout

\begin_layout Plain Layout

[REFERENCING <references>]
\end_layout

\begin_layout Plain Layout

[FOR EACH ROW]
\end_layout

\begin_layout Plain Layout

[WHEN (<condition>)]
\end_layout

\begin_layout Plain Layout

<actions>;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

where
\end_layout

\begin_layout Plain Layout

	<trigger-event> := INSERT | DELETE | UPDATE [OF <column-names>]
\end_layout

\begin_layout Plain Layout

	<references> := OLD as <old-tuple-name> | NEW as <new-tuple-name>
\end_layout

\begin_layout Plain Layout

	<actions> := <PL/SQL block>
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Oracle's rule definition syntax.
\begin_inset CommandInset label
LatexCommand label
name "tab:Oracles's-rule-definition"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Example
Row-level AFTER trigger.
\end_layout

\begin_layout Example
Imagine we have two tables:
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
Inventory(Part, PartOnHand, ReorderPoint, ReorderQty)
\end_layout

\begin_layout Itemize

\family typewriter
PendingOrders(Part, Qty, Date)
\end_layout

\end_deeper
\begin_layout Example
We want to define a rule that whenever a PartOnHand is modified, and its
 new value is smaller than the ReorderPoint (i.e.
 we have less parts than the threshold to order more parts), we add a new
 record to PendingOrders as a new order for this part and the required quantity,
 if it is not already done.
 This can be done as follows:
\end_layout

\begin_layout Example
\begin_inset listings
lstparams "language=SQL,morekeywords={CREATE, RULE, ON, WHEN, IF, EXISTS, SELECT, FROM, WHERE, AND, THEN, ROLLBACK, DECLARE, NUMBER, INSERT, INTO, VALUES, ENDIF, END, BEGIN, FOR, EACH, ROW, OF, AFTER, UPDATE, TRIGGER}"
inline false
status open

\begin_layout Plain Layout

CREATE TRIGGER Reorder
\end_layout

\begin_layout Plain Layout

AFTER UPDATE OF PartOnHand ON Inventory
\end_layout

\begin_layout Plain Layout

FOR EACH ROW
\end_layout

\begin_layout Plain Layout

WHEN (New.PartOnHand < New.ReorderPoint)
\end_layout

\begin_layout Plain Layout

	DECLARE NUMBER X;
\end_layout

\begin_layout Plain Layout

	BEGIN
\end_layout

\begin_layout Plain Layout

		SELECT COUNT(*) INTO X
\end_layout

\begin_layout Plain Layout

		FROM PendingOrders
\end_layout

\begin_layout Plain Layout

		WHERE Part = New.Part;
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		IF X=0 THEN
\end_layout

\begin_layout Plain Layout

			INSERT INTO PendingOrders VALUES (New.Part, New.ReorderQty, SYSDATE)
\end_layout

\begin_layout Plain Layout

		ENDIF;
\end_layout

\begin_layout Plain Layout

	END;
\end_layout

\end_inset


\end_layout

\begin_layout Example
Let's apply the rule to see how it works.
 Let's say our table Inventory is:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Part
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PartOnHand
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ReorderPoint
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ReorderQty
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
200
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
150
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
780
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
500
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
200
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
450
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
400
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
120
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Example
If we execute the following transaction on October 10, 2000:
\end_layout

\begin_layout Example
\begin_inset listings
lstparams "language=SQL,morekeywords={CREATE, RULE, ON, WHEN, IF, EXISTS, SELECT, FROM, WHERE, AND, THEN, ROLLBACK, DECLARE, NUMBER, INSERT, INTO, VALUES, ENDIF, END, BEGIN, FOR, EACH, ROW, OF, AFTER, UPDATE, TRIGGER}"
inline false
status open

\begin_layout Plain Layout

UPDATE Inventory
\end_layout

\begin_layout Plain Layout

SET PartOnHand = PartOnHand - 70
\end_layout

\begin_layout Plain Layout

WHERE Part = 1;
\end_layout

\end_inset


\end_layout

\begin_layout Example
Then the tuple 
\family typewriter
(1,100,2000-10-10)
\family default
 would be inserted into PendingOrders.
\end_layout

\begin_layout Standard
The algorithm for executing rules in Oracle is shown in Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Rule-Processing-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 As we can see, statement-level triggers are executed before/after anything
 else, and row-level triggers are executed before/after each affected tuple
 is modified.
 Note that the executions needs to take into account the priority among
 triggers, but only those of the same granularity (row vs statement) and
 type (before vs after).
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=SQL,morekeywords={while, is, not, select, in, if, execute, delete, from}"
inline false
status open

\begin_layout Plain Layout

For each STATEMENT-LEVEL BEFORE trigger
\end_layout

\begin_layout Plain Layout

	Execute trigger
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

For each row affected by the triggering statement
\end_layout

\begin_layout Plain Layout

	- For each ROW-LEVEL BEFORE trigger
\end_layout

\begin_layout Plain Layout

		Execute trigger
\end_layout

\begin_layout Plain Layout

	- Execute the modification of the row 
\end_layout

\begin_layout Plain Layout

	- Check row-level constraints and assertions
\end_layout

\begin_layout Plain Layout

	- For each ROW-LEVEL AFTER trigger
\end_layout

\begin_layout Plain Layout

		Execute trigger
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Check statement-level constraints and assertions
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

For each STATEMENT-LEVEL AFTER trigger
\end_layout

\begin_layout Plain Layout

	Execute trigger
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
processRules
\begin_inset CommandInset label
LatexCommand label
name "alg:Rule-Processing-1"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Oracle semantics
\end_layout

\begin_layout Itemize
The action part may activate other triggers.
 In that case, the execution of the current trigger is suspended and the
 others are considered using the same algorithm.
 There a maximum number of cascading triggerss, set at 32.
 When this maximum is reached, execution is suspended and an exception is
 raised.
\end_layout

\begin_layout Itemize
If an exception is raised or an error occurs, the changes made by the triggering
 statement and the actions performed by triggers are rolled back.
 This means that Oracle supports partial rollback instead of transaction
 rollback.
\end_layout

\begin_layout Subsubsection
Instead-of triggers
\end_layout

\begin_layout Standard
This is another type of Oracle trigger, in which the action is carried out
 inplace of the statement that produced the activating event.
 These triggers are typically used to update views and they need to be carefully
 used, because changing one action Y for an action X can sometimes have
 unexpected behaviors.
\end_layout

\begin_layout Example
An Instead-of trigger:
\end_layout

\begin_layout Example
\begin_inset listings
lstparams "language=SQL,morekeywords={CREATE, RULE, ON, WHEN, IF, EXISTS, SELECT, FROM, WHERE, AND, THEN, ROLLBACK, DECLARE, NUMBER, INSERT, INTO, VALUES, ENDIF, END, BEGIN, FOR, EACH, ROW, OF, AFTER, UPDATE, TRIGGER}"
inline false
status open

\begin_layout Plain Layout

CREATE TRIGGER manager-insert
\end_layout

\begin_layout Plain Layout

INSTEAD OF INSERT ON Managers
\end_layout

\begin_layout Plain Layout

REFERENCING NEW AS n
\end_layout

\begin_layout Plain Layout

FOR EACH ROW
\end_layout

\begin_layout Plain Layout

	UPDATE Dept d
\end_layout

\begin_layout Plain Layout

	SET mgrno = n.empno
\end_layout

\begin_layout Plain Layout

	WHERE d.deptno = n.deptno;
\end_layout

\end_inset


\end_layout

\begin_layout Example
This trigger automatically updates the manager of a department when a new
 manager is inserted.
\end_layout

\begin_layout Subsection
DB2
\end_layout

\begin_layout Standard
In DB2, every trigger monitors a single event, and are activated immediately,
 BEFORE or AFTER their event.
 They can be defined row-level or statement-level, as in Oracle.
 But in this case state-transition values can be accessed in both granularities:
\end_layout

\begin_layout Itemize
OLD and NEW refer to tuple granularity, as in Oracle.
\end_layout

\begin_layout Itemize
OLD_TABLE and NEW_TABLE refer to table granularity, like the DELETED and
 INSERTED in Starburst.
\end_layout

\begin_layout Standard
DB2's triggers cannot execute data definition nor transactional commands.
 They can raise errors which in turn can cause statement-level rollbacks.
\end_layout

\begin_layout Standard
The syntax is as in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:DB2's-rule-definition-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=SQL,morekeywords={CREATE, RULE, ON, WHEN, IF, EXISTS, SELECT, FROM, WHERE, AND, THEN, ROLLBACK}"
inline false
status open

\begin_layout Plain Layout

CREATE TRIGGER <trigger-name> {BEFORE|AFTER} <trigger-event>
\end_layout

\begin_layout Plain Layout

ON <table-name>
\end_layout

\begin_layout Plain Layout

[REFERENCING <references>]
\end_layout

\begin_layout Plain Layout

FOR EACH {ROW|STATEMENT}
\end_layout

\begin_layout Plain Layout

WHEN (<SQL-condition>)
\end_layout

\begin_layout Plain Layout

<SQL-procedure-statements>;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

where
\end_layout

\begin_layout Plain Layout

	<trigger-event> := INSERT | DELETE | UPDATE [OF <column-names>]
\end_layout

\begin_layout Plain Layout

	<references> := OLD as <old-tuple-name> | NEW as <new-tuple-name> |
\end_layout

\begin_layout Plain Layout

			OLD_TABLE as <old-table-name> | NEW_TABLE as <new-table-name>
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
DB2's rule definition syntax.
\begin_inset CommandInset label
LatexCommand label
name "tab:DB2's-rule-definition-1"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The processing is done as in Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Rule-Processing-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Note that:
\end_layout

\begin_layout Itemize
Steps 1) and 6) are not required when S if part of an user transaction.
\end_layout

\begin_layout Itemize
If an error occurs during the chain processing of S, then the prior DB state
 is restored.
\end_layout

\begin_layout Itemize
IC refers to Integrity Constraints.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=SQL,morekeywords={while, is, not, select, in, if, execute, delete, from}"
inline false
status open

\begin_layout Plain Layout

WHEN triggers ACTIVATE each other:
\end_layout

\begin_layout Plain Layout

	IF a modification statement S in the action A of a trigger causes event
 E:
\end_layout

\begin_layout Plain Layout

		1) SUSPEND execution of A, SAVE its data on a stack
\end_layout

\begin_layout Plain Layout

		2) COMPUTE OLD and NEW relative to E
\end_layout

\begin_layout Plain Layout

		3) EXECUTE BEFORE-triggers relative to E, update NEW
\end_layout

\begin_layout Plain Layout

		4) APPLY NEW transition values to DB.
\end_layout

\begin_layout Plain Layout

		   FOR EACH IC violated by current state with action Aj:
\end_layout

\begin_layout Plain Layout

			a) COMPUTE OLD and NEW relative to Aj
\end_layout

\begin_layout Plain Layout

			b) EXECUTE BEFORE-triggers relative to Aj, update NEW
\end_layout

\begin_layout Plain Layout

			c) APPLY NEW transition values to DB
\end_layout

\begin_layout Plain Layout

			d) PUSH ALL AFTER-triggers relative to Aj into 
\end_layout

\begin_layout Plain Layout

			   a queue of suspended triggers
\end_layout

\begin_layout Plain Layout

		5) EXECUTE ALL AFTER-triggers relative to E
\end_layout

\begin_layout Plain Layout

			IF ANY of them contains action Aj invoking other triggers:
\end_layout

\begin_layout Plain Layout

				REPEAT RECURSIVELY
\end_layout

\begin_layout Plain Layout

		6) POP from the stack the data for A, continue its evaluation
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
processRules
\begin_inset CommandInset label
LatexCommand label
name "alg:Rule-Processing-2"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
DB2 semantics
\end_layout

\begin_layout Itemize

\series bold
Before-triggers
\series default
: these are used to detect error conditions and to condition input values.
 They are executed entirely before the associated event and they cannot
 modify the DB (to avoid recursively activating more triggers).
\end_layout

\begin_layout Itemize

\series bold
After-triggers
\series default
: these are used to embed part of the application logic in the DB.
 The condition is evaluated and the action is possibly executed after the
 event occurs.
 The state of the DB prior to the event can be reconstructed from transition
 values.
\end_layout

\begin_layout Itemize
Several triggers can monitor the same event.
\end_layout

\begin_layout Itemize
In this case, the order is total and entirely based on the creation time
 of the triggers.
 Row-level and statement-level triggers are intertwined in the total order.
\end_layout

\begin_layout Itemize
If the action of a row-level trigger has several statements, they are all
 executed for one tuple before considering the next one.
\end_layout

\begin_layout Example
Imagine we have the following two tables:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Part
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\bar under
PartNum
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Supplier
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cost
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Jones
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
150
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Taylor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
500
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
HDD
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
400
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Jones
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
800
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Distributor
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
City
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
State
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Jones
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Palo Alto
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CA
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Taylor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Minneapolis
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MN
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
HDD
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Atlanta
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GA
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Example
And there is a referential integrity constraint that requires Part Suppliers
 to be also distributors, with HDD as a default Supplier:
\end_layout

\begin_layout Example
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

FOREIGN KEY (Supplier)
\end_layout

\begin_layout Plain Layout

	REFERENCES Distributor(Name)
\end_layout

\begin_layout Plain Layout

	ON DELETE SET DEFAULT;
\end_layout

\end_inset


\end_layout

\begin_layout Example
Then, the following trigger is a row-level trigger that rollbacks when updating
 Supplier to NULL:
\end_layout

\begin_layout Example
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

CREATE TRIGGER OneSupplier
\end_layout

\begin_layout Plain Layout

BEFORE UPDATE OF Supplier ON Part
\end_layout

\begin_layout Plain Layout

REFERENCING NEW AS N
\end_layout

\begin_layout Plain Layout

FOR EACH ROW
\end_layout

\begin_layout Plain Layout

WHEN (N.Supplier is NULL)
\end_layout

\begin_layout Plain Layout

	SIGNAL SQLSTATE '70005' ('Cannot change supplier to NULL');
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
SQL Server
\end_layout

\begin_layout Standard
In SQL Server, a single trigger can run multiple actions, and it can be
 fired by more than one event.
 Also, triggers can be attached to tables or views.
 SQL Server does not support BEFORE-triggers, but it supports AFTER-triggers
 (they can be defined using the word AFTER or FOR
\begin_inset Foot
status open

\begin_layout Plain Layout
FOR and WITH APPEND are used for backward compatibility, but will not be
 supported in the future.
\end_layout

\end_inset

) and INSTEAD OF-triggers.
 
\end_layout

\begin_layout Standard
The triggers can be fired with INSERT, UPDATE and DELETE statements.
 
\end_layout

\begin_layout Standard
The option WITH ENCRYPTION encrypts the text of the trigger in the syscomment
 table.
 
\end_layout

\begin_layout Standard
Finally, the option NOT FOR REPLICATION ensures that the trigger is not
 executed when a replication process modifies the table to which the trigger
 is attached.
\end_layout

\begin_layout Standard
The syntax is shown in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:SQLServer's-rule-definition-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=SQL,morekeywords={CREATE, RULE, ON, WHEN, IF, EXISTS, SELECT, FROM, WHERE, AND, THEN, ROLLBACK}"
inline false
status open

\begin_layout Plain Layout

CREATE TRIGGER <trigger-name> ON <table-name>
\end_layout

\begin_layout Plain Layout

[WITH ENCRYPTION]
\end_layout

\begin_layout Plain Layout

{FOR | AFTER | INSTEAD OF} <list of trigger-events>
\end_layout

\begin_layout Plain Layout

[WITH APPEND]
\end_layout

\begin_layout Plain Layout

[NOT FOR REPLICATION]
\end_layout

\begin_layout Plain Layout

AS <Transact-SQL-statements>;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

where
\end_layout

\begin_layout Plain Layout

	<trigger-event> := INSERT | DELETE | UPDATE
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
SQL Server's rule definition syntax.
\begin_inset CommandInset label
LatexCommand label
name "tab:SQLServer's-rule-definition-1"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\series bold
INSTEAD OF-triggers
\series default
: are defined on a table or a view.
 Triggers defined on a view extend the types of updates that a view support
 by default.
 Only one per triggering action is allowed on a table or view.
 Note that views can be defined on other views, and each of them can have
 its own INSTEAD OF-triggers.
\end_layout

\begin_layout Itemize

\series bold
AFTER-triggers
\series default
: are defined on a table.
 Modifications to views in which the table data is modified in response,
 will fire the AFTER-triggers of the table.
 More than one is allowed on a table.
 The 
\series bold
order of execution
\series default
 can be defined using the 
\emph on
sp_settriggerorder
\emph default
 procedure.
 All other triggers applied to a table execute in random order.
\end_layout

\begin_layout Subsubsection
SQL Server Semantics
\end_layout

\begin_layout Itemize
Both clases of triggers can be applied to a table.
\end_layout

\begin_layout Itemize
If both trigger classes and constraints are defined for a table, the INSTEAD
 OF-trigger fires first.
 Then, constraints are processed and finally AFTER-triggers are fired.
 
\end_layout

\begin_layout Itemize
If constraints are violated, INSTEAD OF-trigger's actions are rolled back.
\end_layout

\begin_layout Itemize
AFTER-triggers do not execute if constraints are violated or if some other
 event causes the table modification to fail.
\end_layout

\begin_layout Itemize
As stored procedures, triggers can be nested up to 32 levels deep and fired
 recursively.
\end_layout

\begin_layout Itemize
Two transition tables are available: INSERTED and DELETED, which are as
 in Starburst.
\end_layout

\begin_layout Itemize
The IF UPDATE(<column-name> clause determines whether an INSERT or UPDATE
 event ocurred to the column.
\end_layout

\begin_layout Itemize
The COLUMNS_UPDATE() clause returns a bit pattern indicating fhich of the
 tested columns were isnerted or updated.
\end_layout

\begin_layout Itemize
The @@ROWCOUNT function returns the number of rows affected by the previous
 Transact-SQL statement in the trigger.
\end_layout

\begin_layout Itemize
A trigger fires even if no rows are affected by the event.
 The RETURN command can be used to exit the trigger transparently when this
 happens.
\end_layout

\begin_layout Itemize
The RAISERROR command is used to display error messages.
\end_layout

\begin_layout Itemize
There are some Transact-SQL statements that are not allowd in triggers:
\end_layout

\begin_deeper
\begin_layout Itemize
ALTER, CREATE, DROP, RESTORE and LOAD DATABASE.
\end_layout

\begin_layout Itemize
LOAD and RESTORE LOG.
\end_layout

\begin_layout Itemize
DISK RESIZE and DISK INIT.
\end_layout

\begin_layout Itemize
RECONFIGURE.
\end_layout

\end_deeper
\begin_layout Itemize
If in a trigger's code it is needed to assign variables, then SET NOCOUNT
 ON must be included in the trigger code, disallowing the messages stating
 how many tuples were modified in each operation.
\end_layout

\begin_layout Subsubsection
Limitations
\end_layout

\begin_layout Itemize
The INSTEAD OF DELETE and INSTEAD OF UPDATE triggers cannot be defined on
 tables that have a correspoonding ON DELETE or ON UPDATE cascading referential
 integrity defined.
\end_layout

\begin_layout Itemize
Triggers cannot be created on a temporary or system table, but they can
 be referenced inside other triggers.
\end_layout

\begin_layout Subsubsection
Nested and Recursive triggers
\end_layout

\begin_layout Standard
SQL Server enables to enable or disable nested and recursive triggers:
\end_layout

\begin_layout Itemize

\series bold
Nested trigger option
\series default
: determines whether a trigger can be executed in cascade.
 There is a limit of 32 nested trigger operations.
 It can be set with 
\emph on
sp_configure 'nested triggers', 1 | 0
\emph default
.
\end_layout

\begin_layout Itemize

\series bold
Recursive trigger option
\series default
: causes triggers to be re-fired when the trigger modifies the same table
 as it is attached to: the neste trigger option must be set to true.
 This option can be set with 
\emph on
sp_dboption '<db-name>', 'recursive triggers', 'TRUE' | 'FALSE'
\emph default
.
\end_layout

\begin_deeper
\begin_layout Standard
Note that recursion can be 
\series bold
direct
\series default
 if a trigger activates another instance of itself or 
\series bold
indirect
\series default
 if the activation sequence is 
\begin_inset Formula $T_{1}\rightarrow T_{2}\rightarrow T_{1}$
\end_inset

.
 The recursive trigger option only copes with the direct recursion, the
 indirect kind is dealt with the nested trigger option.
\end_layout

\end_deeper
\begin_layout Subsubsection
Trigger management
\end_layout

\begin_layout Standard
Trigger management includes the task of altering, renaming, viewing, dropping
 and disabling triggers:
\end_layout

\begin_layout Itemize
Triggers can be modified with the ALTER TRIGGER statement, in which the
 new definition is provided.
\end_layout

\begin_layout Itemize
Triggers can be renamed with the 
\emph on
sp_rename
\emph default
 system stored procedure as
\end_layout

\begin_deeper
\begin_layout Standard
\align center

\emph on
sp_rename @objname = <old-name>, @newname = <new-name>
\end_layout

\end_deeper
\begin_layout Itemize
Triggers can be viewed by querying system tables or by using the 
\emph on
sp_helptrigger
\emph default
 and 
\emph on
sp_helptext
\emph default
 system stored procedures as
\end_layout

\begin_deeper
\begin_layout Standard
\align center

\emph on
sp_helptrigger @tabname = <table-name>
\end_layout

\begin_layout Standard
\align center

\emph on
sp_helptext @objname = <trigger-name>
\end_layout

\end_deeper
\begin_layout Itemize
Triggers can be deleted with the DROP TRIGGER statement.
\end_layout

\begin_layout Itemize
Triggers can be enable and disable using the ENABLE TRIGGER and DISABLE
 TRIGGER clauses of the ALTER TABLE statement.
\end_layout

\begin_layout Example
Let's work with a database with the following tables:
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
Books(
\bar under
TitleID
\bar default
, Title, Publisher, PubDate, Edition, Cost, QtySold)
\end_layout

\begin_layout Itemize

\family typewriter
Orders(
\bar under
OrderId
\bar default
, CustomerId, Amount, OrderDate)
\end_layout

\begin_layout Itemize

\family typewriter
BookOrders(
\bar under
OrderID, TitleId
\bar default
, Qty)
\end_layout

\end_deeper
\begin_layout Example
Here, Books.QtySold is a derived attribute which keeps track of how many
 copies of the book has been sold.
 We can make this updates automatic with the use of the following trigger:
\end_layout

\begin_layout Example
\begin_inset listings
lstparams "language=SQL,numbers=left,numberstyle={\small}"
inline false
status open

\begin_layout Plain Layout

CREATE TRIGGER update_book_qtysold ON BookOrders
\end_layout

\begin_layout Plain Layout

AFTER INSERT, UPDATE, DELETE AS
\end_layout

\begin_layout Plain Layout

-- add if insertion
\end_layout

\begin_layout Plain Layout

	IF EXISTS (SELECT * FROM INSERTED)
\end_layout

\begin_layout Plain Layout

	BEGIN
\end_layout

\begin_layout Plain Layout

		UPDATE Books
\end_layout

\begin_layout Plain Layout

		SET QtySold = QtySold + (SELECT sum(Qty) 
\end_layout

\begin_layout Plain Layout

					FROM INSERTED i
\end_layout

\begin_layout Plain Layout

					WHERE titleId = i.titleId)
\end_layout

\begin_layout Plain Layout

		WHERE titleID IN (SELECT i.titleID FROM INSERTED i)
\end_layout

\begin_layout Plain Layout

	END
\end_layout

\begin_layout Plain Layout

-- subtract if deletion
\end_layout

\begin_layout Plain Layout

	IF EXISTS (SELECT * FROM DELETED)
\end_layout

\begin_layout Plain Layout

	BEGIN
\end_layout

\begin_layout Plain Layout

UPDATE Books
\end_layout

\begin_layout Plain Layout

		SET QtySold = QtySold - (SELECT sum(Qty) 
\end_layout

\begin_layout Plain Layout

					FROM DELETED d
\end_layout

\begin_layout Plain Layout

					WHERE titleId = d.titleId)
\end_layout

\begin_layout Plain Layout

		WHERE titleID IN (SELECT d.titleID FROM DELETED d)
\end_layout

\begin_layout Plain Layout

	END
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
When there is an insertion in BookOrders, the trigger fires and adds the
 corresponding quantity.
\end_layout

\begin_layout Itemize
When there is a deletion, the trigger fires and subtracts the corresponding
 quantity.
\end_layout

\begin_layout Itemize
An update creates both tables, so we would add and subtract to cope with
 the modification.
\end_layout

\end_deeper
\begin_layout Section
Applications of Active Rules
\end_layout

\begin_layout Standard
Rules provide programmers with an effective tool to support both internal
 applications and external applications:
\end_layout

\begin_layout Itemize

\series bold
Internal applications
\series default
: rules support function provided by specific subsystems in passive DBSMs,
 such as the management of IC, derived data, replicated data, version maintenanc
e,...
 Rules can usually be declaratively specified, generated by the system and
 hidden to the user.
\end_layout

\begin_layout Itemize

\series bold
External applications
\series default
: these refer to the application of business rules to the data stored.
 Rules allow to perform computations that would usually need to be expressed
 in application code.
 In addition, rules provide many times a natural way to model reactive behavior
 of the data, as rules respond to external events and perform action in
 consequence.
 This approach becomes specially interested when rules express central policies,
 i.e., knowledge common to applications, centralizing the effort and reducing
 the cost.
\end_layout

\begin_layout Standard
Some examples of applications that can benefit from active technology and
 business rules are:
\end_layout

\begin_layout Itemize
Monitoring access to a building and reacting to abnormal circumstances.
\end_layout

\begin_layout Itemize
Watching evolution of share values on stock market and triggering trading
 actions.
\end_layout

\begin_layout Itemize
Managing inventory to follow stock variations.
\end_layout

\begin_layout Itemize
Managing a netwrok to for energy distribution.
\end_layout

\begin_layout Itemize
Airway assignment in air traffic control.
\end_layout

\begin_layout Standard
As can be seen from these examples, a frequent case of application-specific
 rules are 
\series bold
alterters
\series default
, whose actions signal certain conditions that occur with ot without changing
 the database.
\end_layout

\begin_layout Subsection
A summary of Integrity Constraints
\end_layout

\begin_layout Standard
The 
\series bold
integrity
\series default
 of a database refers to the consistency and conformity of the data with
 the database schema and its constraints.
 Thus, an 
\series bold
integrity constraint
\series default
 is any assertion on the schema which is not defined in the data-structure
 aprt of the schema.
 Constraints declaratively specify conditions to be satisfied by the data
 at all times, so checking for integrity violations is done for every update
 of the state of the database.
\end_layout

\begin_layout Standard
Integrity constraints can be 
\series bold
static
\series default
 if the predicates are evaluated on database states or 
\series bold
dynamic
\series default
 if the predicates are evaluated on state transitions.
 They can also be classified as 
\series bold
built-in
\series default
 if they are defined by special DDL (Data Definition Language) constructs
 (such as keys, nonnull values,...) or 
\series bold
adhoc
\series default
, which are arbitrarily complex domain-dependent constraints.
\end_layout

\begin_layout Standard
In practice, integrity maintenance is achieved through:
\end_layout

\begin_layout Itemize
DBMS checks built-in constraint with automatically generated triggers.
\end_layout

\begin_layout Itemize
DBMS supports limited forms of adhoc constraints.
\end_layout

\begin_layout Itemize
The remaining constraints are implemented as active rules (triggers).
\end_layout

\begin_layout Standard
The process of 
\series bold
rule generation
\series default
 may be partially automated:
\end_layout

\begin_layout Enumerate
The possible causes of violation are the events for the activation of the
 rule.
\end_layout

\begin_layout Enumerate
The declarative formulation of the constraint is the rule condition.
\end_layout

\begin_layout Enumerate
To avoid or eliminate the violation, an action is taken.
 The simplest approach is to rollback the transaction, this is done by 
\series bold
abort rules
\series default
, in contrast, the richer approach provides a domain-dependent corrective
 action, via 
\series bold
repair rules
\series default
.
\end_layout

\begin_layout Standard
Thus:
\end_layout

\begin_layout Itemize

\series bold
Abort rules
\series default
 check that integrity is not violation and prevent the execution of an operation
 which would cause the violation of the integrity by means of the ROLLBACK
 command.
\end_layout

\begin_layout Itemize

\series bold
Repair rules
\series default
 are more sophisticated than abort rules, because they make use of application-d
omain semantics to define a set of actions that restore integrity
\end_layout

\begin_layout Example
Let's do a referential integrity example in Starburst:
\end_layout

\begin_layout Example
We have relations 
\family typewriter
Emp(
\bar under
EmpNo
\bar default
,DeptNo)
\family default
 and 
\family typewriter
Dept(
\bar under
DNo
\bar default
)
\family default
.
 We have the regerential integrity condition 
\begin_inset Formula 
\[
Emp\left[DeptNo\right]\subset Dept\left[DNo\right],
\]

\end_inset

 so the possible violations can come from an INSERT into Emp, a DELETE from
 Dept, and UPDATE of Emp[DeptNo] and an update of Dept[Dno].
 The condition on tuples of Emp for not violating the constraint is:
\end_layout

\begin_layout Example
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

EXISTS (SELECT * FROM Dept WHERE DNo = Emp.DeptNo)
\end_layout

\end_inset


\end_layout

\begin_layout Example
Its denial form, so the constraint is violated is:
\end_layout

\begin_layout Example
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

NOT EXISTS (SELECT * FROM Dept WHERE DNo = Emp.DeptNo)
\end_layout

\end_inset


\end_layout

\begin_layout Example
Thus, we can create abort rules as:
\end_layout

\begin_layout Example
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

CREATE RULE DeptEmp1 ON Emp
\end_layout

\begin_layout Plain Layout

WHEN INSERTED, UPDATED(DeptNo)
\end_layout

\begin_layout Plain Layout

IF EXISTS (SELECT * FROM Emp 
\end_layout

\begin_layout Plain Layout

		WHERE NOT EXISTS (SELECT * FROM Dept WHERE DNo=Emp.DeptNo))
\end_layout

\begin_layout Plain Layout

THEN ROLLBACK;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

CREATE RULE DeptEmp2 ON Dept
\end_layout

\begin_layout Plain Layout

WHEN DELETED, UPDATED(DNo)
\end_layout

\begin_layout Plain Layout

IF EXISTS (SELECT * FROM Emp 
\end_layout

\begin_layout Plain Layout

		WHERE NOT EXISTS (SELECT * FROM Dept WHERE DNo=Emp.DeptNo))
\end_layout

\begin_layout Plain Layout

THEN ROLLBACK;
\end_layout

\end_inset


\end_layout

\begin_layout Example
Note that one rule is neccessary for each relation.
\end_layout

\begin_layout Example
Note also that the defined rules are inneficient, because the computation
 of the condition checks the whole database.
 Rules can assume that the constraint is verified in the initial state,
 so it suffices to compute the condition relative to transition tables.
\end_layout

\begin_layout Example
Now, we are defining a repair rule that:
\end_layout

\begin_deeper
\begin_layout Itemize
If an employee is inserted with a wrong value of DeptNo, it is set to NULL.
\end_layout

\begin_layout Itemize
If the DeptNo of an employee is updated with a wrong value of DeptNo, it
 is set to 99.
\end_layout

\begin_layout Itemize
If a department is deleted or its DNo is updated, then all employees from
 this department are deleted.
\end_layout

\end_deeper
\begin_layout Example
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

CREATE RULE DeptEmp1 ON Emp
\end_layout

\begin_layout Plain Layout

WHEN INSERTED, 
\end_layout

\begin_layout Plain Layout

IF EXISTS (SELECT * FROM INSERTED I 
\end_layout

\begin_layout Plain Layout

		WHERE NOT EXISTS (SELECT * FROM Dept D WHERE D.DNo=I.DeptNo))
\end_layout

\begin_layout Plain Layout

THEN UPDATE Emp
\end_layout

\begin_layout Plain Layout

	SET DeptNo = NULL
\end_layout

\begin_layout Plain Layout

	WHERE EmpNo IN (SELECT EmpNo FROM INSERTED I) AND
\end_layout

\begin_layout Plain Layout

		NOT EXISTS (SELECT * FROM Dept D WHERE D.DNo=Emp.DeptNo);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

CREATE RULE DeptEmp2 ON Emp
\end_layout

\begin_layout Plain Layout

WHEN UPDATED(DeptNo)
\end_layout

\begin_layout Plain Layout

IF EXISTS (SELECT * FROM INSERTED I JOIN DELETED D ON I.EmpNo = D.EmpNo
\end_layout

\begin_layout Plain Layout

		WHERE NOT EXISTS (SELECT * FROM Dept D WHERE D.DNo=Emp.DeptNo))
\end_layout

\begin_layout Plain Layout

THEN UPDATE Emp
\end_layout

\begin_layout Plain Layout

	SET DeptNo = 99
\end_layout

\begin_layout Plain Layout

	WHERE EmpNo IN (SELECT EmpNo FROM INSERTED I JOIN DELETED D ON I.EmpNo =
 D.EmpNo)
\end_layout

\begin_layout Plain Layout

		AND NOT EXISTS (SELECT * FROM Dept D WHERE D.DNo = Emp.DeptNo);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

CREATE RULE DeptEmp3 ON Dept
\end_layout

\begin_layout Plain Layout

WHEN UPDATED(DNo), DELETED
\end_layout

\begin_layout Plain Layout

IF EXISTS (SELECT * FROM Emp 
\end_layout

\begin_layout Plain Layout

			WHERE EXISTS(SELECT * FROM DELETED D WHERE D.DNo = Emp.DeptNo))
\end_layout

\begin_layout Plain Layout

THEN DELETE FROM Emp
\end_layout

\begin_layout Plain Layout

	WHERE EXISTS(SELECT * FROM DELETED D WHERE D.DNo = Emp.DeptNo));
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Management of Derived Data
\end_layout

\begin_layout Standard
A 
\series bold
view
\series default
 can be seen as a query on the DB which returns a relation or a class that
 can be used as any other relation or class.
 A 
\series bold
derived attribute
\series default
 is an attribute that can be computed from other attributes in the DB.
 Both a view and a derived attribute can be expressed with declarative query
 language or deductive rules.
 There are two strategies for derived data:
\end_layout

\begin_layout Enumerate

\series bold
Virtually supported
\series default
: their content is computed on demand.
\end_layout

\begin_layout Enumerate

\series bold
Materialized
\series default
: their content is stored in the database, and it must be recomputed whenever
 the source of data is changed.
\end_layout

\begin_layout Subsubsection
Virtual views with rules
\end_layout

\begin_layout Standard
When an application queries a view, a rule is triggered on the request and
 the action substitutes and evaluates the view definition.
 It requires an event, triggered by queries, and an INSTEAD OF clause in
 rule language.
\end_layout

\begin_layout Standard
There exist two basic strategies:
\end_layout

\begin_layout Itemize

\series bold
Refresh
\series default
: recompute the view from scratch after each update of the source data.
\end_layout

\begin_layout Itemize

\series bold
Incremental
\series default
: compute changes to the view from changes in the source relations, using
 positive and negative deltas (a 
\series bold
delta
\series default
 shows the changes experienced in the database.
 INSERTED and DELETED are one way to implement deltas).
\end_layout

\begin_layout Standard
The rule generation can be automated.
 Refresh rules are simple, but can be very inefficient.
 On the other hand, incremental rules depend on the structure of derivation
 rules, and can be complex.
\end_layout

\begin_layout Example
Imagine we have the following view definition:
\end_layout

\begin_layout Example
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

DEFINE VIEW HighPaidDept AS
\end_layout

\begin_layout Plain Layout

	(SELECT DISTINCT Dept.Name
\end_layout

\begin_layout Plain Layout

	FROM Dept, Emp
\end_layout

\begin_layout Plain Layout

	WHERE Dept.Dno = Emp.DeptNo AND Emp.Sal > 50000);
\end_layout

\end_inset

So this view holds are departments in which some employee earns more than
 50k€ a year.
 This view can change whenever an employee is inserted or deleted, its departmen
t is changed or is salary is changed; and whenever a department is inserted
 or deleted, or its Dno is updated.
\end_layout

\begin_layout Example
A refresh rule defined in Starburst to handle this changes is:
\end_layout

\begin_layout Example
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

CREATE RULE RefreshHighPaidDept1 ON Emp
\end_layout

\begin_layout Plain Layout

WHEN INSERTED, DELETED, UPDATED(DeptNo), UPDATED(Sal)
\end_layout

\begin_layout Plain Layout

THEN DELETE * FROM HighPaidDept;
\end_layout

\begin_layout Plain Layout

	INSERT INTO HighPaidDept
\end_layout

\begin_layout Plain Layout

		(SELECT DISTINCT Dept.Name
\end_layout

\begin_layout Plain Layout

		FROM Dept, Emp
\end_layout

\begin_layout Plain Layout

		WHERE Dept.Dno = Emp.DeptNo AND Emp.Sal > 50000);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

CREATE RULE RefreshHighPaidDept2 ON Dept
\end_layout

\begin_layout Plain Layout

WHEN INSERTED, DELETED, UPDATED(Dno)
\end_layout

\begin_layout Plain Layout

THEN DELETE * FROM HighPaidDept;
\end_layout

\begin_layout Plain Layout

	INSERT INTO HighPaidDept
\end_layout

\begin_layout Plain Layout

		(SELECT DISTINCT Dept.Name
\end_layout

\begin_layout Plain Layout

		FROM Dept, Emp
\end_layout

\begin_layout Plain Layout

		WHERE Dept.Dno = Emp.DeptNo AND Emp.Sal > 50000);
\end_layout

\end_inset


\end_layout

\begin_layout Example
As we can see, all elements from the view are deleted, and the view is recompute
d entirely.
 The incremental approach is more complex.
 As an example, let's define the rule for the case of Insert Dept:
\end_layout

\begin_layout Example
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

CREATE RULE IncHighPaidDept1 ON Dept
\end_layout

\begin_layout Plain Layout

WHEN INSERTED
\end_layout

\begin_layout Plain Layout

THEN INSERT INTO HighPaidDept
\end_layout

\begin_layout Plain Layout

	(SELECT DISTINCT Dept.Name
\end_layout

\begin_layout Plain Layout

	FROM INSERTED I, Emp
\end_layout

\begin_layout Plain Layout

	WHERE I.Dno = Emp.DeptNo AND Emp.Sal > 50000);
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Replication with rules
\end_layout

\begin_layout Standard
Replication consists on storing several copies of the same information.
 This is a common practice in distributed databases.
 Keeping 
\series bold
fully synchronized copies
\series default
 is usually very costly and unnecessary, so it is common to use aynchronous
 techniques to propagate changes between nodes.
\end_layout

\begin_layout Itemize

\series bold
Assymmetric replication
\series default
: in this case there exists a primary copy, in which changes are performed,
 and several secondary copies, which are read only and are updated asynchronousl
y.
 The 
\series bold
capture module
\series default
 monitors changes made by applications to the primary copy, and the 
\series bold
application module
\series default
 propagates these changes to the secondary copies.
\end_layout

\begin_layout Itemize

\series bold
Symmetric replication
\series default
: all copies accept updates asynchronously and each of them has a capture
 and an application modules.
 It is needed to be careful, because simultaneous updates may cause loss
 of consistency.
\end_layout

\begin_layout Example
An example of capturing changes into deltas in Starburst:
\end_layout

\begin_layout Example
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

CREATE RULE Capture1 ON PrimaryCopy
\end_layout

\begin_layout Plain Layout

WHEN INSERTED
\end_layout

\begin_layout Plain Layout

THEN INSERT INTO PosDelta (SELECT * FROM INSERTED);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

CREATE RULE Capture2 ON PrimaryCopy
\end_layout

\begin_layout Plain Layout

WHEN DELETED
\end_layout

\begin_layout Plain Layout

THEN INSERT INTO NegDelta (SELECT * FROM DELETED);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

CREATE RULE Capture3 ON PrimaryCopy
\end_layout

\begin_layout Plain Layout

WHEN UPDATED
\end_layout

\begin_layout Plain Layout

THEN INSERT INTO PosDelta (SELECT * FROM INSERTED);
\end_layout

\begin_layout Plain Layout

	INSERT INTO NegDelta (SELECT * FROM DELETED);
\end_layout

\end_inset


\end_layout

\begin_layout Example
The deltas are applied to the copies with a predefined policy, e.g.
 once very hour.
\end_layout

\begin_layout Subsection
Business Rules: Advantages and Difficulties
\end_layout

\begin_layout Subsubsection
Advantages
\end_layout

\begin_layout Itemize
Active rules can impose a central consistent behavior independent of the
 transactions that cause their execution.
\end_layout

\begin_layout Itemize
Active rules enforce data management policies that no transaction can violate.
\end_layout

\begin_layout Itemize
Activities redundantly coded in several applications programs with passive
 DBMSs can be abstracted in a single version as a rule in an active DBMS.
\end_layout

\begin_layout Itemize
Data management policies can evolve by just modifying the rules on the database,
 instead of the application programs (
\series bold
knowledge independence
\series default
).
\end_layout

\begin_layout Subsubsection
Dificulties
\end_layout

\begin_layout Itemize
Rule organization and content are often hard to control and to specify declarati
vely (i.e.
 the rules are hard to code!).
\end_layout

\begin_layout Itemize
Understanding active rules can be difficult, because they can react to intricate
 event sequences and the outcome of rule processing can depend on the order
 of the event ocurrences and the rule scheduling, which can be hard to analyze
 in complex systems.
\end_layout

\begin_layout Itemize
There are no easy-to-use nor one-fits-all techniques for designing, debugging,
 verifying and monitoring rules.
\end_layout

\begin_layout Subsection
A case study: Energy Management System
\end_layout

\begin_layout Standard
This is an example of an application modeled with active rules, covering
 the business process:
\end_layout

\begin_layout Standard
\align center

\emph on
'Management of the Italian electrical power distribution network.'
\end_layout

\begin_layout Standard
The operational network is a forest of trees, connecting power distributors
 to users.
 The operating conditions are monitored constantly with frequent reconfiguration
s: the structure of the network is dynamic.
 The topology is modified less frequently (we can consider it static).
 The 
\series bold
objective
\series default
 is to transfer the exact power from distributors to users through nodes
 and directed branches connecting pairs of nodes.
\end_layout

\begin_layout Standard
In this scenario, active rules are used to respond to input transactions
 asking for:
\end_layout

\begin_layout Itemize
Reconfigurations due to new users.
\end_layout

\begin_layout Itemize
Changes in their required power.
\end_layout

\begin_layout Itemize
Changes in the assignment of wires.
\end_layout

\begin_layout Standard
The 
\series bold
schema 
\series default
of the database is:
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family typewriter
User(
\bar under
UserId
\bar default
, BranchIn, Power) foreign key (BranchIn) References Branch
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family typewriter
Branch(
\bar under
BranchId
\bar default
, FromNode, ToNode, Power)
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family typewriter
Node(
\bar under
NodeId
\bar default
, BranchIn, Power) foreign key (BranchIn) References Branch
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family typewriter
Distributor(
\bar under
NodeId
\bar default
, Power, MaxPower)
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family typewriter
Wire(
\bar under
WireId
\bar default
, BranchId, WireType, Power) foreign key (BranchId) references Branch foreign
 key (WirteType) references WireType
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
WireType(
\bar under
WireTypeId
\bar default
, MaxPower)
\end_layout

\begin_layout Standard
The network is composed of sites anc onnections between pairs of sites:
\end_layout

\begin_layout Itemize
Sites comprise:
\end_layout

\begin_deeper
\begin_layout Itemize
Power stations: distributors where power is generated and fed into the network.
\end_layout

\begin_layout Itemize
Intermediate nodes: nodes where power is transferred to be redistributed
 across the network.
\end_layout

\begin_layout Itemize
Final users of electrical power.
\end_layout

\end_deeper
\begin_layout Itemize
Connections are called branches:
\end_layout

\begin_deeper
\begin_layout Itemize
class Branch describes all connections between pairs of sites.
\end_layout

\begin_layout Itemize
Several Wires are placed along the branches.
\end_layout

\begin_layout Itemize
Wires are made of a given WireType, each type carrying a maximum power.
\end_layout

\begin_layout Itemize
Branches can be dinamically added or dropeed to the network.
\end_layout

\end_deeper
\begin_layout Standard
The 
\series bold
business rules
\series default
 are the following:
\end_layout

\begin_layout Itemize
Several user requests are gathered in a transaction.
\end_layout

\begin_layout Itemize
If the power requested on wires excees the maximum power of the wire type,
 rules change or add wires in the relevant branches.
\end_layout

\begin_layout Itemize
Rules propagate changes up in the tree, adapting the network to new user
 needs.
\end_layout

\begin_layout Itemize
A transaction fails if the maximum power requested from some distributor
 exceeds the maximum power available at the distributor (in that case, the
 static network needs to be redesigned, but this is out of our scope).
\end_layout

\begin_layout Itemize
To avoid unnecessary rollbacks, rules propagate reductions of power first,
 then increases of power.
 This requires setting the order in which the triggers execute
\begin_inset Foot
status open

\begin_layout Plain Layout
This means we cannot perform this use case in SQL Server because the order
 of the rules cannot be specified.
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Connect a new user
\end_layout

\begin_layout Standard
A new user is connecting to a node with the following procedure:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

CREATE PROCEDURE insertUser(@Node char(3), @Power int) AS
\end_layout

\begin_layout Plain Layout

	DECLARE @User char(3), @Branch char(3), @Wire char(3)
\end_layout

\begin_layout Plain Layout

	EXEC @User = nextUserId
\end_layout

\begin_layout Plain Layout

	EXEC @Branch = nextBranchId
\end_layout

\begin_layout Plain Layout

	EXEC @Wire = nextWireId
\end_layout

\begin_layout Plain Layout

	INSERT INTO Branch (BranchId, FromNode, ToNode, Power)
\end_layout

\begin_layout Plain Layout

		VALUES (@Branch, @User, @Node, @Power)
\end_layout

\begin_layout Plain Layout

	INSERT INTO Wire (WireId, Branch, WireType, Power)
\end_layout

\begin_layout Plain Layout

		VALUES (@Wire, @Branch, 'WT1', @Power)
\end_layout

\begin_layout Plain Layout

	INSERT INTO User (UserId, BranchIn, Power)
\end_layout

\begin_layout Plain Layout

		VALUES (@User, @Branch, @Power);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The node to which a user is connected is determined by an external application:
 usually its closest node.
 'WT1' is the basic wire type.
 nextUserId, nextBranchId and nextWireId procedures are used to obtain the
 next identifier of a user, branch or wire.
\end_layout

\begin_layout Subsubsection
Propagation of power reduction from a user
\end_layout

\begin_layout Standard
If a user requires less power, this change needs to be propagated to its
 input branch:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

CREATE TRIGGER T1_User_Branch ON User
\end_layout

\begin_layout Plain Layout

AFTER UPDATE AS
\end_layout

\begin_layout Plain Layout

-- If some user has decreased its power consumption
\end_layout

\begin_layout Plain Layout

IF EXISTS (SELECT * FROM Inserted I JOIN Deleted D 
\end_layout

\begin_layout Plain Layout

		ON I.UserId = D.UserId WHERE D.Power > I.Power)
\end_layout

\begin_layout Plain Layout

BEGIN
\end_layout

\begin_layout Plain Layout

	UPDATE Branch
\end_layout

\begin_layout Plain Layout

-- Decrease the power consumption by the difference between the past and
 the new values
\end_layout

\begin_layout Plain Layout

	SET Power = Power - (SELECT D.Power - I.Power
\end_layout

\begin_layout Plain Layout

				FROM Inserted I JOIN Deleted D ON I.UserId = D.UserId
\end_layout

\begin_layout Plain Layout

				WHERE I.BranchIn = BranchIn AND D.Power > I.Power) -- Make sure the branch
 is the correct one
\end_layout

\begin_layout Plain Layout

	WHERE BranchId IN (SELECT BranchIn FROM Inserted)
\end_layout

\begin_layout Plain Layout

END;
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Propagation of power reduction from a node
\end_layout

\begin_layout Standard
If a node require less power, propagate the change to its input branch:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

CREATE TRIGGER T2_Node_Branch ON Node
\end_layout

\begin_layout Plain Layout

AFTER UPDATE AS
\end_layout

\begin_layout Plain Layout

-- If some node has decreased its power consumption
\end_layout

\begin_layout Plain Layout

IF EXISTS (SELECT * FROM Inserted I JOIN Deleted D 
\end_layout

\begin_layout Plain Layout

		ON I.NodeId = D.NodeId WHERE D.Power > I.Power)
\end_layout

\begin_layout Plain Layout

BEGIN
\end_layout

\begin_layout Plain Layout

	UPDATE Branch
\end_layout

\begin_layout Plain Layout

-- Decrease the power consumption by the difference between the past and
 the new values
\end_layout

\begin_layout Plain Layout

	SET Power = Power - (SELECT D.Power - I.Power
\end_layout

\begin_layout Plain Layout

				FROM Inserted I JOIN Deleted D ON I.NodeId = D.NodeId
\end_layout

\begin_layout Plain Layout

				WHERE I.BranchIn = BranchIn AND D.Power > I.Power) -- Make sure the branch
 is the correct one
\end_layout

\begin_layout Plain Layout

	WHERE BranchId IN (SELECT BranchIn FROM Inserted)
\end_layout

\begin_layout Plain Layout

END;
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Propagation of power reduction from a branch to a node
\end_layout

\begin_layout Standard
If a branch connected to a node requires less power, propagate the change
 to its input node.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

CREATE TRIGGER T3_Branch_Node ON Branch
\end_layout

\begin_layout Plain Layout

AFTER UPDATE AS
\end_layout

\begin_layout Plain Layout

-- If some branch has decreased its power consumption
\end_layout

\begin_layout Plain Layout

IF EXISTS (SELECT * FROM Inserted I JOIN Deleted D 
\end_layout

\begin_layout Plain Layout

		ON I.BranchId = D.BranchId 
\end_layout

\begin_layout Plain Layout

		WHERE D.Power > I.Power AND I.ToNode IN (SELECT NodeId FROM Node)) -- toNode
 is not a foreign key, so we need to make sure it is a node
\end_layout

\begin_layout Plain Layout

BEGIN
\end_layout

\begin_layout Plain Layout

	UPDATE Node
\end_layout

\begin_layout Plain Layout

-- Decrease the power consumption by the difference between the past and
 the new values
\end_layout

\begin_layout Plain Layout

	SET Power = Power - (SELECT D.Power - I.Power
\end_layout

\begin_layout Plain Layout

				FROM Inserted I JOIN Deleted D ON I.BranchId = D.BranchId
\end_layout

\begin_layout Plain Layout

				WHERE I.ToNode = NodeId AND D.Power > I.Power) -- Make sure the node is
 the correct one
\end_layout

\begin_layout Plain Layout

	WHERE NodeId IN (SELECT toNode FROM Inserted)
\end_layout

\begin_layout Plain Layout

END;
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Propagation of power reduction from a branch to a distributor
\end_layout

\begin_layout Standard
If a branch connected to a distributor requires less power, propagate the
 change to the distributor.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

CREATE TRIGGER T4_Branch_Distributor ON Branch
\end_layout

\begin_layout Plain Layout

AFTER UPDATE AS
\end_layout

\begin_layout Plain Layout

-- If some branch has decreased its power consumption
\end_layout

\begin_layout Plain Layout

IF EXISTS (SELECT * FROM Inserted I JOIN Deleted D 
\end_layout

\begin_layout Plain Layout

		ON I.BranchId = D.BranchId 
\end_layout

\begin_layout Plain Layout

		WHERE D.Power > I.Power AND I.ToNode IN (SELECT NodeId FROM Distributor))
 -- toNode is not a foreign key, so we need to make sure it is a distributor
\end_layout

\begin_layout Plain Layout

BEGIN
\end_layout

\begin_layout Plain Layout

	UPDATE Distributor
\end_layout

\begin_layout Plain Layout

-- Decrease the power consumption by the difference between the past and
 the new values
\end_layout

\begin_layout Plain Layout

	SET Power = Power - (SELECT D.Power - I.Power
\end_layout

\begin_layout Plain Layout

				FROM Inserted I JOIN Deleted D ON I.BranchId = D.BranchId
\end_layout

\begin_layout Plain Layout

				WHERE I.ToNode = NodeId AND D.Power > I.Power) -- Make sure the node is
 the correct one
\end_layout

\begin_layout Plain Layout

	WHERE NodeId IN (SELECT BranchIn FROM Inserted)
\end_layout

\begin_layout Plain Layout

END;
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Propagation of power increase from a user
\end_layout

\begin_layout Standard
If a user requires more power, propagate the change to its input branch.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

CREATE TRIGGER T5_User_Branch ON User
\end_layout

\begin_layout Plain Layout

AFTER UPDATE AS
\end_layout

\begin_layout Plain Layout

-- If some user has increased its power consumption
\end_layout

\begin_layout Plain Layout

IF EXISTS (SELECT * FROM Inserted I JOIN Deleted D 
\end_layout

\begin_layout Plain Layout

		ON I.UserId = D.UserId WHERE D.Power < I.Power)
\end_layout

\begin_layout Plain Layout

BEGIN
\end_layout

\begin_layout Plain Layout

	UPDATE Branch
\end_layout

\begin_layout Plain Layout

-- Increase the power consumption by the difference between the new and
 the past values
\end_layout

\begin_layout Plain Layout

	SET Power = Power - (SELECT D.Power - I.Power
\end_layout

\begin_layout Plain Layout

				FROM Inserted I JOIN Deleted D ON I.UserId = D.UserId
\end_layout

\begin_layout Plain Layout

				WHERE I.BranchIn = BranchIn AND D.Power < I.Power) -- Make sure the branch
 is the correct one
\end_layout

\begin_layout Plain Layout

	WHERE BranchId IN (SELECT BranchIn FROM Inserted)
\end_layout

\begin_layout Plain Layout

END;
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Propagation of power increase from a node
\end_layout

\begin_layout Standard
If a node require more power, propagate the change to its input branch:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

CREATE TRIGGER T6_Node_Branch ON Node
\end_layout

\begin_layout Plain Layout

AFTER UPDATE AS
\end_layout

\begin_layout Plain Layout

-- If some node has increased its power consumption
\end_layout

\begin_layout Plain Layout

IF EXISTS (SELECT * FROM Inserted I JOIN Deleted D 
\end_layout

\begin_layout Plain Layout

		ON I.NodeId = D.NodeId WHERE D.Power < I.Power)
\end_layout

\begin_layout Plain Layout

BEGIN
\end_layout

\begin_layout Plain Layout

	UPDATE Branch
\end_layout

\begin_layout Plain Layout

-- Increase the power consumption by the difference between the new and
 the past values
\end_layout

\begin_layout Plain Layout

	SET Power = Power - (SELECT D.Power - I.Power
\end_layout

\begin_layout Plain Layout

				FROM Inserted I JOIN Deleted D ON I.NodeId = D.NodeId
\end_layout

\begin_layout Plain Layout

				WHERE I.BranchIn = BranchIn AND D.Power < I.Power) -- Make sure the branch
 is the correct one
\end_layout

\begin_layout Plain Layout

	WHERE BranchId IN (SELECT BranchIn FROM Inserted)
\end_layout

\begin_layout Plain Layout

END;
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Propagation of power increase from a branch to a node
\end_layout

\begin_layout Standard
If a branch connected to a node requires more power, propagate the change
 to its input node.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

CREATE TRIGGER T7_Branch_Node ON Branch
\end_layout

\begin_layout Plain Layout

AFTER UPDATE AS
\end_layout

\begin_layout Plain Layout

-- If some branch has increased its power consumption
\end_layout

\begin_layout Plain Layout

IF EXISTS (SELECT * FROM Inserted I JOIN Deleted D 
\end_layout

\begin_layout Plain Layout

		ON I.BranchId = D.BranchId 
\end_layout

\begin_layout Plain Layout

		WHERE D.Power < I.Power AND I.ToNode IN (SELECT NodeId FROM Node)) -- toNode
 is not a foreign key, so we need to make sure it is a node
\end_layout

\begin_layout Plain Layout

BEGIN
\end_layout

\begin_layout Plain Layout

	UPDATE Node
\end_layout

\begin_layout Plain Layout

-- Increase the power consumption by the difference between the new and
 the past values
\end_layout

\begin_layout Plain Layout

	SET Power = Power - (SELECT D.Power - I.Power
\end_layout

\begin_layout Plain Layout

				FROM Inserted I JOIN Deleted D ON I.BranchId = D.BranchId
\end_layout

\begin_layout Plain Layout

				WHERE I.ToNode = NodeId AND D.Power < I.Power) -- Make sure the node is
 the correct one
\end_layout

\begin_layout Plain Layout

	WHERE NodeId IN (SELECT toNode FROM Inserted)
\end_layout

\begin_layout Plain Layout

END;
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Propagation of power increase from a branch to a distributor
\end_layout

\begin_layout Standard
If a branch connected to a distributor requires more power, propagate the
 change to the distributor.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

CREATE TRIGGER T8_Branch_Distributor ON Branch
\end_layout

\begin_layout Plain Layout

AFTER UPDATE AS
\end_layout

\begin_layout Plain Layout

-- If some branch has increased its power consumption
\end_layout

\begin_layout Plain Layout

IF EXISTS (SELECT * FROM Inserted I JOIN Deleted D 
\end_layout

\begin_layout Plain Layout

		ON I.BranchId = D.BranchId 
\end_layout

\begin_layout Plain Layout

		WHERE D.Power < I.Power AND I.ToNode IN (SELECT NodeId FROM Distributor))
 -- toNode is not a foreign key, so we need to make sure it is a distributor
\end_layout

\begin_layout Plain Layout

BEGIN
\end_layout

\begin_layout Plain Layout

	UPDATE Distributor
\end_layout

\begin_layout Plain Layout

-- Increase the power consumption by the difference between the new and
 the past values
\end_layout

\begin_layout Plain Layout

	SET Power = Power - (SELECT D.Power - I.Power
\end_layout

\begin_layout Plain Layout

				FROM Inserted I JOIN Deleted D ON I.BranchId = D.BranchId
\end_layout

\begin_layout Plain Layout

				WHERE I.ToNode = NodeId AND D.Power < I.Power) -- Make sure the node is
 the correct one
\end_layout

\begin_layout Plain Layout

	WHERE NodeId IN (SELECT BranchIn FROM Inserted)
\end_layout

\begin_layout Plain Layout

END;
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Excess power requested from a distributor
\end_layout

\begin_layout Standard
If the power requested from a distributor exceeds its maximum, rollback
 the entire transaction.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

CREATE TRIGGER T9_Distributor ON Distributor
\end_layout

\begin_layout Plain Layout

AFTER UPDATE AS
\end_layout

\begin_layout Plain Layout

-- If some distributor has increased its power consumption exceeding its
 maximum capacity
\end_layout

\begin_layout Plain Layout

IF EXISTS (SELECT * FROM Inserted I WHERE I.Power > I.MaxPower)
\end_layout

\begin_layout Plain Layout

BEGIN
\end_layout

\begin_layout Plain Layout

	RAISERROR 13000 'Maximum capacity of the distributor exceeded'
\end_layout

\begin_layout Plain Layout

	ROLLBACK
\end_layout

\begin_layout Plain Layout

END;
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Propagate power change from a branch to its wires
\end_layout

\begin_layout Standard
If the power of a branch is changed, distributes the change equally on its
 wires.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

CREATE TRIGGER T10_Branch_Wire ON Branch
\end_layout

\begin_layout Plain Layout

AFTER UPDATE AS
\end_layout

\begin_layout Plain Layout

BEGIN
\end_layout

\begin_layout Plain Layout

	UPDATE Wire
\end_layout

\begin_layout Plain Layout

-- Divide the difference between past and new power among all wires and
 subtract it from every wire
\end_layout

\begin_layout Plain Layout

-- note that this works independently of the sign of the change
\end_layout

\begin_layout Plain Layout

	SET Power = Power - (
\end_layout

\begin_layout Plain Layout

				(SELECT D.Power - I.Power 
\end_layout

\begin_layout Plain Layout

				FROM Inserted I JOIN Deleted D ON I.BranchId = D.BranchId
\end_layout

\begin_layout Plain Layout

				WHERE I.BranchId = Branch)
\end_layout

\begin_layout Plain Layout

				/
\end_layout

\begin_layout Plain Layout

				(SELECT COUNT(*) FROM Wire W JOIN Inserted I ON I.BranchId = W.Branch
\end_layout

\begin_layout Plain Layout

				WHERE W.Branch = Branch)
\end_layout

\begin_layout Plain Layout

				)
\end_layout

\begin_layout Plain Layout

	WHERE Branch IN (SELECT BranchId FROM Inserted)
\end_layout

\begin_layout Plain Layout

END;
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Change wire type if power passess threshold
\end_layout

\begin_layout Standard
If the power on a wire goes above the allowed threshold, change the wire
 type.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

CREATE TRIGGER T11_Wire_Type on Wire
\end_layout

\begin_layout Plain Layout

AFTER INSERT, UPDATE AS
\end_layout

\begin_layout Plain Layout

IF EXISTS (SELECT * FROM Inserted I JOIN WireType WT
\end_layout

\begin_layout Plain Layout

		ON WireType = WireTypeId
\end_layout

\begin_layout Plain Layout

		WHERE I.Power > WT.MaxPower -- If the power overpass the maximum allowed
\end_layout

\begin_layout Plain Layout

			AND EXISTS (SELECT * FROM WireType WT1 WHERE WT1.MaxPower > I.Power)) --
 And there is a wiretype which can accept the higher power
\end_layout

\begin_layout Plain Layout

BEGIN
\end_layout

\begin_layout Plain Layout

	UPDATE Wire
\end_layout

\begin_layout Plain Layout

	SET WireType = (SELECT WireTypeId 
\end_layout

\begin_layout Plain Layout

					FROM WireType WT
\end_layout

\begin_layout Plain Layout

					WHERE WT.MaxPower >= Power AND
\end_layout

\begin_layout Plain Layout

					NOT EXISTS( -- There are no two different types with the same maxPower,
 so we take the first wireType whose maxPower is sufficient
\end_layout

\begin_layout Plain Layout

						SELECT * FROM WireType WT1
\end_layout

\begin_layout Plain Layout

						WHERE WT1.MaxPower < WT.MaxPower AND WT1.MaxPower >= Power))
\end_layout

\begin_layout Plain Layout

	WHERE WireId IN (SELECT WireId FROM INSERTED I JOIN WireType WT ON WireType
 = WireTypeId -- make sure we take the appropriate WireId
\end_layout

\begin_layout Plain Layout

				WHERE I.Power > WT.MaxPower AND 
\end_layout

\begin_layout Plain Layout

					EXISTS (SELECT * FROM WireType WT1 WHERE WT1.MaxPower > I.Power))
\end_layout

\begin_layout Plain Layout

END;
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Add a wire to a branch
\end_layout

\begin_layout Standard
If there is no suitable wire type, add another wire to the branch.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

CREATE TRIGGER T12_Wire on Wire
\end_layout

\begin_layout Plain Layout

AFTER INSERT, UPDATE AS
\end_layout

\begin_layout Plain Layout

IF EXISTS (SELECT * FROM Inserted I JOIN WireType WT
\end_layout

\begin_layout Plain Layout

		ON WireType = WireTypeId 
\end_layout

\begin_layout Plain Layout

		WHERE I.Power > WT.MaxPower
\end_layout

\begin_layout Plain Layout

			AND I.Power > (SELECT MAX(MaxPower) FROM WireType)) -- the requested power
 is greater than the allowed for every wiretype
\end_layout

\begin_layout Plain Layout

BEGIN
\end_layout

\begin_layout Plain Layout

	DECLARE @nextWire char(3), @BranchId char(3), @WireId char(3), @Power real,
 @MaxPower real
\end_layout

\begin_layout Plain Layout

	DECLARE wires_cursor CURSOR FOR
\end_layout

\begin_layout Plain Layout

		SELECT I.WireId, I.BranchId, I.Power, WT.MaxPower
\end_layout

\begin_layout Plain Layout

		FROM Inserted I JOIN WireType WT ON WireType = WireTypeId
\end_layout

\begin_layout Plain Layout

		WHERE I.Power > WT.MaxPower
\end_layout

\begin_layout Plain Layout

			AND I.Power > (SELECT MAX(MaxPower) FROM WireType)
\end_layout

\begin_layout Plain Layout

	OPEN wires_cursor
\end_layout

\begin_layout Plain Layout

	FETCH NEXT FROM wires_cursor INTO @WireId, @BranchId, @Power, @MaxPower
\end_layout

\begin_layout Plain Layout

	WHILE @@FETCH_STATUS = 0
\end_layout

\begin_layout Plain Layout

	BEGIN
\end_layout

\begin_layout Plain Layout

		EXEC @nextWire = nextWireId
\end_layout

\begin_layout Plain Layout

		INSERT INTO Wire (WireId, BranchId, WireType, Power) VALUES (@nextWire,
 @BranchId, 'WT1', @Power-0.8*@MaxPower)
\end_layout

\begin_layout Plain Layout

		FETCH NEXT FROM wires_cursor INTO @WireId, @BranchId, @Power, @MaxPower
\end_layout

\begin_layout Plain Layout

	END
\end_layout

\begin_layout Plain Layout

	CLOSE wires_cursor
\end_layout

\begin_layout Plain Layout

	DEALLOCATE wires_cursor
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	UPDATE Wire 
\end_layout

\begin_layout Plain Layout

	SET Power = (SELECT 0.8*MaxPower FROM WireType WT WHERE WT.WireTypeId = WireType)
\end_layout

\begin_layout Plain Layout

	WHERE Power > (SELECT MAX(MaxPower) FROM WireType)
\end_layout

\begin_layout Plain Layout

END;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Graph Databases
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Relational DBMSs are too rigid for Big Data scenarios, and not the best
 option for storing unstructured data.
 The one-size-fits-all approach is no longer valid in many scenarios and
 RDBMSs are hard to scale for billions of rows, because data structures
 used in RDBMSs are optimized for systems with small amounts of memory.
\end_layout

\begin_layout Standard

\series bold
NoSQL technologies
\series default
 do not use the relational model for storing data nor retrieving it.
 Also, they don't generally have the concept of schema, so fields can be
 added to any record as desired, without control.
 These characteristics provide ease to run on clusters as well as an increased
 scaling capability, with horizontal scalability in mind.
 But these gains are not free: there is a trade-off in which the traditional
 concept of consistency gets harmed.
 For example, ACID (Atomic, Consistent, Isolated, Durable) transactions
 are not fully supported most of the times.
\end_layout

\begin_layout Standard
There are several types of NoSQL databases, such as Key-Value stores, Column
 stores, Document databases,...
 We are going to focus on Graph Databases.
\end_layout

\begin_layout Subsection
CAP theorem
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
The 
\series bold
consistency 
\series default
of a database is fullfilled when all updates happen equally for all users
 of the database.
\end_layout

\begin_layout Definition
The 
\series bold
availability
\series default
 guarantees that every request receives a response, whether it succeeded
 or failed.
\end_layout

\begin_layout Definition
The 
\series bold
partition tolerance
\series default
 means that the system is able to operate despite arbitrary message lost
 or failure of part of the system.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A database has, ideally, this three properties fullfilled.
 But the CAP theorem ensures that this is impossible:
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Theorem

\series bold
CAP Theorem
\end_layout

\begin_layout Theorem
A distributed data system cannot guarantee consistency (C), availability
 (A) and partition tolerance (P), but only any combination of two of them.
\end_layout

\end_inset


\end_layout

\begin_layout Remark
If the system needs to be distributed, then partition tolerance is a must.
 So, in practice, there is a decision to choose between fullfilling consistency
 or availability for distributed systems.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
Nonetheless, even the perfect form of the three properties cannot be guaranteed
 at once, it is possible to provide fairly good levels of the one that is
 not optimal.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
The 
\series bold
eventual consistency assumption
\series default
: in the absence of new writes, consistency will be acheived eventually,
 and all replicas that are responsible for a data item will agree on the
 same version and return the last updated value.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
With fewer replicas in the system, R/W operations complete more quickly,
 improving latency.
\end_layout

\begin_layout Subsection
Graph DB model: graphs
\end_layout

\begin_layout Standard
In graph databases, the 
\series bold
data and/or the schema
\series default
 are represented by graphs, or by data structures that generalize the notion
 of graph: hypergraphs.
\end_layout

\begin_layout Standard
The 
\series bold
integrity constraints
\series default
 enforce data consistency.
 Constraints can be grouped in: schema-instance consistency, identity and
 referencial integrity, and functional and inclusion dependencies.
\end_layout

\begin_layout Standard
The 
\series bold
data manipulation
\series default
 is expressed by graph transfromations, or by operations whose main primitives
 are on graph features, like paths, neighborhoods, subgraphs, connectivity
 and graph statistics.
\end_layout

\begin_layout Subsection
The Resource Description Framework (RDF) Model
\end_layout

\begin_layout Standard
RDF allows to express facts, such as 
\emph on
'Ana is the mother of Julia.
\emph default
', but we'd like to be able to express more generic knowledge, like 
\emph on
'If somebody has a daughter, then that person is a parent.'
\emph default
.
 This kind of knowledge is called 
\series bold
schema knowledge
\series default
.
 The RDF schema allows us to do some schema knowledge modeling, and the
 Ontology Web Language (OWL) gives even more expressivity.
\end_layout

\begin_layout Standard
A 
\series bold
class
\series default
 is a set of things or resources.
 In RDF, everything is a 
\series bold
resource
\series default
, that belongs to a class (or several classes).
 The classes can be arranged in 
\series bold
hierarchies
\series default
.
 Every resource is a member of the class 
\family sans
rdfs:Class
\family default
.
\end_layout

\begin_layout Example
A hierarchy of classes in RDF:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Graphics
	filename rdf_0.png
	scale 60

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
The different resources are labelled with:
\end_layout

\begin_layout Itemize

\family typewriter
rdfs:Resource
\family default
: class of all resources.
\end_layout

\begin_layout Itemize

\family typewriter
rdf:Property
\family default
: class of all properties.
\end_layout

\begin_layout Itemize

\family typewriter
rdfs:XMLLiteral
\family default
: class of XML resources.
\end_layout

\begin_layout Itemize

\family typewriter
rdfs:Literal
\family default
: each datatype is a subclass.
\end_layout

\begin_layout Itemize

\family typewriter
rdfs:Bag, rdf:Alt, rdf:Seq, rdfs:Container, rdf:List, rdf:nil, rdfs:ContainerMem
bershipProperty.
\end_layout

\begin_layout Itemize

\family typewriter
rdfs:Datatype
\family default
: class of all datatypes.
\end_layout

\begin_layout Itemize

\family typewriter
rdfs:Statement
\family default
.
\end_layout

\begin_layout Standard
In RDF, there exists implicit knowledge, which can be inferred using 
\series bold
deduction
\series default
.
 This knowledge doesn't need to be stated explicitly: which statements are
 logical consequences from others is governed by the formal semantics.
\end_layout

\begin_layout Example
If a RDF document contains 
\emph on
'u rdf:type ex:Textbook'
\emph default
 and 
\emph on
'ex:Textbook rdfs:subClassOf ex:Book'
\emph default
, then it is deduced that 
\emph on
'u rdf:type ex:Book'
\emph default
.
\end_layout

\begin_layout Standard
As can be seen, RDF are usually stored in 
\series bold
triple stores
\series default
 or 
\series bold
quad stores
\series default
, which are a relational DB.
 This means that it is usually not implemented natively as a graph database,
 which makes it harder to do inference.
 It is more usually used as a metadata storage.
\end_layout

\begin_layout Subsection
The property graph data model
\end_layout

\begin_layout Standard
This model is simpler: in this case, the model is a graph, where nodes and
 edges are annotated with properties.
 It is schema-less, meaning there is not an underlying schema to which the
 data has to adhere.
 Inference is not performed.
\end_layout

\begin_layout Standard
There are several types of relationships supported by graph databases:
\end_layout

\begin_layout Itemize

\series bold
Attributes
\series default
: properties that can be uni- or multi- valued.
\end_layout

\begin_layout Itemize

\series bold
Entities
\series default
: groups of real-world objects.
\end_layout

\begin_layout Itemize

\series bold
Neighborhood relations
\series default
: structures to represents neighborhoods of an entity.
\end_layout

\begin_layout Itemize

\series bold
Standard abstractions
\series default
: part-of, composed-by, n-ary associations.
\end_layout

\begin_layout Itemize

\series bold
Derivation and inheritance
\series default
: subclasses and superclasses, relations of instantiations.
\end_layout

\begin_layout Itemize

\series bold
Nested relations
\series default
: recursively specified relations.
\end_layout

\begin_layout Standard
The abstract data type used is a 
\series bold
graph with properties
\series default
, which is a 4-tuple 
\begin_inset Formula $G=\left(V,E,\Sigma,L\right)$
\end_inset

 such that:
\end_layout

\begin_layout Itemize
\begin_inset Formula $V$
\end_inset

 is a finite set of nodes.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\Sigma$
\end_inset

 is a set of labels.
\end_layout

\begin_layout Itemize
\begin_inset Formula $E\subset V\times V$
\end_inset

 is a set of edges representing labelled binary relationships between elements
 in 
\begin_inset Formula $V$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $L$
\end_inset

 is a function, 
\begin_inset Formula $L:V\times V\rightarrow2^{\Sigma}$
\end_inset

, meaning that each edge can by annotated with zero or more labels from
 
\begin_inset Formula $\Sigma$
\end_inset

.
\end_layout

\begin_layout Standard
The basic operations defined over a graph are:
\end_layout

\begin_layout Itemize
\begin_inset Formula $AddNode\left(G,x\right)$
\end_inset

: adds node 
\begin_inset Formula $x$
\end_inset

 to 
\begin_inset Formula $G$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $DeleteNode\left(G,x\right)$
\end_inset

: deletes 
\begin_inset Formula $x$
\end_inset

 from 
\begin_inset Formula $G$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $Adjacent\left(G,x,y\right)$
\end_inset

: tests if there is an edge from 
\begin_inset Formula $x$
\end_inset

 to 
\begin_inset Formula $y$
\end_inset

 in 
\begin_inset Formula $G$
\end_inset

, i.e., if 
\begin_inset Formula $\left(x,y\right)\in E$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $Neighbors\left(G,x\right)$
\end_inset

: returns all nodes 
\begin_inset Formula $y$
\end_inset

 such that 
\begin_inset Formula $\left(x,y\right)\in E$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $AdjacentEdges\left(G,x,y\right)$
\end_inset

: returns the set of lables of edges going from 
\begin_inset Formula $x$
\end_inset

 to 
\begin_inset Formula $y$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $Add\left(G,x,y,l\right)$
\end_inset

: adds an edge between 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 with label 
\begin_inset Formula $l$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $Delete\left(G,x,y,l\right)$
\end_inset

: deletes and edge between 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 with label 
\begin_inset Formula $l$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $Reach\left(G,x,y\right)$
\end_inset

: tests if there is a path from 
\begin_inset Formula $x$
\end_inset

 to 
\begin_inset Formula $y$
\end_inset

.
 A 
\series bold
path
\series default
 between 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 is a subset of nodes 
\begin_inset Formula $z_{1},...,z_{n}$
\end_inset

 such that 
\begin_inset Formula $\left(x,z_{1}\right),\left(z_{n},y\right)\in E$
\end_inset

 and 
\begin_inset Formula $\left(z_{i},z_{i+1}\right)\in E$
\end_inset

 for all 
\begin_inset Formula $i=1,...,n-1$
\end_inset

.
 The 
\series bold
length
\series default
 of the path is how many edges there are from 
\begin_inset Formula $x$
\end_inset

 to 
\begin_inset Formula $y$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $Path\left(G,x,y\right)$
\end_inset

: return a shorthest path from 
\begin_inset Formula $x$
\end_inset

 to 
\begin_inset Formula $y$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $2-hop\left(G,x\right)$
\end_inset

: return the set of nodes that can be reached from 
\begin_inset Formula $x$
\end_inset

 using paths of length 2.
\end_layout

\begin_layout Itemize
\begin_inset Formula $n-hop\left(G,x\right)$
\end_inset

: returns the set of ndoes that can be reached from 
\begin_inset Formula $x$
\end_inset

 using paths of length 
\begin_inset Formula $n$
\end_inset

.
\end_layout

\begin_layout Standard
The notion of graph can be generalized by that of 
\series bold
hypergraph
\series default
, which is a pair 
\begin_inset Formula $H=\left(V,E\right)$
\end_inset

, where 
\begin_inset Formula $V$
\end_inset

 is a set of nodes, and 
\begin_inset Formula $E\subset2^{V}$
\end_inset

 is a set of non-empty subsets of 
\begin_inset Formula $V$
\end_inset

, called 
\series bold
hyperedges
\series default
.
 If 
\begin_inset Formula $V=\left\{ v_{1},...,v_{n}\right\} $
\end_inset

 and 
\begin_inset Formula $E=\left\{ e_{1},...,e_{m}\right\} $
\end_inset

, we can define the 
\series bold
incidence matrix
\series default
 of 
\begin_inset Formula $H$
\end_inset

 as the matrix 
\begin_inset Formula $A=\left(a_{ij}\right)_{n\times m}$
\end_inset

 where
\begin_inset Formula 
\[
a_{ij}=\begin{cases}
1 & if\ v_{i}\in e_{j}\\
0 & otherwise
\end{cases}
\]

\end_inset

 In this case, this is an 
\series bold
undirected hypergraph
\series default
.
 A 
\series bold
directed hypergraph
\series default
 is defined similarly by 
\begin_inset Formula $H=\left(V,E\right)$
\end_inset

 where in this case 
\begin_inset Formula $E\subset2^{V}\times2^{V}$
\end_inset

, meaning that the nodes in the left set are connected to the nodes of the
 right one.
\end_layout

\begin_layout Subsubsection
Implementation: adjacency list
\end_layout

\begin_layout Standard
In an adjacency list, we maintain an array with as many cells as there are
 nodes in the graph, and:
\end_layout

\begin_layout Itemize
For each node, maintain a list of neighbors.
\end_layout

\begin_layout Itemize
If the graph is directed, the list is only containing outgoing nodes.
\end_layout

\begin_layout Standard
This way it is very cheap to obtain neighbors of a node, but it is not suitable
 for checking if there is an edge between two nodes.
\end_layout

\begin_layout Example
This graph
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename graph_0.png
	scale 60

\end_inset


\end_layout

\end_deeper
\begin_layout Example
Is modelled with the following adjacency list:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
v1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
v2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{(v1,{L2}),(v3,{L4})}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
v3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
v4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{(v1,{L1})}
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Subsubsection
Implementation: incidence list
\end_layout

\begin_layout Standard
In this case, we maintain two arrays, one with as many cells as nodes, and
 another one with as many different edges there are in the graph:
\end_layout

\begin_layout Itemize
Vertices and edges are stored as records of objects.
\end_layout

\begin_layout Itemize
Each vertex stores incident edges, labeled as source if the edge goes out,
 or destination if it goes in.
\end_layout

\begin_layout Itemize
Each edge stores incident nodes.
\end_layout

\begin_layout Example
Now, the graph of the previous example is modeled as:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
v1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{(dest,L2),(dest,L1)}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
v2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{(source,L2),(source,L3)}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
v3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{(dest,L3)}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
v4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{(source,L1)}
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
L1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(V4,V1)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
L2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(V2,V1)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
L3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(V2,V3)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Some properties:
\end_layout

\begin_layout Itemize
Storage is 
\begin_inset Formula $O\left(\left|V\right|+\left|E\right|+\left|L\right|\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $Adjacent\left(G,x,y\right)$
\end_inset

 is 
\begin_inset Formula $O\left(\left|E\right|\right)$
\end_inset

, we have to check at most all edges.
\end_layout

\begin_layout Itemize
\begin_inset Formula $Neighbors\left(G,x\right)$
\end_inset

 is 
\begin_inset Formula $O\left(\left|E\right|\right)$
\end_inset

, we go to node 
\begin_inset Formula $x$
\end_inset

 and for each edge marked as source, we visit it and return the correspondant
 destination.
 At most 
\begin_inset Formula $E$
\end_inset

 checks.
\end_layout

\begin_layout Itemize
\begin_inset Formula $AdjacentEdges\left(G,x,y\right)$
\end_inset

 is again 
\begin_inset Formula $O\left(\left|E\right|\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $Add\left(G,x,y,l\right)$
\end_inset

 is 
\begin_inset Formula $O\left(\left|E\right|\right)$
\end_inset

, as well as delete 
\begin_inset Formula $Delete\left(G,x,y,l\right)$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Implementation: adjacency matrix
\end_layout

\begin_layout Standard
In this case, we maintain a matrix of size 
\begin_inset Formula $n\times n$
\end_inset

, where 
\begin_inset Formula $n$
\end_inset

 is the number of nodes:
\end_layout

\begin_layout Itemize
It is a bidimensional graph representation.
\end_layout

\begin_layout Itemize
Rows represents source nodes.
\end_layout

\begin_layout Itemize
Columnds represent destination nodes.
\end_layout

\begin_layout Itemize
Each non-null entry represents that there is an edge from the source node
 to the destination node.
\end_layout

\begin_layout Example
In this case, the example is modelled as
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
v1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
v2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
v3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
v4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
v1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
v2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{L2}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{L3}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
v3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
v4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{L1}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Properties:
\end_layout

\begin_layout Itemize
The storage is 
\begin_inset Formula $O\left(\left|V\right|\times\left|V\right|\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $Adjacent\left(G,x,y\right)$
\end_inset

 is 
\begin_inset Formula $O\left(1\right)$
\end_inset

, we have to check cell 
\begin_inset Formula $\left(x,y\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
Compute the out-degree of a node is 
\begin_inset Formula $O\left(\left|V\right|\right)$
\end_inset

, we have to sum its row.
\end_layout

\begin_layout Itemize
For the in-degree it is also 
\begin_inset Formula $O\left(\left|V\right|\right)$
\end_inset

, we have to sum its column.
\end_layout

\begin_layout Itemize
Adding an edge between two nodes is 
\begin_inset Formula $O\left(1\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
Compute all paths of length 4 between any pair of nodes is 
\begin_inset Formula $O\left(\left|V\right|^{4}\right)$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Implementation: incidence matrix
\end_layout

\begin_layout Standard
In this case, we store a matrix of size 
\begin_inset Formula $n\times m$
\end_inset

, where 
\begin_inset Formula $n$
\end_inset

 is the number of nodes and 
\begin_inset Formula $m$
\end_inset

 is the number of edges:
\end_layout

\begin_layout Itemize
It is also a bidimensional graph representation.
\end_layout

\begin_layout Itemize
Rows represent nodes.
\end_layout

\begin_layout Itemize
Columns represent edges.
\end_layout

\begin_layout Itemize
A non-null entry represents that the node is incident to the edge, and in
 which mode (source or destination).
\end_layout

\begin_layout Example
The example is represented now as
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
L1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
L2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
L3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
v1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
dest
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
dest
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
v2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
source
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
source
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
v3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
dest
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
v4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
source
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Properties:
\end_layout

\begin_layout Itemize
The storage is 
\begin_inset Formula $O\left(\left|V\right|\times\left|E\right|\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $Adjacent\left(G,x,y\right)$
\end_inset

 is 
\begin_inset Formula $O\left(\left|E\right|\right)$
\end_inset


\end_layout

\begin_layout Itemize
Neighbors
\begin_inset Formula $\left(G,x\right)$
\end_inset

 is 
\begin_inset Formula $O\left(\left|V\right|\times\left|E\right|\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $AdjacentEdges\left(G,x,y\right)$
\end_inset

 is 
\begin_inset Formula $O\left(\left|E\right|\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
Adding or deleting an edge between two nodes is 
\begin_inset Formula $O\left(\left|V\right|\right)$
\end_inset

.
\end_layout

\begin_layout Section
Neo4j
\end_layout

\begin_layout Standard
Neo4j is an open source graph DB system implemented in Java which uses a
 labelled attributed multigraph as data model.
 Nodes and edges can have properties, and there are no restrictions on the
 amount of edges between nodes.
 Loops are allowes and there are different types of traversal strategies
 defined.
\end_layout

\begin_layout Standard
It provides APIs for Java and Python and it is embeddable or server-full.
 It provides full ACID transactions.
\end_layout

\begin_layout Standard
Neo4j provides a native graph processing and storage, characterized by 
\series bold
index-free adjacency
\series default
, meaning that each node keeps direct reference to adjacent nodes, acting
 as a local index and making query time independent from graph size for
 many kinds of queries.
\end_layout

\begin_layout Standard
Another good property is that the joins are precomputed in the form of stored
 relationships.
\end_layout

\begin_layout Standard
It uses a high level query language called 
\series bold
Cypher
\series default
.
\end_layout

\begin_layout Subsection
File storage
\end_layout

\begin_layout Standard
Graphs are stored in files.
 There are three different objects:
\end_layout

\begin_layout Itemize

\series bold
Nodes
\series default
: they have a fixed length of 9 B, to make search performant: finding a
 node is 
\begin_inset Formula $O\left(1\right)$
\end_inset

.
 
\end_layout

\begin_deeper
\begin_layout Itemize
Its first byte is an 
\series bold
in-use
\series default
 flag.
\end_layout

\begin_layout Itemize
Then there are 4 B indicating the address of its first relationship.
\end_layout

\begin_layout Itemize
The final 4 B indicate the address of its first property.
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="9">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Node
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
inUse
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
nextRel
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
nextProp
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Relationships
\series default
: they have a fixed length of 33 B.
\end_layout

\begin_deeper
\begin_layout Itemize
Its first byte is an in-use flag.
\end_layout

\begin_layout Itemize
It is organized as double linked list.
\end_layout

\begin_layout Itemize
Each record contians the IDs of the two nodes in the relationship (4B each).
\end_layout

\begin_layout Itemize
There is a pointer to the relationship type (4 B).
\end_layout

\begin_layout Itemize
For each node, there is a pointer to the previous and next relationship
 records (4 B x 2 each).
\end_layout

\begin_layout Itemize
Finally, a pointer to the next property (4 B).
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="33">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Relationship
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
inUse
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
firstNode
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
secondNode
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
relType
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
firstPrevRel
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
firstNextRel
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
secPrevRel
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
secNextRel
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
nextProp
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Properties
\series default
: they have a fixed length of 32 B divided in blocks og 8 B.
\end_layout

\begin_deeper
\begin_layout Itemize
It includes the ID of the next property in the properties chain, which is
 thus a single linked list.
\end_layout

\begin_layout Itemize
Each property record holds the property type, a pointer to the property
 index file, holding the property name and a value or a pointer to a dynamic
 structure for long strings or arrays.
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="32">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Property
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
propType
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
propIdxFile
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
value
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
nextProp
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Subsubsection
Caching
\end_layout

\begin_layout Standard
Neo4j uses a cache to divide each store into regions, called 
\series bold
pages
\series default
.
 The cache stores a fixed number of pages per file, which are replaces using
 a Least Frequently Used strategy.
\end_layout

\begin_layout Standard
The cache is optimized for reading, and stores object representationsof
 nodes, relationships, and properties, for fast path traversal.
 In this case, node objects contain properties and references to relationships,
 while relationships contain only their properties.
 This is the opposite of what happens in disk storage, where most informaiton
 is in the relationship records.
\end_layout

\begin_layout Subsection
Cypher
\end_layout

\begin_layout Standard
Cypher is the high level query language used by Neo4j for creating nodes,
 updating/deleting information and querying graphs in a graph database.
\end_layout

\begin_layout Standard
Its functioning is different from that of the relational model.
 In the relational model, we first create the structure of the database,
 and then we store tuples, which must be conformant to the structure.
 The foreign keys are defined at the structural level.
 In Neo4j, nodes and edges are directly created, with their properties,
 labels and types as structural information, but no schema is explicitly
 defined.
 The topology of the graph can be thought as analogous to the foreign key
 in the relational model, but defined at the instance level.
\end_layout

\begin_layout Subsubsection
Nodes
\end_layout

\begin_layout Standard
A node is of the form
\begin_inset Formula 
\[
\left(v\ :l_{1}:...:l_{n}\left\{ P_{1}:v_{1},...,P_{k}:v_{k}\right\} \right)
\]

\end_inset

 where 
\begin_inset Formula $v$
\end_inset

 is the node variable, which identifies the node in an expression, 
\begin_inset Formula $:l_{1}:...:l_{n}$
\end_inset

 is a list of 
\begin_inset Formula $n$
\end_inset

 labels associated with the node, and 
\begin_inset Formula $\left\{ P_{1}:v_{1},...,P_{k}:v_{k}\right\} $
\end_inset

 is a list of 
\begin_inset Formula $k$
\end_inset

 properties associated with the node, and their respective assigned values.
 
\begin_inset Formula $P_{i}$
\end_inset

 is the name of the property, 
\begin_inset Formula $v_{i}$
\end_inset

 is the value.
\end_layout

\begin_layout Standard
To create an empty node:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

CREATE (v)
\end_layout

\begin_layout Plain Layout

RETURN v;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The ID is assigned internally, with a different number each time.
 It can be reused by the system but should not be used in applications:
 it should be considered an internal value to the system.
 RETURN is used to display the node:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado3.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
To create a node with two labels:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

CREATE (v :l1:l2)
\end_layout

\begin_layout Plain Layout

RETURN v;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado4.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
To create a node with one label and 3 properties:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

CREATE (v :l1 {P1:'v1', P2:'v2', P3:['v3_1','v3_2']})
\end_layout

\begin_layout Plain Layout

RETURN v;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado5.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
A 
\series bold
query
\series default
 in Cypher is basically a pattern, which will be fullfilled solving the
 associated pattern-matching problem.
\end_layout

\begin_layout Standard
If we want to add a new label to all nodes previously created:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

MATCH(n)
\end_layout

\begin_layout Plain Layout

SET n :newL
\end_layout

\begin_layout Plain Layout

RETURN n;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado6.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
To delete a label from those nodes with a certain label:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

MATCH(n :matchL)
\end_layout

\begin_layout Plain Layout

REMOVE n :delL
\end_layout

\begin_layout Plain Layout

RETURN n;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A similar thing can be done with properties, which are referred to as node.proper
tyName:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

MATCH(n :matchL)
\end_layout

\begin_layout Plain Layout

REMOVE n.propName1, n.propName2
\end_layout

\begin_layout Plain Layout

RETURN n;
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Edges
\end_layout

\begin_layout Standard
An edge has the form
\begin_inset Formula 
\[
\left(n\right)-\left[e\ :Type\left\{ P_{1}:v_{1},...,P_{k}:v_{k}\right\} \right]->\left(v\right)
\]

\end_inset

 where 
\begin_inset Formula $n$
\end_inset

 is the source node and 
\begin_inset Formula $v$
\end_inset

 is the destination node.
 The edge is defined inside the brackets 
\begin_inset Formula $\left[\right]$
\end_inset

.
 It can also be defined of the form 
\begin_inset Formula $\left(n\right)<-\left[\right]-\left(v\right)$
\end_inset

.
 
\begin_inset Formula $e$
\end_inset

 identifies the edge and 
\begin_inset Formula $Type$
\end_inset

 is a mandatory field prefixed by :.
 Finally, we have again a list of 
\begin_inset Formula $k$
\end_inset

 properties and their values.
\end_layout

\begin_layout Standard
Imagine we have 3 employees and want to create the relationship that one
 of them is the manager of the other two and a date as property.
 We can do that with:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

MATCH(n1 :Employee {Name:'1'}),(n2 :Employee {Name:'m'}),(n3 :Employee {Name:'2'
})
\end_layout

\begin_layout Plain Layout

CREATE (n1)<-[e1:manager_of {From:'Dec22'}]-(n2)-[e2:manager_of {From:'Jan23'}]-
>(n3)
\end_layout

\begin_layout Plain Layout

RETURN e1,e2;
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Queries
\end_layout

\begin_layout Standard
As we have said, Cypher is a high level query language based on pattern
 matching.
 It queries graphs expressing informational or topological conditions.
\end_layout

\begin_layout Itemize
MATCH: expresses a pattern that Neo4j tries to match.
\end_layout

\begin_layout Itemize
OPTIONAL MATCH: is like an outer join, i.e., if it does not find a match,
 puts null.
\end_layout

\begin_layout Itemize
WHERE: it must go together with a MATCH or OPTIONAL MATCH expression.
 No order can be assumed for the evaluation of the conditions in the clause,
 Neo4j will decide.
\end_layout

\begin_layout Itemize
RETURN: the evaluation produces subgraphs, and any portion of the match
 can be returned.
\end_layout

\begin_layout Itemize
RETURN DISTINCT: eliminates duplicates.
\end_layout

\begin_layout Itemize
ORDER BY: orders the results with some condition.
\end_layout

\begin_layout Itemize
LIMIT: returns only part of the result.
 Unless ORDER BY is used, no assumptions can be made about the discarded
 results.
\end_layout

\begin_layout Itemize
SKIP: skips the first results.
 Unless ORDER BY is used, no assumptions can be made about the discarded
 results.
\end_layout

\begin_layout Standard
In addition:
\end_layout

\begin_layout Enumerate
If we don't need to make reference to a node, we can use () with no variable
 inside.
\end_layout

\begin_layout Enumerate
If we don't need to refer to an edge, we can omit it, like (n1)- ->(n2).
\end_layout

\begin_layout Enumerate
If we don't need to consider the direction of the edge, we can use - -.
\end_layout

\begin_layout Enumerate
If a pattern matches more than one label, we can write the OR condition
 as | inside the pattern.
 For example, (n :l1|:l2) matches nodes with label l1 or label l2.
\end_layout

\begin_layout Enumerate
To express a path of any length, use [*].
 For a fixed length m use [*m].
\end_layout

\begin_layout Enumerate
To indicate boundaries to the length of a path, minimum n and maximum m,
 use [*n..m].
 To only limit one end use [*n..], [*..m].
\end_layout

\begin_layout Example
A page X gets a score computed as the sum of all votes given by the pages
 that references it.
 If a page Z references a page X, Z gives X a normalized vote computed as
 the inverse of the number of pages references by Z.
 To prevent votes of self-referencing pages, if Z references X and X references
 Z, Z gives 0 votes to X.
\end_layout

\begin_layout Example
We are asked to compute the page rank for each web page.
 One possible solution is:
\end_layout

\begin_layout Example
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (p)-->(r)
\end_layout

\begin_layout Plain Layout

WITH p, 1/count(r) AS vote
\end_layout

\begin_layout Plain Layout

MATCH (p)-->(x)
\end_layout

\begin_layout Plain Layout

WHERE NOT ((x)-->(p))
\end_layout

\begin_layout Plain Layout

RETURN x, SUM(vote) AS Rank
\end_layout

\begin_layout Plain Layout

ORDER BY x.url
\end_layout

\end_inset


\end_layout

\begin_layout Example
The first MATCH-WITH computes, for each node, the inverse of the number
 of outgoing edges, and passes this number on to the next clause.
 Now, for each of these p nodes, we look for paths of length 1 where no
 reciprocity exists.
\end_layout

\begin_layout Example
Another solution uses COLLECT:
\end_layout

\begin_layout Example
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (p)-->(r)
\end_layout

\begin_layout Plain Layout

WITH p, 1/count(r) AS vote
\end_layout

\begin_layout Plain Layout

MATCH (p)-->(x)
\end_layout

\begin_layout Plain Layout

WHERE NOT ((x)-->(p))
\end_layout

\begin_layout Plain Layout

RETURN x.url, COLLECT(p.url), SUM(vote) AS rank
\end_layout

\begin_layout Plain Layout

ORDER BY x.url
\end_layout

\end_inset


\end_layout

\begin_layout Example
In this case, we are using the COLLECT to get the urls that points to x,
 but x does not point to them, in addition to just computing the value.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Temporal Databases
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
There are many applications in which temporal aspects need to be taken into
 account.
 Some examples are in the academic, accounting, insurance, law, medicine,...
 These applications would greatly benefit from a built-in temporal support
 in the DBMS, which would make application development more efficient with
 a potential increase in performance.
 In this sense, a 
\series bold
temporal DBMS
\series default
 is a DBMS that provides mechanisms to store and manipulate time-varying
 information.
\end_layout

\begin_layout Example
A case study: imagine we have a database for managing personel, with the
 relation 
\family typewriter
Employee(Name, Salary, Title, BirthDate)
\family default
.
 It is easy to know the salary of the employee, or its birthdate:
\end_layout

\begin_layout Example
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

-- Salary
\end_layout

\begin_layout Plain Layout

SELECT Salary
\end_layout

\begin_layout Plain Layout

FROM Employee
\end_layout

\begin_layout Plain Layout

WHERE Name = 'John';
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- Birthdate
\end_layout

\begin_layout Plain Layout

SELECT Birthdate
\end_layout

\begin_layout Plain Layout

FROM Employee
\end_layout

\begin_layout Plain Layout

WHERE Name = 'John';
\end_layout

\end_inset


\end_layout

\begin_layout Example
But it is often the case that we don't only want to store the current state
 of things, but also a history.
 For instance, it can be interesting to store the employment history by
 extending the relation 
\family typewriter
Employee(Name, Salary, Title, BirthDate, FromDate, ToDate).
 A dataset sample for this could be the following:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="6">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Salary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Title
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
BirthDate
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FromDate
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ToDate
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
John
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
60K
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Assistant
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9/9/60
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1/1/95
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1/6/95
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
John
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
70K
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Assistant
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9/9/60
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1/6/95
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1/10/95
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
John
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
70K
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Lecturer
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9/9/60
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1/10/95
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1/2/96
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
John
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
70K
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Professor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9/9/60
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1/2/96
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1/1/97
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Example
For the underlying system, the date columns FromDate and ToDate are no different
 from the BirthDate column, but it is obvious for us that the meaning is
 different: FromDate and ToDate need to be understood together as a period
 of time.
\end_layout

\begin_layout Example
Now, to know the employee's current salary, the query gets more complex:
\end_layout

\begin_layout Example
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT Salary
\end_layout

\begin_layout Plain Layout

FROM Employee
\end_layout

\begin_layout Plain Layout

WHERE Name = 'John' AND FromDate <= CURRENT_TIMESTAMP AND CURRENT_TIMESTAMP
 < ToDate; -- The intervals are [)
\end_layout

\end_inset


\end_layout

\begin_layout Example
Another interesting query that we can think of now is determining the salary
 history, i.e., all different salaries earned by the employee and in which
 period of time the employee was earning that salary.
 For our example, the result would be:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Salary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FromDate
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ToDate
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
John
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
60K
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1/1/95
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1/6/95
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
John
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
70K
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1/6/95
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1/1/97
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Example
But how can we achieve this? 
\end_layout

\begin_deeper
\begin_layout Itemize
One possibility is to print all the history, and let the user merge the
 pertinent periods.
\end_layout

\begin_layout Itemize
Another one is to use SQL as a means to perform this operation: we have
 to find those intervals that overlap or are adjacent and that should be
 merged.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename temporal_0.png
	scale 60

\end_inset


\end_layout

\end_deeper
\begin_layout Example
One way to do this in SQL is performing a loop that merges them in pairs,
 until there is nothing else to merge:
\end_layout

\begin_layout Example
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

CREATE TABLE Temp(Salary, FromDate, ToDate) AS
\end_layout

\begin_layout Plain Layout

	SELECT Salary, FromDate, ToDate
\end_layout

\begin_layout Plain Layout

	FROM Employee
\end_layout

\begin_layout Plain Layout

	WHERE Name = 'John'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

repeat
\end_layout

\begin_layout Plain Layout

	UPDATE Temp T1
\end_layout

\begin_layout Plain Layout

	SET T1.ToDate = (SELECT MAX(T2.ToDate)
\end_layout

\begin_layout Plain Layout

				FROM Temp AS T2
\end_layout

\begin_layout Plain Layout

				WHERE T1.Salary = T2.Salary   -- T1 and T2 have the same salary
\end_layout

\begin_layout Plain Layout

				AND T1.FromDate < T2.FromDate -- T1 starts before T2
\end_layout

\begin_layout Plain Layout

				AND T1.ToDate >= T2.FromDate  -- T1 does not end before T2 begins
\end_layout

\begin_layout Plain Layout

				AND T1.ToDate < T2.ToDate)    -- T1 ends before T2
\end_layout

\begin_layout Plain Layout

	WHERE EXISTS (SELECT * 
\end_layout

\begin_layout Plain Layout

				FROM Temp AS T2
\end_layout

\begin_layout Plain Layout

				WHERE T1.Salary = T2.Salary   
\end_layout

\begin_layout Plain Layout

				AND T1.FromDate < T2.FromDate 
\end_layout

\begin_layout Plain Layout

				AND T1.ToDate >= T2.FromDate 
\end_layout

\begin_layout Plain Layout

				AND T1.ToDate < T2.ToDate)
\end_layout

\begin_layout Plain Layout

until no tuples updated
\end_layout

\end_inset


\end_layout

\begin_layout Example
This loop is executed 
\begin_inset Formula $logN$
\end_inset

 times in the worst case, where 
\begin_inset Formula $N$
\end_inset

 is the number of tuples in a chain of overlapping tuples.
 After the loop, we have to deleted extraneous, non-maximal intervals:
\end_layout

\begin_layout Example
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

DELETE FROM Temp T1
\end_layout

\begin_layout Plain Layout

WHERE EXISTS (
\end_layout

\begin_layout Plain Layout

	SELECT *
\end_layout

\begin_layout Plain Layout

	FROM Temp AS T2
\end_layout

\begin_layout Plain Layout

	WHERE T1.Salary = T2.Salary 
\end_layout

\begin_layout Plain Layout

	AND (
\end_layout

\begin_layout Plain Layout

		(T1.FromDate > T2.FromDate AND T1.ToDate <= T2.ToDate) -- T1 is contained
 in T2 (]
\end_layout

\begin_layout Plain Layout

		OR
\end_layout

\begin_layout Plain Layout

		(T1.FromDate >= T2.FromDate AND T1.ToDate < T2.ToDate) -- T1 is contained
 in T2 [)
\end_layout

\end_inset


\end_layout

\begin_layout Example
The same thing can be achieved by unifying everything using a single SQL
 expression as
\end_layout

\begin_layout Example
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

CREATE TABLE Temp(Salary, FromDate, ToDate) AS
\end_layout

\begin_layout Plain Layout

	SELECT Salary, FromDate, ToDate
\end_layout

\begin_layout Plain Layout

	FROM Employee
\end_layout

\begin_layout Plain Layout

	WHERE Name = 'John'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

SELECT DISTINCT F.Salary, F.FromDate, L.ToDate
\end_layout

\begin_layout Plain Layout

FROM Temp as F, Temp as L
\end_layout

\begin_layout Plain Layout

WHERE F.FromDate < L.ToDate AND F.Salary = L.Salary -- same salary and F starts
 before L
\end_layout

\begin_layout Plain Layout

AND NOT EXISTS (
\end_layout

\begin_layout Plain Layout

	SELECT *
\end_layout

\begin_layout Plain Layout

	FROM Temp AS T
\end_layout

\begin_layout Plain Layout

	WHERE T.Salary = F.Salary
\end_layout

\begin_layout Plain Layout

	AND F.FromDate < T.FromDate AND T.FromDate < L.ToDate -- T happens entirely
 between F and L
\end_layout

\begin_layout Plain Layout

	AND NOT EXISTS (
\end_layout

\begin_layout Plain Layout

		SELECT * 
\end_layout

\begin_layout Plain Layout

		FROM Temp as T1
\end_layout

\begin_layout Plain Layout

		WHERE T1.Salary = F.Salary
\end_layout

\begin_layout Plain Layout

		AND T1.FromDate < F.FromDate AND T.FromDate <= T1.ToDate)) -- T starts in
 the middle of T1, which starts before F
\end_layout

\begin_layout Plain Layout

AND NOT EXISTS (
\end_layout

\begin_layout Plain Layout

	SELECT *
\end_layout

\begin_layout Plain Layout

	FROM Temp AS T2
\end_layout

\begin_layout Plain Layout

	WHERE T2.Salary = F.Salary
\end_layout

\begin_layout Plain Layout

	AND (
\end_layout

\begin_layout Plain Layout

		(T2.FromDate < F.FromDate AND F.FromDate <= T2.ToDate) -- F starts in the
 middle of T2
\end_layout

\begin_layout Plain Layout

		OR
\end_layout

\begin_layout Plain Layout

		(T2.FromDate >= L.ToDate AND L.ToDate < T2.ToDate) -- L ends in the middle
 of T2
\end_layout

\begin_layout Plain Layout

	))
\end_layout

\end_inset


\end_layout

\begin_layout Example
This is a complex query, and the logic is that if we want to merge the periods,
 we want to get a From and a To such that every period contained between
 From and To touches or intersect another period, and no period from outside
 From and To touches or interesects any of the periods inside:
\begin_inset Formula 
\begin{align*}
\left(f.From,t.To\right)\ such\ that\  & \forall x:\left(x.From>f.from\land x.To<t.To\right)\implies\exists y:\left(y.From<x.From\land x.From\leq y.To\right)\\
 & \land\\
 & \nexists x:\left(x.From<f.From\land x.To\geq f.From\right)\lor\left(x.From<t.To\land x.To\geq t.To\right)
\end{align*}

\end_inset

 Now, the 
\begin_inset Formula $\forall$
\end_inset

 cannot be used in SQL, but we can use the fact that 
\begin_inset Formula $\forall x:P\left(x\right)\equiv\lnot\lnot\left(\forall x:P\left(x\right)\right)\equiv\lnot\left(\exists x:\lnot P\left(x\right)\right)\equiv\nexists x:\lnot P\left(x\right)$
\end_inset

, noting also that 
\begin_inset Formula $\lnot\left(A\implies B\right)\equiv A\land\lnot B$
\end_inset

, and that is the query that we have shown above.
 An intuitive visualization is the diagram in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Merging-temporal-intervals."
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename temporal_1.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Merging temporal intervals.
 Blue is permitted; Green, Red and Orange are forbidden.
\begin_inset CommandInset label
LatexCommand label
name "fig:Merging-temporal-intervals."

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Example
Another possibility to achieve this temporal features is to make the attributes
 salary and title temporal, instead of the whole table.
 For this, we can split the information of the table into three tables:
\end_layout

\begin_layout Example

\family typewriter
Employee(Name, BirthDate)
\end_layout

\begin_layout Example

\family typewriter
EmployeeSal(Name, Salary, FromDate, ToDate)
\end_layout

\begin_layout Example

\family typewriter
EmployeeTitle(Name, Title, FromDate, ToDate)
\end_layout

\begin_layout Example
Now, getting the salary history is easier, because we only need to query
 the table 
\family typewriter
EmployeeSal:
\end_layout

\begin_layout Example
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT Salary, FromDate, ToDate
\end_layout

\begin_layout Plain Layout

FROM EmployeeSal
\end_layout

\begin_layout Plain Layout

WHERE Name = 'John'
\end_layout

\end_inset


\end_layout

\begin_layout Example
But, what if we want to obtain the history of the combinations of 
\begin_inset Formula $\left(salary,title\right)$
\end_inset

? We have to perform a 
\series bold
temporal join
\series default
.
 Say we have the following tables:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
EmployeeSal
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Salary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FromDate
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ToDate
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
John
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
60K
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1/1/95
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1/6/95
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
John
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
70K
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1/6/95
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1/1/97
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
EmployeeTitle
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Title
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FromDate
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ToDate
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
John
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Assistant
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1/1/95
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1/10/95
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
John
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Lecturer
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1/10/95
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1/2/96
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
John
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Professor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1/2/96
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1/1/97
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Example
In this case, the answer to our temporal join would be:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
EmployeeSal
\begin_inset Formula $\bowtie$
\end_inset

EmployeeTitle
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Salary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Title
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FromDate
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ToDate
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
John
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
60K
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Assistant
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1/1/95
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1/6/95
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
John
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
70K
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Assistant
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1/6/95
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1/10/95
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
John
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
70K
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Lecturer
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1/10/95
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1/2/96
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
John
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
70K
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Professor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1/2/96
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1/1/97
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Example
For these, again, we could print the two tables and let the user make the
 suitable combinations, but it feels better to solve the problem using SQL.
 The query can be done as:
\end_layout

\begin_layout Example
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT S.Name, Salary, Title, S.FromDate, S.toDate
\end_layout

\begin_layout Plain Layout

FROM EmployeeSal S, EmployeeTitle T
\end_layout

\begin_layout Plain Layout

WHERE S.Name = T.Name -- join by the name of the employee
\end_layout

\begin_layout Plain Layout

	AND T.FromDate <= S.FromDate 
\end_layout

\begin_layout Plain Layout

	AND S.ToDate <= T.ToDate     -- CASE 1: period of S contained in period of
 T
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

UNION ALL
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

SELECT S.Name, Salary, Title, S.FromDate, T.ToDate
\end_layout

\begin_layout Plain Layout

FROM EmployeeSal S, EmployeeTitle T
\end_layout

\begin_layout Plain Layout

WHERE S.Name = T.Name -- join by the name of the employee
\end_layout

\begin_layout Plain Layout

	AND T.FromDate < S.FromDate AND S.FromDate < T.ToDate
\end_layout

\begin_layout Plain Layout

	AND S.ToDate > T.ToDate      -- CASE 2: period of S starts inside period
 of T, and ends after
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

UNION ALL
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

SELECT S.Name, Salary, Title, T.FromDate, S.ToDate
\end_layout

\begin_layout Plain Layout

FROM EmployeeSal S, EmployeeTitle T
\end_layout

\begin_layout Plain Layout

WHERE S.Name = T.Name -- join by the name of the employee
\end_layout

\begin_layout Plain Layout

	AND S.FromDate < T.FromDate AND T.FromDate < S.ToDate
\end_layout

\begin_layout Plain Layout

	AND T.ToDate > S.ToDate      -- CASE 3: period of T starts inside period
 of S, and ends after
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

UNION ALL
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

SELECT S.Name, Salary, Title, T.FromDate, T.toDate
\end_layout

\begin_layout Plain Layout

FROM EmployeeSal S, EmployeeTitle T
\end_layout

\begin_layout Plain Layout

WHERE S.Name = T.Name -- join by the name of the employee
\end_layout

\begin_layout Plain Layout

	AND S.FromDate <= T.FromDate 
\end_layout

\begin_layout Plain Layout

	AND T.ToDate <= S.ToDate     -- CASE 4: period of T contained in period of
 S	
\end_layout

\end_inset


\end_layout

\begin_layout Example
The four cases are depicted in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Temporal-join:-cases."
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Example
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename temporal_2.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Temporal-join:-cases."

\end_inset

Temporal join: cases.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Example
If we are using a system with embedded temporal capabilities, i.e., implementing
 TSQL2 (temporal SQL), we can let the system do it and just perform a join
 as we do it usually:
\end_layout

\begin_layout Example
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT S.Name, Salary, Title
\end_layout

\begin_layout Plain Layout

FROM EmployeeSal S JOIN EmployeeTitle T ON S.Name = T.Name
\end_layout

\end_inset


\end_layout

\begin_layout Section
Time Ontology
\end_layout

\begin_layout Standard
Time can be modelled in several ways, depending on the use case:
\end_layout

\begin_layout Itemize

\series bold
Linear
\series default
: there is a total order in the instants.
\end_layout

\begin_layout Itemize

\series bold
Hypothetical
\series default
: the time is linear to the past, but from the current moment on, there
 several possible timelines.
\end_layout

\begin_layout Itemize

\series bold
Directed Acyclic Graph (DAG)
\series default
: hypothetical approach in which some possible futures can merge.
\end_layout

\begin_layout Itemize

\series bold
Periodic/cyclic time
\series default
: such as weeks, months...
 useful for recurrent processes.
\end_layout

\begin_layout Standard
We are going to assume a linear time structure.
 
\end_layout

\begin_layout Standard
Regarding the limits of the timeline, we can classify it:
\end_layout

\begin_layout Itemize
Unbounded: it is infinite to the past and to the future.
\end_layout

\begin_layout Itemize
Time origin exists: it is bounded on the left, and infinite to the future.
\end_layout

\begin_layout Itemize
Bounded time: it is bounded on both ends.
\end_layout

\begin_layout Standard
Also, the bounds can be unspecified or specified.
\end_layout

\begin_layout Standard
We also need to consider the density of the time measures (i.e.
 what is an instant?).
 In this sense, we can classify the timeline as:
\end_layout

\begin_layout Itemize
Discrete: the timeline is isomorphic to the integers.
 This means it is composed of a sequence of non-descomposable time periods,
 of some fixed minimal duration, named 
\series bold
chronons
\series default
 and between a pair of chronons there is a finite number of chronons.
\end_layout

\begin_layout Itemize
Dense: in this case, it is isomorphic to the ration numbers, with an infinite
 number of instants between each pair of chronons.
\end_layout

\begin_layout Itemize
Continuous: the timeline is isomorphic to the real numbers, and again there
 is an infinite amount of instants between each pair of chronons.
\end_layout

\begin_layout Standard
Usually, a distance between chronons can be defined.
\end_layout

\begin_layout Subsection
TSQL2: Time ontology
\end_layout

\begin_layout Standard
TSQL2 uses a linear time structure, bounded on both ends.
 The timeline is composed of chronons, which is the smallest possible granularit
y.
 Consecutive chronons can be grouped together into 
\series bold
granules
\series default
, giving multiple granularities and enable to convert from one another.
 The density is not defined and it is not possible to make questions in
 different granularities.
 The implementation is basically as discrete and the distance between two
 chronons is the amount of chronons in-between.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Plain Layout

\series bold
Temporal Types
\end_layout

\begin_layout Itemize

\series bold
Instant
\series default
: a chronon in the time line.
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
Event
\series default
: an instantaneous fact, something ocurring at an instant.
\end_layout

\begin_layout Itemize

\series bold
Event ocurrence time
\series default
: valid-time instant at which the event occurs in the real world.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Instant set
\end_layout

\begin_layout Itemize

\series bold
Time period
\series default
: the time between two instants (sometimes called interval, but this conflicts
 with the SQL type INTERVAL)
\end_layout

\begin_layout Itemize

\series bold
Time interval
\series default
: a directed duration of time
\end_layout

\begin_layout Itemize

\series bold
Duration
\series default
: an amount of time with a known length, but no specific starting or ending
 instants.
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
Positive interval
\series default
: forward motion time.
\end_layout

\begin_layout Itemize

\series bold
Negative interval
\series default
: backward motion time.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Temporal element
\series default
: finite union of periods.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This way, in SQL92 we have the following Temporal Types:
\end_layout

\begin_layout Itemize
DATE (YYYY-MM-DD)
\end_layout

\begin_layout Itemize
TIME (HH:MM:SS)
\end_layout

\begin_layout Itemize
DATETIME (YYYY-MM-DD HH:MM:SS)
\end_layout

\begin_layout Itemize
INTERVAL (no default granularity)
\end_layout

\begin_layout Standard
And in TSQL2 we have:
\end_layout

\begin_layout Itemize
PERIOD: DATETIME - DATETIME
\end_layout

\begin_layout Subsubsection
Time and facts
\end_layout

\begin_layout Standard
The 
\series bold
valid time of a fact
\series default
 is the time in which the fact is true in the modelled reality, which is
 independant of its recording in the database and can be past, present or
 future.
\end_layout

\begin_layout Standard
The 
\series bold
transaction time of a fact
\series default
 is when the fact is current in the database and may be retrieved.
 
\end_layout

\begin_layout Standard
These two dimensions are orthogonal.
\end_layout

\begin_layout Standard
There are four types of tables:
\end_layout

\begin_layout Itemize

\series bold
Snapshot
\series default
: these are usual SQL table, in which there is no temporality involved.
 What there is in the table is the current truth.
 They can be modified through time, but we only have access to the current
 truth.
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename temporal_4.png
	scale 60

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Transaction Time
\series default
: these tables are a set of snapshots tables, in which the past states can
 be queried for information, but they cannot be modified.
 When the current truth is modified, a snapshot is taken to preserved the
 history of changes.
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename temporal_3.png
	scale 60

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Valid time
\series default
: these are like transaction tables, but in which modification is permitted
 everywhere.
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename temporal_5.png
	scale 60

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Bitemporal
\series default
: in this case, we have valid time tables that can be taken snapshots to
 preserve full states.
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename temporal_6.png
	scale 60

\end_inset


\end_layout

\end_deeper
\begin_layout Section
Temporal Conceptual Modeling
\end_layout

\begin_layout Standard
Conceptual modeling is important because it focuses on the application,
 rather than the implementation.
 Thus, it is technology independent, which enhances the portability and
 the durability of the solution.
 It is also user oriented and uses a formal, unambiguous specification,
 allowing for visual interfaces and teh exchange and integration of information.
\end_layout

\begin_layout Subsection
The conceptual manifesto
\end_layout

\begin_layout Itemize
Semantically powerful data structures.
\end_layout

\begin_layout Itemize
Simple data model, with few clean concepts and standard well-known semantics.
\end_layout

\begin_layout Itemize
No aritifical time objects.
\end_layout

\begin_layout Itemize
Time orthogonal to data structures.
\end_layout

\begin_layout Itemize
Various granularities.
\end_layout

\begin_layout Itemize
Clean, visual notations.
\end_layout

\begin_layout Itemize
Intuitive icons/symbols.
\end_layout

\begin_layout Itemize
Explicit temporal relationships and integrity constraints.
\end_layout

\begin_layout Itemize
Support of valid time and transaction time.
\end_layout

\begin_layout Itemize
Past to future.
\end_layout

\begin_layout Itemize
Co-existence of temporal and tradicional data.
\end_layout

\begin_layout Itemize
Query languages.
\end_layout

\begin_layout Itemize
Complete and precise definition of the model.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pegado7.png
	scale 70

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:An-example-of"

\end_inset

An example of a temporal model in three different ways.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:An-example-of"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we can see three different ways to model a schema.
 Note how they are different, because the temporal attributes are dealt
 with differently in each of the models.
\end_layout

\begin_layout Subsubsection
MADS temporal data types
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pegado8.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
The MADS temporal data types.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Time, SimpleTime and ComplexTime are abstract classes.
\end_layout

\begin_layout Subsubsection
Temporal objects
\end_layout

\begin_layout Standard
A temporal object is marked with the symbol 
\begin_inset Graphics
	filename pegado9.png

\end_inset

, and it indicates that the object has a set of periods of validity associated.
\end_layout

\begin_layout Standard
For example, if we have the relation 
\family typewriter
Employee
\family default

\begin_inset Graphics
	filename pegado9.png

\end_inset


\family typewriter
(name, birthDate, address, salary, projects (1..n))
\family default
, then, an instance of the relation can be:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="6">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multirow="3" alignment="center" valignment="middle" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Peter
\end_layout

\end_inset
</cell>
<cell multirow="3" alignment="center" valignment="middle" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8/9/64
\end_layout

\end_inset
</cell>
<cell multirow="3" alignment="center" valignment="middle" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Rue de la Paix
\end_layout

\end_inset
</cell>
<cell multirow="3" alignment="center" valignment="middle" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5000
\end_layout

\end_inset
</cell>
<cell multirow="3" alignment="center" valignment="middle" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{MADS, HELIOS}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color red
[7/94-6/96] [7/97-6/98] Active
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color red
[7/96-7/97] Suspended
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
The red colored text are the life cycle information of the record.
\end_layout

\begin_layout Standard
The life cycle of an object can be 
\series bold
continuous
\series default
 if there are no gaps between its creation and its deletion, or 
\series bold
discontinuous
\series default
 if such gaps exist.
\end_layout

\begin_layout Subsubsection
Non-temporal objects
\end_layout

\begin_layout Standard
Non-temporal objects can be modeled with the absence of a lifecycle, or
 with a default life cycle which encodes that it is always active.
 A usual option is to put it as 
\begin_inset Formula $\left[0,\infty\right]$
\end_inset

.
\end_layout

\begin_layout Standard
The 
\series bold
TSQL2 policy
\series default
 is that temporal operators are not allowed on non-temporal relations.
 So if we need to perform some kind of temporal operation in non-temporal
 relations, such as a join with a temporal relation, then we need to use
 the default life cycle.
\end_layout

\begin_layout Example
An example is the following query:
\end_layout

\begin_layout Example
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT Dept, Name, COUNT(PID)
\end_layout

\begin_layout Plain Layout

FROM Department, Employee
\end_layout

\begin_layout Plain Layout

WHERE Employee.dept = Department.Dept
\end_layout

\begin_layout Plain Layout

	AND VALID(Employee) OVERLAPS PERIOD '[1/1/96-31/12/96]'
\end_layout

\begin_layout Plain Layout

GROUP BY dept
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Temporal attributes
\end_layout

\begin_layout Standard
A temporal attribute is marked with the symbol 
\begin_inset Graphics
	filename pegado9.png

\end_inset

, and it indicates that the attribute itself has a lifecycle associated.
\end_layout

\begin_layout Standard
For example, if we have the relation 
\family typewriter
Employee(name, birthDate, address, salary
\family default

\begin_inset Graphics
	filename pegado9.png

\end_inset


\family typewriter
, projects (1..n))
\family default
, then, an instance of the relation can be:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="6">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multirow="3" alignment="center" valignment="middle" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Peter
\end_layout

\end_inset
</cell>
<cell multirow="3" alignment="center" valignment="middle" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8/9/64
\end_layout

\end_inset
</cell>
<cell multirow="3" alignment="center" valignment="middle" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Rue de la Paix
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color red
[7/94-6/96] 
\end_layout

\end_inset
</cell>
<cell multirow="3" alignment="center" valignment="middle" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{MADS, HELIOS}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color red
[6/96-Now] 
\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection*
Temporal complex attributes
\end_layout

\begin_layout Standard
It is also possible to have temporal complex attributes, meaning attributes
 with subattributes.
 The temporality can be in either the full attribute, in which case a lifecyle
 will be attached to the whole attribute, or to a subattribute, in which
 case the lifecycle will be attached to only the subattribute.
\end_layout

\begin_layout Standard
For example, can have the relation 
\family typewriter
Laboratory(name, projects (1..n) 
\family default

\begin_inset Graphics
	filename pegado9.png

\end_inset


\family typewriter
 {name, manager, budget}) 
\family default
and the relation 
\family typewriter
Laboratory(name, projects (1..n) {name, manager 
\family default

\begin_inset Graphics
	filename pegado9.png

\end_inset


\family typewriter
, budget}).
\end_layout

\begin_layout Standard
An example of the first relation is:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LBD
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{(MADS,Chris,1500)}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color red
[1/1/95-31/12/95]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{(MADS,Chris,1500),(Helios,Martin,2000)}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color red
[31/12/95-Now]
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
An example of the second relation is:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LBD
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{(MADS,
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Stef
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color red
1/1/95-31/12/95
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Chris
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color red
31/12/95-Now
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset

,1500),(Helios,
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
John
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color blue
31/12/95-Now
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset

,2000)}
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
In this second case, if we update manager, we add one new element to the
 manager history.
 If we update the project name, we would simply change it, because project
 is not temporal.
\end_layout

\begin_layout Subsubsection
Attribute timestamping properties
\end_layout

\begin_layout Itemize
Attribute types / timestamping: none, irregular, regular, instants, durations,...
\end_layout

\begin_layout Itemize
Cardinalities: snapshot and DBlifespan.
\end_layout

\begin_layout Itemize
Identifiers: snapshot or DBlifespan.
\end_layout

\begin_layout Standard
MADS has no implicit constraint, even if they make sense, such as:
\end_layout

\begin_layout Itemize
The validity period of an attribute must be within the lifecycle of the
 object it belongs to.
\end_layout

\begin_layout Itemize
The validity period of a complex attribute is the union of the validity
 periods of its components.
\end_layout

\begin_layout Subsubsection
Temporal generalization
\end_layout

\begin_layout Standard
The life cycles are inherited from parent classes, and more temporal attributes
 can be added.
 For example:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename temporal_7.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
In this case, Employee is temporal, even though its parent is not.
 Employee inherits the temporal attribute address.
\end_layout

\begin_layout Standard
Another example:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename temporal_8.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
In this case, both Temporary and Permanent are temporal objects.
\end_layout

\begin_layout Standard
In the case in which the child is also declared as temporal, it is called
 
\series bold
dynamic temporal generalization
\series default
 and in that case the objects maintains two lifecycles: the one inherited
 from its parent, and the one defined on itself.
 For example:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename temporal_9.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
In this case, Permanent employees have two lifecycles: their lifecycle as
 a permanent and the inherited lifecycle as an employee.
 The redefined life cycle has to be including the one inherited.
\end_layout

\begin_layout Subsubsection
Temporal relationships
\end_layout

\begin_layout Standard
A temporal relationship is also marked with the symbol 
\begin_inset Graphics
	filename pegado9.png

\end_inset

, meaning that the relation between the objects possesses a lifecycle.
\end_layout

\begin_layout Standard
Some usual constraints used in temporal relationships:
\end_layout

\begin_layout Itemize
The 
\series bold
validity period of a relationship
\series default
 must be within the intersection of the life cycles of the objects it links.
\end_layout

\begin_layout Itemize
A temporal relationship can only link temporal objects.
\end_layout

\begin_layout Standard
Again, MADS does not impose any constraints.
\end_layout

\begin_layout Example
Let's see some temporal relationships.
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename temporal_10.png
	scale 60

\end_inset


\end_layout

\end_deeper
\begin_layout Example
In this case, a possible data can be:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Employee
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
e1
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
John
\end_layout

\end_inset
</cell>
<cell multirow="3" alignment="center" valignment="middle" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[7/8/77-Now]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4/7/55
\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bd Haussman
\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
e2
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Peter
\end_layout

\end_inset
</cell>
<cell multirow="3" alignment="center" valignment="middle" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[1/2/78-Now]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8/10/60
\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bd Général Jacques
\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
WorksOn
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
w1
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(e1,p2,
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[7/8/77-Now]
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset

)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[7/8/77-Now]
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
w2
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(e1,p1,
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[7/8/77-1/2/78]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
25
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[1/2/78-Now]
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset

)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[7/8/77-Now]
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
w2
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(e2,p1,
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[1/2/78-Now]
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset

)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[1/2/78-Now]
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Project
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
p1
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MADS
\end_layout

\end_inset
</cell>
<cell multirow="3" alignment="center" valignment="middle" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[1/5/76-Now]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Christine
\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5000
\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
p2
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
HELIOS
\end_layout

\end_inset
</cell>
<cell multirow="3" alignment="center" valignment="middle" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[1/2/78-Now]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yves
\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6000
\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Example
Another example, which is slightly different is the following:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename temporal_11.png
	scale 60

\end_inset


\end_layout

\end_deeper
\begin_layout Example
In this case, the data can be:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Employee
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
e1
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
John
\end_layout

\end_inset
</cell>
<cell multirow="3" alignment="center" valignment="middle" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[7/8/77-Now]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4/7/55
\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bd Haussman
\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
e2
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Peter
\end_layout

\end_inset
</cell>
<cell multirow="3" alignment="center" valignment="middle" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[1/2/78-Now]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8/10/60
\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bd Général Jacques
\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
WorksOn
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
w1
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(e1,p2,
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[7/8/77-Now]
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset

)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
w2
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(e1,p1,
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[7/8/77-1/2/78]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
25
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[1/2/78-Now]
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset

)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
w2
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(e2,p1,
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[1/2/78-Now]
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset

)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Project
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
p1
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MADS
\end_layout

\end_inset
</cell>
<cell multirow="3" alignment="center" valignment="middle" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[1/5/76-Now]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Christine
\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5000
\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
p2
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
HELIOS
\end_layout

\end_inset
</cell>
<cell multirow="3" alignment="center" valignment="middle" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[1/2/78-Now]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yves
\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6000
\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Example
Now, only currently valid tuples are kept in the relationship.
 But for these, the history of hours/week is maintained.
\end_layout

\begin_layout Subsubsection
Synchronization relationships
\end_layout

\begin_layout Standard
They describe temporal constraints between the life cycles of two objects
 and they are expressed with Allen's operator extended for temporal elements:
\end_layout

\begin_layout Itemize
\begin_inset Formula $before\left(i1,i2\right)$
\end_inset

: interval 
\begin_inset Formula $i1$
\end_inset

 ends before 
\begin_inset Formula $i2$
\end_inset

 starts.
\end_layout

\begin_layout Itemize
\begin_inset Formula $meets\left(i1,i2\right)$
\end_inset

: interval 
\begin_inset Formula $i1$
\end_inset

 ends just when 
\begin_inset Formula $i2$
\end_inset

 starts.
\end_layout

\begin_layout Itemize
\begin_inset Formula $overlaps\left(i1,i2\right)$
\end_inset

: intervals 
\begin_inset Formula $i1$
\end_inset

 and 
\begin_inset Formula $i2$
\end_inset

 overlaps at some point.
\end_layout

\begin_layout Itemize
\begin_inset Formula $during\left(i1,i2\right)$
\end_inset

: interval 
\begin_inset Formula $i1$
\end_inset

 is contained inside interval 
\begin_inset Formula $i2$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $starts\left(i1,i2\right)$
\end_inset

: intervals 
\begin_inset Formula $i1$
\end_inset

 and 
\begin_inset Formula $i2$
\end_inset

 start at the same time.
\end_layout

\begin_layout Itemize
\begin_inset Formula $finishes\left(i1,i2\right)$
\end_inset

: intervals 
\begin_inset Formula $i1$
\end_inset

 and 
\begin_inset Formula $i2$
\end_inset

 finish at the same time.
\end_layout

\begin_layout Standard
They can be visually seen in Figure
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pegado10.png

\end_inset


\begin_inset Graphics
	filename pegado11.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Allen's temporal operators and how to express them.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
These relationships express a temporal constraint between the whole life
 cycles or the active periods.
\end_layout

\begin_layout Subsubsection
Example of a temporal schema
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado53.png

\end_inset


\end_layout

\begin_layout Section
Manipulating Temporal Databases with SQL-92
\end_layout

\begin_layout Standard
Data type for periods is not available in SQL-92.
 Thus, a period is simulated with two Date columns: fromDate and toDate,
 indicating the beginning and end of the period, respectively.
 Some notes:
\end_layout

\begin_layout Itemize
The special date '3000-01-01' denotes currently valid.
\end_layout

\begin_layout Itemize
The periods are considered closed-open, [).
\end_layout

\begin_layout Itemize
A table can be viewes as a compact representation of a sequence of snapshot
 tables, each one valid on a particular day.
\end_layout

\begin_layout Subsection
Temporal statements
\end_layout

\begin_layout Standard
Temporal statement apply to queries, modifications, views and integrity
 constraints.
 They are:
\end_layout

\begin_layout Itemize

\series bold
Current
\series default
: applies to the current point in time.
 Example: what is Bob's current position?
\end_layout

\begin_layout Itemize

\series bold
Time-sliced
\series default
: applies to some point in time in the past or in the future.
 Example: what was Bob's position on 1-1-2007?
\end_layout

\begin_layout Itemize

\series bold
Sequenced
\series default
: applies to each point in time.
 Example: what is Bob's position history?
\end_layout

\begin_layout Itemize

\series bold
Non-sequenced
\series default
: applies to all points in time, ignoring the time-varying nature of tables.
 Example: when did Bob changed history?
\end_layout

\begin_layout Subsection
Temporal keys
\end_layout

\begin_layout Standard
Imagine we have the relation 
\family typewriter
Incumbents(SSN,PCN,FromDate,ToDate)
\family default
 and we want to enforce that each employee has only one position at a point
 in time.
 If we use the key of the corresponding non-temporal table, (SSN,PCN), then
 we would not be able to enter the same employee for different periods.
 Thus, we need to somehow include the dates in the key.
 The options are: (SSN,PCN,FromDate), (SSN,PCN,ToDate) or (SSN,PCN,FromDate,ToDa
te).
 None of them captures the constraint that we want to enforce, because there
 are overlapping periods associated with the same SSN: we need a 
\series bold
sequenced constraint
\series default
, applied at each point in time.
 All constraints specified on a snapshot table have sequenced counterparts,
 specified on the analogous valid-time table.
\end_layout

\begin_layout Subsubsection
Sequenced primary key
\end_layout

\begin_layout Example
Employees have only one position at a point in time.
\end_layout

\begin_layout Example
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

CREATE TRIGGER Seq_Primary_Key ON Incumbents FOR INSERT, UPDATE AS
\end_layout

\begin_layout Plain Layout

IF EXISTS( SELECT * 
\end_layout

\begin_layout Plain Layout

		FROM Incumbents I1 
\end_layout

\begin_layout Plain Layout

		WHERE 1 < ( SELECT COUNT(I2.SSN) -- How many entries
\end_layout

\begin_layout Plain Layout

				FROM Incumbents I2
\end_layout

\begin_layout Plain Layout

				WHERE I1.SSN = I2.SSN AND I1.PCN = I2.PCN -- The same employee
\end_layout

\begin_layout Plain Layout

				AND I1.FromDate < I2.ToDate -- I1 starts before I2 ends
\end_layout

\begin_layout Plain Layout

				AND I1.ToDate > I2.FromDate)) -- I1 ends after I2 starts: the two conditions
 are searching for intersections
\end_layout

\begin_layout Plain Layout

	OR EXISTS (SELECT * 
\end_layout

\begin_layout Plain Layout

			FROM Incumbents I
\end_layout

\begin_layout Plain Layout

			WHERE I.SSN IS NULL OR I.PCN IS NULL) -- no NULLS values of SSN and PCN
 can be inserted
\end_layout

\begin_layout Plain Layout

BEGIN
\end_layout

\begin_layout Plain Layout

	RAISERROR('Violation of sequenced primary key constraint',1,2)
\end_layout

\begin_layout Plain Layout

	ROLLBACK TRANSACTION
\end_layout

\begin_layout Plain Layout

END
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Handling Now
\end_layout

\begin_layout Standard
We have to decide how to timestamp current data.
 One alternative is to put NULL in the ToDate, which allows to identify
 current records by checking: 
\family typewriter
WHERE ToDate IS NULL
\family default
.
 But it possesses some disadvantages:
\end_layout

\begin_layout Itemize
Users get confused with a data of NULL.
\end_layout

\begin_layout Itemize
In SQL many comparisons with a NULL return false, so we might exclude some
 rows that should not be excluded from the query.
\end_layout

\begin_layout Itemize
Other uses or NULL are not available.
\end_layout

\begin_layout Standard
Another approach is to set the ToDate to the largest value in the timestamp
 domain: '3000-01-01'.
 The disadvantages of this are:
\end_layout

\begin_layout Itemize
The DB states that something will be true in the far future.
\end_layout

\begin_layout Itemize
'Now' and 'Forever' are represented in the same way.
\end_layout

\begin_layout Subsection
Duplicates
\end_layout

\begin_layout Standard
There are different kind of duplicates in temporal databases:
\end_layout

\begin_layout Itemize

\series bold
Value equivalent
\series default
: the values of the nontimestamp columns are equivalent.
 Example: all rows in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:temp_dup"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Itemize

\series bold
Sequenced duplicates
\series default
: when in some instant, the rows are duplicate.
 Example: rows 1 and 2 in the table.
\end_layout

\begin_layout Itemize

\series bold
Current duplicates
\series default
: they are sequenced duplicates at the current instant.
 Example: rows 4 and 5 in the table.
\end_layout

\begin_layout Itemize

\series bold
Nonsequenced duplicates
\series default
: the values of all columns are identical.
 Example: rows 2 and 3 in the table.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Incumbents
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SSN
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PCN
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FromDate
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ToDate
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
111223333
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
120033
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1996-01-01
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1996-06-01
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
111223333
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
120033
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1996-06-01
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1996-10-01
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
111223333
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
120033
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1996-06-01
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1996-10-01
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
111223333
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
120033
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1996-10-01
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Now
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
111223333
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
120033
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1997-12-01
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Now
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Temporal duplicates example.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "tab:temp_dup"

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Preventing duplicates
\end_layout

\begin_layout Itemize
To prevent value equivalent rows: we define a secondary key using UNIQUE(SSN,PCN
).
\end_layout

\begin_layout Itemize
To prevent nonsequenced duplicates: UNIQUE(SSN,PCN,FromDate,ToDate).
\end_layout

\begin_layout Itemize
To prevent current duplicates: no employee can have two identical positions
 at the current time:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

CREATE TRIGGER Current_Dups ON Incumbents FOR INSERT, UPDATE, DELETE AS
\end_layout

\begin_layout Plain Layout

IF EXISTS( SELECT I1.SSN 
\end_layout

\begin_layout Plain Layout

		FROM Incumbents I1
\end_layout

\begin_layout Plain Layout

		WHERE 1 < (SELECT COUNT(I2.SSN) 
\end_layout

\begin_layout Plain Layout

				FROM Incumbents I2
\end_layout

\begin_layout Plain Layout

				WHERE I1.SSN = I2.SSN AND I1.PCN=I2.PCN
\end_layout

\begin_layout Plain Layout

				AND I1.FromDate <= CURRENT_DATE AND CURRENT_DATE < I1.ToDate -- I1 is
 current
\end_layout

\begin_layout Plain Layout

				AND I2.FromDate <= CURRENT_DATE AND CURRENT_DATE < I2.ToDate )) -- I2
 is current
\end_layout

\begin_layout Plain Layout

BEGIN
\end_layout

\begin_layout Plain Layout

	RAISERROR('Transaction allows current duplicates',1,2)
\end_layout

\begin_layout Plain Layout

	ROLLBACK TRANSACTION
\end_layout

\begin_layout Plain Layout

END
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
To prevent current duplicates, assuming no future data, we notice that current
 data will have the same ToDate, so we set UNIQUE(SSN,PCN,ToDate).
\end_layout

\begin_layout Itemize
To prevent sequenced duplicates, we do as with the trigger for sequenced
 primary keys, but disregarding NULL values (because now we are not making
 a key UNIQUE+NOTNULL, but only UNIQUE):
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

CREATE TRIGGER Seq_Dup ON Incumbents FOR INSERT, UPDATE AS
\end_layout

\begin_layout Plain Layout

IF EXISTS( SELECT * 
\end_layout

\begin_layout Plain Layout

		FROM Incumbents I1 
\end_layout

\begin_layout Plain Layout

		WHERE 1 < ( SELECT COUNT(I2.SSN) -- How many entries
\end_layout

\begin_layout Plain Layout

				FROM Incumbents I2
\end_layout

\begin_layout Plain Layout

				WHERE I1.SSN = I2.SSN AND I1.PCN = I2.PCN -- The same employee
\end_layout

\begin_layout Plain Layout

				AND I1.FromDate < I2.ToDate -- I1 starts before I2 ends
\end_layout

\begin_layout Plain Layout

				AND I1.ToDate > I2.FromDate)) -- I1 ends after I2 starts: the two conditions
 are searching for intersections
\end_layout

\begin_layout Plain Layout

BEGIN
\end_layout

\begin_layout Plain Layout

	RAISERROR('Violation of sequenced primary key constraint',1,2)
\end_layout

\begin_layout Plain Layout

	ROLLBACK TRANSACTION
\end_layout

\begin_layout Plain Layout

END
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
To prevent sequenced duplicates, asumming only modifications to current
 data, we can use UNIQUE(SSN, PCN, ToDate).
\end_layout

\begin_layout Standard
Now, we want to enforce that each employee has at most one position.
 In a snapshot table, this would be equivalent to UNIQUE(SSN), and now the
 sequenced constraint is: at any time each employee has at most one position,
 i.e., SSN is sequenced unique:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

CREATE TRIGGER Seq_Unique ON Incumbents FOR INSERT, UPDATE, DELETE AS
\end_layout

\begin_layout Plain Layout

IF EXISTS( SELECT I1.SSN 
\end_layout

\begin_layout Plain Layout

		FROM Incumbents I1
\end_layout

\begin_layout Plain Layout

		WHERE 1 < ( SELECT COUNT(I2.SSN)
\end_layout

\begin_layout Plain Layout

				FROM Incumbents I2
\end_layout

\begin_layout Plain Layout

				WHERE I1.SSN = I2.SSN
\end_layout

\begin_layout Plain Layout

				AND I1.FromDate < I2.ToDate
\end_layout

\begin_layout Plain Layout

				AND I1.ToDate > I2.FromDate))
\end_layout

\begin_layout Plain Layout

		OR EXISTS (SELECT * FROM Incumbents AS I WHERE I.SSN IS NULL)
\end_layout

\begin_layout Plain Layout

BEGIN
\end_layout

\begin_layout Plain Layout

	RAISERROR('Transaction violates sequenced unique constraint',1,2)
\end_layout

\begin_layout Plain Layout

	ROLLBACK TRANSACTION
\end_layout

\begin_layout Plain Layout

END
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We can also think about the nonsequenced constraint: an employee cannot
 have more than one position over two identical periods, i.e.
 SSN is nonsequenced unique: UNIQUE(SSN,FromDate,ToDate).
\end_layout

\begin_layout Standard
Or current constraint: an employee has at most one position now, i.e.
 SSN is current unique:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

CREATE TRIGGER Current_Unique ON Incumbents FOR INSERT, UPDATE, DELETE AS
\end_layout

\begin_layout Plain Layout

IF EXISTS( SELECT I1.SSN 
\end_layout

\begin_layout Plain Layout

		FROM Incumbents I1
\end_layout

\begin_layout Plain Layout

		WHERE 1 < (SELECT COUNT(I2.SSN) 
\end_layout

\begin_layout Plain Layout

				FROM Incumbents I2
\end_layout

\begin_layout Plain Layout

				WHERE I1.SSN = I2.SSN
\end_layout

\begin_layout Plain Layout

				AND I1.FromDate <= CURRENT_DATE AND CURRENT_DATE < I1.ToDate -- I1 is
 current
\end_layout

\begin_layout Plain Layout

				AND I2.FromDate <= CURRENT_DATE AND CURRENT_DATE < I2.ToDate )) -- I2
 is current
\end_layout

\begin_layout Plain Layout

BEGIN
\end_layout

\begin_layout Plain Layout

	RAISERROR('Transaction allows current duplicates',1,2)
\end_layout

\begin_layout Plain Layout

	ROLLBACK TRANSACTION
\end_layout

\begin_layout Plain Layout

END
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Referential integrity
\end_layout

\begin_layout Standard
We want to enforce that Incumbents.PCN is a foreign key for Position.PCN.
 There several possible cases, depending on what tables are temporal.
\end_layout

\begin_layout Subsubsection
Case 1: neither table is temporal
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

CREATE TABLE Incumbents(
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	PCN CHAR(6) NOT NULL REFERENCES Position,
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Case 2: both tables are temporal
\end_layout

\begin_layout Standard
In this case, if we want the PCN to be a 
\series bold
current foreign key
\series default
, the PCN of all current incumbents must be listed in the current positions:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

CREATE TRIGGER Current_RI ON Incumbents FOR INSERT, UPDATE, DELETE AS
\end_layout

\begin_layout Plain Layout

IF EXISTS( SELECT * 
\end_layout

\begin_layout Plain Layout

		FROM Incumbents I
\end_layout

\begin_layout Plain Layout

		WHERE I.ToDate = '3000-01-01'
\end_layout

\begin_layout Plain Layout

		AND NOT EXISTS( SELECT *
\end_layout

\begin_layout Plain Layout

					FROM Position P
\end_layout

\begin_layout Plain Layout

					WHERE I.PCN = P.PCN -- The position is correct
\end_layout

\begin_layout Plain Layout

					AND P.ToDate='3000-01-01')) -- And is active
\end_layout

\begin_layout Plain Layout

BEGIN
\end_layout

\begin_layout Plain Layout

	RAISERROR('Violation of current referential integrity',1,2)
\end_layout

\begin_layout Plain Layout

	ROLLBACK TRANSACTION
\end_layout

\begin_layout Plain Layout

END
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Or it can be a 
\series bold
sequenced foreign key
\series default
:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

CREATE TRIGGER Seq_RI ON Incumbents FOR INSERT, UPDATE, DELETE AS
\end_layout

\begin_layout Plain Layout

IF EXISTS( SELECT * 
\end_layout

\begin_layout Plain Layout

		FROM Incumbents I
\end_layout

\begin_layout Plain Layout

		WHERE NOT EXISTS( SELECT *
\end_layout

\begin_layout Plain Layout

						FROM Position P
\end_layout

\begin_layout Plain Layout

						WHERE I.PCN = P.PCN 
\end_layout

\begin_layout Plain Layout

						AND P.FromDate <= I.FromDate
\end_layout

\begin_layout Plain Layout

						AND P.ToDate > I.FromDate) -- These two search for P s.t.
 I starts in the middle of P
\end_layout

\begin_layout Plain Layout

		OR NOT EXISTS( SELECT *
\end_layout

\begin_layout Plain Layout

					FROM Position P
\end_layout

\begin_layout Plain Layout

					WHERE I.PCN = P.PCN 
\end_layout

\begin_layout Plain Layout

					AND P.FromDate < I.ToDate
\end_layout

\begin_layout Plain Layout

					AND P.ToDate >= I.ToDate) -- These two search for P s.t.
 I ends in the middle of P
\end_layout

\begin_layout Plain Layout

		OR EXISTS( SELECT * 
\end_layout

\begin_layout Plain Layout

				FROM Position P
\end_layout

\begin_layout Plain Layout

				WHERE I.PCN = P.PCN
\end_layout

\begin_layout Plain Layout

				AND I.FromDate < P.ToDate AND I.ToDate > P.ToDate -- P ends in the middle
 of I
\end_layout

\begin_layout Plain Layout

				AND NOT EXISTS( SELECT *
\end_layout

\begin_layout Plain Layout

								FROM Position P2
\end_layout

\begin_layout Plain Layout

								WHERE P2.PCN = P.PCN 
\end_layout

\begin_layout Plain Layout

								AND P2.FromDate <= P.ToDate
\end_layout

\begin_layout Plain Layout

								AND P2.ToDate > P.ToDate))) -- These two search for P2 that continues
 the RI instead of P
\end_layout

\begin_layout Plain Layout

BEGIN
\end_layout

\begin_layout Plain Layout

	RAISERROR('Violation of sequential referential integrity',1,2)
\end_layout

\begin_layout Plain Layout

	ROLLBACK TRANSACTION
\end_layout

\begin_layout Plain Layout

END
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Contiguous history
\end_layout

\begin_layout Standard
A contiguous history is such that there are no gaps in the history.
 Enforcing contiguous history is a nonsequenced constraint, because it requires
 examining the table at multiple points of time.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

CREATE TRIGGER Cont_History ON Position FOR INSERT, UPDATE, DELETE AS
\end_layout

\begin_layout Plain Layout

IF EXISTS( SELECT * 
\end_layout

\begin_layout Plain Layout

		FROM Position P1, Position P2
\end_layout

\begin_layout Plain Layout

		WHERE P1.PCN = P2.PCN 
\end_layout

\begin_layout Plain Layout

		AND P1.ToDate < P2.FromDate -- If P1 and P2 are separated
\end_layout

\begin_layout Plain Layout

		AND NOT EXISTS( SELECT * 
\end_layout

\begin_layout Plain Layout

					FROM Position P3
\end_layout

\begin_layout Plain Layout

					WHERE P3.PCN = P1.PCN
\end_layout

\begin_layout Plain Layout

					AND (
\end_layout

\begin_layout Plain Layout

						(P3.FromDate <= P1.ToDate AND P3.ToDate > P1.ToDate) -- P3 extends P1
 to the right
\end_layout

\begin_layout Plain Layout

						OR
\end_layout

\begin_layout Plain Layout

						(P3.FromDate < P2.FromDate AND P3.ToDate >= P2.FromDate)))) -- P3 extends
 P2 to the left
\end_layout

\begin_layout Plain Layout

BEGIN
\end_layout

\begin_layout Plain Layout

	RAISERROR('Transaction violates contiguous history',1,2)
\end_layout

\begin_layout Plain Layout

	ROLLBACK TRANSACTION
\end_layout

\begin_layout Plain Layout

END
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We can also have the situation that Incumbents.PCN is a FK for Position.PCN
 and Position.PCN defines a contiguous history.
 In this case, we can omit the part of searching for the P2 that extends
 a P that ends in the middle of I.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

CREATE TRIGGER Seq_RI_CH ON Incumbents FOR INSERT, UPDATE, DELETE AS
\end_layout

\begin_layout Plain Layout

IF EXISTS( SELECT *
\end_layout

\begin_layout Plain Layout

		FROM Incumbents I
\end_layout

\begin_layout Plain Layout

		WHERE NOT EXISTS( SELECT * 
\end_layout

\begin_layout Plain Layout

						FROM Position P
\end_layout

\begin_layout Plain Layout

						WHERE I.PCN = P.PCN
\end_layout

\begin_layout Plain Layout

						AND P.FromDate <= I.ToDate AND I.FromDate < P.ToDate)
\end_layout

\begin_layout Plain Layout

		OR NOT EXISTS( SELECT *
\end_layout

\begin_layout Plain Layout

					FROM Position P 
\end_layout

\begin_layout Plain Layout

					WHERE I.PCN = P.PCN
\end_layout

\begin_layout Plain Layout

					AND P.FromDate < I.ToDate AND I.ToDate <= P.ToDate))
\end_layout

\begin_layout Plain Layout

BEGIN
\end_layout

\begin_layout Plain Layout

	RAISERROR('Violation of sequenced referential integrity',1,2)
\end_layout

\begin_layout Plain Layout

	ROLLBACK TRANSACTION
\end_layout

\begin_layout Plain Layout

END
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Case 3: Only the referenced table is temporal
\end_layout

\begin_layout Standard
Current FK:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

CREATE TRIGGER Current_RI ON Incumbents FOR INSERT, UPDATE, DELETE AS
\end_layout

\begin_layout Plain Layout

IF EXISTS( SELECT * 
\end_layout

\begin_layout Plain Layout

		FROM Incumbents I
\end_layout

\begin_layout Plain Layout

		WHERE NOT EXISTS( SELECT *
\end_layout

\begin_layout Plain Layout

						FROM Position P
\end_layout

\begin_layout Plain Layout

						WHERE I.PCN = P.PCN AND P.ToDate = '3000-01-01')) -- P is current
\end_layout

\begin_layout Plain Layout

BEGIN
\end_layout

\begin_layout Plain Layout

	RAISERROR('Violation of current referential integrity',1,2)
\end_layout

\begin_layout Plain Layout

	ROLLBACK TRANSACTION
\end_layout

\begin_layout Plain Layout

END
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Querying valid-time tables
\end_layout

\begin_layout Standard
We have the relations:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Employee
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SSN
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FirstName
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LastName
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
BirthDate
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Incumbents
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SSN
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PCN
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FromDate
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ToDate
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Salary
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SSN
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Amount
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FromDate
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ToDate
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Position
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PCN
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
JobTitle
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Say we want to obtain Bob's current position.
 Then:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

-- Option 1
\end_layout

\begin_layout Plain Layout

SELECT JobTitle
\end_layout

\begin_layout Plain Layout

FROM Employee E, Incumbents I, Position P
\end_layout

\begin_layout Plain Layout

WHERE F.FirstName = 'Bob' 
\end_layout

\begin_layout Plain Layout

	AND E.SSN = I.SSN 
\end_layout

\begin_layout Plain Layout

	AND I.PCN = P.PCN
\end_layout

\begin_layout Plain Layout

	AND I.ToDate = '3000-01-01'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- Option 2
\end_layout

\begin_layout Plain Layout

SELECT JobTitle
\end_layout

\begin_layout Plain Layout

FROM Employee E, Incumbents I, Position P
\end_layout

\begin_layout Plain Layout

WHERE F.FirstName = 'Bob' 
\end_layout

\begin_layout Plain Layout

	AND E.SSN = I.SSN 
\end_layout

\begin_layout Plain Layout

	AND I.PCN = P.PCN
\end_layout

\begin_layout Plain Layout

	AND I.FromDate <= CURRENT_DATE AND I.ToDate > CURRENT_DATE -- This one is
 more portable
\end_layout

\end_inset


\end_layout

\begin_layout Standard
And Bob's current position and salary? Current joins:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT JobTitle, Amount
\end_layout

\begin_layout Plain Layout

FROM Employee E, Incumbents I, Position P, Salary S
\end_layout

\begin_layout Plain Layout

WHERE FirstName = 'Bob'
\end_layout

\begin_layout Plain Layout

	AND E.SSN = I.SSN AND I.PCN = P.PCN AND E.SSN = S.SSN
\end_layout

\begin_layout Plain Layout

	AND I.FromDate <= CURRENT_DATE AND I.ToDate > CURRENT_DATE -- I is current
\end_layout

\begin_layout Plain Layout

	AND S.FromDate <= CURRENT_DATE AND S.ToDate > CURRENT_DATE -- S is current
\end_layout

\end_inset


\end_layout

\begin_layout Standard
And if we want to get what employees have currently no position?
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT FirstName
\end_layout

\begin_layout Plain Layout

FROM Employee e
\end_layout

\begin_layout Plain Layout

WHERE NOT EXISTS( SELECT *
\end_layout

\begin_layout Plain Layout

				FROM Incumbents I
\end_layout

\begin_layout Plain Layout

				WHERE E.SSN = I.SSN
\end_layout

\begin_layout Plain Layout

				AND I.FromDate <= CURRENT_DATE AND I.ToDate > CURRENT_DATE)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Extracting prior states
\end_layout

\begin_layout Standard
A 
\series bold
timeslice query
\series default
 extracts a state at a particular point in time.
 They require an additional predicate for each temporal tables: they are
 basically the same as checking the current state, but with a different
 date.
\end_layout

\begin_layout Standard
For example: Bob's position at the beginning of 1997?
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT JobTitle
\end_layout

\begin_layout Plain Layout

FROM Employee E, Incumbents I, Position P
\end_layout

\begin_layout Plain Layout

WHERE F.FirstName = 'Bob' 
\end_layout

\begin_layout Plain Layout

	AND E.SSN = I.SSN 
\end_layout

\begin_layout Plain Layout

	AND I.PCN = P.PCN
\end_layout

\begin_layout Plain Layout

	AND I.FromDate <= '1997-01-01' AND I.ToDate > '1997-01-01'
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Sequenced queries
\end_layout

\begin_layout Standard
A 
\series bold
sequenced query
\series default
 is such that its result is a valid-time table.
 They use sequenced variants of basic operations:
\end_layout

\begin_layout Itemize

\series bold
Sequenced selection
\series default
: no change:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT *
\end_layout

\begin_layout Plain Layout

FROM Salary
\end_layout

\begin_layout Plain Layout

WHERE Amount > 5000
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Sequenced projection
\series default
: include the timestamp columns in the select list, because if not we would
 obtain several values for the same employees:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT SSN, FromDate, ToDate
\end_layout

\begin_layout Plain Layout

FROM Salary
\end_layout

\end_inset

If we want to remove the duplicates here, we need to 
\series bold
coalesce
\series default
 the results.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT DISTINCT F.SSN, F.FromDate, L.ToDate
\end_layout

\begin_layout Plain Layout

FROM Salary F, Salary L
\end_layout

\begin_layout Plain Layout

WHERE F.FromDate < L.ToDate -- F is to the left of L
\end_layout

\begin_layout Plain Layout

	AND F.SSN = L.SSN -- And they are of the same SSN
\end_layout

\begin_layout Plain Layout

	AND NOT EXISTS( SELECT * -- This is the: forall M inside the period, it
 can be extended to the left
\end_layout

\begin_layout Plain Layout

					FROM Salary M
\end_layout

\begin_layout Plain Layout

					WHERE M.SSN = F.SSN -- M belongs to the same SSN
\end_layout

\begin_layout Plain Layout

					AND F.FromDate < M.FromDate and M.FromDate <= L.ToDate -- M starts between
 F and L
\end_layout

\begin_layout Plain Layout

					AND NOT EXISTS( SELECT * 
\end_layout

\begin_layout Plain Layout

									FROM Salary T1
\end_layout

\begin_layout Plain Layout

									WHERE T1.SSN = F.SSN
\end_layout

\begin_layout Plain Layout

									AND T1.FromDate < M.FromDate AND M.FromDate <= T1.ToDate))
\end_layout

\begin_layout Plain Layout

	AND NOT EXISTS( SELECT * -- This is the: the period is maximal
\end_layout

\begin_layout Plain Layout

					FROM Salary T2
\end_layout

\begin_layout Plain Layout

					WHERE T2.SSN = F.SSN
\end_layout

\begin_layout Plain Layout

					AND (
\end_layout

\begin_layout Plain Layout

						(T2.FromDate < F.FromDate AND F.FromDate <= T2.ToDate)
\end_layout

\begin_layout Plain Layout

						OR
\end_layout

\begin_layout Plain Layout

						(T2.FromDate <= L.ToDate AND L.ToDate < T2.ToDate))
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Sequenced sort
\series default
: in this case we require the result to be ordered at each point in time.
 This can be accomplished by appending the start and end time columns in
 the ORDEER BY:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT *
\end_layout

\begin_layout Plain Layout

FROM Incumbents
\end_layout

\begin_layout Plain Layout

ORDER BY PCN, FromDate, ToDate
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It can also be done by omitting the timestamp columns.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Sequenced union
\series default
: a UNION ALL (retaining duplicates) over temporal tables is automatically
 sequenced if the timestamp columns are kept:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT * 
\end_layout

\begin_layout Plain Layout

FROM Salary
\end_layout

\begin_layout Plain Layout

WHERE Amount > 50000
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

UNION ALL
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

SELECT *
\end_layout

\begin_layout Plain Layout

FROM Salary
\end_layout

\begin_layout Plain Layout

WHERE Amount < 10000
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Sequenced join
\series default
: imagine we want to determine the salary and position history for each
 employee.
 This implies a sequenced join between Salary and Incumbents.
 It is supposed that there are no duplicate rows in the tables: at each
 point in time an employee has one salary and one position.
 In SQL, a sequenced join requires four select statements and complex inequality
 predicates and the following code does not generate duplicates.
 This is why UNION ALL is used without problems, and being more efficient
 than UNION, which does a lot of work for removing non-ocurring duplicates
\begin_inset Foot
status open

\begin_layout Plain Layout
We already saw how the temporal join is done before.
\end_layout

\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

-- Usual sequenced join
\end_layout

\begin_layout Plain Layout

SELECT S.SSN, Amount, PCN, S.FromDate, S.ToDate
\end_layout

\begin_layout Plain Layout

FROM Salary S, Incumbents I
\end_layout

\begin_layout Plain Layout

WHERE S.SSN = I.SSN
\end_layout

\begin_layout Plain Layout

	AND I.FromDate < S.FromDate AND S.ToDate <= I.ToDate
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

UNION ALL
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

SELECT S.SSN, Amount, PCN, S.FromDate, I.ToDate
\end_layout

\begin_layout Plain Layout

FROM Salary S, Incumbents I
\end_layout

\begin_layout Plain Layout

WHERE S.SSN = I.SSN
\end_layout

\begin_layout Plain Layout

	AND I.FromDate <= S.FromDate 
\end_layout

\begin_layout Plain Layout

	AND S.FromDate < I.ToDate AND S.ToDate > I.ToDate
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

UNION ALL
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

SELECT S.SSN, Amount, PCN, I.FromDate, S.ToDate
\end_layout

\begin_layout Plain Layout

FROM Salary S, Incumbents I
\end_layout

\begin_layout Plain Layout

WHERE S.SSN = I.SSN
\end_layout

\begin_layout Plain Layout

	AND S.FromDate <= I.FromDate 
\end_layout

\begin_layout Plain Layout

	AND I.FromDate < S.ToDate AND I.ToDate > S.ToDate
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

UNION ALL
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

SELECT S.SSN, Amount, PCN, I.FromDate, I.ToDate
\end_layout

\begin_layout Plain Layout

FROM Salary S, Incumbents I
\end_layout

\begin_layout Plain Layout

WHERE S.SSN = I.SSN
\end_layout

\begin_layout Plain Layout

	AND S.FromDate < I.FromDate AND I.ToDate <= S.ToDate
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This can also be done using CASE, which allows to write the query in a single
 statement: the first case simulates a maxDate function of the two arguments,
 the second one a minDate function.
 The condition in the WHERE ensures that the period of validity is well
 formed:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

-- Sequenced join with CASE
\end_layout

\begin_layout Plain Layout

SELECT S.SSN, Amount, PCN,
\end_layout

\begin_layout Plain Layout

			CASE WHEN S.FromDate > I.FromDate THEN S.FromDate ELSE I.FromDate
\end_layout

\begin_layout Plain Layout

				END AS FromDate,
\end_layout

\begin_layout Plain Layout

			CASE WHEN S.ToDate > I.ToDate THEN I.ToDate ELSE S.ToDate
\end_layout

\begin_layout Plain Layout

				END AS ToDate
\end_layout

\begin_layout Plain Layout

FROM Salary S, Incumbents I
\end_layout

\begin_layout Plain Layout

WHERE S.SSN = I.SSN
\end_layout

\begin_layout Plain Layout

AND (CASE WHEN S.FromDate > I.FromDate THEN S.FromDate ELSE I.FromDate END)
\end_layout

\begin_layout Plain Layout

	<
\end_layout

\begin_layout Plain Layout

	(CASE WHEN S.ToDate > I.ToDate THEN I.ToDate ELSE S.ToDate END)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Another way to do the sequenced join is using functions:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

-- Sequenced join with functions
\end_layout

\begin_layout Plain Layout

CREATE FUNCTION minDate(@one SMALLDATETIME, @two SMALLDATETIME)
\end_layout

\begin_layout Plain Layout

RETURNS SMALLDATETIME AS
\end_layout

\begin_layout Plain Layout

BEGIN
\end_layout

\begin_layout Plain Layout

	RETURN CASE WHEN @one < @two THEN @one ELSE @two END
\end_layout

\begin_layout Plain Layout

END
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

CREATE FUNCTION maxDate(@one SMALLDATETIME, @two SMALLDATETIME)
\end_layout

\begin_layout Plain Layout

RETURNS SMALLDATETIME AS
\end_layout

\begin_layout Plain Layout

BEGIN
\end_layout

\begin_layout Plain Layout

	RETURN CASE WHEN @one < @two THEN @two ELSE @one END
\end_layout

\begin_layout Plain Layout

END
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

SELECT S.SSN, Amount, PCN, maxDate(S.FromDate, I.FromDate) AS FromDate, minDate(S.To
Date, I.ToDate) AS ToDate
\end_layout

\begin_layout Plain Layout

FROM Salary S, Incumbents I
\end_layout

\begin_layout Plain Layout

WHERE S.SSN = I.SSN
\end_layout

\begin_layout Plain Layout

	AND maxDate(S.FromDate,I.FromDate) < minDate(S.ToDate,I.ToDate)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Temporal difference
\series default
: the usual difference is implemented in SQL with EXCEPT, NOT EXISTS or
 NOT IN.
 For example, if we want to list the employees who are department heads
 (PCN=1234) but are not also professors (PCN=5555), we can do it as:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

-- Nontemporal veersion
\end_layout

\begin_layout Plain Layout

-- using NOT EXISTS
\end_layout

\begin_layout Plain Layout

SELECT SSN
\end_layout

\begin_layout Plain Layout

FROM Incumbents I1
\end_layout

\begin_layout Plain Layout

WHERE I1.PCN = 1234
\end_layout

\begin_layout Plain Layout

	AND NOT EXISTS( SELECT * 
\end_layout

\begin_layout Plain Layout

					FROM Incumbents I2
\end_layout

\begin_layout Plain Layout

					WHERE I1.SSN = I2.SSN AND I2.PCN = 5555)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

--using EXCEPT
\end_layout

\begin_layout Plain Layout

SELECT SSN
\end_layout

\begin_layout Plain Layout

FROM Incumbents 
\end_layout

\begin_layout Plain Layout

WHERE PCN = 1234
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

EXCEPT
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

SELECT SSN
\end_layout

\begin_layout Plain Layout

FROM Incumbents
\end_layout

\begin_layout Plain Layout

WHERE PCN = 5555
\end_layout

\end_inset


\end_layout

\begin_layout Standard
But the sequenced difference is a bit more complex.
 There are four possible cases, depicted in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Cases-for-temporal"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename temporal_12.png
	scale 60

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Cases for temporal difference.
\begin_inset CommandInset label
LatexCommand label
name "fig:Cases-for-temporal"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The SQL query is:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT A.SSN, A.FromDate, B.FromDate AS ToDate
\end_layout

\begin_layout Plain Layout

FROM Incumbents A, Incumbents B
\end_layout

\begin_layout Plain Layout

WHERE A.PCN = 1234 AND B.PCN = 5555 AND A.SSN = B.SSN
\end_layout

\begin_layout Plain Layout

	AND A.FromDate < B.FromDate AND B.FromDate < A.ToDate -- Case 1
\end_layout

\begin_layout Plain Layout

	AND NOT EXISTS( SELECT *
\end_layout

\begin_layout Plain Layout

					FROM Incumbents C
\end_layout

\begin_layout Plain Layout

					WHERE A.SSN = C.SSN AND C.SSN = 5555
\end_layout

\begin_layout Plain Layout

						AND A.FromDate < C.ToDate AND C.FromDate < B.FromDate) -- Check that we
 are not in case 3
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

UNION
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

SELECT A.SSN, B.ToDate AS FromDate, A.ToDate
\end_layout

\begin_layout Plain Layout

FROM Incumbents A, Incumbents B
\end_layout

\begin_layout Plain Layout

WHERE A.PCN = 1234 AND B.PCN = 5555 AND A.SSN = B.SSN
\end_layout

\begin_layout Plain Layout

	AND A.FromDate < B.ToDate AND B.ToDate < A.ToDate -- Case 2
\end_layout

\begin_layout Plain Layout

	AND NOT EXISTS( SELECT *
\end_layout

\begin_layout Plain Layout

					FROM Incumbents C
\end_layout

\begin_layout Plain Layout

					WHERE A.SSN = C.SSN AND C.PCN = 5555
\end_layout

\begin_layout Plain Layout

						AND B.ToDate < C.ToDate AND C.FromDate < A.ToDate) -- Check we are not
 in case 3
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

UNION
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

SELECT A.SSN, B1.ToDate AS FromDate, B2.FromDate AS ToDate
\end_layout

\begin_layout Plain Layout

FROM Incumbents A, Incumbents B1, Incumbents B2
\end_layout

\begin_layout Plain Layout

WHERE A.PCN = 1234 AND B1.PCN = 5555 AND B2.PCN = 5555
\end_layout

\begin_layout Plain Layout

	AND A.SSN = B1.SSN AND A.SSN = B2.SSN
\end_layout

\begin_layout Plain Layout

	AND B1.ToDate < B2.FromDate
\end_layout

\begin_layout Plain Layout

	AND A.FromDate < B1.ToDate
\end_layout

\begin_layout Plain Layout

	AND B2.FromDate < A.ToDate -- Case 3
\end_layout

\begin_layout Plain Layout

	AND NOT EXISTS( SELECT *
\end_layout

\begin_layout Plain Layout

					FROM Incumbents C
\end_layout

\begin_layout Plain Layout

					WHERE A.SSN = C.SSN AND C.SSN = 5555
\end_layout

\begin_layout Plain Layout

					AND B1.ToDate < C.ToDate AND C.FromDate < B2.FromDate) -- Check B1 and
 B2 are not temporary contected
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

UNION
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

SELECT SSN, FromDate, ToDate
\end_layout

\begin_layout Plain Layout

FROM Incumbents A
\end_layout

\begin_layout Plain Layout

WHERE A.PCN = 1234
\end_layout

\begin_layout Plain Layout

	AND NOT EXISTS( SELECT *
\end_layout

\begin_layout Plain Layout

					FROM Incumbents C
\end_layout

\begin_layout Plain Layout

					WHERE A.SSN = C.SSN AND C.PCN = 5555
\end_layout

\begin_layout Plain Layout

						AND A.FromDate < C.ToDate AND C.FromDate < A.ToDate) -- Case 4
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Subsubsection
Nonsequenced queries
\end_layout

\begin_layout Standard
Nonsequenced operators are straightforward: they ignore the time-varying
 nature of the tables.
\end_layout

\begin_layout Example
List all the salaries, past and present, of employees who had been lecturer
 at some time:
\end_layout

\begin_layout Example
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT Amount
\end_layout

\begin_layout Plain Layout

FROM Incumbents I, Position P, Salary S
\end_layout

\begin_layout Plain Layout

WHERE I.SSN = S.SSN AND I.PCN = P.PCN
\end_layout

\begin_layout Plain Layout

	AND JobTitle = 'Lecturer';
\end_layout

\end_inset


\end_layout

\begin_layout Example
When did employees receive raises?
\end_layout

\begin_layout Example
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT S2.SSN, S2.FromDate AS RaiseDate
\end_layout

\begin_layout Plain Layout

FROM Salary S1, Salary S2
\end_layout

\begin_layout Plain Layout

WHERE S2.Amount > S1.Amount AND S1.SSN = S2.SSN AND S1.ToDate = S2.FromDate;
\end_layout

\end_inset


\end_layout

\begin_layout Example
Remove 
\series bold
nonsequenced duplicates
\series default
 from Incumbents:
\end_layout

\begin_layout Example
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT DISTINCT *
\end_layout

\begin_layout Plain Layout

FROM Incumbents
\end_layout

\end_inset


\end_layout

\begin_layout Example
Remove 
\series bold
value-equivalent rows
\series default
 from Incumbents:
\end_layout

\begin_layout Example
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT DISTINCT SSN, PCN
\end_layout

\begin_layout Plain Layout

FROM Incumbents
\end_layout

\end_inset


\end_layout

\begin_layout Example
Remove 
\series bold
current duplicates
\series default
 from Incumbents:
\end_layout

\begin_layout Example
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT DISTINCT SSN, PCN
\end_layout

\begin_layout Plain Layout

FROM Incumbents
\end_layout

\begin_layout Plain Layout

WHERE ToDate = '3000-01-01'
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Sequenced aggregation function
\end_layout

\begin_layout Standard
Say we have two relations:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Affiliation
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SSN
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DNumber
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FromDate
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ToDate
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Salary
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SSN
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Amount
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FromDate
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ToDate
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
And we want the maximum salary.
 The non-temporal version is straighforward:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT MAX(Amount)
\end_layout

\begin_layout Plain Layout

FROM Salary
\end_layout

\end_inset


\end_layout

\begin_layout Standard
And the maximum salary by department:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT DNumber, MAX(Amount)
\end_layout

\begin_layout Plain Layout

FROM Affiliation A, Salary S
\end_layout

\begin_layout Plain Layout

WHERE A.SSN = S.SSN
\end_layout

\begin_layout Plain Layout

GROUP BY DNumber
\end_layout

\end_inset


\end_layout

\begin_layout Standard
But the temporal version is not that easy.
 We have to do as in this visual example:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado12.png

\end_inset


\end_layout

\begin_layout Standard
The steps to follow are:
\end_layout

\begin_layout Enumerate
Compute the periods on which a maximum must be calculated.
\end_layout

\begin_layout Enumerate
Compute the maximum for the periods.
\end_layout

\begin_layout Enumerate
Coalesce the results (as we have already seen)
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

-- Step 1: compute periods
\end_layout

\begin_layout Plain Layout

CREATE VIEW SalChanges(Day) AS
\end_layout

\begin_layout Plain Layout

	SELECT DISTINCT FromDate
\end_layout

\begin_layout Plain Layout

	FROM Salary
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	UNION
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	SELECT DISTINCT ToDate
\end_layout

\begin_layout Plain Layout

	FROM Salary
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

CREATE VIEW SalPeriods(FromDate, ToDate) AS
\end_layout

\begin_layout Plain Layout

	SELECT P1.Day, P2.Day
\end_layout

\begin_layout Plain Layout

	FROM SalChanges P1, SalChanges P2
\end_layout

\begin_layout Plain Layout

	WHERE P1.Day < P2.Day -- Get all consecutive combinations
\end_layout

\begin_layout Plain Layout

		AND NOT EXISTS( SELECT * 
\end_layout

\begin_layout Plain Layout

						FROM Salchanges P3
\end_layout

\begin_layout Plain Layout

						WHERE P1.Day < P3.Day AND P3.Day < P2.Day) -- Ensure they are consecutive
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- Step 2
\end_layout

\begin_layout Plain Layout

CREATE VIEW TempMax(MaxSalary, FromDate, ToDate) AS
\end_layout

\begin_layout Plain Layout

	SELECT MAX(S.AMOUNT), P.FromDate, P.ToDate
\end_layout

\begin_layout Plain Layout

	FROM SALARY S, SalPeriods P
\end_layout

\begin_layout Plain Layout

	WHERE S.FromDate <= P.FromDate AND P.ToDate <= S.ToDate
\end_layout

\begin_layout Plain Layout

	GROUP BY P.FromDate, I.ToDate
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- Step 3: COALESCE
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now, we want to compute the history of maximum salary by deparment:
\end_layout

\begin_layout Enumerate
Compute by department the periods on which a maximum must be calculated.
\end_layout

\begin_layout Enumerate
Compute the maximum salary for these periods.
\end_layout

\begin_layout Enumerate
Coalesce the results.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

-- Step 1
\end_layout

\begin_layout Plain Layout

CREATE VIEW Aff_Sal(DNumber, Amount, FromDate, ToDate) AS
\end_layout

\begin_layout Plain Layout

	SELECT DISTINCT A.DNumber, S.Amount, maxDate(S.FromDate, A.FromDate) AS FromDate,
 minDate(S.ToDate, A.ToDate) AS ToDate
\end_layout

\begin_layout Plain Layout

	FROM Affiliation A, Salary S
\end_layout

\begin_layout Plain Layout

	WHERE A.SSN = S:SSN
\end_layout

\begin_layout Plain Layout

		AND maxDate(S.FromDate,A.FromDate) < minDate(S.ToDate,A.ToDate)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

CREATE VIEW SalChanges(DNumber, Day) AS
\end_layout

\begin_layout Plain Layout

	SELECT DISTINCT DNumber, FromDate
\end_layout

\begin_layout Plain Layout

	FROM Aff_Sal
\end_layout

\begin_layout Plain Layout

	UNION
\end_layout

\begin_layout Plain Layout

	SELECT DISTINCT DNumber, ToDate
\end_layout

\begin_layout Plain Layout

	FROM Aff_Sal
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

CREATE VIEW SalPeriods(DNumber, FromDate, ToDate) AS
\end_layout

\begin_layout Plain Layout

	SELECT P1.DNumber, P1.Day, P2.Day
\end_layout

\begin_layout Plain Layout

	FROM SalChanges P1, SalChanges P2
\end_layout

\begin_layout Plain Layout

	WHERE P1.DNumber = P2.DNumber AND P1.Day < P2.Day
\end_layout

\begin_layout Plain Layout

	AND NOT EXISTS( SELECT *
\end_layout

\begin_layout Plain Layout

					FROM SalChanges P3
\end_layout

\begin_layout Plain Layout

					WHERE P3.DNumber = P1.DNumber 
\end_layout

\begin_layout Plain Layout

						AND P1.Day < P3.Day AND P3.Day < P2.Day)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- Step 2
\end_layout

\begin_layout Plain Layout

CREATE VIEW TempMaxDep(DNumber, MaxSalary, FromDate, ToDate) AS
\end_layout

\begin_layout Plain Layout

	SELECT P.DNumber, MAX(Amount), P.FromDate, P.ToDate
\end_layout

\begin_layout Plain Layout

	FROM Aff_Sal A, SalPeriods P
\end_layout

\begin_layout Plain Layout

	WHERE A.DNumber = P.DNumber
\end_layout

\begin_layout Plain Layout

		AND A.FromDate <= P.FromDate AND P.ToDate <= A.ToDate
\end_layout

\begin_layout Plain Layout

	GROUP BY P.DNumber, P.FromDate, P.ToDate
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- Step 3: COALESCE
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Sequenced division
\end_layout

\begin_layout Standard
Now we have the tables:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Affiliation
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SSN
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DNumber
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FromDate
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ToDate
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Controls
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PNumber
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DNumber
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FromDate
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ToDate
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
WorksOn
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SSN
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PNumber
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FromDate
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ToDate
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
And say we want to get the employees that are working all projects of the
 department to which they are affiliated.
 
\end_layout

\begin_layout Itemize
Nontemporal version:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT SSN
\end_layout

\begin_layout Plain Layout

FROM Affiliation A
\end_layout

\begin_layout Plain Layout

WHERE NOT EXISTS( SELECT * -- There are no projects associated to the dept
 in which the employee does not work
\end_layout

\begin_layout Plain Layout

				  FROM Controls C
\end_layout

\begin_layout Plain Layout

				  WHERE A.DNumber = C.DNumber -- Get all projects controlled by the dept
\end_layout

\begin_layout Plain Layout

					AND NOT EXISTS( SELECT *
\end_layout

\begin_layout Plain Layout

									FROM WorksOn W
\end_layout

\begin_layout Plain Layout

									WHERE C.PNumber = W AND A.SSN = W.SSN)) -- Check if the employee works
 on it
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Sequenced division: Case1.
 Only WorksOn is temporal.
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado13.png

\end_inset


\end_layout

\begin_layout Enumerate
Construct the periods on which the division must be computed.
\end_layout

\begin_layout Enumerate
Compute the division.
\end_layout

\begin_layout Enumerate
Coalesce.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

-- Step 1
\end_layout

\begin_layout Plain Layout

CREATE VIEW ProjChangesC1(SSN,Day) AS
\end_layout

\begin_layout Plain Layout

	SELECT SSN.FromDate FROM WorksOn
\end_layout

\begin_layout Plain Layout

	UNION
\end_layout

\begin_layout Plain Layout

	SELECT SSn.ToDate FROM WorksOn
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

CREATE VIEW ProjPeriodsC1(SSN,FromDate,ToDate) AS
\end_layout

\begin_layout Plain Layout

	SELECT P1.SSN, P1.Day, P2.Day
\end_layout

\begin_layout Plain Layout

	FROM ProjChangesC1 P1, ProjChangesC1 P2
\end_layout

\begin_layout Plain Layout

	WHERE P1.SSN = P2.SSN AND P1.Day < P2.Day
\end_layout

\begin_layout Plain Layout

		AND NOT EXISTS( SELECT * 
\end_layout

\begin_layout Plain Layout

						FROM ProjChangesC1 P3
\end_layout

\begin_layout Plain Layout

						WHERE P3.SSN = P1.SSN 
\end_layout

\begin_layout Plain Layout

							AND P3.Day > P1.Day AND P3.Day < P2.Day)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- Step 2
\end_layout

\begin_layout Plain Layout

CREATE VIEW TempUnivQuantC1(SSN, FromDate, ToDate) AS
\end_layout

\begin_layout Plain Layout

	SELECT DISTINCT P.SSN, P.FromDate, P.ToDate
\end_layout

\begin_layout Plain Layout

	FROM ProjPeriodsC1 P, Affiliation A
\end_layout

\begin_layout Plain Layout

	WHERE P.SSN = A.SSN 
\end_layout

\begin_layout Plain Layout

		AND NOT EXISTS( SELECT *
\end_layout

\begin_layout Plain Layout

						FROM CONTROLS C
\end_layout

\begin_layout Plain Layout

						WHERE A.DNumber = C.DNumber 
\end_layout

\begin_layout Plain Layout

							AND NOT EXISTS( SELECT *
\end_layout

\begin_layout Plain Layout

											FROM WorksOn W
\end_layout

\begin_layout Plain Layout

											WHERE C.PNumber = W.PNumber AND P.SSN = W.SSN
\end_layout

\begin_layout Plain Layout

											AND W.FromDate <= P.FromDate AND W.ToDate >= P.ToDate))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- Step 3: COALESCE
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Sequenced division: Case 2.
 Only Controls and WorksOn are temporal.
 In this case, employees may work on projects controlled by departments
 different from the department to which they are affiliated.
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado14.png

\end_inset


\end_layout

\begin_layout Enumerate
Construct the periods on which the division must be computed.
\end_layout

\begin_layout Enumerate
Compute the division of these periods.
\end_layout

\begin_layout Enumerate
Coalesce.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

-- Step 1
\end_layout

\begin_layout Plain Layout

CREATE VIEW ProjChangesC2(SSN,Day) AS
\end_layout

\begin_layout Plain Layout

	SELECT SSN, FromDate
\end_layout

\begin_layout Plain Layout

	FROM Affiliation A, Controls C
\end_layout

\begin_layout Plain Layout

	WHERE A.DNumber = C.DNumber
\end_layout

\begin_layout Plain Layout

	UNION
\end_layout

\begin_layout Plain Layout

	SELECT SSN, ToDate
\end_layout

\begin_layout Plain Layout

	FROM Affiliationn A, Controls C
\end_layout

\begin_layout Plain Layout

	WHERE A.DNumber = C.DNumber
\end_layout

\begin_layout Plain Layout

	UNION
\end_layout

\begin_layout Plain Layout

	SELECT SSN, FromDate
\end_layout

\begin_layout Plain Layout

	FROM WorksOn
\end_layout

\begin_layout Plain Layout

	UNION
\end_layout

\begin_layout Plain Layout

	SELECT SSN, ToDate
\end_layout

\begin_layout Plain Layout

	FROM WorksOn
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

CREATE VIEW ProjPeriodsC2(SSN,FromDate,ToDate) AS
\end_layout

\begin_layout Plain Layout

	SELECT P1.SSN, P1.Day, P2.Day
\end_layout

\begin_layout Plain Layout

	FROM ProjChanges P1, ProjChanges P2
\end_layout

\begin_layout Plain Layout

	WHERE P1.SSN = P2.SSN AND P1.Day < P2.Day
\end_layout

\begin_layout Plain Layout

		AND NOT EXISTS( SELECT *
\end_layout

\begin_layout Plain Layout

						FROM ProjChanges P3
\end_layout

\begin_layout Plain Layout

						WHERE P3.SSN = P1.SSN AND P1.Day < P3.Day AND P3.Day < P2.Day)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- Step 2
\end_layout

\begin_layout Plain Layout

CREATE VIEW TempUnivC2(SSN, FromDate, ToDate) AS
\end_layout

\begin_layout Plain Layout

	SELECT DISTINCT P.SSN, P.FromDate, P.ToDate
\end_layout

\begin_layout Plain Layout

	FROM ProjPeriodsC2 P, Affiliation A
\end_layout

\begin_layout Plain Layout

	WHERE P.SSN = A.SSN 
\end_layout

\begin_layout Plain Layout

		AND NOT EXISTS( SELECT *
\end_layout

\begin_layout Plain Layout

						FROM Controls C
\end_layout

\begin_layout Plain Layout

						WHERE A.DNumber = C.DNumber 
\end_layout

\begin_layout Plain Layout

							AND C.FromDate <= P.FromDate AND P.ToDate <= C.ToDate
\end_layout

\begin_layout Plain Layout

							AND NOT EXISTS( SELECT * 
\end_layout

\begin_layout Plain Layout

											FROM WorksOn W
\end_layout

\begin_layout Plain Layout

											WHERE C.PNumber = W.PNumber AND P.SSN = W.SSN
\end_layout

\begin_layout Plain Layout

												AND W.FromDate <= P.FromDate AND P.ToDate <= W.ToDate))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- Step 3: COALESCE
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Sequenced division: Case 3.
 Only Affiliation and WorksOn are temporal.
 Again, employees may work in projects controlled by departments different
 from the department to which they are affiliated.
 
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado15.png

\end_inset


\end_layout

\begin_layout Standard
The steps are conceptually the same, so let's go with SQL:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

-- Step 1
\end_layout

\begin_layout Plain Layout

CREATE VIEW Aff_WO(SSN, DNumber, PNumber, FromDate, ToDate) AS
\end_layout

\begin_layout Plain Layout

	SELECT DISTINCT A.SSN, A.DNumber, W.PNumber, maxDate(A.FromDate,W.FromDate)
 AS FromDate, minDate(A.ToDate,W.ToDate) AS ToDate
\end_layout

\begin_layout Plain Layout

	FROM Affiliation A, WorksOn W
\end_layout

\begin_layout Plain Layout

	WHERE A.SSN = W.SSN AND maxDate(A.FromDate,W.FromDate) < minDate(A.ToDate,W.toDate)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

CREATE VIEW ProjChangesC3(SSN, DNumber, Day) AS
\end_layout

\begin_layout Plain Layout

	SELECT SSN, DNumber, FromDate FROM Aff_WO 
\end_layout

\begin_layout Plain Layout

	UNION
\end_layout

\begin_layout Plain Layout

	SELECT SSN, DNumber, ToDate FROM Aff_WO
\end_layout

\begin_layout Plain Layout

	UNION
\end_layout

\begin_layout Plain Layout

	SELECT SSN, DNumber, FromDate FROM Affiliation
\end_layout

\begin_layout Plain Layout

	UNION
\end_layout

\begin_layout Plain Layout

	SELECT SSN, DNumber, ToDate FROM Affiliation
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

CREATE VIEW ProjPeriodsC3(SSN, DNumber, FromDate, ToDate) AS
\end_layout

\begin_layout Plain Layout

	SELECT P1.SSN, P1.DNumber, P1.Day, P2.Day
\end_layout

\begin_layout Plain Layout

	FROM ProjChangesC3 P1, ProjChangesC3 P2
\end_layout

\begin_layout Plain Layout

	WHERE P1.SSN = P2.SSN AND P1.DNumber = P2.DNumber
\end_layout

\begin_layout Plain Layout

		AND P1.Day < P2.Day 
\end_layout

\begin_layout Plain Layout

		AND NOT EXISTS( SELECT *
\end_layout

\begin_layout Plain Layout

						FROM ProjChangesC3 P3
\end_layout

\begin_layout Plain Layout

						WHERE P3.SSN = P1.SSN AND P3.DNumber = P1.DNumber
\end_layout

\begin_layout Plain Layout

							AND P1.Day < P3.Day AND P3.Day < P2.Day)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- Step 2
\end_layout

\begin_layout Plain Layout

CREATE VIEW TempUnivQuantC3(SSN, FromDate, ToDate) AS
\end_layout

\begin_layout Plain Layout

	SELECT DISTINCT P.SSN, P.FromDate, P.ToDate
\end_layout

\begin_layout Plain Layout

	FROM ProjPeriodsC3 P
\end_layout

\begin_layout Plain Layout

	WHERE NOT EXISTS( SELECT *
\end_layout

\begin_layout Plain Layout

					FROM Controls C
\end_layout

\begin_layout Plain Layout

					WHERE P.DNumber = C.DNumber 
\end_layout

\begin_layout Plain Layout

						AND NOT EXISTS( SELECT *
\end_layout

\begin_layout Plain Layout

										FROM WorksOn W
\end_layout

\begin_layout Plain Layout

										WHERE C.PNumber = W.PNumber AND P.SSN = W.SSN
\end_layout

\begin_layout Plain Layout

											AND W.FromDate <= P.FromDate AND P.ToDate <= W.ToDate))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- Step 3: COALESCE
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Sequenced division, Case 4.
 The three tables are temporal.
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado16.png

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

-- Step 1
\end_layout

\begin_layout Plain Layout

CREATE VIEW Aff_Cont(SSN, DNumber, PNumber, FromDate, ToDate) AS
\end_layout

\begin_layout Plain Layout

	SELECT DISTINCT A.SSN, A.DNumber, C.PNumber,maxDate(A.FromDate,C.FromDate) AS
 FromDate, minDate(A.ToDate,C.ToDate) AS ToDate
\end_layout

\begin_layout Plain Layout

	FROM Affiliation A, Controls C 
\end_layout

\begin_layout Plain Layout

	WHERE A.DNumber=C.DNumber
\end_layout

\begin_layout Plain Layout

		AND maxDate(A.FromDate,C.FromDate) < minDate(A.ToDate,C.ToDate)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

CREATE VIEW Aff_Cont_WO(SSN, DNumber, PNumber, FromDate, ToDate) AS
\end_layout

\begin_layout Plain Layout

	SELECT DISTINCT A.SSN, A.DNumber, W.PNumber, maxDate(A.FromDate,W.FromDate)
 AS FromDate, minDate(A.ToDate,W.ToDate) AS ToDate
\end_layout

\begin_layout Plain Layout

	FROM Aff_Cont A, WorksOn W 
\end_layout

\begin_layout Plain Layout

	WHERE A.PNumber=W.PNumber AND A.SSN=W.SSN
\end_layout

\begin_layout Plain Layout

		AND maxDate(A.FromDate,W.FromDate) < minDate(A.ToDate,W.ToDate)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

CREATE VIEW ProjChangesC4(SSN, DNumber, Day) AS
\end_layout

\begin_layout Plain Layout

	SELECT SSN, DNumber, FromDate FROM Aff_Cont 
\end_layout

\begin_layout Plain Layout

	UNION
\end_layout

\begin_layout Plain Layout

	SELECT SSN, DNumber, ToDate FROM Aff_Cont 
\end_layout

\begin_layout Plain Layout

	UNION
\end_layout

\begin_layout Plain Layout

	SELECT SSN, DNumber, FromDate FROM Aff_Cont_WO 
\end_layout

\begin_layout Plain Layout

	UNION
\end_layout

\begin_layout Plain Layout

	SELECT SSN, DNumber, ToDate FROM Aff_Cont_WO 
\end_layout

\begin_layout Plain Layout

	UNION
\end_layout

\begin_layout Plain Layout

	SELECT SSN, DNumber, FromDate FROM Affiliation 
\end_layout

\begin_layout Plain Layout

	UNION
\end_layout

\begin_layout Plain Layout

	SELECT SSN, DNumber, ToDate FROM Affiliation
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

CREATE VIEW ProjPeriodsC4(SSN, DNumber, FromDate, ToDate) AS
\end_layout

\begin_layout Plain Layout

	SELECT P1.SSN, P1.DNumber, P1.Day, P2.Day
\end_layout

\begin_layout Plain Layout

	FROM ProjChangesC4 P1, ProjChangesC4 P2 
\end_layout

\begin_layout Plain Layout

	WHERE P1.SSN = P2.SSN AND P1.DNumber = P2.DNumber AND P1.Day < P2.Day
\end_layout

\begin_layout Plain Layout

		AND NOT EXISTS( SELECT * 
\end_layout

\begin_layout Plain Layout

						FROM ProjChangesC4 P3
\end_layout

\begin_layout Plain Layout

						WHERE P1.SSN = P3.SSN AND P1.DNumber = P3.DNumber
\end_layout

\begin_layout Plain Layout

							AND P1.Day < P3.Day AND P3.Day < P2.Day)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- Step 2
\end_layout

\begin_layout Plain Layout

CREATE VIEW TempUnivQuantC4(SSN, FromDate, ToDate) AS 
\end_layout

\begin_layout Plain Layout

	SELECT DISTINCT P.SSN, P.FromDate, P.ToDate 
\end_layout

\begin_layout Plain Layout

	FROM ProjPeriodsC4 P 
\end_layout

\begin_layout Plain Layout

	WHERE NOT EXISTS( SELECT * 
\end_layout

\begin_layout Plain Layout

					FROM Controls C 
\end_layout

\begin_layout Plain Layout

					WHERE P.DNumber = C.DNumber 
\end_layout

\begin_layout Plain Layout

						AND C.FromDate <= P.FromDate AND P.ToDate <= C.ToDate 
\end_layout

\begin_layout Plain Layout

						AND NOT EXISTS( SELECT * 
\end_layout

\begin_layout Plain Layout

										FROM WorksOn W 
\end_layout

\begin_layout Plain Layout

										WHERE C.PNumber = W.PNumber AND P.SSN=W.SSN 
\end_layout

\begin_layout Plain Layout

											AND W.FromDate <= P.FromDate AND P.ToDate <= W.ToDate))
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Section
Temporal Support in current DBMSs and SQL 2011
\end_layout

\begin_layout Subsection
Oracle
\end_layout

\begin_layout Itemize
Oracle 9i included support for transaction time.
 
\series bold
Flashback queries
\series default
 allow the application to access prior transaction-time states of their
 database: they are transaction timeslice queries.
 Database modifications and conventional queries are temporally upward compatibl
e.
\end_layout

\begin_layout Itemize
Oracle 10g extended flashback queries to retrieve all the versions of a
 row between two transaction times.
 It also allowed tables and databases to be rolled back to a previous transactio
n time, discarding changes after that time.
\end_layout

\begin_layout Itemize
Oracle 10g Workspace Manager includes the period data type, valid-time support,
 transaction-time support, bitemporal support and support for sequenced
 primary keys, sequenced uniqueness, sequenced referential integrity and
 sequenced selection and projection.
\end_layout

\begin_layout Itemize
Oracle 11g does not rely on transient storage like the undo segments, it
 records changes in the Flashback Recovery Area.
 Valid-time queries were also enhanced.
\end_layout

\begin_layout Subsection
Teradata
\end_layout

\begin_layout Itemize
Teradata Database 13.10 introduced the period data type, valid-time support,
 transaction-time support, timeslices, temporal upward compatibility, sequenced
 primary key and temporal referential integrity constraints, nonsequenced
 queries, and sequenced projection and selection.
\end_layout

\begin_layout Itemize
Teradata Database 14 adds capabilities to create a global picture of an
 organization's business at any point in time.
\end_layout

\begin_layout Subsection
DB2
\end_layout

\begin_layout Standard
IBM DB2 10 includes the period data type, valid-time support (termed business
 time), transaction-time support (termed system time), timeslices, temporal
 upward compatibility, sequenced primary keys, and sequenced projection
 and selection.
\end_layout

\begin_layout Subsection
SQL 2011
\end_layout

\begin_layout Standard
SQL2011 has temporal support:
\end_layout

\begin_layout Itemize

\series bold
Application-time period tables
\series default
: valid-time tables.
 They have sequenced primary and foreign keys, support single-table valid-time
 sequenced insertions, deletions and updates, and nonsequenced valid-time
 queries.
\end_layout

\begin_deeper
\begin_layout Standard
They contain a PERIOD clause with an user-defined period name.
 Currently restricted to temporal periods only.
 They must contain two additional columns, to store the start time and the
 end time of a period associated with the row, whose values are set by the
 user.
 The user can also specify primary key/unique constraints to ensure that
 no two rows with the same key value have overlapping periods, as well as
 referential integrity constraints to ensure that the period of every child
 row is completely contained in the period of exactly one parent row or
 in the combined period of two or more consecutive parent rows.
\end_layout

\begin_layout Standard
Queries, inserts, updates and deletes behave exactly like in regular tables.
 Additional syntax is provided on UPDATE and DELETE statements for partial
 period updates and deletes.
\end_layout

\begin_layout Standard
We can 
\series bold
create
\series default
 an application-time period table as
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

CREATE TABLE employees(
\end_layout

\begin_layout Plain Layout

	emp_name VARCHAR(50) NOT NULL PRIMARY KEY,
\end_layout

\begin_layout Plain Layout

	dept_id VARCHAR(10),
\end_layout

\begin_layout Plain Layout

	start_date DATE NOT NULL,
\end_layout

\begin_layout Plain Layout

	end_date DATE NOT NULL,
\end_layout

\begin_layout Plain Layout

	PERIOD FOR emp_period (start_date, end_date),
\end_layout

\begin_layout Plain Layout

	PRIMARY KEY(emp_name, emp_period WITHOUT OVERLAPS),
\end_layout

\begin_layout Plain Layout

	FOREIGN KEY(dept_id, PERIOD emp_period) REFERENCES departments(Dept_id,
 PERIOD dept_period));
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The PERIOD clause automatically enforces the constraint end_date > start_date.
 The name of the period can be any user-defined name.
 The period is closed-open, [).
\end_layout

\begin_layout Standard
To 
\series bold
insert
\series default
 a row into an application-time period table, the user needs to provide
 the start and end time of the period for each row.
 The time values can be either in the past, current or future.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

INSERT INTO employees (emp_name, dept_id, start_date, end_date)
\end_layout

\begin_layout Plain Layout

VALUES ('John', 'J13', DATE '1995-11-15', DATE '1996-11-15'),
\end_layout

\begin_layout Plain Layout

		('Tracy', 'K25', DATE '1996-01-01', DATE '1997-11-15')
\end_layout

\end_inset


\end_layout

\begin_layout Standard
All rows canbe potentially 
\series bold
updated
\series default
.
 Users are allowed to update the start and end columns of the period associated
 with each row and when a row is updated using the regular UPDATE statement,
 the regular semantics apply.
 Additional syntax is provided for UPDATE statements to specify the time
 period during which the update applies, and only rows that lie within the
 specified period are impacted in that case.
 This can lead to row splits, if the modification lies in the middle of
 the period of the row.
 Users are not allowed to update the start and end columns of the period
 associated with each row under this option.
\end_layout

\begin_layout Standard
Also, all rows can be potentially 
\series bold
deleted
\series default
.
 Again, normal semantics apply unless we use the syntax provided to specify
 the time period during which the delete applies, so only rows lying inside
 the indicated period are impacted.
 This can also lead to row splits.
\end_layout

\begin_layout Standard
To 
\series bold
query
\series default
 a table, normal syntax applies.
 If we want to retrieve the current department of John:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT dept_id 
\end_layout

\begin_layout Plain Layout

FROM employees
\end_layout

\begin_layout Plain Layout

WHERE emp_name = 'John' 
\end_layout

\begin_layout Plain Layout

	AND start_date <= CURRENT_DATE AND end_date > CURRENT_DATE
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Or if we want the number of different departments in which John worked since
 Jan 1 96:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT COUNT(DISTINCT dept_id)
\end_layout

\begin_layout Plain Layout

FROM employees
\end_layout

\begin_layout Plain Layout

WHERE emp_name = 'John'
\end_layout

\begin_layout Plain Layout

	AND start_date<=DATE '1996-01-01' AND end_date > DATE '1996-01-01'
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Benefits 
\series default
of application-time period tables:
\end_layout

\begin_layout Itemize
Most business data is time sensitive.
\end_layout

\begin_layout Itemize
DB systems today offer no support for associating user-maintained time periods
 with rows nor enforcing constraints such as '
\emph on
an employee can be in only one department in any given period
\emph default
'.
\end_layout

\begin_layout Itemize
Updating/deleting a row for a part of its validity period.
\end_layout

\begin_layout Itemize
Currently, applications take the responsibility for managing such requirements.
\end_layout

\begin_layout Itemize
The major issues are the complexity of the code and its poor performance.
\end_layout

\begin_layout Itemize
These table provide: 
\end_layout

\begin_deeper
\begin_layout Itemize
Significant simplification of application code
\end_layout

\begin_layout Itemize
Significant improvement in performance
\end_layout

\begin_layout Itemize
Transparent to legacy applications
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
System-versioned tables
\series default
: transaction-time tables.
 They have transaction-time current primary and foreign keys, support transactio
n-time current insertions, deletions and updates, and transaction-time current
 and nonsequenced queries.
\end_layout

\begin_deeper
\begin_layout Standard
These tables contain a PERIOD clause with a pre-defined period name (SYSTEM_TIME
) and specify WITH SYSTEM VERSIONING.
 They must contain two additional columns, to store the start time and the
 end time of the SYSTEM_TIME period, whose values are set by the system,
 not the user.
 Unlike regular tables, system-versioned tables preserve the old versions
 of rows as the table is updated.
\end_layout

\begin_layout Standard
Rows whose periods intersect the current time are called 
\series bold
current system rows
\series default
, all others are called 
\series bold
historical system rows
\series default
.
 Only current system rows can be updated or deleted and the constraints
 are enforced only on current system rows.
\end_layout

\begin_layout Standard
To 
\series bold
create
\series default
 a table:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

CREATE TABLE employee(
\end_layout

\begin_layout Plain Layout

	emp_name VARCHAR(50) NOT NULL PRIMARY KEY,
\end_layout

\begin_layout Plain Layout

	dept_id VARCHAR(10),
\end_layout

\begin_layout Plain Layout

	system_start TIMESTAMP(6) GENERATED ALWAYS AS ROW START,
\end_layout

\begin_layout Plain Layout

	system_end TIMESTAMP(6) GENERATED ALWAYS AS ROW END,
\end_layout

\begin_layout Plain Layout

	PERIOD FOR SYSTEM_TIME (system_start, system_end),
\end_layout

\begin_layout Plain Layout

	FOREIGN KEY (dept_id) REFERENCES departments(dept_id);
\end_layout

\begin_layout Plain Layout

) WITH SYSTEM VERSIONING;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The PERIOD clause automatically enforces the constraint system_end > system_star
t and the name of the period must be SYSTEM_TIME.
 The period is closed, open [).
\end_layout

\begin_layout Standard
When a row is 
\series bold
inserted
\series default
 into a system-versiones table, the SQL-implementation sets the start time
 to the transaction time and the end time to the largest timestamp value.
 All rows inserted in a transaction will get the same values for the start
 and end columns.
\end_layout

\begin_layout Standard
When a row is 
\series bold
updated
\series default
 the SQL-implementation insert the 'old' version of the row into the table
 before updating the row, setting its end time and the start time of the
 updated row to the transaction time.
 Users are not allowed to modify the start nor end time.
\end_layout

\begin_layout Standard
When a row is 
\series bold
deleted
\series default
, the SQL-implementation does not actually delete the row, but sets its
 end time to the transaction time.
\end_layout

\begin_layout Standard
To 
\series bold
query
\series default
 a system-versiones table, existing syntax for querying regular tables is
 applicable.
 Additional syntax is provided for expressing queries involving system-versioned
 tables in a more succint manner:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

FOR SYSTEM_TIME AS OF <datetime> -- Ask for data of the date datetime 
\end_layout

\begin_layout Plain Layout

FOR SYSTEM_TIME BETWEEN <datetime> AND <datetime> -- Ask for data between
 the two given datetimes
\end_layout

\begin_layout Plain Layout

FOR SYSTEM_TIME FROM <datetime> TO <datetime> -- Same
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If none of this clause are specified, the system queries only current system
 tables.
\end_layout

\begin_layout Standard

\series bold
Benefits
\series default
 of system-versioned tables:
\end_layout

\begin_layout Itemize
Today's DB systems focus mainly on managing current data, providing almnost
 no support for managing historical data, while some applications have an
 inherent need for preserving old data.
 Also, regulatory and compliance laws require keeping old data around for
 a certain period of time.
 Currently, applications take on this responsibility.
 
\end_layout

\begin_layout Itemize
The major issues are as before: complexity of the code and poor performance.
\end_layout

\begin_layout Itemize
System-versioned tables provide:
\end_layout

\begin_deeper
\begin_layout Itemize
Significant simplification of application code.
\end_layout

\begin_layout Itemize
Significant improvement in performance.
\end_layout

\begin_layout Itemize
Transparent to legacy applications.
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
System-versiones application-time period tables
\series default
: bitemporal tables.
 They support temporal queries and modifications of combinations of the
 valid-time and transaction-time variants.
 These tables support features of both application-time period tables and
 system-versioned tables.
\end_layout

\begin_deeper
\begin_layout Standard
To 
\series bold
create
\series default
 a table:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

CREATE TABLE employees(
\end_layout

\begin_layout Plain Layout

	emp_name VARCHAR(50) NOT NULL PRIMARY KEY,
\end_layout

\begin_layout Plain Layout

	dept_id VARCHAR(10),
\end_layout

\begin_layout Plain Layout

	start_date DATE NOT NULL,
\end_layout

\begin_layout Plain Layout

	end_date DATE NOT NULL,
\end_layout

\begin_layout Plain Layout

	system_start TIMESTAMP(6) GENERATED ALWAYS AS ROW START,
\end_layout

\begin_layout Plain Layout

	System_end TIMESTAMP(6) GENERATED ALWAYS AS ROW END,
\end_layout

\begin_layout Plain Layout

	PERIOD FOR emp_period (start_date, end_date),
\end_layout

\begin_layout Plain Layout

	PERIOD FOR SYSTEM_TIME (system_start, system_end),
\end_layout

\begin_layout Plain Layout

	PRIMARY KEY (emp_name, emp_period WITHOUT OVERLAPS),
\end_layout

\begin_layout Plain Layout

	FOREIGN KEY (dept_id, PERIOD emp_period) REFERENCES departments (dept_id,
 PERIOD dept_period)
\end_layout

\begin_layout Plain Layout

) WITH SYSTEM VERSIONING;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Say we want to make the following update: On 15/12/97, John is loaned to
 department M12 starting from 01/01/98 to 01/07/98:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

UPDATE employees FOR PORTION OF emp_period
\end_layout

\begin_layout Plain Layout

FROM DATE '1998-01-01' TO DATE '1998-07-01'
\end_layout

\begin_layout Plain Layout

SET dept_id = 'M12' WHERE emp_name = 'John'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Or in 15/12/98, John is approved for a leave of absence from 1/1/99 to 1/1/2000:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

DELETE FROM employees
\end_layout

\begin_layout Plain Layout

FOR PORTION OF emp_period FROM DATE '1999-01-01' TO DATE '2000-01-01'
\end_layout

\begin_layout Plain Layout

WHERE emp_name = 'John'
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Spatial Databases
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
A 
\series bold
spatial database
\series default
 is a database that needs to store and query spatial objects, such as points
 (a house in a city), lines (a road) or polygons (a country).
 Thus, a 
\series bold
spatial DBMS
\series default
 is a DBMS that manages data existing in some space:
\end_layout

\begin_layout Itemize
2D or 2.5D: integrated circuits (VLSI design) or geographic space (GIS, urban
 planning).
\end_layout

\begin_layout Itemize
2.5D: elevation.
\end_layout

\begin_layout Itemize
3D: medicine (brain models), biological research (moledule structures),
 architecture (CAD) or ground models (geology).
\end_layout

\begin_layout Standard
The supporting technology needs to be able to manage large collections of
 geometric objects, and major commercial and open source DBMSs provide spatial
 support.
\end_layout

\begin_layout Standard
Spatial databases are important because queries to databases are posed in
 high level declarative manner, usually with SQL, which is popular in the
 commercial DB world.
 Also, although the standard SQL operates on relatively simple data types,
 additional spatial data types and operations can be defined in spatial
 databases.
\end_layout

\begin_layout Standard
A 
\series bold
geographic information system (GIS)
\series default
 is a system designed to capture, store, manipulate, analyze, manage and
 present geographically-referenced data, as well as non spatial data.
 It can be used to establish connections between different elements using
 geography operations, such as the location, the proximity or the spatial
 distribution.
 There are plenty of commercial and open source systems of this kind, but
 with limited temporal support.
\end_layout

\begin_layout Standard
A GIS can be seen as a set of subsystems:
\end_layout

\begin_layout Itemize
Data processing: data acquisition, input and store.
\end_layout

\begin_layout Itemize
Data analysis: retrieval and analysis.
\end_layout

\begin_layout Itemize
Information use: it is needed an interaction between GIS group and users
 to plan analytical procedures and data structures.
 The users of GIS are researches, planners or managers.
\end_layout

\begin_layout Itemize
Management system: it has an organizational role, being a separate unit
 in a resource management.
 An agency offering spatial DB and analysis services.
\end_layout

\begin_layout Standard
There are many fields involved in the development of GIS: geography, cartography
, remote sensing, photogrammetry, geodesy, statistics, operations research,
 mathematics, civil engineering and computer science, with computer aided
 design (CAD), computer graphics, AI and DBMS.
\end_layout

\begin_layout Subsection
GIS architectures
\end_layout

\begin_layout Standard
There are several possible architectures for a GIS:
\end_layout

\begin_layout Itemize

\series bold
Ad Hoc Systems
\series default
: they are developed for a specific problem.
 They are not modular, nor reusable nor extensible, nor friendly but are
 very efficient.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pegado17.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Ad Hoc GIS.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Loosely coupled approach
\series default
: structured information and geometry are stored at different places:
\end_layout

\begin_deeper
\begin_layout Itemize
There is a RDBMS for non spatial data.
\end_layout

\begin_layout Itemize
There is a specific module for spatial data management.
\end_layout

\begin_layout Standard
This allows for modularity, but there are two heterogeneous models in use.
 This makes it more difficult to model, integrate and use.
 Also, there is a partial loss of basic DBMS functionality (concurrency,
 optimization, recovery, querying).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pegado18.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Loosely coupled GIS.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Integrated
\series default
 
\series bold
approach
\series default
: this approach is an extended relational system, which makes it modular,
 extensible, reusable and friendly.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pegado19.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Integrated GIS.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Section
Georeferences and Coordinate Systems
\end_layout

\begin_layout Subsection
Projected coordinate systems
\end_layout

\begin_layout Standard
Going from 3D to 2D for Earth representation always involves a projection,
 so information on the projection is essential for applications analyzing
 spatial relationships and the choice of the projection used can influence
 the results.
 Also, the Earth is a complex surface whose shape and dimensions cannot
 be described with mathematical formulas.
 Two main reference surfaces are used to approximate the shape of the Earth:
 the 
\series bold
ellipsoid
\series default
 and the 
\series bold
geoid
\series default
.
\end_layout

\begin_layout Standard
The 
\series bold
geoid
\series default
 is a reference model for the physical surface of the Earth.
 It is defined as the equipotential surface of the Earth's gravity field
 which best fits the global mean sea level and extended through the continents.
 It is used in geodesy but it is not very practical to produce maps.
 Also, since its mathematical description is unknown, it is impossible to
 identify mathematical relationships for moving from the Earth to a map.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pegado20.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
The geoid.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
An 
\series bold
ellipsoid
\series default
 is a mathematically defined surface that approximates the geoid.
 It is the 3-dimensional version of an ellipse.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pegado21.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
An ellipse (left) and how it can approximate locally a complex shape (right).
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\series bold
flattening
\series default
 measures how much the symmetry axis is compressed relative to the equatorial
 radius, it is computed by
\begin_inset Formula 
\[
f=\frac{a-b}{a}.
\]

\end_inset

 For the Earth, 
\begin_inset Formula $f\sim\frac{1}{300}$
\end_inset

: the difference of the major and minor semi-axis is approximately 21 km.
 The ellopsoid is thus used to measure locations, using the latitude and
 the longitude, for points of interest.
 These locations on the ellipsoid are then projected onto a mapping plane.
 Note that different regions of the world use a different reference ellipsoid
 that minimize the differences between the geoid and the ellipsoid.
 For Belgium, the ellipsoid is GRS80 or WGS84, with 
\begin_inset Formula $a=6378137\ m$
\end_inset

 and 
\begin_inset Formula $f=\frac{1}{298.2572}$
\end_inset

.
\end_layout

\begin_layout Standard
This is done because the physical Earth has excursions of +8km and -11km,
 so the geoid's total variation goes from -107m to +85m compared to a perfect
 ellipsoid.
\end_layout

\begin_layout Subsubsection
Latitude and longitude
\end_layout

\begin_layout Standard
Latitude and longitude are measures of the angles (in degrees) from the
 center of the Earth to a point on the Earth's surface.
 The 
\series bold
latitude
\series default
 measures angles in the North-South direction, with the equator being at
 0º.
 The 
\series bold
longitude
\series default
 measures angles in the East-West direction, with the prime meridian at
 0º.
\end_layout

\begin_layout Standard
Note that they are not uniform units of distance, because the degrees change
 differently depending on where in the map we look at.
 Only along the equator the distance represented by one degree of longitude
 approximates the distance represented by one degree of latitude.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pegado22.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
The latitude and the longitude.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To produce a map, the curved surface of the Earth, approximated by an ellipsoid
 is transformed into the flat plane of the map by means of a map projection.
 A point on the reference surface of the Earth with coordinates 
\begin_inset Formula $\left(\phi,\lambda\right)$
\end_inset

 is transformed into Cartesian coordinates 
\begin_inset Formula $\left(x,y\right)$
\end_inset

 representing the positions on the map plane.
 Each projection causes deformations in one or another way.
 
\end_layout

\begin_layout Standard
Map projections can be categorized in four ways: shape used, angle, fit
 and properties.
\end_layout

\begin_layout Subsubsection
Shape of projection surface
\end_layout

\begin_layout Standard
Different shapes can be used for projection, commonly either a flat plane,
 a cylinder or a cone.
 Note that cylinders and cones are flat shapes, but they can be rolled flat
 without introducing additional distorsion.
\end_layout

\begin_layout Standard
According to this categorization, the projection can be:
\end_layout

\begin_layout Itemize
Cylindrical: coordinates projected onto a cylinder.
 These work best for rectangular areas.
\end_layout

\begin_layout Itemize
Conical: coordinates projected onto a cone.
 These work best for triangle shaped areas.
\end_layout

\begin_layout Itemize
Azimuthal: coordinates projected directly onto a flat planar surface.
 These work best for circular areas.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pegado23.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Shapes of projection surface.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Angle
\end_layout

\begin_layout Standard
The angle referes to the alignment of the projection surface, measured as
 the angle between the main axis of the Earth and the main symmetry axis
 of the projection surface:
\end_layout

\begin_layout Itemize
Normal: the two axes are parallel.
\end_layout

\begin_layout Itemize
Transverse: the two axes are perpendicular.
\end_layout

\begin_layout Itemize
Oblique: the two axes are at some other angle.
\end_layout

\begin_layout Standard
Ideally the plane of projection is aligned as closely as possible with the
 main axis of the area to be mapped, minimizing distorsion and scale errors.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pegado24.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Angle of projection.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Fit
\end_layout

\begin_layout Standard
The fit is a measure of how closely the projection surface fits the surface
 of the Earth:
\end_layout

\begin_layout Itemize
Tangent: the projection surface touches the surface of the Earth.
\end_layout

\begin_layout Itemize
Secan: the projection surface slices through the Earth.
\end_layout

\begin_layout Standard
Distorsion occurs whenever the projection surface is not touching or intersectin
g the surface of the Earth.
 Secant projections usually reduce scale errors, because the two surface
 intersect in more places and the overall fits tends to be better.
 A globe is the only way to represent the entire Earth without significant
 scale errors.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pegado25.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Fit of projection.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Geometric deformations
\end_layout

\begin_layout Standard
With different projections, different measures are preseved:
\end_layout

\begin_layout Itemize
Conformal: preserve shapes and angles.
 Recommended for navigational charts and topographic maps.
\end_layout

\begin_layout Itemize
Equal area: preserve areas in correct relative size.
 Best suited for thematic mapping.
\end_layout

\begin_layout Itemize
Equidistant: preserve distance (only possible at certain locations or in
 certain directions).
 Best suited when measuring distance from a point.
\end_layout

\begin_layout Itemize
True-direction: preserve accurate directions.
\end_layout

\begin_layout Standard
It is impossible to construct a map that is equal-area and conformal.
\end_layout

\begin_layout Section
Conceptual Modelling for Spatial Databases
\end_layout

\begin_layout Standard
The data modeling of spatial features requires for multiple views of space
 (discrete and continuous; 2D, 2.5D and 3D), multiple representation of the
 data, at different scales and from different viewpoints, several spatial
 abstract data types (point, line, area, set of points,...) and explicit spatial
 relationships (crossing, adjacency,...).
\end_layout

\begin_layout Standard
Let's see this requirements in depth.
 First, we have 
\series bold
interaction requirements
\series default
:
\end_layout

\begin_layout Itemize
Visual interactions: map displays, information visualizations and graphical
 queries on maps.
\end_layout

\begin_layout Itemize
Flexible, context-dependent interactions.
\end_layout

\begin_layout Itemize
Multiple user profiles (a highway can have constructors, car drivers, hikers,...)
\end_layout

\begin_layout Itemize
Multiple instantiations (a building may be a school and a church).
\end_layout

\begin_layout Standard

\series bold
Practical requirements
\series default
:
\end_layout

\begin_layout Itemize
Huge dataset: collecting new data is expensive, so reusing highly heterogeneous
 datasets is a must...
 but it is very complex.
 The integration requires understanding, so a conceptual model is important.
\end_layout

\begin_layout Itemize
Integration of DB with different space/time granularity.
\end_layout

\begin_layout Itemize
Coexistence with non-spatial and non-temporal data.
\end_layout

\begin_layout Itemize
Reengineering of legacy applications.
\end_layout

\begin_layout Itemize
Interoperability.
\end_layout

\begin_layout Standard
Thus, 
\series bold
conceptual modelling
\series default
 is important because it focuses on the application, it is technology independen
t, which increases portability and durability.
 It is user oriented and uses a formal unambiguous specification, with the
 support of visual interfaces for data definition and manipulation.
 It is the best vehicle for information exchange and integration.
\end_layout

\begin_layout Subsection
The Spatiotemporal conceptual manifesto
\end_layout

\begin_layout Standard
It has a good expressive power, with a simple data model, with few clean
 concepts and standard, well-known semantics.
 There are no artificial constructs and space, time and data structures
 are treated as orthogonal.
 It provieds a clean, visual notation and intuitive icons and symbols, providing
 a formal definition and an associated query language.
\end_layout

\begin_layout Standard
As with temporal DB, in spatial DB there are multiple ways to model the
 reality, each with its own characteristics.
 For example:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado26.png

\end_inset


\end_layout

\begin_layout Standard
And there is also a MADS Spatial Type Hierarchy:
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pegado27.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
MADS Spatial Type Hierarchy.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We need to keep in mind that the types are 
\series bold
topologically closed
\series default
: all geometries include their boundary.
\end_layout

\begin_layout Standard
Geo, SimpleGeo and ComplexGeo are abstract classes.
\end_layout

\begin_layout Subsubsection
MADS Spatial datatypes
\end_layout

\begin_layout Itemize

\series bold
Point
\series default
: its boundary is the empty set.
\end_layout

\begin_layout Itemize

\series bold
Line
\series default
: it can be of several types:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado28.png

\end_inset


\end_layout

\begin_layout Standard
Its boundary is composed of the extreme points, if any.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Surface
\series default
: it is define by 1 exterior boundary and 0 or more interior boundaries,
 defining its holes:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado29.png

\end_inset


\end_layout

\begin_layout Standard
The following are not surfaces:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado30.png

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Complex geometries
\series default
: a complex geometry is a geometry composed of several sub-geometries.
 Its boundary is defined recursively as the spatial union of:
\end_layout

\begin_deeper
\begin_layout Itemize
The boundaries of its components that do not intersect with other components.
\end_layout

\begin_layout Itemize
The intersecting boundaries that do not lie in the interior of their union.
\end_layout

\begin_layout Standard
If we have two geometries, 
\begin_inset Formula $a$
\end_inset

 and 
\begin_inset Formula $b$
\end_inset

, then
\begin_inset Formula 
\[
B\left(a\cup b\right)=\left[B\left(a\right)-b\right]\cup\left[B\left(b\right)-a\right]\cup\left[\left(B\left(a\right)\cap b\right)\cup\left(B\left(b\right)\cap a\right)-I\left(a\cup b\right)\right],
\]

\end_inset

 where 
\begin_inset Formula $B\left(x\right)$
\end_inset

 is the boundary of 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $I\left(x\right)$
\end_inset

 is the interior of 
\begin_inset Formula $x$
\end_inset

.
 A sample classification of different cases is the following:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado31.png

\end_inset


\end_layout

\end_deeper
\begin_layout Subsubsection
Topological predicates
\end_layout

\begin_layout Standard
A topological predicate specifies how two geometries relate to each other.
 It is based on the definition of their boundary 
\begin_inset Formula $B\left(x\right)$
\end_inset

, interior 
\begin_inset Formula $I\left(x\right)$
\end_inset

, and exterior 
\begin_inset Formula $E\left(x\right)$
\end_inset

, and their dimension 
\begin_inset Formula $Dim\left(x\right)$
\end_inset

, which can be -1,0,1 or 2 (-1 is for the empty set).
 The 
\series bold
dimensionally extended 9-intersection matrix (DE-9IM)
\series default
 is a matrix used for defining predicates.
 It is based in the following template:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Interior
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Boundary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Exterior
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Interior
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Dim\left(I\left(a\right)\cap I\left(b\right)\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Dim\left(I\left(a\right)\cap B\left(b\right)\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Dim\left(I\left(a\right)\cap E\left(b\right)\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Boundary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Dim\left(B\left(a\right)\cap I\left(b\right)\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Dim\left(B\left(a\right)\cap B\left(b\right)\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Dim\left(B\left(a\right)\cap E\left(b\right)\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Exterior
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Dim\left(E\left(a\right)\cap I\left(b\right)\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Dim\left(E\left(a\right)\cap B\left(b\right)\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Dim\left(E\left(a\right)\cap E\left(b\right)\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
It is coded using a dense notation with a string of 9 characters, to represent
 the cells of the matrix.
 The possible characters are:
\end_layout

\begin_layout Itemize

\series bold
T
\series default
: non-empty intersection.
\end_layout

\begin_layout Itemize

\series bold
F
\series default
: empty intersection.
\end_layout

\begin_layout Itemize

\series bold
0
\series default
: intersection is a point.
\end_layout

\begin_layout Itemize

\series bold
1
\series default
: intersection is a line.
\end_layout

\begin_layout Itemize

\series bold
2
\series default
: intersection is a surface.
\end_layout

\begin_layout Itemize

\series bold
*
\series default
: it is irrelevant.
\end_layout

\begin_layout Example
\begin_inset Formula $Disjoint\left(a,b\right)$
\end_inset

 is true if their intersection is empty.
 So, it is
\begin_inset Formula 
\[
Disjoint\left(a,b\right)=\left[I\left(a\right)\cap I\left(b\right)=\emptyset\right]\land\left[I\left(a\right)\cap B\left(b\right)=\emptyset\right]\land\left[B\left(a\right)\cap I\left(b\right)=\emptyset\right]\land\left[B\left(a\right)\cap B\left(b\right)=\emptyset\right].
\]

\end_inset

 Then, it can be coded as 'FF*FF****'.
\end_layout

\begin_layout Example
Let's see some predicates:
\end_layout

\begin_layout Itemize
\begin_inset Formula $Meets\left(a,b\right)\iff\left[I\left(a\right)\cap I\left(b\right)=\emptyset\right]\land\left[a\cap b\neq\emptyset\right]\land\left[Dim\left(a\cap b\right)=0\right]$
\end_inset

.
 Some geometries that satisfy it:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado32.png

\end_inset


\end_layout

\begin_layout Standard
And some that don't:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado33.png

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $Adjacent\left(a,b\right)\iff\left[I\left(a\right)\cap I\left(b\right)=\emptyset\right]\land\left[a\cap b\neq\emptyset\right]\land\left[Dim\left(a\cap b\right)=1\right].$
\end_inset

 Some geometries that satisfy it:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado34.png

\end_inset


\end_layout

\begin_layout Standard
And an example that doesn't:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado35.png

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $Touches\left(a,b\right)\iff\left[I\left(a\right)\cap I\left(b\right)=\emptyset\right]\land\left[a\cap b\neq\emptyset\right]\iff Meets\left(a,b\right)\lor Adjacent\left(a,b\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $Crosses\left(a,b\right)\iff\left[Dim\left(I\left(a\right)\cap I\left(b\right)\right)<\max\left\{ Dim\left(I\left(a\right)\right),Dim\left(I\left(b\right)\right)\right\} \right]\land\left[a\cap b\neq a\right]\land\left[a\cap b\neq b\right]\land\left[a\cap b\neq\emptyset\right]$
\end_inset

.
 Some geometries that satisfy it:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado36.png

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $Overlaps\left(a,b\right)\iff\left[Dim\left(I\left(a\right)\right)=Dim\left(I\left(b\right)\right)=Dim\left(I\left(a\right)\cap I\left(b\right)\right)\right]\land\left[a\cap b\neq a\right]\land\left[a\cap b\neq b\right]$
\end_inset

.
 Some geometries that satisfy it:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado37.png

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $Contains\left(a,b\right)\iff Within\left(b,a\right)\iff\left[I\left(a\right)\cap I\left(a\right)\neq\emptyset\right]\land\left[a\cap b=b\right]$
\end_inset

.
 Some geometries that satisfy it:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado38.png

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $Disjoint\left(a,b\right)\iff a\cap b=\emptyset\iff Intersects\left(E\left(a\right),b\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $Equals\left(a,b\right)\iff\left[a\cap b=a\right]\land\left[a\cap b=b\right]\iff\left(a-b\right)\cup\left(b-a\right)=\emptyset$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $Covers\left(a,b\right)\iff a\cap b=b\iff b-a=\emptyset$
\end_inset

 (same as 
\begin_inset Formula $contains\left(a,b\right)$
\end_inset

 but it can have empty interior).
\end_layout

\begin_layout Itemize
\begin_inset Formula $Encloses\left(a,b\right)\iff Surrounded\left(b,a\right)$
\end_inset

: the definition is involved, depending of whether 
\begin_inset Formula $a$
\end_inset

 is a (set of) line(s) or a (set of) surface(s).
 Some examples that verify it:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado39.png

\end_inset


\end_layout

\end_deeper
\begin_layout Subsubsection
Spatial objects
\end_layout

\begin_layout Standard
Objects can be defined as spatial:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Country 
\begin_inset Graphics
	filename pegado40.png

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
name
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
population
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection
Spatial attributes
\end_layout

\begin_layout Standard
Both non-spatial and spatial objects types can have spatial attributes.
 The domain of a spatial attribute is a spatial type, and can be multi-values.
 A spatial attribute of a spatial object type may induce a toplogical constraint
 (e.g.
 the capital of a country is located within the geometry of the country),
 but is is not necessarilly the case: it depends on application semantics
 and the application schema must explicitly state these constraints.
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Client
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
name
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
address
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
location
\begin_inset Graphics
	filename pegado41.png

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Country 
\begin_inset Graphics
	filename pegado40.png

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
name
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
population
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
capital
\begin_inset Graphics
	filename pegado41.png

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
rivers(1,n) 
\begin_inset Graphics
	filename pegado42.png

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Road
\begin_inset Graphics
	filename pegado42.png

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
name
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
responsible
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
stations(1,n) 
\begin_inset Graphics
	filename pegado41.png

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection*
Spatial complex attributes
\end_layout

\begin_layout Standard
Spatial attributes can be a component of a complex and/or multivalued attribute.
 It is usual to keep both thematic (alphanumeric) and location data for
 attributes, as a capital, for example.
 This allows to print both the name and the location in a map.
 However, in real maps the toponyms have also a location: there are precise
 cartographic rules for placing them, so it is a semi-automatic process.
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Country 
\begin_inset Graphics
	filename pegado40.png

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
name
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
population
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
capital
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
name
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
location
\begin_inset Graphics
	filename pegado41.png

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
provinces(1,n) 
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
name
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
location 
\begin_inset Graphics
	filename pegado40.png

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection
Spatial objects VS spatial attributes
\end_layout

\begin_layout Standard
Representing a concept as a spatial object or as a spatial attribute depends
 on the application and it is determined by the relative importance of the
 concept.
 This has implications in the way of accessing the instances of the concept.
 For example, buildings:
\end_layout

\begin_layout Itemize
As spatial objects: the application can access a building one by one.
\end_layout

\begin_layout Itemize
As spatial attributes: the access to a building must be made through the
 land plot containing it.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado43.png

\end_inset


\end_layout

\begin_layout Subsubsection
Generalization: inheriting spatiality.
\end_layout

\begin_layout Standard
Spaciality is inherited through generalization, based on the well-known
 
\series bold
substitutability principle
\series default
 in OOP.
 For simple inheritance it is not necessary to re-state the geometry in
 the subtype and, as usual, spatiality can be added to a subtype, so that
 only instances of the subtype have associated spaciality.
\end_layout

\begin_layout Subsubsection*
Refining/redefining spatiality
\end_layout

\begin_layout Standard
This arises when a spaciality is re-stated in a subtype:
\end_layout

\begin_layout Itemize

\series bold
Refinement
\series default
: it restricts the inherited property.
 The value remains the same in the supertype and the subtype.
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado44.png

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Redefinition
\series default
: it keeps substitutability with respect to typing and allows dynamic binding.
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado45.png

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Overloading
\series default
: relaxes substitutability, inhibiting dynamic binding.
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado46.png

\end_inset


\end_layout

\end_deeper
\begin_layout Subsubsection*
Multiple inheritance
\end_layout

\begin_layout Standard
Spatiality is inherited from several supertypes, and this creates an ambiguity
 when referring to the spatiality of the subtype.
 Several policies have been proposed for solving this issue in the OO community,
 and the most general policy is: 
\emph on
all inherited properties are available in the subtype, is the user who must
 disambiguate in queries
\emph default
.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado47.png

\end_inset


\end_layout

\begin_layout Subsubsection
Spatial relationships
\end_layout

\begin_layout Standard
Spatiality can also be defined for relationships, and it is orthogonal to
 the fact that linked object types are spatial.
 If a spatial relationship relates spatial types, spatial constraints may
 restrict the geometries.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado48.png

\end_inset


\end_layout

\begin_layout Subsubsection*
Topological relationships
\end_layout

\begin_layout Standard
They are specified on a relationship type that links at least two spatial
 types, and constraint the spatiality of the instances of the related types.
 Many topological constraints can be defined using the DE-9IM.
 The conceptual model depicts only the most general ones.
 These are:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado49.png

\end_inset


\end_layout

\begin_layout Subsubsection
Spatial aggregation
\end_layout

\begin_layout Standard
Traditional aggregation relatiomnships can link spatial types.
 Usually, aggregation has exclusive semantics, stated by cardinalities in
 the component role.
 Also, the spatiality of the aggregation is often partitioned into the spatialit
y of the components.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado50.png

\end_inset


\end_layout

\begin_layout Standard
Note that it is not the case for the second example, where the spaciality
 of Antena corresponds to its coverage, so the same location can be covered
 by several antennas.
 Spaciality of the aggregation is the 
\series bold
spatial union
\series default
 of the spaciality of the antennas.
\end_layout

\begin_layout Subsubsection
Space and time varying attributes
\end_layout

\begin_layout Standard
They are also referred to as 
\series bold
continuous fields
\series default
, and allow to represent phenomena that change in space and/or time, such
 as elevation (to each point there is an associated real number), population
 (to each point there is an associated integer) or temperature (to each
 point in space there is an associated real number, which evolves over time).
 At the 
\series bold
conceptual
\series default
 
\series bold
level
\series default
, it can be represented as a continuous function, so operators for manipulating
 fields can be defined.
 At the 
\series bold
logical level
\series default
 it can be implemented in several ways:
\end_layout

\begin_layout Itemize

\series bold
Raster
\series default
: discretize the space into regular cells and assign a value to each cell.
\end_layout

\begin_layout Itemize

\series bold
TIN
\series default
: keep values at particular locations and use interpolation for calculating
 the value at any point.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado51.png

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Section
Logical Modelling for Spatial Databases
\end_layout

\begin_layout Subsection
Representation models
\end_layout

\begin_layout Standard
This model try to represent an infinite sets of points of the Euclidean
 space in a computer.
 There two alternative representations:
\end_layout

\begin_layout Itemize

\series bold
Object-based model
\series default
 (vector): describes the spatial extent of relevant objects with a set of
 points.
 It uses pints, lines and surfaces for describing spaciality and the choice
 of geometric types is arbitrary, varying across systems.
\end_layout

\begin_layout Itemize

\series bold
Field-based model
\series default
 (raster): each point in space is associated with one or several values,
 defined as continuous functions.
\end_layout

\begin_layout Subsubsection
Raster model: tesselation
\end_layout

\begin_layout Standard
Tesselation is the decomposition of the plane into polygonal units, which
 might be regular or irregular, depending on whether the polygonal units
 are of equal size:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado54.png

\end_inset


\end_layout

\begin_layout Standard
Regular tesselation is used for remote sensing data, while irregular tesselation
 is used for zoning in social, demographic or economic data.
 A spatial Object is represented by the smallest subset of pixels that contains
 it.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado55.png

\end_inset


\end_layout

\begin_layout Subsection
Digital Elevation Models (DEMs)
\end_layout

\begin_layout Standard
They provide a digital (finite) representation of an abstract model of space.
 DEMs are useful to represent a natural phenomenon that is a continuous
 function of the 2D space.
 They are based on a finite collection of sample values, and the rest are
 obtained by interpolation.
\end_layout

\begin_layout Standard

\series bold
Triangulated irregular networks
\series default
 (TINs) are based on a triangular partition of the 2D space:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado56.png

\end_inset


\end_layout

\begin_layout Standard
No assumption is made on the distribution and location of the vertices of
 the triangles and the elevation value is recorded at each vertex.
 The value for the rest of the points is interpolated using linear interpolation
 of the 3 vertices of the triangle that contains the point.
\end_layout

\begin_layout Subsection
Representing the geometry of a collection of objects
\end_layout

\begin_layout Standard
There are three comonly used rperesentations: spaghetti, network and topological
, which mainly differ in the expression of topological relationships among
 the component objects.
\end_layout

\begin_layout Subsubsection
Spaghetti model
\end_layout

\begin_layout Standard
The geometry of any object is described independently of the rest, so no
 topology is stored in the model: the topological relationships must be
 computed on demand.
 This implies representation redundancy, but enables heterogeneous representatio
ns mixing points, polylines and regions without restrictions.
 
\end_layout

\begin_layout Standard
Advantages:
\end_layout

\begin_layout Itemize
Simplicity.
\end_layout

\begin_layout Itemize
Provides the end user with easy input of new objects into the collection.
\end_layout

\begin_layout Standard
Drawbacks:
\end_layout

\begin_layout Itemize
Lack of explicit information about topological relationships among spatial
 objects.
\end_layout

\begin_layout Itemize
Redundancy: problem with large datasets and source of inconsistency.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado57.png

\end_inset


\end_layout

\begin_layout Subsubsection
Network model
\end_layout

\begin_layout Standard
It is destined for network or graph based applications.
 The topological relationships among points and polylines are stored:
\end_layout

\begin_layout Itemize

\series bold
Nodes
\series default
: distinguished points that connect a list of arcs.
 
\end_layout

\begin_layout Itemize

\series bold
Arcs
\series default
: polyline that starts at a node and ends at a node.
\end_layout

\begin_layout Standard
Nodes allow efficient line connectivity test and network computations.
 There are two types of points: regular points and nodes.
\end_layout

\begin_layout Standard
Depending on the implementation, the network is planar or nonplanar:
\end_layout

\begin_layout Itemize
Planar network: each edge intersection is recorded as a node, even if it
 does not correspond to a real-world entity.
\end_layout

\begin_layout Itemize
Nonplanar network: edges may cross without producing an intersection.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado58.png

\end_inset


\end_layout

\begin_layout Subsubsection
Topological model
\end_layout

\begin_layout Standard
It is similar to the network model, except that the network is plannar.
 It induces a planar subdivision into adjacent polygons, some of which may
 not correspond to actual geographic objects:
\end_layout

\begin_layout Itemize

\series bold
Node
\series default
: represented by a point and the list of arcs starting/ending at it.
 And 
\series bold
isolated point
\series default
 (empty list of arcs) identifies the location of point features, such as
 towers, point of interest,...
\end_layout

\begin_layout Itemize

\series bold
Arc
\series default
: features its ending points, list of vertices and two polygons having the
 arc as a common boundary.
\end_layout

\begin_layout Itemize

\series bold
Polygon
\series default
: represented by a list of arcs, each arc being shared with a neighbor polygon.
\end_layout

\begin_layout Itemize

\series bold
Region
\series default
: represented by one or more adjacent polygons.
\end_layout

\begin_layout Standard
There is no redundancy: each point/line is stored only once.
\end_layout

\begin_layout Standard
Advantages: efficient computation of topological queries, and up-to-date
 consistency.
\end_layout

\begin_layout Standard
Drawbacks: some DB objects have no semantics in real world, and the xomplexity
 of the structure may slow down some operations.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado59.png

\end_inset


\end_layout

\begin_layout Section
SQL/MM
\end_layout

\begin_layout Subsection
SQL/MM Spatial: Geometry Type Hierarchy
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado60.png

\end_inset


\end_layout

\begin_layout Standard
ST_Geometry, ST_Curve and ST_Surface are not instantiable types.
\end_layout

\begin_layout Subsubsection
ST_Geometry
\end_layout

\begin_layout Standard
Represents 0D, 1D and 2D geometries that exist in 2D, 3D or 4D.
 Geometries in 
\begin_inset Formula $\mathbb{R}^{2}$
\end_inset

 have points with 
\begin_inset Formula $\left(x,y\right)$
\end_inset

 coordinate values, in 
\begin_inset Formula $\mathbb{R}^{3}$
\end_inset

 it is 
\begin_inset Formula $\left(x,y,z\right)$
\end_inset

 or 
\begin_inset Formula $\left(x,y,m\right)$
\end_inset

 and in 
\begin_inset Formula $\mathbb{R}^{4}$
\end_inset

 it is 
\begin_inset Formula $\left(x,y,z,m\right)$
\end_inset

.
\end_layout

\begin_layout Standard
The 
\begin_inset Formula $z$
\end_inset

 usually represents altitude.
\end_layout

\begin_layout Standard
The 
\begin_inset Formula $m$
\end_inset

 usually represents a measurement: it is key to support linear networking
 applications, such as street routing, transportation or pipelining.
\end_layout

\begin_layout Standard
Geometry values are topolofically closed, i.e., they include their boundary.
 
\end_layout

\begin_layout Standard
All locations in a geometry are in the same spatial reference system (SRS),
 and geometric calculations are done in the SRS of the first geometry in
 the parameter list of a routine.
 The return value is also in the SRS of the first parameter.
\end_layout

\begin_layout Subsubsection
Methods
\end_layout

\begin_layout Subsubsection*
Metadata
\end_layout

\begin_layout Itemize
ST_Dimension: returns the dimension of a geometry.
\end_layout

\begin_layout Itemize
ST_CoordDim: returns the coordinate dimension of a geometry.
\end_layout

\begin_layout Itemize
ST_GeometryType: returns the type of the geometry as a CHARACTER VARYING
 value.
\end_layout

\begin_layout Itemize
ST_SRID: observes and mutates the spatial reference system identifier of
 a geometry.
\end_layout

\begin_layout Itemize
ST_Transform: returns the geometry in the specified SRS.
\end_layout

\begin_layout Itemize
ST_IsEmpty: tests if a geometry corresponds to the empty set.
\end_layout

\begin_layout Itemize
ST_IsSimple: tests if a geometry has no anomalous geometric points.
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado61.png

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
ST_IsValid: tests if a geometry is well formed.
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado62.png

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
ST_Is3D: tests whether a geometry has 
\begin_inset Formula $z$
\end_inset

 coordinate.
\end_layout

\begin_layout Itemize
ST_IsMeasured: tests whether a geometry has 
\begin_inset Formula $m$
\end_inset

 coordinate.
\end_layout

\begin_layout Subsubsection*
Spatial analysis
\end_layout

\begin_layout Itemize
ST_Boundary: returns the boundary of a geometry.
\end_layout

\begin_layout Itemize
ST_Envelope: returns the bounding rectangle of a geometry.
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado63.png

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
ST_ConvexHull: returns the convex hull of a geometry.
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado64.png

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
ST_Buffer: returns the geometry that represents all points whose distance
 from any point of a geometry is less than or equal to a specified value.
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado65.png

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
ST_Union: returns the geometry that represents the point set union of two
 geometries.
\end_layout

\begin_layout Itemize
ST_Intersection: returns the geometry that represent the point set intersection
 of two geometries.
\end_layout

\begin_layout Itemize
ST_Difference: returns the geometry that represents the point set difference
 of two geometries.
\end_layout

\begin_layout Itemize
ST_SymDifference: returns the geometry that represents the point set symmetric
 difference of two geometries.
\end_layout

\begin_layout Itemize
ST_Distance: returns the distance between two geometries.
\end_layout

\begin_layout Subsubsection*
Input/Output
\end_layout

\begin_layout Itemize
ST_WTKToSQL: returns the geometry for the specified well-known text representati
on.
\end_layout

\begin_layout Itemize
ST_AsText: returns the well-known text representation for the specified
 geometry.
\end_layout

\begin_layout Itemize
ST_WKBToSQL: returns the geometry for the specified well-known binary representa
tion.
\end_layout

\begin_layout Itemize
ST_AsBinary: returns the well-known binary representation for the specified
 geometry.
\end_layout

\begin_layout Itemize
ST_GMLToSQL: returns the geometry for the specified GML representation.
\end_layout

\begin_layout Itemize
ST_AsGML: returns the GML representation for the specified geometry.
\end_layout

\begin_layout Itemize
ST_GeomFromText: returns a geometry, which is transformed from a CHARACTER
 LARGE OBJECT value that represents its well-known text representation.
\end_layout

\begin_layout Itemize
ST_GeomFromWKB: returns a geometry, which is transformed from a BINARY LARGE
 OBJECT value that represents its well-known binary representation.
\end_layout

\begin_layout Itemize
ST_GeomFromGML: returns a geometry, which is transformed from a CHARACTER
 LARGE OBJECT value that represents its GML representation.
\end_layout

\begin_layout Subsubsection*
Boundary, Interior, Exterior
\end_layout

\begin_layout Standard
Boundary of a geometry: set of geometries of the next lower dimension.
\end_layout

\begin_layout Itemize
ST_Point or ST_MultiPoint: empty set.
\end_layout

\begin_layout Itemize
ST_Curve: start and end ST_Point values if nonclosed, empty set if closed.
\end_layout

\begin_layout Itemize
ST_MultiCurve: ST_Point values that in the boundaries of an odd number of
 its element ST_Curve values.
\end_layout

\begin_layout Itemize
ST_Polygon: its set of linear rings.
\end_layout

\begin_layout Itemize
ST_Multipolygon: set of linear rings of its ST_Polygon values.
\end_layout

\begin_layout Itemize
Arbitrary collection of geometries whose interiors are disjoint: geometries
 drawn from the boundaries of the element geometries by application of the
 mod 2 union rule.
\end_layout

\begin_layout Itemize
The domain of geometries considered consists of those values that are topologica
lly closed.
\end_layout

\begin_layout Standard
Interior of a geometry: points that are left when the boundary is removed.
\end_layout

\begin_layout Standard
Exterior of a geometry: points not in the interior or boundary.
\end_layout

\begin_layout Subsubsection*
Spatial relationships
\end_layout

\begin_layout Itemize
ST_Equals: tests if a geometry is spatially equal to another geometry.
\end_layout

\begin_layout Itemize
ST_Disjoint: tests if a geometry is spatially disjoint from another geometry.
\end_layout

\begin_layout Itemize
ST_Intersects: tests if a geometry spatially intersects another geometry.
\end_layout

\begin_layout Itemize
ST_Touches: tests if a geometry spatially touches another geometry.
\end_layout

\begin_layout Itemize
ST_Crosses: tests if a geometry spatially crosses another geometry.
\end_layout

\begin_layout Itemize
ST_Within: tests if a geometry is spatially within another geometry.
\end_layout

\begin_layout Itemize
ST_Contains: tests if a geometry spatially contains another geometry.
\end_layout

\begin_layout Itemize
ST_Overlaps: tests if a geometry spatially overlaps another geometry.
\end_layout

\begin_layout Itemize
ST_Relate: tests if a geometry is spatially related to another geometry
 by testing for intersections between their interior, boundary and exterior
 as specified by the intersection matrix.
 For example: a.ST_Disjoint(b)=a.ST_Relate(b,'FF*FF****').
\end_layout

\begin_layout Subsubsection
Example of conceptual schema
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado52.png

\end_inset


\end_layout

\begin_layout Standard
To create the tables:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Create Table Country(
\end_layout

\begin_layout Plain Layout

	country_code integer,
\end_layout

\begin_layout Plain Layout

	country_name varchar (30),
\end_layout

\begin_layout Plain Layout

	geometry ST_MultiPolygon,
\end_layout

\begin_layout Plain Layout

	Primary Key (country_code))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Create Table State(
\end_layout

\begin_layout Plain Layout

	state_code integer,
\end_layout

\begin_layout Plain Layout

	state_name varchar (30),
\end_layout

\begin_layout Plain Layout

	country_code integer,
\end_layout

\begin_layout Plain Layout

	geometry ST_MultiPolygon,
\end_layout

\begin_layout Plain Layout

	Primary Key (state_code),
\end_layout

\begin_layout Plain Layout

	Foreign Key (country_code) References Country)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Create Table County(
\end_layout

\begin_layout Plain Layout

	county_code integer
\end_layout

\begin_layout Plain Layout

	county_name varchar (30),
\end_layout

\begin_layout Plain Layout

	state_code integer,
\end_layout

\begin_layout Plain Layout

	population integer,
\end_layout

\begin_layout Plain Layout

	geometry ST_MultiPolygon,
\end_layout

\begin_layout Plain Layout

	Primary Key (county_code),
\end_layout

\begin_layout Plain Layout

	Foreign Key (state_code) References State)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Table Highway is NOT spatial */
\end_layout

\begin_layout Plain Layout

Create Table Highway(
\end_layout

\begin_layout Plain Layout

	highway_code integer,
\end_layout

\begin_layout Plain Layout

	highway_name varchar (4),
\end_layout

\begin_layout Plain Layout

	highway_type varchar (2),
\end_layout

\begin_layout Plain Layout

	Primary Key (highway_code))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Create Table HighwaySection(
\end_layout

\begin_layout Plain Layout

	section_code integer,
\end_layout

\begin_layout Plain Layout

	section_number integer,
\end_layout

\begin_layout Plain Layout

	highway_code integer,
\end_layout

\begin_layout Plain Layout

	Primary Key (section_code,highway_code),
\end_layout

\begin_layout Plain Layout

	Foreign Key (section_code) References Section,
\end_layout

\begin_layout Plain Layout

	Foreign Key (highway_code) References Highway)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Create Table Section(
\end_layout

\begin_layout Plain Layout

	section_code integer,
\end_layout

\begin_layout Plain Layout

	section_name varchar (4),
\end_layout

\begin_layout Plain Layout

	number_lanes integer,
\end_layout

\begin_layout Plain Layout

	city_start varchar (30),
\end_layout

\begin_layout Plain Layout

	city_end varchar (30),
\end_layout

\begin_layout Plain Layout

	geometry ST_Line,
\end_layout

\begin_layout Plain Layout

	Primary Key (section_code),
\end_layout

\begin_layout Plain Layout

	Foreign Key (city_start) References City,
\end_layout

\begin_layout Plain Layout

	Foreign Key (city_end) References City)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Create Table City(
\end_layout

\begin_layout Plain Layout

	city_name varchar (30),
\end_layout

\begin_layout Plain Layout

	population integer,
\end_layout

\begin_layout Plain Layout

	geometry ST_MultiPolygon,
\end_layout

\begin_layout Plain Layout

	Primary Key (city_name))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Create Table LandUse(
\end_layout

\begin_layout Plain Layout

	region_name varchar (30),
\end_layout

\begin_layout Plain Layout

	land_use_type varchar (30),
\end_layout

\begin_layout Plain Layout

	geometry ST_Polygon,
\end_layout

\begin_layout Plain Layout

	Primary Key (region_name))
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Reference queries: alphanumerical criteria
\end_layout

\begin_layout Standard
Number of inhabitants in the county of San Francisco:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

select population
\end_layout

\begin_layout Plain Layout

from County
\end_layout

\begin_layout Plain Layout

where county_name = 'San Francisco'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
List of the counties of the state of California:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

select county_name
\end_layout

\begin_layout Plain Layout

from County, State
\end_layout

\begin_layout Plain Layout

from State.state_code = County.state_code
\end_layout

\begin_layout Plain Layout

	and state_name = 'California'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Number of inhabitants in the US:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

select sum (c2.population)
\end_layout

\begin_layout Plain Layout

from Country c1, State s, County c2
\end_layout

\begin_layout Plain Layout

where c1.country_name = 'USA'
\end_layout

\begin_layout Plain Layout

	and c1.country_code = s.country_code
\end_layout

\begin_layout Plain Layout

	and s.state_code = c2.state_code
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Number of lanes in the first section of Interstate 99:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

select s.number_lanes
\end_layout

\begin_layout Plain Layout

from Highway h1, HighwaySection h2, Section s
\end_layout

\begin_layout Plain Layout

where h1.highway_code = h2.highway_code
\end_layout

\begin_layout Plain Layout

	and h2.section_code = s.section_code
\end_layout

\begin_layout Plain Layout

	and h1.highway_name = 'I99'
\end_layout

\begin_layout Plain Layout

	and h2.section_number = 1
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Name of all sections that constitute Interstate 99:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

select s.section_name
\end_layout

\begin_layout Plain Layout

from Highway h1, HighwaySection h2, Section s
\end_layout

\begin_layout Plain Layout

where h1.highway_name = 'I99'
\end_layout

\begin_layout Plain Layout

	and h1.highway_code = h2.highway_code
\end_layout

\begin_layout Plain Layout

	and h2.section_code = s.section_code
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Reference queries: spatial criteria
\end_layout

\begin_layout Standard
Counties adjacent to the county of San Francisco in the same state:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

select c1.county_name
\end_layout

\begin_layout Plain Layout

from County c1, County c2
\end_layout

\begin_layout Plain Layout

where c2.county_name = 'San Francisco'
\end_layout

\begin_layout Plain Layout

	and c1.state_code = c2.state_code
\end_layout

\begin_layout Plain Layout

	and ST_Touches(c1.geometry, c2.geometry)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Display of the state of California (supposing that the State table is non
 spatial):
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

select ST_Union(c.geometry)
\end_layout

\begin_layout Plain Layout

from County c, State s
\end_layout

\begin_layout Plain Layout

where s.state_code = c.state_code
\end_layout

\begin_layout Plain Layout

	and s.state_name = 'California'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Counties larger than the largest county in California:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

select c1.county_name
\end_layout

\begin_layout Plain Layout

from County c1
\end_layout

\begin_layout Plain Layout

where ST_Area(c1.geometry) > (select max (ST_Area(c.geometry))
\end_layout

\begin_layout Plain Layout

								from County c, State s
\end_layout

\begin_layout Plain Layout

								where s.state_code = c.state_code
\end_layout

\begin_layout Plain Layout

									and s.state_name = 'California')
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Length of Interstate 99:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

select sum (ST_Length(s.geometry))
\end_layout

\begin_layout Plain Layout

from Highway h1, HighwaySection h2, Section s
\end_layout

\begin_layout Plain Layout

where h1.highway_name = 'I99'
\end_layout

\begin_layout Plain Layout

	and h1.highway_code = h2.highway_code
\end_layout

\begin_layout Plain Layout

	and h2.section_code = s.section_code
\end_layout

\end_inset


\end_layout

\begin_layout Standard
All highways going through the state of California:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

select distinct h1.highway_name
\end_layout

\begin_layout Plain Layout

from State s1, Highway h1, HighwaySection h2, Section s2
\end_layout

\begin_layout Plain Layout

where s1.state_name = 'California'
\end_layout

\begin_layout Plain Layout

	and h1.highway_code = h2.highway_code
\end_layout

\begin_layout Plain Layout

	and h2.section_code = s2.section_code
\end_layout

\begin_layout Plain Layout

	and ST_Overlaps(s2.geometry, s1.geometry)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Display all residential areas in the county of San Jose:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

select ST_Intersection(l.geometry, c.geometry)
\end_layout

\begin_layout Plain Layout

from County c, LandUse l
\end_layout

\begin_layout Plain Layout

where c.county_name = 'San Jose'
\end_layout

\begin_layout Plain Layout

	and l.land_use_type = 'residential area'
\end_layout

\begin_layout Plain Layout

	and ST_Overlaps(l.geometry, c.geometry)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Overlay the map of administrative units and land use:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

select county_name, land_use_type, ST_Intersection(c.geometry, l.geometry)
\end_layout

\begin_layout Plain Layout

from County c, LandUse l
\end_layout

\begin_layout Plain Layout

where ST_Overlaps(c.geometry, l.geometry)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Reference queries: interactive queries
\end_layout

\begin_layout Standard
Description of the county pointed to on the screen:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

select county_name, population
\end_layout

\begin_layout Plain Layout

from County
\end_layout

\begin_layout Plain Layout

where ST_Contains(geometry, @point)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Counties that intersect a given rectangle on the screen:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

select county_name
\end_layout

\begin_layout Plain Layout

from County
\end_layout

\begin_layout Plain Layout

where ST_Overlaps(geometry, @rectangle)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Part of counties that are withini a given rectangle on the screen (clipping):
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

select ST_Intersection(geometry, @rectangle)
\end_layout

\begin_layout Plain Layout

from County
\end_layout

\begin_layout Plain Layout

where ST_Overlaps(geometry, @rectangle)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Description of the highway section pointed to on the screen:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

select section_name, number_lanes
\end_layout

\begin_layout Plain Layout

from Section
\end_layout

\begin_layout Plain Layout

where ST_Contains(geometry, @point)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Description of the highways of which a section is pointed to on the screen:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

select h1.highway_name, h1.highway_type
\end_layout

\begin_layout Plain Layout

from Highway h1, HighwaySection h2, Section s
\end_layout

\begin_layout Plain Layout

where h1.highway_code = h2.highway_code
\end_layout

\begin_layout Plain Layout

	and h2.section_code = s.section_code
\end_layout

\begin_layout Plain Layout

	and ST_Contains(s.geometry, @point)
\end_layout

\end_inset


\end_layout

\begin_layout Section
Representative Systems
\end_layout

\begin_layout Subsection
Oracle Locator
\end_layout

\begin_layout Standard
Included in all editions of the DB, with all functions required for standard
 GIS tools and all geometric objects (Points, lines and polygons in 2D,
 3D and 4D).
 It uses indexing with quadtrees and rtrees and supports geometric queries,
 proximity search, distance calculation, multiple projection and conversion
 of projections.
\end_layout

\begin_layout Subsubsection
Oracle Spatial
\end_layout

\begin_layout Standard
It is an option or Oracle DB Enterprise edition, which extends the locator
 with geometric transformations, spatial aggregations, dynamic segmentation,
 measures, network modelling, topology, raster, geocoder, spatial data mining,
 3D types and Web Services.
\end_layout

\begin_layout Subsubsection
Oracle Network Model
\end_layout

\begin_layout Standard
It is a data model for representing networks in the database.
 It maintains connectivity and attributes at the link and node levels.
 It is used for networks management and as a navigation engine for route
 calculation.
\end_layout

\begin_layout Subsubsection
Oracle Topological Model
\end_layout

\begin_layout Standard
It persists the storage of the topology with nodes, arcs and faces, and
 the topological relations, allowing for advanced consistency checks.
 The data model allows to define objects through topological primitives
 and adds the type SDO_TOPO_GEOMETRY.
 It coexists with traditional spatial data.
\end_layout

\begin_layout Subsubsection
Oracle Geo Raster
\end_layout

\begin_layout Standard
It adds the new data type SDO_GEORASTER, providing an open, general purpose
 raster data model, with storage and indexing of raster data, as well as
 the ability to query an analyze raster data.
\end_layout

\begin_layout Subsubsection
Oracle geocoding
\end_layout

\begin_layout Standard
Generates latitude/longitude points from address.
 It is an international addressing standardization, working with formatted
 and unformatted addresses.
 Its tolerance parameters support fuzzy matching.
\end_layout

\begin_layout Subsubsection
Oracle MapViewer
\end_layout

\begin_layout Standard
It is supplied with all versions of Oracle Application Server, providing
 XML, Java and JS interfaces.
 It is a tool for map definition, for maps described in the database, thematic
 maps.
\end_layout

\begin_layout Subsubsection
Oracle: geometry type
\end_layout

\begin_layout Standard
To create a spatial table in Oracle:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

CREATE TABLE Cells (
\end_layout

\begin_layout Plain Layout

	Cell_id NUMBER,
\end_layout

\begin_layout Plain Layout

	Cell_name VARCHAR2(32),
\end_layout

\begin_layout Plain Layout

	Cell_type NUMBER,
\end_layout

\begin_layout Plain Layout

	Location SDO_GEOMETRY,
\end_layout

\begin_layout Plain Layout

	Covered_area SDO_GEOMETRY);
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Oracle: geometrical primitives
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado66.png

\end_inset


\end_layout

\begin_layout Itemize
Point: represents point objects in 2, 3 or 4 dimensions.
\end_layout

\begin_layout Itemize
Line: represents linear objects and is formed of straight lines or arcs.
 A closed line does not delineate a surface and self-crossing lines are
 allowed.
 They are encoded as a list of points 
\begin_inset Formula $\left(x_{1},y_{1},...,x_{n},y_{n}\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
Polygon: represents surface objects.
 The contour must be closed and the interior can contain one or more holes.
 The boundary cannot intersect and it is formed by straight lines or arcs
 (or a combination).
 Some specific forms as rectangles and circles can be expressed more efficiently.
\end_layout

\begin_layout Subsubsection
Oracle: element
\end_layout

\begin_layout Standard
An element is the basic component of geometric objects.
 The type of an element can be point, line or polygons.
 Fromed of an ordered sequence of points.
\end_layout

\begin_layout Subsubsection
Oracle: geometry
\end_layout

\begin_layout Standard
Represents a spatial object and is composed of an ordered list of elements,
 which may be homogeneous or heterogeneous.
\end_layout

\begin_layout Subsubsection
Oracle: layer
\end_layout

\begin_layout Standard
Represents a geometrical column in a table.
 In general, it contains objects of the same nature.
\end_layout

\begin_layout Subsubsection
SDO_GEOMETRY type
\end_layout

\begin_layout Standard
Structure:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SDO_GTYPE 	NUMBER
\end_layout

\begin_layout Plain Layout

SDO_SRID 	NUMBER
\end_layout

\begin_layout Plain Layout

SDO_POINT 	SDO_POINT_TYPE
\end_layout

\begin_layout Plain Layout

SDO_ELEM_INFO 	SDO_ELEM_INFO_ARRAY
\end_layout

\begin_layout Plain Layout

SDO_ORDINATES 	SDO_ORDINATE_ARRAY
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

CREATE TABLE states (
\end_layout

\begin_layout Plain Layout

	state VARCHAR2(30),
\end_layout

\begin_layout Plain Layout

	totpop NUMBER(9),
\end_layout

\begin_layout Plain Layout

	geom SDO_GEOMETRY);
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
SDO_GTYPE
\end_layout

\begin_layout Standard
Define the nature of the geometric shape contained in the object.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado71.png

\end_inset


\end_layout

\begin_layout Standard

\series bold
SDO_SRID
\end_layout

\begin_layout Standard
SRID = Spatial Reference System ID.
 It specifies the coordinate system of the object.
 The list of possible values is in the table MDSYS.CS:SRS.
 A common value is 8307: which is 'Longitude/Latitude WGS84', used by the
 GPS system.
 All geometries of a layer must have the same SRID.
 Layers may have different SRIDs.
 Automatic conversion for spatial queries.
\end_layout

\begin_layout Standard

\series bold
SDO_POINT
\end_layout

\begin_layout Standard
Structure
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

x NUMBER
\end_layout

\begin_layout Plain Layout

y NUMBER
\end_layout

\begin_layout Plain Layout

z NUMBER
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Example
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

INSERT INTO TELEPHONE_POLES (col-1, ..., col-n, geom)
\end_layout

\begin_layout Plain Layout

VALUES (attribute-1, ..., attribute-n,
\end_layout

\begin_layout Plain Layout

	SDO_GEOMETRY (
\end_layout

\begin_layout Plain Layout

		2001, 8307,
\end_layout

\begin_layout Plain Layout

		SDO_POINT_TYPE (-75.2,43.7,null),
\end_layout

\begin_layout Plain Layout

		null, null)
\end_layout

\begin_layout Plain Layout

);
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
SDO_ORDINATES
\end_layout

\begin_layout Standard
Object type SDO_ORDINATE_ARRAY which is VARRAY (1048576) OF NUMBER.
 It stores the coordinates of lines and polygons.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado73.png

\end_inset


\end_layout

\begin_layout Standard

\series bold
SDO_ELEM_INFO
\end_layout

\begin_layout Standard
Object type SDO_ELEM_INFO_ARRAY which is VARRAY (1048576) OF NUMBER.
 It specifies the nature of the elements and describes the various components
 of a complex object.
 There three entries per element:
\end_layout

\begin_layout Itemize

\series bold
Ordinate offset
\series default
: position of the first number for this element in the array SDO_ORDINATES.
\end_layout

\begin_layout Itemize

\series bold
Element type
\series default
: type of the element.
\end_layout

\begin_layout Itemize

\series bold
Interpretation
\series default
: straight line, arc,..
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado72.png

\end_inset


\end_layout

\begin_layout Standard
Examples of geometries:
\end_layout

\begin_layout Standard
Line:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename pegado74.png

\end_inset


\end_layout

\begin_layout Standard
Polygon:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename pegado75.png

\end_inset


\end_layout

\begin_layout Standard
Multipoint:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename pegado76.png

\end_inset


\end_layout

\begin_layout Standard

\series bold
Constructing a line
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

INSERT INTO LINES (col-1, ..., col-n, geom) VALUES (
\end_layout

\begin_layout Plain Layout

	attribute_1, ..., attribute_n,
\end_layout

\begin_layout Plain Layout

	SDO_GEOMETRY (
\end_layout

\begin_layout Plain Layout

		2002, 8307, null,
\end_layout

\begin_layout Plain Layout

		SDO_ELEM_INFO_ARRAY (1,2,1),
\end_layout

\begin_layout Plain Layout

		SDO_ORDINATE_ARRAY (
\end_layout

\begin_layout Plain Layout

			10,10, 20,25, 30,10, 40,10))
\end_layout

\begin_layout Plain Layout

);
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Metadata
\end_layout

\begin_layout Standard
Defines the boundaries of a layer, i.e., minimum and amximium coordinates
 for each dimension.
 Sets the tolerance of a layer, i.e., the maximum distance between two points
 for them to be considered different.
 And defines the coordinate system for a layer.
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

INSERT INTO USER_SDO_GEOM_METADATA (TABLE_NAME, COLUMN_NAME, DIMINFO, SRID)
 VALUES (
\end_layout

\begin_layout Plain Layout

	'ROADS', 'GEOMETRY',
\end_layout

\begin_layout Plain Layout

	SDO_DIM_ARRAY (
\end_layout

\begin_layout Plain Layout

		SDO_DIM_ELEMENT('Long', -180, 180, 0.5),
\end_layout

\begin_layout Plain Layout

		SDO_DIM_ELEMENT('Lat', -90, 90, 0.5)),	8307 );
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Constructing geometries
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

-- Standard constructor
\end_layout

\begin_layout Plain Layout

INSERT INTO TELEPHONE_POLES (col-1, ..., col-n, geom) VALUES (attribute-1,
 ..., attribute-n,
\end_layout

\begin_layout Plain Layout

	SDO_GEOMETRY (
\end_layout

\begin_layout Plain Layout

		2001, 8307,
\end_layout

\begin_layout Plain Layout

		SDO_POINT_TYPE (-75.2,43.7,null),
\end_layout

\begin_layout Plain Layout

		null, null)
\end_layout

\begin_layout Plain Layout

);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- Well-Known Text (WKT) constructor
\end_layout

\begin_layout Plain Layout

INSERT INTO TELEPHONE_POLES (col-1, ..., col-n, geom) VALUES (attribute-1,
 ..., attribute-n,
\end_layout

\begin_layout Plain Layout

	SDO_GEOMETRY ('POINT (-75.2 43.7)',8307)
\end_layout

\begin_layout Plain Layout

);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- Well-Known Binary (WKB) constructor
\end_layout

\begin_layout Plain Layout

INSERT INTO TELEPHONE_POLES (col-1, ..., col-n, geom) VALUES (attribute-1,
 ..., attribute-n,
\end_layout

\begin_layout Plain Layout

	SDO_GEOMETRY (:my_blob,8307)
\end_layout

\begin_layout Plain Layout

);
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Oracle: Spatial indexes
\end_layout

\begin_layout Itemize

\series bold
R-tree indexing
\series default
: tree rectangles that provide indexing in 2 or 3 dimensions.
 It is based on the 
\series bold
Minimum Bounding Rectangle
\series default
 (MBR) of objects.
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado67.png

\end_inset


\end_layout

\begin_layout Standard
To create an index:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

CREATE INDEX Customer_Idx ON Customers(Location)
\end_layout

\begin_layout Plain Layout

	INDEXTYPE IS MDSYS.SPATIAL_INDEX;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The CREATE INDEX statement may have additional parameters.
 To delete the index:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

DROP INDEX <index-name>;
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Quad-tree indexing: use a regular grid.
 It is not maintained in oracle now.
\end_layout

\begin_layout Standard
A spatial index must exists before we can ask spatial queries on a table.
\end_layout

\begin_layout Subsubsection
Oracle: query execution model
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado68.png

\end_inset


\end_layout

\begin_layout Standard
But it can be optimized:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado69.png

\end_inset


\end_layout

\begin_layout Subsubsection
Oracle: writing spatial queries
\end_layout

\begin_layout Standard
They contain a sptail predicate, and are expressed through specific SQL
 operators: SDO_RELATE, SDO_INSIDE, SDO_TOUCH, SDO_WITHIN_DISTANCE, SDO_NN.
 The spatial index must exists, otherwise we will get an error message.
\end_layout

\begin_layout Standard

\series bold
Topological predicates
\end_layout

\begin_layout Standard
They select objects by their topological relationship with another object:
 SDO_INSIDE, SDO_CONTAINS, SDO_COVERS, SDO_COVEREDBY, SDO_OVERLAPS, SDO_TOUCH,
 SDO_EQUAL, SDO_ANYINTERACT.
\end_layout

\begin_layout Standard
The SDO_RELATE is a generic operator for which we can specify a mask, that
 can be 'INSIDE', 'CONTAINS', 'TOUCH',...
 or a combination as 'INSIDE+CONTAINS'
\end_layout

\begin_layout Standard

\series bold
Sample queries
\end_layout

\begin_layout Standard
Which parks are entirely contianed in the state of Wyoming:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

-- way 1
\end_layout

\begin_layout Plain Layout

SELECT p.name
\end_layout

\begin_layout Plain Layout

FROM us_parks p, us_states s
\end_layout

\begin_layout Plain Layout

WHERE s.state = 'Wyoming'
\end_layout

\begin_layout Plain Layout

	AND SDO_INSIDE (p.geom, s.geom) = 'TRUE';
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- way 2
\end_layout

\begin_layout Plain Layout

SELECT p.name
\end_layout

\begin_layout Plain Layout

FROM us_parks p, us_states s
\end_layout

\begin_layout Plain Layout

WHERE s.state = 'Wyoming'
\end_layout

\begin_layout Plain Layout

	AND SDO_RELATE(p.geom,s.geom,'MASK=INSIDE') = 'TRUE';
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Which states contain all or part of Yellowstone Park:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT s.state
\end_layout

\begin_layout Plain Layout

FROM us_states s, us_parks p
\end_layout

\begin_layout Plain Layout

WHERE SDO_ANYINTERACT (s.geom, p.geom) = 'TRUE'
\end_layout

\begin_layout Plain Layout

	AND p.name = 'Yellowstone NP';
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In which competing jurisdictions is my client:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT s.id, s.name
\end_layout

\begin_layout Plain Layout

FROM customers c, competitors_sales_regions s
\end_layout

\begin_layout Plain Layout

	WHERE c.id = 5514 AND SDO_CONTAINS (s.geom, c.location) = 'TRUE';
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Find all counties around Passaic County:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT c1.county, c1.state_abrv
\end_layout

\begin_layout Plain Layout

FROM us_counties c1, us_counties c2
\end_layout

\begin_layout Plain Layout

WHERE c2.state = 'New Jersey' AND c2.county = 'Passaic'
\end_layout

\begin_layout Plain Layout

	AND SDO_TOUCH (c1.geom, c2.geom) = 'TRUE';
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Queries with a constant window
\end_layout

\begin_layout Standard
Find all customers of type Platinum in a rectangular area:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT name, category
\end_layout

\begin_layout Plain Layout

FROM customers
\end_layout

\begin_layout Plain Layout

WHERE SDO_INSIDE (location,
\end_layout

\begin_layout Plain Layout

	sdo_geometry (2003, 8307, null,
\end_layout

\begin_layout Plain Layout

	sdo_elem_info_array (1,1003,3),
\end_layout

\begin_layout Plain Layout

	sdo_ordinate_array (-122.413, 37.785,-122.403, 37.792)))
\end_layout

\begin_layout Plain Layout

	='TRUE'
\end_layout

\begin_layout Plain Layout

	AND customer_grade = 'PLATINUM';
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In which competitor sales territories is located a geographical point:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT id, name
\end_layout

\begin_layout Plain Layout

FROM competitors_sales_regions
\end_layout

\begin_layout Plain Layout

WHERE SDO_CONTAINS (geom,
\end_layout

\begin_layout Plain Layout

	SDO_GEOMETRY(2001, 8307,
\end_layout

\begin_layout Plain Layout

	SDO_POINT_TYPE(-122.41762, 37.7675089, NULL),
\end_layout

\begin_layout Plain Layout

	NULL, NULL) 
\end_layout

\begin_layout Plain Layout

	= 'TRUE';
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Queries based on distance
\end_layout

\begin_layout Standard
These are used to select objects according to distance from another point.
 Distance can be expressed in any unit of distance and if no unit is specified,
 the distance is expressed in the unit of the coordinate system.
 For longitude/latitude data, these are meters.
 The function used is SDO_WITHIN_DISTANCE.
\end_layout

\begin_layout Standard
Which agencies are less than 1km form this client:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT b.id, b.phone_number
\end_layout

\begin_layout Plain Layout

FROM customers c, branches b
\end_layout

\begin_layout Plain Layout

WHERE c.id = 8314
\end_layout

\begin_layout Plain Layout

	AND SDO_WITHIN_DISTANCE(b.location, c.location,'distance=1 unit=km')= 'TRUE';
\end_layout

\end_inset


\end_layout

\begin_layout Standard
How many customers in each category are located within 1/4 mile of my office
 number 77:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT customer_grade, COUNT(*)
\end_layout

\begin_layout Plain Layout

FROM branches b, customers c
\end_layout

\begin_layout Plain Layout

WHERE b.id=77
\end_layout

\begin_layout Plain Layout

	AND SDO_WITHIN_DISTANCE (c.location, b.location,'DISTANCE=0.25 UNIT=MILE')='TRUE'
\end_layout

\begin_layout Plain Layout

GROUP BY customer_grade;
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Research based on proximity
\end_layout

\begin_layout Standard
These select the N closest objects of another objects: SDO_NN.
 ROWNUM can be used to limit result.
 SDO_NN_DISTANCE is used to categorize answers by distance.
\end_layout

\begin_layout Standard
What is the nearest office to this client?
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT b.id, b.phone_number
\end_layout

\begin_layout Plain Layout

FROM customers c, branches b
\end_layout

\begin_layout Plain Layout

WHERE c.id = 8314
\end_layout

\begin_layout Plain Layout

	AND SDO_NN(b.location, c.location,'sdo_num_res=1')= 'TRUE';
\end_layout

\end_inset


\end_layout

\begin_layout Standard
What are my five customers closest to this competitor:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT c.id, c.name, c.customer_grade
\end_layout

\begin_layout Plain Layout

FROM competitors co, customers c
\end_layout

\begin_layout Plain Layout

WHERE co.id=1
\end_layout

\begin_layout Plain Layout

	AND SDO_NN (c.location, co.location,'SDO_NUM_RES=5')='TRUE' ;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This only works if no other selection criterion is present.
\end_layout

\begin_layout Standard
What are my five customers closest to this competitor, and give the distance:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT c.id, c.name, c.customer_grade, SDO_NN_DISTANCE(1) distance
\end_layout

\begin_layout Plain Layout

FROM competitors co, customers c
\end_layout

\begin_layout Plain Layout

WHERE co.id=1
\end_layout

\begin_layout Plain Layout

	AND SDO_NN (c.location, co.location,'SDO_NUM_RES=5', 1)='TRUE'
\end_layout

\begin_layout Plain Layout

ORDER BY distance;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If we want to add more filters, we cannot use the SDO_NN function, because
 it is evaluated first.
 We have to do the trick with SDO_DISTANCE+ORDER BY+ROWNUM.
\end_layout

\begin_layout Standard

\series bold
Spatial Join
\end_layout

\begin_layout Standard
It is used to find correlations between two tables, based on topology or
 distance.
 It compares all objects in a table with all those of another table, so
 it requires a R-Tree on each table.
 Technically implemented as a function that returns a table: the SDO_JOIN.
\end_layout

\begin_layout Standard
Associate with each GOLD customer the sales territory in which is is located:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT s.id, c.id, c.name
\end_layout

\begin_layout Plain Layout

FROM customers c, sales_regions s, TABLE(SDO_JOIN('customers','location','sales_
regions','geom','mask=inside')) j
\end_layout

\begin_layout Plain Layout

WHERE j.rowid1 = c.rowid
\end_layout

\begin_layout Plain Layout

	AND j.rowid2 = s.rowid
\end_layout

\begin_layout Plain Layout

	AND c.customer_grade = 'GOLD'
\end_layout

\begin_layout Plain Layout

ORDER BY s.id, c.id;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Find all gold customers who are less than 500 meters from one of our branches
 in San Francisco:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT DISTINCT c.id, c.name, b.id
\end_layout

\begin_layout Plain Layout

FROM customers c, branches b, TABLE(SDO_JOIN('CUSTOMERS','LOCATION','BRANCHES','
LOCATION','DISTANCE=500 UNIT=METER')) j
\end_layout

\begin_layout Plain Layout

WHERE j.rowid1 = c.rowid
\end_layout

\begin_layout Plain Layout

	AND j.rowid2 = b.rowid
\end_layout

\begin_layout Plain Layout

	AND c.customer_grade = 'GOLD'
\end_layout

\begin_layout Plain Layout

	AND b.city = 'SAN FRANCISCO';
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Spatial functions
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado70.png

\end_inset


\end_layout

\begin_layout Standard
Objects must be in the same coordinate system.
\end_layout

\begin_layout Standard
What is the total area of Yellowstone National Park:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT sdo_geom.sdo_area(geom,0.005,'unit=sq_km')
\end_layout

\begin_layout Plain Layout

FROM us_parks
\end_layout

\begin_layout Plain Layout

WHERE name = 'Yellowstone NP';
\end_layout

\end_inset


\end_layout

\begin_layout Standard
What is the length of the Mississippi riveer:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT sdo_geom.sdo_length(geom,0.005,'unit=km')
\end_layout

\begin_layout Plain Layout

FROM us_rivers
\end_layout

\begin_layout Plain Layout

WHERE name = 'Mississippi';
\end_layout

\end_inset


\end_layout

\begin_layout Standard
What is the distance between Los Angeles and San Francisco:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT sdo_geom.sdo_distance(a.location, b.location, 0.005, 'unit=mile')
\end_layout

\begin_layout Plain Layout

FROM us_cities a, us_cities b
\end_layout

\begin_layout Plain Layout

WHERE a.city = 'Los Angeles'
\end_layout

\begin_layout Plain Layout

	AND b.city = 'San Francisco';
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Generating objects
\end_layout

\begin_layout Itemize
SDO_BUFFER(g,size) generates a buffer of the size chosen.
 
\end_layout

\begin_layout Itemize
SDO_CENTROID(g) calculates the center of gravity of a polygon.
\end_layout

\begin_layout Itemize
SDO_CONVEXHULL(g): generates the convex hull of the object.
\end_layout

\begin_layout Itemize
SDO_MBR(g) generates the bulk of the rectangle object.
\end_layout

\begin_layout Standard

\series bold
Combining objects
\end_layout

\begin_layout Itemize
SDO_UNION(g1,g2)
\end_layout

\begin_layout Itemize
SDO_INTERSECTION(g1,g2)
\end_layout

\begin_layout Itemize
SDO_DIFFERENCE(g1,g2)
\end_layout

\begin_layout Itemize
SDO_XOR(g1,g2) is the symmetric difference.
\end_layout

\begin_layout Standard
What is the area occupied by the Yellowstone Park in the state it occupies:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT s.state, sdo_geom.sdo_area (sdo_geom.sdo_intersection (s.geom, p.geom,
 0.5),0.5, 'unit=sq_km') area
\end_layout

\begin_layout Plain Layout

FROM us_states s, us_parks p
\end_layout

\begin_layout Plain Layout

WHERE SDO_ANYINTERACT (s.geom, p.geom) = 'TRUE'
\end_layout

\begin_layout Plain Layout

	AND p.name = 'Yellowstone NP';
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Spatial aggregation
\end_layout

\begin_layout Standard
Aggregate functions operate on the set of objects.
\end_layout

\begin_layout Itemize
SDO_AGGR_MBR: returns the rectangle of space around a set of objects.
\end_layout

\begin_layout Itemize
SDO_AGGR_UNION: computes the union of a set of geometric objects.
\end_layout

\begin_layout Itemize
SDO_AGGR_CENTROID: calculates the centroid of a set of objects.
\end_layout

\begin_layout Itemize
SDO_AGGR_CONVEXHULL: calculates the convex hull around a set of objects.
\end_layout

\begin_layout Standard
Find the focal point of all our customers in Daly City:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT SDO_AGGR_CENTROID(SDOAGGRTYPE(location,0.5)) center
\end_layout

\begin_layout Plain Layout

FROM customers
\end_layout

\begin_layout Plain Layout

WHERE city = 'DALY CITY';
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Calculate the number of customer in each zip code, and calculate the focal
 point for these clients:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SELECT COUNT(*), postal_code, SDO_AGGR_CENTROID(SDOAGGRTYPE(location,0.5))
 center
\end_layout

\begin_layout Plain Layout

FROM customers
\end_layout

\begin_layout Plain Layout

GROUP BY postal_code;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintCited"
bibfiles "advDB_bib"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
