#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage{footmisc}
\usepackage{listings}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{1,0.99,0.94}

\lstdefinestyle{mystyle}{
	language=SQL,
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,  
    frame=single,
    tabsize=2
}

\lstset{style=mystyle}
\end_preamble
\use_default_options true
\begin_modules
tcolorbox
customHeadersFooters
theorems-ams-bytype
theorems-sec-bytype
algorithm2e
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=blue, urlcolor=blue, citecolor=blue, pdfstartview={FitH}, unicode=true"
\papersize a4paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\boxbgcolor #62a0ea
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 3cm
\rightmargin 2cm
\bottommargin 3cm
\headheight 2cm
\headsep 1cm
\footskip 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
INFOH415 - Advanced Databases
\end_layout

\begin_layout Date
Fall 2022
\end_layout

\begin_layout Author
Jose Antonio Lorencio Abril
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename 1200px-Université_libre_de_Bruxelles_(logo).svg.png
	scale 10

\end_inset


\end_layout

\begin_layout Standard
\align right
Professor: Esteban Zimanyi
\end_layout

\begin_layout Standard
\align right
Student e-mail: jose.lorencio.abril@ulb.be
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Address
This is a summary of the course 
\emph on
Advanced Databases
\emph default
 taught at the Université Libre de Bruxelles by Professor Esteban Zimanyi
 in the academic year 22/23.
 Most of the content of this document is adapted from the course notes by
 Zimanyi, 
\begin_inset CommandInset citation
LatexCommand cite
key "Zimanyi2022"
literal "false"

\end_inset

, so I won't be citing it all the time.
 Other references will be provided when used.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList table

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList algorithm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Active Databases
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Traditionally, DBMS are 
\series bold
passive
\series default
, meaning that all actions on data result from explicit invocation in applicatio
n programs.
 In contrast, 
\series bold
active DMBS
\series default
 can perform actions automatically, in response to monitored events, such
 as updates in the database, certain points in time or defined events which
 are external to the database.
\end_layout

\begin_layout Standard

\series bold
Integrity constraints
\series default
 are a well-known mechanism that has been used since the early stages of
 SQL to enhance integrity by imposing constraints to the data.
 These constraints will only allow modifications to the database that do
 not violate them.
 Also, it is common for DBMS to provide mechanisms to store procedures,
 in the form of precompiled packets that can be invoked by the user.
 These are usually caled 
\series bold
stored procedure
\series default
.
\end_layout

\begin_layout Standard
The active database technology make an abstraction of these two features:
 the 
\series bold
triggers
\series default
.
 
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
A 
\series bold
trigger
\series default
 or, more generally, an 
\series bold
ECA rule
\series default
, consists of an event, a condition and a set of actions:
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
Event
\series default
: indicates when the trigger must be called.
\end_layout

\begin_layout Itemize

\series bold
Condition
\series default
: indicates the checks that must be done after the trigger is called.
 If the condition is fulfilled, then the set of actions is executed.
 Otherwise, the trigger does not perform any action.
\end_layout

\begin_layout Itemize

\series bold
Actions
\series default
: performed when the condition is fullfilled.
\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Example
A conceptual trigger could be like the following:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Event
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A customer has not paid 3 invoices at the due date.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Condition
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
If the credit limit of the customer is less than 20000€.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Action
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cancel all curernt orders of the customer.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
There are several aspects of the semantics of an applications that can be
 expressed through triggers:
\end_layout

\begin_layout Itemize
Static constraints: refer to referential integrity, cardinality of relations
 or value restrictions.
\end_layout

\begin_layout Itemize
Control, business rules and workflow management rules: refer to restrictions
 imposed by the business requirements.
\end_layout

\begin_layout Itemize
Historical data rules: define how historial data has to be treated.
\end_layout

\begin_layout Itemize
Implementation of generic relationships: with triggers we can define arbitrarily
 complex relationships.
\end_layout

\begin_layout Itemize
Derived data rules: refer to the treatment of materialized attributes, materiali
zed views and replicated data.
\end_layout

\begin_layout Itemize
Access control rules: define which users can access which content and with
 which permissions.
\end_layout

\begin_layout Itemize
Monitoring rules: assess performance and resource usage.
\end_layout

\begin_layout Standard
The benefits of active technology are:
\end_layout

\begin_layout Itemize
Simplification of application programs by embedding part of the functionality
 into the database using triggers.
\end_layout

\begin_layout Itemize
Increased automation by the automatic execution of triggered actions.
\end_layout

\begin_layout Itemize
Higher reliability of data because the checks can be more elaborate and
 the actions to take in each case are precisely defined.
\end_layout

\begin_layout Itemize
Increased flexibility with the possibility of increasing code reuse and
 centralization of the data management.
\end_layout

\begin_layout Section
Representative Systems and Prototypes
\end_layout

\begin_layout Standard
Even though this basic model is simple and intuitive, each vendor proposes
 its own way to implement triggers, which were not in the SQL-92 standard.
 We are going to study Starbust triggers, Oracle triggers and DB2 triggers.
\end_layout

\begin_layout Subsection
Starbust
\end_layout

\begin_layout Standard
Starbust is a Relational DBMS prototype developed by IBM.
 In Starbust, the 
\series bold
triggers
\series default
 are defined with the following definition of their components:
\end_layout

\begin_layout Itemize

\series bold
Event
\series default
: events can refer to data-manipulation operations in SQL, i.e.
 INSERT, DELETE or UPDATE.
\end_layout

\begin_layout Itemize

\series bold
Conditions
\series default
: are boolean predicates in SQL on the current state of the database after
 the event has occurred.
\end_layout

\begin_layout Itemize

\series bold
Actions
\series default
: are SQL statements, rule-manipulation statements or the ROLLBACK operation.
\end_layout

\begin_layout Example

\emph on
'The salary of employees is not larger than the salary of the manager of
 their department.'
\end_layout

\begin_layout Example
The easiest way to maintain this rule is to rollback any action that violates
 it.
 This restriction can be broken (if we focus on modifications on the employees
 only) when a new employee is inserted, when the department of an employee
 is modified or when the salary of an employee is updated.
 Thus, a trigger that solves this could have these actions as events, then
 it can check whether the condition is fullfilled or not.
 If it is not, then the action can be rollback to the previous state, in
 which the condition was fullfilled.
\end_layout

\begin_layout Example
\begin_inset listings
lstparams "language=SQL,morekeywords={CREATE, RULE, ON, WHEN, IF, EXISTS, SELECT, FROM, WHERE, AND, THEN, ROLLBACK}"
inline false
status open

\begin_layout Plain Layout

CREATE RULE Mgrsals ON Emp
\end_layout

\begin_layout Plain Layout

WHEN INSERTED, UPDATED(Dept), UPDATED(Salary)
\end_layout

\begin_layout Plain Layout

IF EXISTS (
\end_layout

\begin_layout Plain Layout

	SELECT *
\end_layout

\begin_layout Plain Layout

	FROM Emp E, Dept D, EMP M
\end_layout

\begin_layout Plain Layout

	WHERE E.Dept = D.Dept --Check the correct department
\end_layout

\begin_layout Plain Layout

		  AND E.Sal > M.Sal --Check the salary condition
\end_layout

\begin_layout Plain Layout

		  AND D.Mgr = M.Name --Check the manager is the correct one
\end_layout

\begin_layout Plain Layout

	)
\end_layout

\begin_layout Plain Layout

THEN ROLLBACK;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The syntax of Starbust's rule definition is as described in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Starbust's-rule-definition"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 As we can see, rules have an unique name and each rule is associated with
 a single relation.
 The events are defined to be only database updates, but one rule can have
 several events defined on the target relation.
 
\end_layout

\begin_layout Standard
The same event can be used in several triggers, so one event can trigger
 different actions to be executed.
 For this not to produce an unwanted outcome, it is possible to establish
 the order in which different triggers must be executed, by using the PRECEDES
 and FOLLOWS declarations.
 The order defined by this operators is partial (not all triggers are comparable
) and must be acyclic to avoid deadlocks.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=SQL,morekeywords={CREATE, RULE, ON, WHEN, IF, EXISTS, SELECT, FROM, WHERE, AND, THEN, ROLLBACK}"
inline false
status open

\begin_layout Plain Layout

CREATE RULE <rule-name> ON <relation-name>
\end_layout

\begin_layout Plain Layout

WHEN <list of trigger-events>
\end_layout

\begin_layout Plain Layout

[IF <condition>]
\end_layout

\begin_layout Plain Layout

THEN <list of SQL-statements>
\end_layout

\begin_layout Plain Layout

[PRECEDES <list of rule-names>]
\end_layout

\begin_layout Plain Layout

[FOLLOWS <list of rule-names>];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

where
\end_layout

\begin_layout Plain Layout

	<trigger-event> := INSERTED | DELETED | UPDATED [<attributes>]
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Starbust's rule definition syntax.
\begin_inset CommandInset label
LatexCommand label
name "tab:Starbust's-rule-definition"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Example

\emph on
'If the average salary of employees gets over 100, reduce the salary of
 all employees by 10%.'
\end_layout

\begin_layout Example
In this case, the condition can be violated when a new employee is inserted,
 when an employee is deleted or when the salary is updated.
 Now, the action is not to rollback the operation, but to reduce the salary
 of every employee by 10%.
\end_layout

\begin_layout Example
First, let's exemplify the cases in which the condition is violated.
 Imagine the following initial state of the table Emp:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sal
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
John
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
50
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mike
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sarah
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
120
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Example
The average salary is 90, so the condition is fullfilled.
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
INSERT INTO Emp VALUES('James', 200)
\end_layout

\begin_deeper
\begin_layout Standard
The average salary would be 117,5 and the condition is not fullfilled.
\end_layout

\end_deeper
\begin_layout Itemize

\family typewriter
DELETE FROM Emp WHERE Name='John'
\end_layout

\begin_deeper
\begin_layout Standard
The average salary would be 110 and the condition is not fullfilled.
\end_layout

\end_deeper
\begin_layout Itemize

\family typewriter
UPDATE Emp SET Sal=110 WHERE Name='John'
\end_layout

\begin_deeper
\begin_layout Standard
The average salary would be 110 and the condition is not fullfilled.
\end_layout

\end_deeper
\end_deeper
\begin_layout Example
The trigger could be defined as:
\end_layout

\begin_layout Example
\begin_inset listings
lstparams "language=SQL,morekeywords={CREATE, RULE, ON, WHEN, IF, EXISTS, SELECT, FROM, WHERE, AND, THEN, ROLLBACK}"
inline false
status open

\begin_layout Plain Layout

CREATE RULE SalaryControl ON Emp
\end_layout

\begin_layout Plain Layout

WHEN INSERTED, DELETED, UPDATED(Sal)
\end_layout

\begin_layout Plain Layout

IF 
\end_layout

\begin_layout Plain Layout

	(SELECT AVG(Sal) FROM Emp) > 100
\end_layout

\begin_layout Plain Layout

THEN 
\end_layout

\begin_layout Plain Layout

	UPDATE Emp
\end_layout

\begin_layout Plain Layout

	SET Sal = 0.9*Sal;
\end_layout

\end_inset


\end_layout

\begin_layout Example
Note, nonetheless, that for the first example, we would get the following
 result:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sal
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
John
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
45
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mike
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
90
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sarah
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
108
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
James
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
180
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Example
Here, the mean is 105.75, still bigger than 100.
 We will see how to solve this issue later.
\end_layout

\begin_layout Subsubsection
Starbust Semantics
\end_layout

\begin_layout Standard
At this point, it is interesting to bring some definitions up to scene:
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
A 
\series bold
transaction
\series default
 is a sequence of statements that is to be treated as an atomic unit of
 work for some aspect of the processing, i.e., a transaction either executes
 from beginning to end, or it does not execute at all.
\end_layout

\begin_layout Plain Layout
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
A 
\series bold
statement
\series default
 is a part of a transaction, which expresses an operation on the database.
\end_layout

\begin_layout Plain Layout
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
En 
\series bold
event
\series default
 (in a more precise way than before) is the occurrence of executing a statement,
 i.e., a request for executing an operation on the database.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Thus, rules are triggered by the execution of operations in statements.
 In Starbust, rules are 
\series bold
statement-level
\series default
, meaning they are executed once per statement, even for statements that
 trigger events on several tuples.
 In addition, the execution mode is 
\series bold
deffered
\series default
.
 This means that all rules triggered during a transaction are placed in
 what is called the 
\series bold
conflict set
\series default
 (i.e.
 the set of triggered rules).
 When the transaction finishes, all rules are executed in triggering order
 or in the defined order, if there is one.
 Nonetheless, if the need for a rule executing during a transaction exists,
 we can use the PROCESS RULES declaration, which executes all rules in the
 conflict set.
 
\end_layout

\begin_layout Standard
The algorithm for executing all rules after the transaction finished or
 PROCESS RULES is called is described in Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Rule-Processing"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 As we can see, rule processing basically involves 3 stages:
\end_layout

\begin_layout Enumerate

\series bold
Activation
\series default
: the event in the rule requests the execution of an operation and this
 is detected by the system.
\end_layout

\begin_layout Enumerate

\series bold
Consideration
\series default
: the condition of the rule is evaluated.
\end_layout

\begin_layout Enumerate

\series bold
Execution
\series default
: if the condition is fullfilled, the action in the rule is executed.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=SQL,morekeywords={while, is, not, select, in, if, execute, delete, from}"
inline false
status open

\begin_layout Plain Layout

while CS is not empty
\end_layout

\begin_layout Plain Layout

	select R in CS with highest priority
\end_layout

\begin_layout Plain Layout

	delete R from CS
\end_layout

\begin_layout Plain Layout

	if R.condition is TRUE
\end_layout

\begin_layout Plain Layout

		execute R.action
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
processRules(conflict set CS)
\begin_inset CommandInset label
LatexCommand label
name "alg:Rule-Processing"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Correctness of rules
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
The 
\series bold
repeatability of the execution
\series default
 is the property that ensures that the system behaves in the same way when
 it receives the same input transaction in the same database state, i.e.,
 the results are deterministic.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As we have seen before, rule definitions specify a partial order for execution,
 but several rules may have highest priority at the moment of selection.
 To achieve repeatability, the system maintains a total order, based on
 the user-defined partial order and the timestamps of the creation of the
 rules.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
The 
\series bold
termination of rule execution
\series default
 is reached when an empty conflict set is obtained.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that the execution of the rules may trigger more rules, this could
 cause 
\series bold
nontermination
\series default
, if two rules call each other in a cycle.
 Thus, ensuring termination is one of the main problems of active-rule design.
\end_layout

\begin_layout Example
Return to the previous example.
 We saw how the first of the examples did not end up fullfilling the condition,
 but it is because we did not take into account that the rule would trigger
 itself because it updates the Salary of Emp.
 Thus, the insertion and subsequent execution of the rule triggered gave
 us:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sal
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
John
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
45
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mike
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
90
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sarah
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
108
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
James
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
180
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Example
As we have updated the salaries, the rule is triggered again.
 The condition would be fullfilled, 105.75>100 and the salaries would be
 modified again, arriving to the table as:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sal
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
John
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
41.5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mike
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
81
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sarah
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
97.2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
James
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
162
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Example
As the salaries ahve been updated again, the rule is triggered once more.
 Now, the mean is 95.425 < 100, so the condition is not met and the actions
 are not executed.
 The rule has terminated.
\end_layout

\begin_layout Example
In this case, termination is ensured because all values are decreased by
 10%.
 This implies that the mean is also decreased by 10%.
 Thus, no matter how high the mean is at the beginning, at some point it
 will go below 100, because 
\begin_inset Formula $0.9x<x,\ \forall x>0$
\end_inset

.
\end_layout

\begin_layout Remark
In general, guaranteeing termination is responsibility of the programmer
 is not an easy task.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
A rule is 
\series bold
correct
\series default
 (or possesses the correctness property) if it ensures repeatability and
 termination, taking into account the rest of factors in the database (other
 rules, domain of the attributes, structure of the tables,...).
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
State transitions and net effect
\end_layout

\begin_layout Standard
A transaction causes a state transition of the database, in the form of
 an addition, suppression of modification of one or more tuples of the database.
\end_layout

\begin_layout Standard
Before the transaction commits, the system stores two temporary 
\series bold
transition relations
\series default
, that contain the tuples affected by the transition.
 This tables are:
\end_layout

\begin_layout Itemize
INSERTED: for each event, it stores newly inserted tuples and the new form
 of tuples that have been modified.
\end_layout

\begin_layout Itemize
DELETED: for each event, it stores deleted tuples and the old form of tuples
 that have been modified.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
The 
\series bold
net effect
\series default
 of a transaction on a tuple is the composed effect of the transaction on
 the tuple, from the starting state to the end of the transaction.
\end_layout

\end_inset


\end_layout

\begin_layout Example
Some simple net effects:
\end_layout

\begin_deeper
\begin_layout Itemize
The sequence 
\family typewriter
INSERT 
\begin_inset Formula $\rightarrow$
\end_inset

 UPDATE 
\begin_inset Formula $\rightarrow$
\end_inset

 ...
 
\begin_inset Formula $\rightarrow$
\end_inset

 UPDATE 
\begin_inset Formula $\rightarrow$
\end_inset

 DELETE 
\family default
on a newl tuple, has null effect: the tuple was not in the database at the
 beginning, and it is not there at the end.
\end_layout

\begin_layout Itemize
The sequence 
\family typewriter
INSERT 
\begin_inset Formula $\rightarrow$
\end_inset

 UPDATE 
\begin_inset Formula $\rightarrow$
\end_inset

 ...
 
\begin_inset Formula $\rightarrow$
\end_inset

 UPDATE 
\family default
on a new tuple, has the same net effect as inserting the tuple with the
 values given in the last update.
\end_layout

\begin_layout Itemize
The sequence
\family typewriter
 UPDATE 
\begin_inset Formula $\rightarrow$
\end_inset

 ...
 
\begin_inset Formula $\rightarrow$
\end_inset

 UPDATE 
\begin_inset Formula $\rightarrow$
\end_inset

 DELETE 
\family default
on an existing tuple, has the same net effect as just deleting it.
\end_layout

\end_deeper
\begin_layout Remark
Rules consider the net effect of transactions between two database states,
 so each tuple appears at most once in each temporary table.
\end_layout

\begin_layout Example
Let's see the INSERTED and DELETED tables of our example.
 We start with the table
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sal
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
John
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
50
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mike
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sarah
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
120
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Example
And perform 
\family typewriter
UPDATE Emp SET Sal=110 WHERE Name='John'.
 
\family default
If we accessed the temporary tables now, we would see:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
INSERTED
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sal
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
John
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
110
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DELETED
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sal
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
John
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
50
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Example
Now, the rule is triggered because salary has been updated.
 The condition is met and the action is launched.
 If we accessed the temporary tables now, we would see:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
INSERTED
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sal
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
John
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
99
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mike
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
90
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sarah
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
108
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DELETED
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sal
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
John
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
50
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mike
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sarah
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
120
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Example
Note how the first tuple in INSERTED shows only the net effect on the tuple.
\end_layout

\begin_layout Standard
With this definitions, we can give a more precise definition of rule triggering:
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
A rule is 
\series bold
triggered
\series default
 if any of the transition relations corresponding to its triggering operations
 is not empty.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A great feature of rules is that it is possible to reference the transition
 tables, which can be very useful in many occasions.
\end_layout

\begin_layout Example
Now, imagine we want to add the rule '
\emph on
If an employee is inserted with a salary greater than 100, add the employee
 to the table of hifh paid employees'
\emph default
.
 This rule could be defined as:
\begin_inset listings
lstparams "language=SQL,morekeywords={CREATE, RULE, ON, WHEN, IF, EXISTS, SELECT, FROM, WHERE, AND, THEN, ROLLBACK}"
inline false
status open

\begin_layout Plain Layout

CREATE RULE HighPaid ON Emp
\end_layout

\begin_layout Plain Layout

WHEN 
\end_layout

\begin_layout Plain Layout

IF 
\end_layout

\begin_layout Plain Layout

	EXISTS (SELECT * FROM INSERTED WHERE Sal > 100)
\end_layout

\begin_layout Plain Layout

THEN 
\end_layout

\begin_layout Plain Layout

	INSERT INTO HighPaidEmp
\end_layout

\begin_layout Plain Layout

	(SELECT * FROM INSERTED WHERE Sal > 100)
\end_layout

\begin_layout Plain Layout

FOLLOWS SalaryControl;
\end_layout

\end_inset


\end_layout

\begin_layout Example
When we insert (James, 200), the tuple is inserted and the rules SalaryControl
 and HighPaid are triggered.
 Because we have defined HighPaid to follow SalaryControl, the latter would
 execute earlier.
 Now, SalaryControl, as we saw, would trigger more instances of the same
 rule, which would be all executed before HighPaid.
 At the end, as all employees would have been modified, all of them with
 a salary bigger than 100 would be added to the table HighPaidEmp because
 of this new rule.
 In this case, only James fullfills the condition.
\end_layout

\begin_layout Subsubsection
More Starbust commands
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=SQL,morekeywords={CREATE, RULE, ON, WHEN, IF, EXISTS, SELECT, FROM, WHERE, AND, THEN, ROLLBACK}"
inline false
status open

\begin_layout Plain Layout

1) DEACTIVATE RULE <rule-name> ON <table-name>
\end_layout

\begin_layout Plain Layout

		Makes the specified rule not to be taken into account.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

2) ACTIVATE RULE <rule-name> ON <table-name>
\end_layout

\begin_layout Plain Layout

		Makes the specified rule to be taken into account.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

3) DROP RULE <rule-name> ON <table-name>
\end_layout

\begin_layout Plain Layout

		Deletes the specified rule.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

4) CREATE RULESET <ruleset-name>
\end_layout

\begin_layout Plain Layout

		Creates a ruleset, i.e., a set of related rules.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

5) ALTER RULESET <ruleset-name> [ADDRULES <rule-names>] [DELRULES <rule-names>]
\end_layout

\begin_layout Plain Layout

		Allows to add or delete rules to/from a ruleset.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

6) DROP RULESET <ruleset-name>
\end_layout

\begin_layout Plain Layout

		Deletes the specified ruleset (but not the rules).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

7) PROCESS RULES
\end_layout

\begin_layout Plain Layout

		Processes all active rules.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

8) PROCESS RULESET <ruleset-name>
\end_layout

\begin_layout Plain Layout

		Process a specified ruleset, if it is active.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

9) PROCESS RULE <rule-name>
\end_layout

\begin_layout Plain Layout

		Process a specified rule, if it is active.
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Starbust's rule commands.
\begin_inset CommandInset label
LatexCommand label
name "tab:Starbust's-commands"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Oracle
\end_layout

\begin_layout Standard
In Oracle, the term used is TRIGGER.
 Triggers in Oracle respond to modification operations (INSERT, DELETE,
 UPDATE) to a relation, just as in Starburst.
\end_layout

\begin_layout Standard
The triggers in Oracle can be defined for different granularities:
\end_layout

\begin_layout Itemize

\series bold
Tuple-level
\series default
: the rule is triggered once for each tuple concerned by the triggering
 event.
\end_layout

\begin_layout Itemize

\series bold
Statement-level
\series default
: the rule is triggered only once even if several tuples are involved.
\end_layout

\begin_layout Standard
Also, the execution mode of triggers in Oracle is 
\series bold
immediate
\series default
, meaning they are executed just after the event has ben requested, in contrast
 to Starburst, in which the execution mode is referred, as we saw.
 This allows for rules to be executed before, after or even instead of the
 operation of the triggering event.
 In 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Oracles's-rule-definition"
plural "false"
caps "false"
noprefix "false"

\end_inset

, the definition syntax of triggers in Oracle is detailed.
 Some notes:
\end_layout

\begin_layout Itemize
The BEFORE or AFTER commands define when the rule should execute in relation
 to the events that trigger it.
\end_layout

\begin_layout Itemize
If FOR EACH ROW is written, then the trigger is a tuple-level trigger, and
 it is activated once for each tuple concerned.
 
\end_layout

\begin_deeper
\begin_layout Itemize
This is useful if the code in the actions depends on data provided by the
 triggering statement or on the tuples affected.
\end_layout

\begin_layout Itemize
The INSERTING, DELETING and UPDATING statements may be used in the action
 to check which triggering event has occurred.
\end_layout

\begin_layout Itemize
OLD and NEW reference the old value of the tuple (if it is update or delete)
 and the new value of the tuple (if it is update or insert).
\end_layout

\begin_layout Itemize
The condition consists of a simple predicate on the current tuple.
\end_layout

\end_deeper
\begin_layout Itemize
If FOR EACH ROW is not written, then the trigger is a statement-level trigger,
 and it is activated once for each triggering statement even if several
 tuples are involved or no tuple is updated.
\end_layout

\begin_deeper
\begin_layout Itemize
In this case, OLD and NEW are meaningless.
\end_layout

\begin_layout Itemize
This is useful if the code of the actions does not depend on the data provided
 by the triggering statement nor the tuples affected.
\end_layout

\begin_layout Itemize
It does not have a condition part
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fn:1"

\end_inset

It is not clear why Oracle engineers made it like this.
\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize
It does not have the possibility to refer to intermediate relations as in
 Starbust
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footref{fn:1}
\end_layout

\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize
Oracle triggers can execute actions containing arbitrary PL/SQL
\begin_inset Foot
status open

\begin_layout Plain Layout
PL/SQL extends SQL by adding the typical constructs of a programming language.
\end_layout

\end_inset

 code (not just SQL as in Starburst).
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=SQL,morekeywords={CREATE, RULE, ON, WHEN, IF, EXISTS, SELECT, FROM, WHERE, AND, THEN, ROLLBACK}"
inline false
status open

\begin_layout Plain Layout

CREATE TRIGGER <trigger-name> {BEFORE|AFTER} <list of trigger-events>
\end_layout

\begin_layout Plain Layout

ON <table-name>
\end_layout

\begin_layout Plain Layout

[REFERENCING <references>]
\end_layout

\begin_layout Plain Layout

[FOR EACH ROW]
\end_layout

\begin_layout Plain Layout

[WHEN (<condition>)]
\end_layout

\begin_layout Plain Layout

<actions>;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

where
\end_layout

\begin_layout Plain Layout

	<trigger-event> := INSERT | DELETE | UPDATE [OF <column-names>]
\end_layout

\begin_layout Plain Layout

	<references> := OLD as <old-tuple-name> | NEW as <new-tuple-name>
\end_layout

\begin_layout Plain Layout

	<actions> := <PL/SQL block>
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Oracle's rule definition syntax.
\begin_inset CommandInset label
LatexCommand label
name "tab:Oracles's-rule-definition"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Example
Row-level AFTER trigger.
\end_layout

\begin_layout Example
Imagine we have two tables:
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
Inventory(Part, PartOnHand, ReorderPoint, ReorderQty)
\end_layout

\begin_layout Itemize

\family typewriter
PendingOrders(Part, Qty, Date)
\end_layout

\end_deeper
\begin_layout Example
We want to define a rule that whenever a PartOnHand is modified, and its
 new value is smaller than the ReorderPoint (i.e.
 we have less parts than the threshold to order more parts), we add a new
 record to PendingOrders as a new order for this part and the required quantity,
 if it is not already done.
 This can be done as follows:
\end_layout

\begin_layout Example
\begin_inset listings
lstparams "language=SQL,morekeywords={CREATE, RULE, ON, WHEN, IF, EXISTS, SELECT, FROM, WHERE, AND, THEN, ROLLBACK, DECLARE, NUMBER, INSERT, INTO, VALUES, ENDIF, END, BEGIN, FOR, EACH, ROW, OF, AFTER, UPDATE, TRIGGER}"
inline false
status open

\begin_layout Plain Layout

CREATE TRIGGER Reorder
\end_layout

\begin_layout Plain Layout

AFTER UPDATE OF PartOnHand ON Inventory
\end_layout

\begin_layout Plain Layout

FOR EACH ROW
\end_layout

\begin_layout Plain Layout

WHEN (New.PartOnHand < New.ReorderPoint)
\end_layout

\begin_layout Plain Layout

	DECLARE NUMBER X;
\end_layout

\begin_layout Plain Layout

	BEGIN
\end_layout

\begin_layout Plain Layout

		SELECT COUNT(*) INTO X
\end_layout

\begin_layout Plain Layout

		FROM PendingOrders
\end_layout

\begin_layout Plain Layout

		WHERE Part = New.Part;
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		IF X=0 THEN
\end_layout

\begin_layout Plain Layout

			INSERT INTO PendingOrders VALUES (New.Part, New.ReorderQty, SYSDATE)
\end_layout

\begin_layout Plain Layout

		ENDIF;
\end_layout

\begin_layout Plain Layout

	END;
\end_layout

\end_inset


\end_layout

\begin_layout Example
Let's apply the rule to see how it works.
 Let's say our table Inventory is:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Part
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PartOnHand
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ReorderPoint
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ReorderQty
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
200
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
150
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
780
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
500
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
200
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
450
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
400
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
120
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Example
If we execute the following transaction on October 10, 2000:
\end_layout

\begin_layout Example
\begin_inset listings
lstparams "language=SQL,morekeywords={CREATE, RULE, ON, WHEN, IF, EXISTS, SELECT, FROM, WHERE, AND, THEN, ROLLBACK, DECLARE, NUMBER, INSERT, INTO, VALUES, ENDIF, END, BEGIN, FOR, EACH, ROW, OF, AFTER, UPDATE, TRIGGER}"
inline false
status open

\begin_layout Plain Layout

UPDATE Inventory
\end_layout

\begin_layout Plain Layout

SET PartOnHand = PartOnHand - 70
\end_layout

\begin_layout Plain Layout

WHERE Part = 1;
\end_layout

\end_inset


\end_layout

\begin_layout Example
Then the tuple 
\family typewriter
(1,100,2000-10-10)
\family default
 would be inserted into PendingOrders.
\end_layout

\begin_layout Standard
The algorithm for executing rules in Oracle is shown in Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Rule-Processing-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 As we can see, statement-level triggers are executed before/after anything
 else, and row-level triggers are executed before/after each affected tuple
 is modified.
 Note that the executions needs to take into account the priority among
 triggers, but only those of the same granularity (row vs statement) and
 type (before vs after).
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=SQL,morekeywords={while, is, not, select, in, if, execute, delete, from}"
inline false
status open

\begin_layout Plain Layout

For each STATEMENT-LEVEL BEFORE trigger
\end_layout

\begin_layout Plain Layout

	Execute trigger
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

For each row affected by the triggering statement
\end_layout

\begin_layout Plain Layout

	- For each ROW-LEVEL BEFORE trigger
\end_layout

\begin_layout Plain Layout

		Execute trigger
\end_layout

\begin_layout Plain Layout

	- Execute the modification of the row 
\end_layout

\begin_layout Plain Layout

	- Check row-level constraints and assertions
\end_layout

\begin_layout Plain Layout

	- For each ROW-LEVEL AFTER trigger
\end_layout

\begin_layout Plain Layout

		Execute trigger
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Check statement-level constraints and assertions
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

For each STATEMENT-LEVEL AFTER trigger
\end_layout

\begin_layout Plain Layout

	Execute trigger
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
processRules
\begin_inset CommandInset label
LatexCommand label
name "alg:Rule-Processing-1"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Oracle semantics
\end_layout

\begin_layout Itemize
The action part may activate other triggers.
 In that case, the execution of the current trigger is suspended and the
 others are considered using the same algorithm.
 There a maximum number of cascading triggerss, set at 32.
 When this maximum is reached, execution is suspended and an exception is
 raised.
\end_layout

\begin_layout Itemize
If an exception is raised or an error occurs, the changes made by the triggering
 statement and the actions performed by triggers are rolled back.
 This means that Oracle supports partial rollback instead of transaction
 rollback.
\end_layout

\begin_layout Subsubsection
Instead-of triggers
\end_layout

\begin_layout Standard
This is another type of Oracle trigger, in which the action is carried out
 inplace of the statement that produced the activating event.
 These triggers are typically used to update views and they need to be carefully
 used, because changing one action Y for an action X can sometimes have
 unexpected behaviors.
\end_layout

\begin_layout Example
An Instead-of trigger:
\end_layout

\begin_layout Example
\begin_inset listings
lstparams "language=SQL,morekeywords={CREATE, RULE, ON, WHEN, IF, EXISTS, SELECT, FROM, WHERE, AND, THEN, ROLLBACK, DECLARE, NUMBER, INSERT, INTO, VALUES, ENDIF, END, BEGIN, FOR, EACH, ROW, OF, AFTER, UPDATE, TRIGGER}"
inline false
status open

\begin_layout Plain Layout

CREATE TRIGGER manager-insert
\end_layout

\begin_layout Plain Layout

INSTEAD OF INSERT ON Managers
\end_layout

\begin_layout Plain Layout

REFERENCING NEW AS n
\end_layout

\begin_layout Plain Layout

FOR EACH ROW
\end_layout

\begin_layout Plain Layout

	UPDATE Dept d
\end_layout

\begin_layout Plain Layout

	SET mgrno = n.empno
\end_layout

\begin_layout Plain Layout

	WHERE d.deptno = n.deptno;
\end_layout

\end_inset


\end_layout

\begin_layout Example
This trigger automatically updates the manager of a department when a new
 manager is inserted.
\end_layout

\begin_layout Subsection
DB2
\end_layout

\begin_layout Standard
In DB2, every trigger monitors a single event, and are activated immediately,
 BEFORE or AFTER their event.
 They can be defined row-level or statement-level, as in Oracle.
 But in this case state-transition values can be accessed in both granularities:
\end_layout

\begin_layout Itemize
OLD and NEW refer to tuple granularity, as in Oracle.
\end_layout

\begin_layout Itemize
OLD_TABLE and NEW_TABLE refer to table granularity, like the DELETED and
 INSERTED in Starburst.
\end_layout

\begin_layout Standard
DB2's triggers cannot execute data definition nor transactional commands.
 They can raise errors which in turn can cause statement-level rollbacks.
\end_layout

\begin_layout Standard
The syntax is as in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:DB2's-rule-definition-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=SQL,morekeywords={CREATE, RULE, ON, WHEN, IF, EXISTS, SELECT, FROM, WHERE, AND, THEN, ROLLBACK}"
inline false
status open

\begin_layout Plain Layout

CREATE TRIGGER <trigger-name> {BEFORE|AFTER} <trigger-event>
\end_layout

\begin_layout Plain Layout

ON <table-name>
\end_layout

\begin_layout Plain Layout

[REFERENCING <references>]
\end_layout

\begin_layout Plain Layout

FOR EACH {ROW|STATEMENT}
\end_layout

\begin_layout Plain Layout

WHEN (<SQL-condition>)
\end_layout

\begin_layout Plain Layout

<SQL-procedure-statements>;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

where
\end_layout

\begin_layout Plain Layout

	<trigger-event> := INSERT | DELETE | UPDATE [OF <column-names>]
\end_layout

\begin_layout Plain Layout

	<references> := OLD as <old-tuple-name> | NEW as <new-tuple-name> |
\end_layout

\begin_layout Plain Layout

			OLD_TABLE as <old-table-name> | NEW_TABLE as <new-table-name>
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
DB2's rule definition syntax.
\begin_inset CommandInset label
LatexCommand label
name "tab:DB2's-rule-definition-1"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The processing is done as in Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Rule-Processing-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Note that:
\end_layout

\begin_layout Itemize
Steps 1) and 6) are not required when S if part of an user transaction.
\end_layout

\begin_layout Itemize
If an error occurs during the chain processing of S, then the prior DB state
 is restored.
\end_layout

\begin_layout Itemize
IC refers to Integrity Constraints.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=SQL,morekeywords={while, is, not, select, in, if, execute, delete, from}"
inline false
status open

\begin_layout Plain Layout

WHEN triggers ACTIVATE each other:
\end_layout

\begin_layout Plain Layout

	IF a modification statement S in the action A of a trigger causes event
 E:
\end_layout

\begin_layout Plain Layout

		1) SUSPEND execution of A, SAVE its data on a stack
\end_layout

\begin_layout Plain Layout

		2) COMPUTE OLD and NEW relative to E
\end_layout

\begin_layout Plain Layout

		3) EXECUTE BEFORE-triggers relative to E, update NEW
\end_layout

\begin_layout Plain Layout

		4) APPLY NEW transition values to DB.
\end_layout

\begin_layout Plain Layout

		   FOR EACH IC violated by current state with action Aj:
\end_layout

\begin_layout Plain Layout

			a) COMPUTE OLD and NEW relative to Aj
\end_layout

\begin_layout Plain Layout

			b) EXECUTE BEFORE-triggers relative to Aj, update NEW
\end_layout

\begin_layout Plain Layout

			c) APPLY NEW transition values to DB
\end_layout

\begin_layout Plain Layout

			d) PUSH ALL AFTER-triggers relative to Aj into 
\end_layout

\begin_layout Plain Layout

			   a queue of suspended triggers
\end_layout

\begin_layout Plain Layout

		5) EXECUTE ALL AFTER-triggers relative to E
\end_layout

\begin_layout Plain Layout

			IF ANY of them contains action Aj invoking other triggers:
\end_layout

\begin_layout Plain Layout

				REPEAT RECURSIVELY
\end_layout

\begin_layout Plain Layout

		6) POP from the stack the data for A, continue its evaluation
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
processRules
\begin_inset CommandInset label
LatexCommand label
name "alg:Rule-Processing-2"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
DB2 semantics
\end_layout

\begin_layout Itemize

\series bold
Before-triggers
\series default
: these are used to detect error conditions and to condition input values.
 They are executed entirely before the associated event and they cannot
 modify the DB (to avoid recursively activating more triggers).
\end_layout

\begin_layout Itemize

\series bold
After-triggers
\series default
: these are used to embed part of the application logic in the DB.
 The condition is evaluated and the action is possibly executed after the
 event occurs.
 The state of the DB prior to the event can be reconstructed from transition
 values.
\end_layout

\begin_layout Itemize
Several triggers can monitor the same event.
\end_layout

\begin_layout Itemize
In this case, the order is total and entirely based on the creation time
 of the triggers.
 Row-level and statement-level triggers are intertwined in the total order.
\end_layout

\begin_layout Itemize
If the action of a row-level trigger has several statements, they are all
 executed for one tuple before considering the next one.
\end_layout

\begin_layout Example
Imagine we have the following two tables:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Part
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\bar under
PartNum
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Supplier
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cost
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Jones
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
150
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Taylor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
500
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
HDD
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
400
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Jones
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
800
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Distributor
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
City
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
State
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Jones
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Palo Alto
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CA
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Taylor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Minneapolis
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MN
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
HDD
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Atlanta
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GA
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Example
And there is a referential integrity constraint that requires Part Suppliers
 to be also distributors, with HDD as a default Supplier:
\end_layout

\begin_layout Example
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

FOREIGN KEY (Supplier)
\end_layout

\begin_layout Plain Layout

	REFERENCES Distributor(Name)
\end_layout

\begin_layout Plain Layout

	ON DELETE SET DEFAULT;
\end_layout

\end_inset


\end_layout

\begin_layout Example
Then, the following trigger is a row-level trigger that rollbacks when updating
 Supplier to NULL:
\end_layout

\begin_layout Example
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

CREATE TRIGGER OneSupplier
\end_layout

\begin_layout Plain Layout

BEFORE UPDATE OF Supplier ON Part
\end_layout

\begin_layout Plain Layout

REFERENCING NEW AS N
\end_layout

\begin_layout Plain Layout

FOR EACH ROW
\end_layout

\begin_layout Plain Layout

WHEN (N.Supplier is NULL)
\end_layout

\begin_layout Plain Layout

	SIGNAL SQLSTATE '70005' ('Cannot change supplier to NULL');
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
SQL Server
\end_layout

\begin_layout Standard
In SQL Server, a single trigger can run multiple actions, and it can be
 fired by more than one event.
 Also, triggers can be attached to tables or views.
 SQL Server does not support BEFORE-triggers, but it supports AFTER-triggers
 (they can be defined using the word AFTER or FOR
\begin_inset Foot
status open

\begin_layout Plain Layout
FOR and WITH APPEND are used for backward compatibility, but will not be
 supported in the future.
\end_layout

\end_inset

) and INSTEAD OF-triggers.
 
\end_layout

\begin_layout Standard
The triggers can be fired with INSERT, UPDATE and DELETE statements.
 
\end_layout

\begin_layout Standard
The option WITH ENCRYPTION encrypts the text of the trigger in the syscomment
 table.
 
\end_layout

\begin_layout Standard
Finally, the option NOT FOR REPLICATION ensures that the trigger is not
 executed when a replication process modifies the table to which the trigger
 is attached.
\end_layout

\begin_layout Standard
The syntax is shown in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:SQLServer's-rule-definition-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=SQL,morekeywords={CREATE, RULE, ON, WHEN, IF, EXISTS, SELECT, FROM, WHERE, AND, THEN, ROLLBACK}"
inline false
status open

\begin_layout Plain Layout

CREATE TRIGGER <trigger-name> ON <table-name>
\end_layout

\begin_layout Plain Layout

[WITH ENCRYPTION]
\end_layout

\begin_layout Plain Layout

{FOR | AFTER | INSTEAD OF} <list of trigger-events>
\end_layout

\begin_layout Plain Layout

[WITH APPEND]
\end_layout

\begin_layout Plain Layout

[NOT FOR REPLICATION]
\end_layout

\begin_layout Plain Layout

AS <Transact-SQL-statements>;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

where
\end_layout

\begin_layout Plain Layout

	<trigger-event> := INSERT | DELETE | UPDATE
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
SQL Server's rule definition syntax.
\begin_inset CommandInset label
LatexCommand label
name "tab:SQLServer's-rule-definition-1"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\series bold
INSTEAD OF-triggers
\series default
: are defined on a table or a view.
 Triggers defined on a view extend the types of updates that a view support
 by default.
 Only one per triggering action is allowed on a table or view.
 Note that views can be defined on other views, and each of them can have
 its own INSTEAD OF-triggers.
\end_layout

\begin_layout Itemize

\series bold
AFTER-triggers
\series default
: are defined on a table.
 Modifications to views in which the table data is modified in response,
 will fire the AFTER-triggers of the table.
 More than one is allowed on a table.
 The 
\series bold
order of execution
\series default
 can be defined using the 
\emph on
sp_settriggerorder
\emph default
 procedure.
 All other triggers applied to a table execute in random order.
\end_layout

\begin_layout Subsubsection
SQL Server Semantics
\end_layout

\begin_layout Itemize
Both clases of triggers can be applied to a table.
\end_layout

\begin_layout Itemize
If both trigger classes and constraints are defined for a table, the INSTEAD
 OF-trigger fires first.
 Then, constraints are processed and finally AFTER-triggers are fired.
 
\end_layout

\begin_layout Itemize
If constraints are violated, INSTEAD OF-trigger's actions are rolled back.
\end_layout

\begin_layout Itemize
AFTER-triggers do not execute if constraints are violated or if some other
 event causes the table modification to fail.
\end_layout

\begin_layout Itemize
As stored procedures, triggers can be nested up to 32 levels deep and fired
 recursively.
\end_layout

\begin_layout Itemize
Two transition tables are available: INSERTED and DELETED, which are as
 in Starburst.
\end_layout

\begin_layout Itemize
The IF UPDATE(<column-name> clause determines whether an INSERT or UPDATE
 event ocurred to the column.
\end_layout

\begin_layout Itemize
The COLUMNS_UPDATE() clause returns a bit pattern indicating fhich of the
 tested columns were isnerted or updated.
\end_layout

\begin_layout Itemize
The @@ROWCOUNT function returns the number of rows affected by the previous
 Transact-SQL statement in the trigger.
\end_layout

\begin_layout Itemize
A trigger fires even if no rows are affected by the event.
 The RETURN command can be used to exit the trigger transparently when this
 happens.
\end_layout

\begin_layout Itemize
The RAISERROR command is used to display error messages.
\end_layout

\begin_layout Itemize
There are some Transact-SQL statements that are not allowd in triggers:
\end_layout

\begin_deeper
\begin_layout Itemize
ALTER, CREATE, DROP, RESTORE and LOAD DATABASE.
\end_layout

\begin_layout Itemize
LOAD and RESTORE LOG.
\end_layout

\begin_layout Itemize
DISK RESIZE and DISK INIT.
\end_layout

\begin_layout Itemize
RECONFIGURE.
\end_layout

\end_deeper
\begin_layout Itemize
If in a trigger's code it is needed to assign variables, then SET NOCOUNT
 ON must be included in the trigger code, disallowing the messages stating
 how many tuples were modified in each operation.
\end_layout

\begin_layout Subsubsection
Limitations
\end_layout

\begin_layout Itemize
The INSTEAD OF DELETE and INSTEAD OF UPDATE triggers cannot be defined on
 tables that have a correspoonding ON DELETE or ON UPDATE cascading referential
 integrity defined.
\end_layout

\begin_layout Itemize
Triggers cannot be created on a temporary or system table, but they can
 be referenced inside other triggers.
\end_layout

\begin_layout Subsubsection
Nested and Recursive triggers
\end_layout

\begin_layout Standard
SQL Server enables to enable or disable nested and recursive triggers:
\end_layout

\begin_layout Itemize

\series bold
Nested trigger option
\series default
: determines whether a trigger can be executed in cascade.
 There is a limit of 32 nested trigger operations.
 It can be set with 
\emph on
sp_configure 'nested triggers', 1 | 0
\emph default
.
\end_layout

\begin_layout Itemize

\series bold
Recursive trigger option
\series default
: causes triggers to be re-fired when the trigger modifies the same table
 as it is attached to: the neste trigger option must be set to true.
 This option can be set with 
\emph on
sp_dboption '<db-name>', 'recursive triggers', 'TRUE' | 'FALSE'
\emph default
.
\end_layout

\begin_deeper
\begin_layout Standard
Note that recursion can be 
\series bold
direct
\series default
 if a trigger activates another instance of itself or 
\series bold
indirect
\series default
 if the activation sequence is 
\begin_inset Formula $T_{1}\rightarrow T_{2}\rightarrow T_{1}$
\end_inset

.
 The recursive trigger option only copes with the direct recursion, the
 indirect kind is dealt with the nested trigger option.
\end_layout

\end_deeper
\begin_layout Subsubsection
Trigger management
\end_layout

\begin_layout Standard
Trigger management includes the task of altering, renaming, viewing, dropping
 and disabling triggers:
\end_layout

\begin_layout Itemize
Triggers can be modified with the ALTER TRIGGER statement, in which the
 new definition is provided.
\end_layout

\begin_layout Itemize
Triggers can be renamed with the 
\emph on
sp_rename
\emph default
 system stored procedure as
\end_layout

\begin_deeper
\begin_layout Standard
\align center

\emph on
sp_rename @objname = <old-name>, @newname = <new-name>
\end_layout

\end_deeper
\begin_layout Itemize
Triggers can be viewed by querying system tables or by using the 
\emph on
sp_helptrigger
\emph default
 and 
\emph on
sp_helptext
\emph default
 system stored procedures as
\end_layout

\begin_deeper
\begin_layout Standard
\align center

\emph on
sp_helptrigger @tabname = <table-name>
\end_layout

\begin_layout Standard
\align center

\emph on
sp_helptext @objname = <trigger-name>
\end_layout

\end_deeper
\begin_layout Itemize
Triggers can be deleted with the DROP TRIGGER statement.
\end_layout

\begin_layout Itemize
Triggers can be enable and disable using the ENABLE TRIGGER and DISABLE
 TRIGGER clauses of the ALTER TABLE statement.
\end_layout

\begin_layout Example
Let's work with a database with the following tables:
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
Books(
\bar under
TitleID
\bar default
, Title, Publisher, PubDate, Edition, Cost, QtySold)
\end_layout

\begin_layout Itemize

\family typewriter
Orders(
\bar under
OrderId
\bar default
, CustomerId, Amount, OrderDate)
\end_layout

\begin_layout Itemize

\family typewriter
BookOrders(
\bar under
OrderID, TitleId
\bar default
, Qty)
\end_layout

\end_deeper
\begin_layout Example
Here, Books.QtySold is a derived attribute which keeps track of how many
 copies of the book has been sold.
 We can make this updates automatic with the use of the following trigger:
\end_layout

\begin_layout Example
\begin_inset listings
lstparams "language=SQL,numbers=left,numberstyle={\small}"
inline false
status open

\begin_layout Plain Layout

CREATE TRIGGER update_book_qtysold ON BookOrders
\end_layout

\begin_layout Plain Layout

AFTER INSERT, UPDATE, DELETE AS
\end_layout

\begin_layout Plain Layout

-- add if insertion
\end_layout

\begin_layout Plain Layout

	IF EXISTS (SELECT * FROM INSERTED)
\end_layout

\begin_layout Plain Layout

	BEGIN
\end_layout

\begin_layout Plain Layout

		UPDATE Books
\end_layout

\begin_layout Plain Layout

		SET QtySold = QtySold + (SELECT sum(Qty) 
\end_layout

\begin_layout Plain Layout

					FROM INSERTED i
\end_layout

\begin_layout Plain Layout

					WHERE titleId = i.titleId)
\end_layout

\begin_layout Plain Layout

		WHERE titleID IN (SELECT i.titleID FROM INSERTED i)
\end_layout

\begin_layout Plain Layout

	END
\end_layout

\begin_layout Plain Layout

-- subtract if deletion
\end_layout

\begin_layout Plain Layout

	IF EXISTS (SELECT * FROM DELETED)
\end_layout

\begin_layout Plain Layout

	BEGIN
\end_layout

\begin_layout Plain Layout

UPDATE Books
\end_layout

\begin_layout Plain Layout

		SET QtySold = QtySold - (SELECT sum(Qty) 
\end_layout

\begin_layout Plain Layout

					FROM DELETED d
\end_layout

\begin_layout Plain Layout

					WHERE titleId = d.titleId)
\end_layout

\begin_layout Plain Layout

		WHERE titleID IN (SELECT d.titleID FROM DELETED d)
\end_layout

\begin_layout Plain Layout

	END
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
When there is an insertion in BookOrders, the trigger fires and adds the
 corresponding quantity.
\end_layout

\begin_layout Itemize
When there is a deletion, the trigger fires and subtracts the corresponding
 quantity.
\end_layout

\begin_layout Itemize
An update creates both tables, so we would add and subtract to cope with
 the modification.
\end_layout

\end_deeper
\begin_layout Section
Applications of Active Rules
\end_layout

\begin_layout Standard
Rules provide programmers with an effective tool to support both internal
 applications and external applications:
\end_layout

\begin_layout Itemize

\series bold
Internal applications
\series default
: rules support function provided by specific subsystems in passive DBSMs,
 such as the management of IC, derived data, replicated data, version maintenanc
e,...
 Rules can usually be declaratively specified, generated by the system and
 hidden to the user.
\end_layout

\begin_layout Itemize

\series bold
External applications
\series default
: these refer to the application of business rules to the data stored.
 Rules allow to perform computations that would usually need to be expressed
 in application code.
 In addition, rules provide many times a natural way to model reactive behavior
 of the data, as rules respond to external events and perform action in
 consequence.
 This approach becomes specially interested when rules express central policies,
 i.e., knowledge common to applications, centralizing the effort and reducing
 the cost.
\end_layout

\begin_layout Standard
Some examples of applications that can benefit from active technology and
 business rules are:
\end_layout

\begin_layout Itemize
Monitoring access to a building and reacting to abnormal circumstances.
\end_layout

\begin_layout Itemize
Watching evolution of share values on stock market and triggering trading
 actions.
\end_layout

\begin_layout Itemize
Managing inventory to follow stock variations.
\end_layout

\begin_layout Itemize
Managing a netwrok to for energy distribution.
\end_layout

\begin_layout Itemize
Airway assignment in air traffic control.
\end_layout

\begin_layout Standard
As can be seen from these examples, a frequent case of application-specific
 rules are 
\series bold
alterters
\series default
, whose actions signal certain conditions that occur with ot without changing
 the database.
\end_layout

\begin_layout Subsection
A summary of Integrity Constraints
\end_layout

\begin_layout Standard
The 
\series bold
integrity
\series default
 of a database refers to the consistency and conformity of the data with
 the database schema and its constraints.
 Thus, an 
\series bold
integrity constraint
\series default
 is any assertion on the schema which is not defined in the data-structure
 aprt of the schema.
 Constraints declaratively specify conditions to be satisfied by the data
 at all times, so checking for integrity violations is done for every update
 of the state of the database.
\end_layout

\begin_layout Standard
Integrity constraints can be 
\series bold
static
\series default
 if the predicates are evaluated on database states or 
\series bold
dynamic
\series default
 if the predicates are evaluated on state transitions.
 They can also be classified as 
\series bold
built-in
\series default
 if they are defined by special DDL (Data Definition Language) constructs
 (such as keys, nonnull values,...) or 
\series bold
adhoc
\series default
, which are arbitrarily complex domain-dependent constraints.
\end_layout

\begin_layout Standard
In practice, integrity maintenance is achieved through:
\end_layout

\begin_layout Itemize
DBMS checks built-in constraint with automatically generated triggers.
\end_layout

\begin_layout Itemize
DBMS supports limited forms of adhoc constraints.
\end_layout

\begin_layout Itemize
The remaining constraints are implemented as active rules (triggers).
\end_layout

\begin_layout Standard
The process of 
\series bold
rule generation
\series default
 may be partially automated:
\end_layout

\begin_layout Enumerate
The possible causes of violation are the events for the activation of the
 rule.
\end_layout

\begin_layout Enumerate
The declarative formulation of the constraint is the rule condition.
\end_layout

\begin_layout Enumerate
To avoid or eliminate the violation, an action is taken.
 The simplest approach is to rollback the transaction, this is done by 
\series bold
abort rules
\series default
, in contrast, the richer approach provides a domain-dependent corrective
 action, via 
\series bold
repair rules
\series default
.
\end_layout

\begin_layout Standard
Thus:
\end_layout

\begin_layout Itemize

\series bold
Abort rules
\series default
 check that integrity is not violation and prevent the execution of an operation
 which would cause the violation of the integrity by means of the ROLLBACK
 command.
\end_layout

\begin_layout Itemize

\series bold
Repair rules
\series default
 are more sophisticated than abort rules, because they make use of application-d
omain semantics to define a set of actions that restore integrity
\end_layout

\begin_layout Example
Let's do a referential integrity example in Starburst:
\end_layout

\begin_layout Example
We have relations 
\family typewriter
Emp(
\bar under
EmpNo
\bar default
,DeptNo)
\family default
 and 
\family typewriter
Dept(
\bar under
DNo
\bar default
)
\family default
.
 We have the regerential integrity condition 
\begin_inset Formula 
\[
Emp\left[DeptNo\right]\subset Dept\left[DNo\right],
\]

\end_inset

 so the possible violations can come from an INSERT into Emp, a DELETE from
 Dept, and UPDATE of Emp[DeptNo] and an update of Dept[Dno].
 The condition on tuples of Emp for not violating the constraint is:
\end_layout

\begin_layout Example
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

EXISTS (SELECT * FROM Dept WHERE DNo = Emp.DeptNo)
\end_layout

\end_inset


\end_layout

\begin_layout Example
Its denial form, so the constraint is violated is:
\end_layout

\begin_layout Example
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

NOT EXISTS (SELECT * FROM Dept WHERE DNo = Emp.DeptNo)
\end_layout

\end_inset


\end_layout

\begin_layout Example
Thus, we can create abort rules as:
\end_layout

\begin_layout Example
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

CREATE RULE DeptEmp1 ON Emp
\end_layout

\begin_layout Plain Layout

WHEN INSERTED, UPDATED(DeptNo)
\end_layout

\begin_layout Plain Layout

IF EXISTS (SELECT * FROM Emp 
\end_layout

\begin_layout Plain Layout

		WHERE NOT EXISTS (SELECT * FROM Dept WHERE DNo=Emp.DeptNo))
\end_layout

\begin_layout Plain Layout

THEN ROLLBACK;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

CREATE RULE DeptEmp2 ON Dept
\end_layout

\begin_layout Plain Layout

WHEN DELETED, UPDATED(DNo)
\end_layout

\begin_layout Plain Layout

IF EXISTS (SELECT * FROM Emp 
\end_layout

\begin_layout Plain Layout

		WHERE NOT EXISTS (SELECT * FROM Dept WHERE DNo=Emp.DeptNo))
\end_layout

\begin_layout Plain Layout

THEN ROLLBACK;
\end_layout

\end_inset


\end_layout

\begin_layout Example
Note that one rule is neccessary for each relation.
\end_layout

\begin_layout Example
Note also that the defined rules are inneficient, because the computation
 of the condition checks the whole database.
 Rules can assume that the constraint is verified in the initial state,
 so it suffices to compute the condition relative to transition tables.
\end_layout

\begin_layout Example
Now, we are defining a repair rule that:
\end_layout

\begin_deeper
\begin_layout Itemize
If an employee is inserted with a wrong value of DeptNo, it is set to NULL.
\end_layout

\begin_layout Itemize
If the DeptNo of an employee is updated with a wrong value of DeptNo, it
 is set to 99.
\end_layout

\begin_layout Itemize
If a department is deleted or its DNo is updated, then all employees from
 this department are deleted.
\end_layout

\end_deeper
\begin_layout Example
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

CREATE RULE DeptEmp1 ON Emp
\end_layout

\begin_layout Plain Layout

WHEN INSERTED, 
\end_layout

\begin_layout Plain Layout

IF EXISTS (SELECT * FROM INSERTED I 
\end_layout

\begin_layout Plain Layout

		WHERE NOT EXISTS (SELECT * FROM Dept D WHERE D.DNo=I.DeptNo))
\end_layout

\begin_layout Plain Layout

THEN UPDATE Emp
\end_layout

\begin_layout Plain Layout

	SET DeptNo = NULL
\end_layout

\begin_layout Plain Layout

	WHERE EmpNo IN (SELECT EmpNo FROM INSERTED I) AND
\end_layout

\begin_layout Plain Layout

		NOT EXISTS (SELECT * FROM Dept D WHERE D.DNo=Emp.DeptNo);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

CREATE RULE DeptEmp2 ON Emp
\end_layout

\begin_layout Plain Layout

WHEN UPDATED(DeptNo)
\end_layout

\begin_layout Plain Layout

IF EXISTS (SELECT * FROM INSERTED I JOIN DELETED D ON I.EmpNo = D.EmpNo
\end_layout

\begin_layout Plain Layout

		WHERE NOT EXISTS (SELECT * FROM Dept D WHERE D.DNo=Emp.DeptNo))
\end_layout

\begin_layout Plain Layout

THEN UPDATE Emp
\end_layout

\begin_layout Plain Layout

	SET DeptNo = 99
\end_layout

\begin_layout Plain Layout

	WHERE EmpNo IN (SELECT EmpNo FROM INSERTED I JOIN DELETED D ON I.EmpNo =
 D.EmpNo)
\end_layout

\begin_layout Plain Layout

		AND NOT EXISTS (SELECT * FROM Dept D WHERE D.DNo = Emp.DeptNo);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

CREATE RULE DeptEmp3 ON Dept
\end_layout

\begin_layout Plain Layout

WHEN UPDATED(DNo), DELETED
\end_layout

\begin_layout Plain Layout

IF EXISTS (SELECT * FROM Emp 
\end_layout

\begin_layout Plain Layout

			WHERE EXISTS(SELECT * FROM DELETED D WHERE D.DNo = Emp.DeptNo))
\end_layout

\begin_layout Plain Layout

THEN DELETE FROM Emp
\end_layout

\begin_layout Plain Layout

	WHERE EXISTS(SELECT * FROM DELETED D WHERE D.DNo = Emp.DeptNo));
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Management of Derived Data
\end_layout

\begin_layout Standard
A 
\series bold
view
\series default
 can be seen as a query on the DB which returns a relation or a class that
 can be used as any other relation or class.
 A 
\series bold
derived attribute
\series default
 is an attribute that can be computed from other attributes in the DB.
 Both a view and a derived attribute can be expressed with declarative query
 language or deductive rules.
 There are two strategies for derived data:
\end_layout

\begin_layout Enumerate

\series bold
Virtually supported
\series default
: their content is computed on demand.
\end_layout

\begin_layout Enumerate

\series bold
Materialized
\series default
: their content is stored in the database, and it must be recomputed whenever
 the source of data is changed.
\end_layout

\begin_layout Subsubsection
Virtual views with rules
\end_layout

\begin_layout Standard
When an application queries a view, a rule is triggered on the request and
 the action substitutes and evaluates the view definition.
 It requires an event, triggered by queries, and an INSTEAD OF clause in
 rule language.
\end_layout

\begin_layout Standard
There exist two basic strategies:
\end_layout

\begin_layout Itemize

\series bold
Refresh
\series default
: recompute the view from scratch after each update of the source data.
\end_layout

\begin_layout Itemize

\series bold
Incremental
\series default
: compute changes to the view from changes in the source relations, using
 positive and negative deltas (a 
\series bold
delta
\series default
 shows the changes experienced in the database.
 INSERTED and DELETED are one way to implement deltas).
\end_layout

\begin_layout Standard
The rule generation can be automated.
 Refresh rules are simple, but can be very inefficient.
 On the other hand, incremental rules depend on the structure of derivation
 rules, and can be complex.
\end_layout

\begin_layout Example
Imagine we have the following view definition:
\end_layout

\begin_layout Example
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

DEFINE VIEW HighPaidDept AS
\end_layout

\begin_layout Plain Layout

	(SELECT DISTINCT Dept.Name
\end_layout

\begin_layout Plain Layout

	FROM Dept, Emp
\end_layout

\begin_layout Plain Layout

	WHERE Dept.Dno = Emp.DeptNo AND Emp.Sal > 50000);
\end_layout

\end_inset

So this view holds are departments in which some employee earns more than
 50k€ a year.
 This view can change whenever an employee is inserted or deleted, its departmen
t is changed or is salary is changed; and whenever a department is inserted
 or deleted, or its Dno is updated.
\end_layout

\begin_layout Example
A refresh rule defined in Starburst to handle this changes is:
\end_layout

\begin_layout Example
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

CREATE RULE RefreshHighPaidDept1 ON Emp
\end_layout

\begin_layout Plain Layout

WHEN INSERTED, DELETED, UPDATED(DeptNo), UPDATED(Sal)
\end_layout

\begin_layout Plain Layout

THEN DELETE * FROM HighPaidDept;
\end_layout

\begin_layout Plain Layout

	INSERT INTO HighPaidDept
\end_layout

\begin_layout Plain Layout

		(SELECT DISTINCT Dept.Name
\end_layout

\begin_layout Plain Layout

		FROM Dept, Emp
\end_layout

\begin_layout Plain Layout

		WHERE Dept.Dno = Emp.DeptNo AND Emp.Sal > 50000);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

CREATE RULE RefreshHighPaidDept2 ON Dept
\end_layout

\begin_layout Plain Layout

WHEN INSERTED, DELETED, UPDATED(Dno)
\end_layout

\begin_layout Plain Layout

THEN DELETE * FROM HighPaidDept;
\end_layout

\begin_layout Plain Layout

	INSERT INTO HighPaidDept
\end_layout

\begin_layout Plain Layout

		(SELECT DISTINCT Dept.Name
\end_layout

\begin_layout Plain Layout

		FROM Dept, Emp
\end_layout

\begin_layout Plain Layout

		WHERE Dept.Dno = Emp.DeptNo AND Emp.Sal > 50000);
\end_layout

\end_inset


\end_layout

\begin_layout Example
As we can see, all elements from the view are deleted, and the view is recompute
d entirely.
 The incremental approach is more complex.
 As an example, let's define the rule for the case of Insert Dept:
\end_layout

\begin_layout Example
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

CREATE RULE IncHighPaidDept1 ON Dept
\end_layout

\begin_layout Plain Layout

WHEN INSERTED
\end_layout

\begin_layout Plain Layout

THEN INSERT INTO HighPaidDept
\end_layout

\begin_layout Plain Layout

	(SELECT DISTINCT Dept.Name
\end_layout

\begin_layout Plain Layout

	FROM INSERTED I, Emp
\end_layout

\begin_layout Plain Layout

	WHERE I.Dno = Emp.DeptNo AND Emp.Sal > 50000);
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Replication with rules
\end_layout

\begin_layout Standard
Replication consists on storing several copies of the same information.
 This is a common practice in distributed databases.
 Keeping 
\series bold
fully synchronized copies
\series default
 is usually very costly and unnecessary, so it is common to use aynchronous
 techniques to propagate changes between nodes.
\end_layout

\begin_layout Itemize

\series bold
Assymmetric replication
\series default
: in this case there exists a primary copy, in which changes are performed,
 and several secondary copies, which are read only and are updated asynchronousl
y.
 The 
\series bold
capture module
\series default
 monitors changes made by applications to the primary copy, and the 
\series bold
application module
\series default
 propagates these changes to the secondary copies.
\end_layout

\begin_layout Itemize

\series bold
Symmetric replication
\series default
: all copies accept updates asynchronously and each of them has a capture
 and an application modules.
 It is needed to be careful, because simultaneous updates may cause loss
 of consistency.
\end_layout

\begin_layout Example
An example of capturing changes into deltas in Starburst:
\end_layout

\begin_layout Example
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

CREATE RULE Capture1 ON PrimaryCopy
\end_layout

\begin_layout Plain Layout

WHEN INSERTED
\end_layout

\begin_layout Plain Layout

THEN INSERT INTO PosDelta (SELECT * FROM INSERTED);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

CREATE RULE Capture2 ON PrimaryCopy
\end_layout

\begin_layout Plain Layout

WHEN DELETED
\end_layout

\begin_layout Plain Layout

THEN INSERT INTO NegDelta (SELECT * FROM DELETED);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

CREATE RULE Capture3 ON PrimaryCopy
\end_layout

\begin_layout Plain Layout

WHEN UPDATED
\end_layout

\begin_layout Plain Layout

THEN INSERT INTO PosDelta (SELECT * FROM INSERTED);
\end_layout

\begin_layout Plain Layout

	INSERT INTO NegDelta (SELECT * FROM DELETED);
\end_layout

\end_inset


\end_layout

\begin_layout Example
The deltas are applied to the copies with a predefined policy, e.g.
 once very hour.
\end_layout

\begin_layout Subsection
Business Rules: Advantages and Difficulties
\end_layout

\begin_layout Subsubsection
Advantages
\end_layout

\begin_layout Itemize
Active rules can impose a central consistent behavior independent of the
 transactions that cause their execution.
\end_layout

\begin_layout Itemize
Active rules enforce data management policies that no transaction can violate.
\end_layout

\begin_layout Itemize
Activities redundantly coded in several applications programs with passive
 DBMSs can be abstracted in a single version as a rule in an active DBMS.
\end_layout

\begin_layout Itemize
Data management policies can evolve by just modifying the rules on the database,
 instead of the application programs (
\series bold
knowledge independence
\series default
).
\end_layout

\begin_layout Subsubsection
Dificulties
\end_layout

\begin_layout Itemize
Rule organization and content are often hard to control and to specify declarati
vely (i.e.
 the rules are hard to code!).
\end_layout

\begin_layout Itemize
Understanding active rules can be difficult, because they can react to intricate
 event sequences and the outcome of rule processing can depend on the order
 of the event ocurrences and the rule scheduling, which can be hard to analyze
 in complex systems.
\end_layout

\begin_layout Itemize
There are no easy-to-use nor one-fits-all techniques for designing, debugging,
 verifying and monitoring rules.
\end_layout

\begin_layout Subsection
A case study: Energy Management System
\end_layout

\begin_layout Standard
This is an example of an application modeled with active rules, covering
 the business process:
\end_layout

\begin_layout Standard
\align center

\emph on
'Management of the Italian electrical power distribution network.'
\end_layout

\begin_layout Standard
The operational network is a forest of trees, connecting power distributors
 to users.
 The operating conditions are monitored constantly with frequent reconfiguration
s: the structure of the network is dynamic.
 The topology is modified less frequently (we can consider it static).
 The 
\series bold
objective
\series default
 is to transfer the exact power from distributors to users through nodes
 and directed branches connecting pairs of nodes.
\end_layout

\begin_layout Standard
In this scenario, active rules are used to respond to input transactions
 asking for:
\end_layout

\begin_layout Itemize
Reconfigurations due to new users.
\end_layout

\begin_layout Itemize
Changes in their required power.
\end_layout

\begin_layout Itemize
Changes in the assignment of wires.
\end_layout

\begin_layout Standard
The 
\series bold
schema 
\series default
of the database is:
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family typewriter
User(
\bar under
UserId
\bar default
, BranchIn, Power) foreign key (BranchIn) References Branch
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family typewriter
Branch(
\bar under
BranchId
\bar default
, FromNode, ToNode, Power)
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family typewriter
Node(
\bar under
NodeId
\bar default
, BranchIn, Power) foreign key (BranchIn) References Branch
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family typewriter
Distributor(
\bar under
NodeId
\bar default
, Power, MaxPower)
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family typewriter
Wire(
\bar under
WireId
\bar default
, BranchId, WireType, Power) foreign key (BranchId) references Branch foreign
 key (WirteType) references WireType
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
WireType(
\bar under
WireTypeId
\bar default
, MaxPower)
\end_layout

\begin_layout Standard
The network is composed of sites anc onnections between pairs of sites:
\end_layout

\begin_layout Itemize
Sites comprise:
\end_layout

\begin_deeper
\begin_layout Itemize
Power stations: distributors where power is generated and fed into the network.
\end_layout

\begin_layout Itemize
Intermediate nodes: nodes where power is transferred to be redistributed
 across the network.
\end_layout

\begin_layout Itemize
Final users of electrical power.
\end_layout

\end_deeper
\begin_layout Itemize
Connections are called branches:
\end_layout

\begin_deeper
\begin_layout Itemize
class Branch describes all connections between pairs of sites.
\end_layout

\begin_layout Itemize
Several Wires are placed along the branches.
\end_layout

\begin_layout Itemize
Wires are made of a given WireType, each type carrying a maximum power.
\end_layout

\begin_layout Itemize
Branches can be dinamically added or dropeed to the network.
\end_layout

\end_deeper
\begin_layout Standard
The 
\series bold
business rules
\series default
 are the following:
\end_layout

\begin_layout Itemize
Several user requests are gathered in a transaction.
\end_layout

\begin_layout Itemize
If the power requested on wires excees the maximum power of the wire type,
 rules change or add wires in the relevant branches.
\end_layout

\begin_layout Itemize
Rules propagate changes up in the tree, adapting the network to new user
 needs.
\end_layout

\begin_layout Itemize
A transaction fails if the maximum power requested from some distributor
 exceeds the maximum power available at the distributor (in that case, the
 static network needs to be redesigned, but this is out of our scope).
\end_layout

\begin_layout Itemize
To avoid unnecessary rollbacks, rules propagate reductions of power first,
 then increases of power.
 This requires setting the order in which the triggers execute
\begin_inset Foot
status open

\begin_layout Plain Layout
This means we cannot perform this use case in SQL Server because the order
 of the rules cannot be specified.
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Connect a new user
\end_layout

\begin_layout Standard
A new user is connecting to a node with the following procedure:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

CREATE PROCEDURE insertUser(@Node char(3), @Power int) AS
\end_layout

\begin_layout Plain Layout

	DECLARE @User char(3), @Branch char(3), @Wire char(3)
\end_layout

\begin_layout Plain Layout

	EXEC @User = nextUserId
\end_layout

\begin_layout Plain Layout

	EXEC @Branch = nextBranchId
\end_layout

\begin_layout Plain Layout

	EXEC @Wire = nextWireId
\end_layout

\begin_layout Plain Layout

	INSERT INTO Branch (BranchId, FromNode, ToNode, Power)
\end_layout

\begin_layout Plain Layout

		VALUES (@Branch, @User, @Node, @Power)
\end_layout

\begin_layout Plain Layout

	INSERT INTO Wire (WireId, Branch, WireType, Power)
\end_layout

\begin_layout Plain Layout

		VALUES (@Wire, @Branch, 'WT1', @Power)
\end_layout

\begin_layout Plain Layout

	INSERT INTO User (UserId, BranchIn, Power)
\end_layout

\begin_layout Plain Layout

		VALUES (@User, @Branch, @Power);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The node to which a user is connected is determined by an external application:
 usually its closest node.
 'WT1' is the basic wire type.
 nextUserId, nextBranchId and nextWireId procedures are used to obtain the
 next identifier of a user, branch or wire.
\end_layout

\begin_layout Subsubsection
Propagation of power reduction from a user
\end_layout

\begin_layout Standard
If a user requires less power, this change needs to be propagated to its
 input branch:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

CREATE TRIGGER T1_User_Branch ON User
\end_layout

\begin_layout Plain Layout

AFTER UPDATE AS
\end_layout

\begin_layout Plain Layout

-- If some user has decreased its power consumption
\end_layout

\begin_layout Plain Layout

IF EXISTS (SELECT * FROM Inserted I JOIN Deleted D 
\end_layout

\begin_layout Plain Layout

		ON I.UserId = D.UserId WHERE D.Power > I.Power)
\end_layout

\begin_layout Plain Layout

BEGIN
\end_layout

\begin_layout Plain Layout

	UPDATE Branch
\end_layout

\begin_layout Plain Layout

-- Decrease the power consumption by the difference between the past and
 the new values
\end_layout

\begin_layout Plain Layout

	SET Power = Power - (SELECT D.Power - I.Power
\end_layout

\begin_layout Plain Layout

				FROM Inserted I JOIN Deleted D ON I.UserId = D.UserId
\end_layout

\begin_layout Plain Layout

				WHERE I.BranchIn = BranchIn AND D.Power > I.Power) -- Make sure the branch
 is the correct one
\end_layout

\begin_layout Plain Layout

	WHERE BranchId IN (SELECT BranchIn FROM Inserted)
\end_layout

\begin_layout Plain Layout

END;
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Propagation of power reduction from a node
\end_layout

\begin_layout Standard
If a node require less power, propagate the change to its input branch:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

CREATE TRIGGER T2_Node_Branch ON Node
\end_layout

\begin_layout Plain Layout

AFTER UPDATE AS
\end_layout

\begin_layout Plain Layout

-- If some node has decreased its power consumption
\end_layout

\begin_layout Plain Layout

IF EXISTS (SELECT * FROM Inserted I JOIN Deleted D 
\end_layout

\begin_layout Plain Layout

		ON I.NodeId = D.NodeId WHERE D.Power > I.Power)
\end_layout

\begin_layout Plain Layout

BEGIN
\end_layout

\begin_layout Plain Layout

	UPDATE Branch
\end_layout

\begin_layout Plain Layout

-- Decrease the power consumption by the difference between the past and
 the new values
\end_layout

\begin_layout Plain Layout

	SET Power = Power - (SELECT D.Power - I.Power
\end_layout

\begin_layout Plain Layout

				FROM Inserted I JOIN Deleted D ON I.NodeId = D.NodeId
\end_layout

\begin_layout Plain Layout

				WHERE I.BranchIn = BranchIn AND D.Power > I.Power) -- Make sure the branch
 is the correct one
\end_layout

\begin_layout Plain Layout

	WHERE BranchId IN (SELECT BranchIn FROM Inserted)
\end_layout

\begin_layout Plain Layout

END;
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Propagation of power reduction from a branch to a node
\end_layout

\begin_layout Standard
If a branch connected to a node requires less power, propagate the change
 to its input node.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

CREATE TRIGGER T3_Branch_Node ON Branch
\end_layout

\begin_layout Plain Layout

AFTER UPDATE AS
\end_layout

\begin_layout Plain Layout

-- If some branch has decreased its power consumption
\end_layout

\begin_layout Plain Layout

IF EXISTS (SELECT * FROM Inserted I JOIN Deleted D 
\end_layout

\begin_layout Plain Layout

		ON I.BranchId = D.BranchId 
\end_layout

\begin_layout Plain Layout

		WHERE D.Power > I.Power AND I.ToNode IN (SELECT NodeId FROM Node)) -- toNode
 is not a foreign key, so we need to make sure it is a node
\end_layout

\begin_layout Plain Layout

BEGIN
\end_layout

\begin_layout Plain Layout

	UPDATE Node
\end_layout

\begin_layout Plain Layout

-- Decrease the power consumption by the difference between the past and
 the new values
\end_layout

\begin_layout Plain Layout

	SET Power = Power - (SELECT D.Power - I.Power
\end_layout

\begin_layout Plain Layout

				FROM Inserted I JOIN Deleted D ON I.BranchId = D.BranchId
\end_layout

\begin_layout Plain Layout

				WHERE I.ToNode = NodeId AND D.Power > I.Power) -- Make sure the node is
 the correct one
\end_layout

\begin_layout Plain Layout

	WHERE NodeId IN (SELECT toNode FROM Inserted)
\end_layout

\begin_layout Plain Layout

END;
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Propagation of power reduction from a branch to a distributor
\end_layout

\begin_layout Standard
If a branch connected to a distributor requires less power, propagate the
 change to the distributor.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

CREATE TRIGGER T4_Branch_Distributor ON Branch
\end_layout

\begin_layout Plain Layout

AFTER UPDATE AS
\end_layout

\begin_layout Plain Layout

-- If some branch has decreased its power consumption
\end_layout

\begin_layout Plain Layout

IF EXISTS (SELECT * FROM Inserted I JOIN Deleted D 
\end_layout

\begin_layout Plain Layout

		ON I.BranchId = D.BranchId 
\end_layout

\begin_layout Plain Layout

		WHERE D.Power > I.Power AND I.ToNode IN (SELECT NodeId FROM Distributor))
 -- toNode is not a foreign key, so we need to make sure it is a distributor
\end_layout

\begin_layout Plain Layout

BEGIN
\end_layout

\begin_layout Plain Layout

	UPDATE Distributor
\end_layout

\begin_layout Plain Layout

-- Decrease the power consumption by the difference between the past and
 the new values
\end_layout

\begin_layout Plain Layout

	SET Power = Power - (SELECT D.Power - I.Power
\end_layout

\begin_layout Plain Layout

				FROM Inserted I JOIN Deleted D ON I.BranchId = D.BranchId
\end_layout

\begin_layout Plain Layout

				WHERE I.ToNode = NodeId AND D.Power > I.Power) -- Make sure the node is
 the correct one
\end_layout

\begin_layout Plain Layout

	WHERE NodeId IN (SELECT BranchIn FROM Inserted)
\end_layout

\begin_layout Plain Layout

END;
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Propagation of power increase from a user
\end_layout

\begin_layout Standard
If a user requires more power, propagate the change to its input branch.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

CREATE TRIGGER T5_User_Branch ON User
\end_layout

\begin_layout Plain Layout

AFTER UPDATE AS
\end_layout

\begin_layout Plain Layout

-- If some user has increased its power consumption
\end_layout

\begin_layout Plain Layout

IF EXISTS (SELECT * FROM Inserted I JOIN Deleted D 
\end_layout

\begin_layout Plain Layout

		ON I.UserId = D.UserId WHERE D.Power < I.Power)
\end_layout

\begin_layout Plain Layout

BEGIN
\end_layout

\begin_layout Plain Layout

	UPDATE Branch
\end_layout

\begin_layout Plain Layout

-- Increase the power consumption by the difference between the new and
 the past values
\end_layout

\begin_layout Plain Layout

	SET Power = Power - (SELECT D.Power - I.Power
\end_layout

\begin_layout Plain Layout

				FROM Inserted I JOIN Deleted D ON I.UserId = D.UserId
\end_layout

\begin_layout Plain Layout

				WHERE I.BranchIn = BranchIn AND D.Power < I.Power) -- Make sure the branch
 is the correct one
\end_layout

\begin_layout Plain Layout

	WHERE BranchId IN (SELECT BranchIn FROM Inserted)
\end_layout

\begin_layout Plain Layout

END;
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Propagation of power increase from a node
\end_layout

\begin_layout Standard
If a node require more power, propagate the change to its input branch:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

CREATE TRIGGER T6_Node_Branch ON Node
\end_layout

\begin_layout Plain Layout

AFTER UPDATE AS
\end_layout

\begin_layout Plain Layout

-- If some node has increased its power consumption
\end_layout

\begin_layout Plain Layout

IF EXISTS (SELECT * FROM Inserted I JOIN Deleted D 
\end_layout

\begin_layout Plain Layout

		ON I.NodeId = D.NodeId WHERE D.Power < I.Power)
\end_layout

\begin_layout Plain Layout

BEGIN
\end_layout

\begin_layout Plain Layout

	UPDATE Branch
\end_layout

\begin_layout Plain Layout

-- Increase the power consumption by the difference between the new and
 the past values
\end_layout

\begin_layout Plain Layout

	SET Power = Power - (SELECT D.Power - I.Power
\end_layout

\begin_layout Plain Layout

				FROM Inserted I JOIN Deleted D ON I.NodeId = D.NodeId
\end_layout

\begin_layout Plain Layout

				WHERE I.BranchIn = BranchIn AND D.Power < I.Power) -- Make sure the branch
 is the correct one
\end_layout

\begin_layout Plain Layout

	WHERE BranchId IN (SELECT BranchIn FROM Inserted)
\end_layout

\begin_layout Plain Layout

END;
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Propagation of power increase from a branch to a node
\end_layout

\begin_layout Standard
If a branch connected to a node requires more power, propagate the change
 to its input node.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

CREATE TRIGGER T7_Branch_Node ON Branch
\end_layout

\begin_layout Plain Layout

AFTER UPDATE AS
\end_layout

\begin_layout Plain Layout

-- If some branch has increased its power consumption
\end_layout

\begin_layout Plain Layout

IF EXISTS (SELECT * FROM Inserted I JOIN Deleted D 
\end_layout

\begin_layout Plain Layout

		ON I.BranchId = D.BranchId 
\end_layout

\begin_layout Plain Layout

		WHERE D.Power < I.Power AND I.ToNode IN (SELECT NodeId FROM Node)) -- toNode
 is not a foreign key, so we need to make sure it is a node
\end_layout

\begin_layout Plain Layout

BEGIN
\end_layout

\begin_layout Plain Layout

	UPDATE Node
\end_layout

\begin_layout Plain Layout

-- Increase the power consumption by the difference between the new and
 the past values
\end_layout

\begin_layout Plain Layout

	SET Power = Power - (SELECT D.Power - I.Power
\end_layout

\begin_layout Plain Layout

				FROM Inserted I JOIN Deleted D ON I.BranchId = D.BranchId
\end_layout

\begin_layout Plain Layout

				WHERE I.ToNode = NodeId AND D.Power < I.Power) -- Make sure the node is
 the correct one
\end_layout

\begin_layout Plain Layout

	WHERE NodeId IN (SELECT toNode FROM Inserted)
\end_layout

\begin_layout Plain Layout

END;
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Propagation of power increase from a branch to a distributor
\end_layout

\begin_layout Standard
If a branch connected to a distributor requires more power, propagate the
 change to the distributor.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

CREATE TRIGGER T8_Branch_Distributor ON Branch
\end_layout

\begin_layout Plain Layout

AFTER UPDATE AS
\end_layout

\begin_layout Plain Layout

-- If some branch has increased its power consumption
\end_layout

\begin_layout Plain Layout

IF EXISTS (SELECT * FROM Inserted I JOIN Deleted D 
\end_layout

\begin_layout Plain Layout

		ON I.BranchId = D.BranchId 
\end_layout

\begin_layout Plain Layout

		WHERE D.Power < I.Power AND I.ToNode IN (SELECT NodeId FROM Distributor))
 -- toNode is not a foreign key, so we need to make sure it is a distributor
\end_layout

\begin_layout Plain Layout

BEGIN
\end_layout

\begin_layout Plain Layout

	UPDATE Distributor
\end_layout

\begin_layout Plain Layout

-- Increase the power consumption by the difference between the new and
 the past values
\end_layout

\begin_layout Plain Layout

	SET Power = Power - (SELECT D.Power - I.Power
\end_layout

\begin_layout Plain Layout

				FROM Inserted I JOIN Deleted D ON I.BranchId = D.BranchId
\end_layout

\begin_layout Plain Layout

				WHERE I.ToNode = NodeId AND D.Power < I.Power) -- Make sure the node is
 the correct one
\end_layout

\begin_layout Plain Layout

	WHERE NodeId IN (SELECT BranchIn FROM Inserted)
\end_layout

\begin_layout Plain Layout

END;
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Excess power requested from a distributor
\end_layout

\begin_layout Standard
If the power requested from a distributor exceeds its maximum, rollback
 the entire transaction.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

CREATE TRIGGER T9_Distributor ON Distributor
\end_layout

\begin_layout Plain Layout

AFTER UPDATE AS
\end_layout

\begin_layout Plain Layout

-- If some distributor has increased its power consumption exceeding its
 maximum capacity
\end_layout

\begin_layout Plain Layout

IF EXISTS (SELECT * FROM Inserted I WHERE I.Power > I.MaxPower)
\end_layout

\begin_layout Plain Layout

BEGIN
\end_layout

\begin_layout Plain Layout

	RAISERROR 13000 'Maximum capacity of the distributor exceeded'
\end_layout

\begin_layout Plain Layout

	ROLLBACK
\end_layout

\begin_layout Plain Layout

END;
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Propagate power change from a branch to its wires
\end_layout

\begin_layout Standard
If the power of a branch is changed, distributes the change equally on its
 wires.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

CREATE TRIGGER T10_Branch_Wire ON Branch
\end_layout

\begin_layout Plain Layout

AFTER UPDATE AS
\end_layout

\begin_layout Plain Layout

BEGIN
\end_layout

\begin_layout Plain Layout

	UPDATE Wire
\end_layout

\begin_layout Plain Layout

-- Divide the difference between past and new power among all wires and
 subtract it from every wire
\end_layout

\begin_layout Plain Layout

-- note that this works independently of the sign of the change
\end_layout

\begin_layout Plain Layout

	SET Power = Power - (
\end_layout

\begin_layout Plain Layout

				(SELECT D.Power - I.Power 
\end_layout

\begin_layout Plain Layout

				FROM Inserted I JOIN Deleted D ON I.BranchId = D.BranchId
\end_layout

\begin_layout Plain Layout

				WHERE I.BranchId = Branch)
\end_layout

\begin_layout Plain Layout

				/
\end_layout

\begin_layout Plain Layout

				(SELECT COUNT(*) FROM Wire W JOIN Inserted I ON I.BranchId = W.Branch
\end_layout

\begin_layout Plain Layout

				WHERE W.Branch = Branch)
\end_layout

\begin_layout Plain Layout

				)
\end_layout

\begin_layout Plain Layout

	WHERE Branch IN (SELECT BranchId FROM Inserted)
\end_layout

\begin_layout Plain Layout

END;
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Change wire type if power passess threshold
\end_layout

\begin_layout Standard
If the power on a wire goes above the allowed threshold, change the wire
 type.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

CREATE TRIGGER T11_Wire_Type on Wire
\end_layout

\begin_layout Plain Layout

AFTER INSERT, UPDATE AS
\end_layout

\begin_layout Plain Layout

IF EXISTS (SELECT * FROM Inserted I JOIN WireType WT
\end_layout

\begin_layout Plain Layout

		ON WireType = WireTypeId
\end_layout

\begin_layout Plain Layout

		WHERE I.Power > WT.MaxPower -- If the power overpass the maximum allowed
\end_layout

\begin_layout Plain Layout

			AND EXISTS (SELECT * FROM WireType WT1 WHERE WT1.MaxPower > I.Power)) --
 And there is a wiretype which can accept the higher power
\end_layout

\begin_layout Plain Layout

BEGIN
\end_layout

\begin_layout Plain Layout

	UPDATE Wire
\end_layout

\begin_layout Plain Layout

	SET WireType = (SELECT WireTypeId 
\end_layout

\begin_layout Plain Layout

					FROM WireType WT
\end_layout

\begin_layout Plain Layout

					WHERE WT.MaxPower >= Power AND
\end_layout

\begin_layout Plain Layout

					NOT EXISTS( -- There are no two different types with the same maxPower,
 so we take the first wireType whose maxPower is sufficient
\end_layout

\begin_layout Plain Layout

						SELECT * FROM WireType WT1
\end_layout

\begin_layout Plain Layout

						WHERE WT1.MaxPower < WT.MaxPower AND WT1.MaxPower >= Power))
\end_layout

\begin_layout Plain Layout

	WHERE WireId IN (SELECT WireId FROM INSERTED I JOIN WireType WT ON WireType
 = WireTypeId -- make sure we take the appropriate WireId
\end_layout

\begin_layout Plain Layout

				WHERE I.Power > WT.MaxPower AND 
\end_layout

\begin_layout Plain Layout

					EXISTS (SELECT * FROM WireType WT1 WHERE WT1.MaxPower > I.Power))
\end_layout

\begin_layout Plain Layout

END;
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Add a wire to a branch
\end_layout

\begin_layout Standard
If there is no suitable wire type, add another wire to the branch.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

CREATE TRIGGER T12_Wire on Wire
\end_layout

\begin_layout Plain Layout

AFTER INSERT, UPDATE AS
\end_layout

\begin_layout Plain Layout

IF EXISTS (SELECT * FROM Inserted I JOIN WireType WT
\end_layout

\begin_layout Plain Layout

		ON WireType = WireTypeId 
\end_layout

\begin_layout Plain Layout

		WHERE I.Power > WT.MaxPower
\end_layout

\begin_layout Plain Layout

			AND I.Power > (SELECT MAX(MaxPower) FROM WireType)) -- the requested power
 is greater than the allowed for every wiretype
\end_layout

\begin_layout Plain Layout

BEGIN
\end_layout

\begin_layout Plain Layout

	DECLARE @nextWire char(3), @BranchId char(3), @WireId char(3), @Power real,
 @MaxPower real
\end_layout

\begin_layout Plain Layout

	DECLARE wires_cursor CURSOR FOR
\end_layout

\begin_layout Plain Layout

		SELECT I.WireId, I.BranchId, I.Power, WT.MaxPower
\end_layout

\begin_layout Plain Layout

		FROM Inserted I JOIN WireType WT ON WireType = WireTypeId
\end_layout

\begin_layout Plain Layout

		WHERE I.Power > WT.MaxPower
\end_layout

\begin_layout Plain Layout

			AND I.Power > (SELECT MAX(MaxPower) FROM WireType)
\end_layout

\begin_layout Plain Layout

	OPEN wires_cursor
\end_layout

\begin_layout Plain Layout

	FETCH NEXT FROM wires_cursor INTO @WireId, @BranchId, @Power, @MaxPower
\end_layout

\begin_layout Plain Layout

	WHILE @@FETCH_STATUS = 0
\end_layout

\begin_layout Plain Layout

	BEGIN
\end_layout

\begin_layout Plain Layout

		EXEC @nextWire = nextWireId
\end_layout

\begin_layout Plain Layout

		INSERT INTO Wire (WireId, BranchId, WireType, Power) VALUES (@nextWire,
 @BranchId, 'WT1', @Power-0.8*@MaxPower)
\end_layout

\begin_layout Plain Layout

		FETCH NEXT FROM wires_cursor INTO @WireId, @BranchId, @Power, @MaxPower
\end_layout

\begin_layout Plain Layout

	END
\end_layout

\begin_layout Plain Layout

	CLOSE wires_cursor
\end_layout

\begin_layout Plain Layout

	DEALLOCATE wires_cursor
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	UPDATE Wire 
\end_layout

\begin_layout Plain Layout

	SET Power = (SELECT 0.8*MaxPower FROM WireType WT WHERE WT.WireTypeId = WireType)
\end_layout

\begin_layout Plain Layout

	WHERE Power > (SELECT MAX(MaxPower) FROM WireType)
\end_layout

\begin_layout Plain Layout

END;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Graph Databases
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Relational DBMSs are too rigid for Big Data scenarios, and not the best
 option for storing unstructured data.
 The one-size-fits-all approach is no longer valid in many scenarios and
 RDBMSs are hard to scale for billions of rows, because data structures
 used in RDBMSs are optimized for systems with small amounts of memory.
\end_layout

\begin_layout Standard

\series bold
NoSQL technologies
\series default
 do not use the relational model for storing data nor retrieving it.
 Also, they don't generally have the concept of schema, so fields can be
 added to any record as desired, without control.
 These characteristics provide ease to run on clusters as well as an increased
 scaling capability, with horizontal scalability in mind.
 But these gains are not free: there is a trade-off in which the traditional
 concept of consistency gets harmed.
 For example, ACID (Atomic, Consistent, Isolated, Durable) transactions
 are not fully supported most of the times.
\end_layout

\begin_layout Standard
There are several types of NoSQL databases, such as Key-Value stores, Column
 stores, Document databases,...
 We are going to focus on Graph Databases.
\end_layout

\begin_layout Subsection
CAP theorem
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
The 
\series bold
consistency 
\series default
of a database is fullfilled when all updates happen equally for all users
 of the database.
\end_layout

\begin_layout Definition
The 
\series bold
availability
\series default
 guarantees that every request receives a response, whether it succeeded
 or failed.
\end_layout

\begin_layout Definition
The 
\series bold
partition tolerance
\series default
 means that the system is able to operate despite arbitrary message lost
 or failure of part of the system.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A database has, ideally, this three properties fullfilled.
 But the CAP theorem ensures that this is impossible:
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Theorem

\series bold
CAP Theorem
\end_layout

\begin_layout Theorem
A distributed data system cannot guarantee consistency (C), availability
 (A) and partition tolerance (P), but only any combination of two of them.
\end_layout

\end_inset


\end_layout

\begin_layout Remark
If the system needs to be distributed, then partition tolerance is a must.
 So, in practice, there is a decision to choose between fullfilling consistency
 or availability for distributed systems.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
Nonetheless, even the perfect form of the three properties cannot be guaranteed
 at once, it is possible to provide fairly good levels of the one that is
 not optimal.
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Definition
The 
\series bold
eventual consistency assumption
\series default
: in the absence of new writes, consistency will be acheived eventually,
 and all replicas that are responsible for a data item will agree on the
 same version and return the last updated value.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
With fewer replicas in the system, R/W operations complete more quickly,
 improving latency.
\end_layout

\begin_layout Subsection
Graph DB model: graphs
\end_layout

\begin_layout Standard
In graph databases, the 
\series bold
data and/or the schema
\series default
 are represented by graphs, or by data structures that generalize the notion
 of graph: hypergraphs.
\end_layout

\begin_layout Standard
The 
\series bold
integrity constraints
\series default
 enforce data consistency.
 Constraints can be grouped in: schema-instance consistency, identity and
 referencial integrity, and functional and inclusion dependencies.
\end_layout

\begin_layout Standard
The 
\series bold
data manipulation
\series default
 is expressed by graph transfromations, or by operations whose main primitives
 are on graph features, like paths, neighborhoods, subgraphs, connectivity
 and graph statistics.
\end_layout

\begin_layout Subsection
The Resource Description Framework (RDF) Model
\end_layout

\begin_layout Standard
RDF allows to express facts, such as 
\emph on
'Ana is the mother of Julia.
\emph default
', but we'd like to be able to express more generic knowledge, like 
\emph on
'If somebody has a daughter, then that person is a parent.'
\emph default
.
 This kind of knowledge is called 
\series bold
schema knowledge
\series default
.
 The RDF schema allows us to do some schema knowledge modeling, and the
 Ontology Web Language (OWL) gives even more expressivity.
\end_layout

\begin_layout Standard
A 
\series bold
class
\series default
 is a set of things or resources.
 In RDF, everything is a 
\series bold
resource
\series default
, that belongs to a class (or several classes).
 The classes can be arranged in 
\series bold
hierarchies
\series default
.
 Every resource is a member of the class 
\family sans
rdfs:Class
\family default
.
\end_layout

\begin_layout Example
A hierarchy of classes in RDF:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Graphics
	filename rdf_0.png
	scale 60

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
The different resources are labelled with:
\end_layout

\begin_layout Itemize

\family typewriter
rdfs:Resource
\family default
: class of all resources.
\end_layout

\begin_layout Itemize

\family typewriter
rdf:Property
\family default
: class of all properties.
\end_layout

\begin_layout Itemize

\family typewriter
rdfs:XMLLiteral
\family default
: class of XML resources.
\end_layout

\begin_layout Itemize

\family typewriter
rdfs:Literal
\family default
: each datatype is a subclass.
\end_layout

\begin_layout Itemize

\family typewriter
rdfs:Bag, rdf:Alt, rdf:Seq, rdfs:Container, rdf:List, rdf:nil, rdfs:ContainerMem
bershipProperty.
\end_layout

\begin_layout Itemize

\family typewriter
rdfs:Datatype
\family default
: class of all datatypes.
\end_layout

\begin_layout Itemize

\family typewriter
rdfs:Statement
\family default
.
\end_layout

\begin_layout Standard
In RDF, there exists implicit knowledge, which can be inferred using 
\series bold
deduction
\series default
.
 This knowledge doesn't need to be stated explicitly: which statements are
 logical consequences from others is governed by the formal semantics.
\end_layout

\begin_layout Example
If a RDF document contains 
\emph on
'u rdf:type ex:Textbook'
\emph default
 and 
\emph on
'ex:Textbook rdfs:subClassOf ex:Book'
\emph default
, then it is deduced that 
\emph on
'u rdf:type ex:Book'
\emph default
.
\end_layout

\begin_layout Standard
As can be seen, RDF are usually stored in 
\series bold
triple stores
\series default
 or 
\series bold
quad stores
\series default
, which are a relational DB.
 This means that it is usually not implemented natively as a graph database,
 which makes it harder to do inference.
 It is more usually used as a metadata storage.
\end_layout

\begin_layout Subsection
The property graph data model
\end_layout

\begin_layout Standard
This model is simpler: in this case, the model is a graph, where nodes and
 edges are annotated with properties.
 It is schema-less, meaning there is not an underlying schema to which the
 data has to adhere.
 Inference is not performed.
\end_layout

\begin_layout Standard
There are several types of relationships supported by graph databases:
\end_layout

\begin_layout Itemize

\series bold
Attributes
\series default
: properties that can be uni- or multi- valued.
\end_layout

\begin_layout Itemize

\series bold
Entities
\series default
: groups of real-world objects.
\end_layout

\begin_layout Itemize

\series bold
Neighborhood relations
\series default
: structures to represents neighborhoods of an entity.
\end_layout

\begin_layout Itemize

\series bold
Standard abstractions
\series default
: part-of, composed-by, n-ary associations.
\end_layout

\begin_layout Itemize

\series bold
Derivation and inheritance
\series default
: subclasses and superclasses, relations of instantiations.
\end_layout

\begin_layout Itemize

\series bold
Nested relations
\series default
: recursively specified relations.
\end_layout

\begin_layout Standard
The abstract data type used is a 
\series bold
graph with properties
\series default
, which is a 4-tuple 
\begin_inset Formula $G=\left(V,E,\Sigma,L\right)$
\end_inset

 such that:
\end_layout

\begin_layout Itemize
\begin_inset Formula $V$
\end_inset

 is a finite set of nodes.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\Sigma$
\end_inset

 is a set of labels.
\end_layout

\begin_layout Itemize
\begin_inset Formula $E\subset V\times V$
\end_inset

 is a set of edges representing labelled binary relationships between elements
 in 
\begin_inset Formula $V$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $L$
\end_inset

 is a function, 
\begin_inset Formula $L:V\times V\rightarrow2^{\Sigma}$
\end_inset

, meaning that each edge can by annotated with zero or more labels from
 
\begin_inset Formula $\Sigma$
\end_inset

.
\end_layout

\begin_layout Standard
The basic operations defined over a graph are:
\end_layout

\begin_layout Itemize
\begin_inset Formula $AddNode\left(G,x\right)$
\end_inset

: adds node 
\begin_inset Formula $x$
\end_inset

 to 
\begin_inset Formula $G$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $DeleteNode\left(G,x\right)$
\end_inset

: deletes 
\begin_inset Formula $x$
\end_inset

 from 
\begin_inset Formula $G$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $Adjacent\left(G,x,y\right)$
\end_inset

: tests if there is an edge from 
\begin_inset Formula $x$
\end_inset

 to 
\begin_inset Formula $y$
\end_inset

 in 
\begin_inset Formula $G$
\end_inset

, i.e., if 
\begin_inset Formula $\left(x,y\right)\in E$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $Neighbors\left(G,x\right)$
\end_inset

: returns all nodes 
\begin_inset Formula $y$
\end_inset

 such that 
\begin_inset Formula $\left(x,y\right)\in E$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $AdjacentEdges\left(G,x,y\right)$
\end_inset

: returns the set of lables of edges going from 
\begin_inset Formula $x$
\end_inset

 to 
\begin_inset Formula $y$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $Add\left(G,x,y,l\right)$
\end_inset

: adds an edge between 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 with label 
\begin_inset Formula $l$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $Delete\left(G,x,y,l\right)$
\end_inset

: deletes and edge between 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 with label 
\begin_inset Formula $l$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $Reach\left(G,x,y\right)$
\end_inset

: tests if there is a path from 
\begin_inset Formula $x$
\end_inset

 to 
\begin_inset Formula $y$
\end_inset

.
 A 
\series bold
path
\series default
 between 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 is a subset of nodes 
\begin_inset Formula $z_{1},...,z_{n}$
\end_inset

 such that 
\begin_inset Formula $\left(x,z_{1}\right),\left(z_{n},y\right)\in E$
\end_inset

 and 
\begin_inset Formula $\left(z_{i},z_{i+1}\right)\in E$
\end_inset

 for all 
\begin_inset Formula $i=1,...,n-1$
\end_inset

.
 The 
\series bold
length
\series default
 of the path is how many edges there are from 
\begin_inset Formula $x$
\end_inset

 to 
\begin_inset Formula $y$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $Path\left(G,x,y\right)$
\end_inset

: return a shorthest path from 
\begin_inset Formula $x$
\end_inset

 to 
\begin_inset Formula $y$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $2-hop\left(G,x\right)$
\end_inset

: return the set of nodes that can be reached from 
\begin_inset Formula $x$
\end_inset

 using paths of length 2.
\end_layout

\begin_layout Itemize
\begin_inset Formula $n-hop\left(G,x\right)$
\end_inset

: returns the set of ndoes that can be reached from 
\begin_inset Formula $x$
\end_inset

 using paths of length 
\begin_inset Formula $n$
\end_inset

.
\end_layout

\begin_layout Standard
The notion of graph can be generalized by that of 
\series bold
hypergraph
\series default
, which is a pair 
\begin_inset Formula $H=\left(V,E\right)$
\end_inset

, where 
\begin_inset Formula $V$
\end_inset

 is a set of nodes, and 
\begin_inset Formula $E\subset2^{V}$
\end_inset

 is a set of non-empty subsets of 
\begin_inset Formula $V$
\end_inset

, called 
\series bold
hyperedges
\series default
.
 If 
\begin_inset Formula $V=\left\{ v_{1},...,v_{n}\right\} $
\end_inset

 and 
\begin_inset Formula $E=\left\{ e_{1},...,e_{m}\right\} $
\end_inset

, we can define the 
\series bold
incidence matrix
\series default
 of 
\begin_inset Formula $H$
\end_inset

 as the matrix 
\begin_inset Formula $A=\left(a_{ij}\right)_{n\times m}$
\end_inset

 where
\begin_inset Formula 
\[
a_{ij}=\begin{cases}
1 & if\ v_{i}\in e_{j}\\
0 & otherwise
\end{cases}
\]

\end_inset

 In this case, this is an 
\series bold
undirected hypergraph
\series default
.
 A 
\series bold
directed hypergraph
\series default
 is defined similarly by 
\begin_inset Formula $H=\left(V,E\right)$
\end_inset

 where in this case 
\begin_inset Formula $E\subset2^{V}\times2^{V}$
\end_inset

, meaning that the nodes in the left set are connected to the nodes of the
 right one.
\end_layout

\begin_layout Subsubsection
Implementation: adjacency list
\end_layout

\begin_layout Standard
In an adjacency list, we maintain an array with as many cells as there are
 nodes in the graph, and:
\end_layout

\begin_layout Itemize
For each node, maintain a list of neighbors.
\end_layout

\begin_layout Itemize
If the graph is directed, the list is only containing outgoing nodes.
\end_layout

\begin_layout Standard
This way it is very cheap to obtain neighbors of a node, but it is not suitable
 for checking if there is an edge between two nodes.
\end_layout

\begin_layout Example
This graph
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename graph_0.png
	scale 60

\end_inset


\end_layout

\end_deeper
\begin_layout Example
Is modelled with the following adjacency list:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
v1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
v2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{(v1,{L2}),(v3,{L4})}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
v3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
v4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{(v1,{L1})}
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Subsubsection
Implementation: incidence list
\end_layout

\begin_layout Standard
In this case, we maintain two arrays, one with as many cells as nodes, and
 another one with as many different edges there are in the graph:
\end_layout

\begin_layout Itemize
Vertices and edges are stored as records of objects.
\end_layout

\begin_layout Itemize
Each vertex stores incident edges, labeled as source if the edge goes out,
 or destination if it goes in.
\end_layout

\begin_layout Itemize
Each edge stores incident nodes.
\end_layout

\begin_layout Example
Now, the graph of the previous example is modeled as:
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
v1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{(dest,L2),(dest,L1)}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
v2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{(source,L2),(source,L3)}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
v3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{(dest,L3)}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
v4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{(source,L1)}
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
L1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(V4,V1)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
L2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(V2,V1)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
L3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(V2,V3)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Some properties:
\end_layout

\begin_layout Itemize
Storage is 
\begin_inset Formula $O\left(\left|V\right|+\left|E\right|+\left|L\right|\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $Adjacent\left(G,x,y\right)$
\end_inset

 is 
\begin_inset Formula $O\left(\left|E\right|\right)$
\end_inset

, we have to check at most all edges.
\end_layout

\begin_layout Itemize
\begin_inset Formula $Neighbors\left(G,x\right)$
\end_inset

 is 
\begin_inset Formula $O\left(\left|E\right|\right)$
\end_inset

, we go to node 
\begin_inset Formula $x$
\end_inset

 and for each edge marked as source, we visit it and return the correspondant
 destination.
 At most 
\begin_inset Formula $E$
\end_inset

 checks.
\end_layout

\begin_layout Itemize
\begin_inset Formula $AdjacentEdges\left(G,x,y\right)$
\end_inset

 is again 
\begin_inset Formula $O\left(\left|E\right|\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $Add\left(G,x,y,l\right)$
\end_inset

 is 
\begin_inset Formula $O\left(\left|E\right|\right)$
\end_inset

, as well as delete 
\begin_inset Formula $Delete\left(G,x,y,l\right)$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Implementation: adjacency matrix
\end_layout

\begin_layout Standard
In this case, we maintain a matrix of size 
\begin_inset Formula $n\times n$
\end_inset

, where 
\begin_inset Formula $n$
\end_inset

 is the number of nodes:
\end_layout

\begin_layout Itemize
It is a bidimensional graph representation.
\end_layout

\begin_layout Itemize
Rows represents source nodes.
\end_layout

\begin_layout Itemize
Columnds represent destination nodes.
\end_layout

\begin_layout Itemize
Each non-null entry represents that there is an edge from the source node
 to the destination node.
\end_layout

\begin_layout Example
In this case, the example is modelled as
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
v1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
v2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
v3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
v4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
v1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
v2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{L2}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{L3}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
v3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
v4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{L1}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Properties:
\end_layout

\begin_layout Itemize
The storage is 
\begin_inset Formula $O\left(\left|V\right|\times\left|V\right|\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $Adjacent\left(G,x,y\right)$
\end_inset

 is 
\begin_inset Formula $O\left(1\right)$
\end_inset

, we have to check cell 
\begin_inset Formula $\left(x,y\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
Compute the out-degree of a node is 
\begin_inset Formula $O\left(\left|V\right|\right)$
\end_inset

, we have to sum its row.
\end_layout

\begin_layout Itemize
For the in-degree it is also 
\begin_inset Formula $O\left(\left|V\right|\right)$
\end_inset

, we have to sum its column.
\end_layout

\begin_layout Itemize
Adding an edge between two nodes is 
\begin_inset Formula $O\left(1\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
Compute all paths of length 4 between any pair of nodes is 
\begin_inset Formula $O\left(\left|V\right|^{4}\right)$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Implementation: incidence matrix
\end_layout

\begin_layout Standard
In this case, we store a matrix of size 
\begin_inset Formula $n\times m$
\end_inset

, where 
\begin_inset Formula $n$
\end_inset

 is the number of nodes and 
\begin_inset Formula $m$
\end_inset

 is the number of edges:
\end_layout

\begin_layout Itemize
It is also a bidimensional graph representation.
\end_layout

\begin_layout Itemize
Rows represent nodes.
\end_layout

\begin_layout Itemize
Columns represent edges.
\end_layout

\begin_layout Itemize
A non-null entry represents that the node is incident to the edge, and in
 which mode (source or destination).
\end_layout

\begin_layout Example
The example is represented now as
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
L1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
L2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
L3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
v1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
dest
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
dest
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
v2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
source
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
source
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
v3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
dest
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
v4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
source
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Properties:
\end_layout

\begin_layout Itemize
The storage is 
\begin_inset Formula $O\left(\left|V\right|\times\left|E\right|\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $Adjacent\left(G,x,y\right)$
\end_inset

 is 
\begin_inset Formula $O\left(\left|E\right|\right)$
\end_inset


\end_layout

\begin_layout Itemize
Neighbors
\begin_inset Formula $\left(G,x\right)$
\end_inset

 is 
\begin_inset Formula $O\left(\left|V\right|\times\left|E\right|\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $AdjacentEdges\left(G,x,y\right)$
\end_inset

 is 
\begin_inset Formula $O\left(\left|E\right|\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
Adding or deleting an edge between two nodes is 
\begin_inset Formula $O\left(\left|V\right|\right)$
\end_inset

.
\end_layout

\begin_layout Section
Neo4j
\end_layout

\begin_layout Standard
Neo4j is an open source graph DB system implemented in Java which uses a
 labelled attributed multigraph as data model.
 Nodes and edges can have properties, and there are no restrictions on the
 amount of edges between nodes.
 Loops are allowes and there are different types of traversal strategies
 defined.
\end_layout

\begin_layout Standard
It provides APIs for Java and Python and it is embeddable or server-full.
 It provides full ACID transactions.
\end_layout

\begin_layout Standard
Neo4j provides a native graph processing and storage, characterized by 
\series bold
index-free adjacency
\series default
, meaning that each node keeps direct reference to adjacent nodes, acting
 as a local index and making query time independent from graph size for
 many kinds of queries.
\end_layout

\begin_layout Standard
Another good property is that the joins are precomputed in the form of stored
 relationships.
\end_layout

\begin_layout Standard
It uses a high level query language called 
\series bold
Cypher
\series default
.
\end_layout

\begin_layout Subsection
File storage
\end_layout

\begin_layout Standard
Graphs are stored in files.
 There are three different objects:
\end_layout

\begin_layout Itemize

\series bold
Nodes
\series default
: they have a fixed length of 9 B, to make search performant: finding a
 node is 
\begin_inset Formula $O\left(1\right)$
\end_inset

.
 
\end_layout

\begin_deeper
\begin_layout Itemize
Its first byte is an 
\series bold
in-use
\series default
 flag.
\end_layout

\begin_layout Itemize
Then there are 4 B indicating the address of its first relationship.
\end_layout

\begin_layout Itemize
The final 4 B indicate the address of its first property.
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="9">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Node
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
inUse
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
nextRel
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
nextProp
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Relationships
\series default
: they have a fixed length of 33 B.
\end_layout

\begin_deeper
\begin_layout Itemize
Its first byte is an in-use flag.
\end_layout

\begin_layout Itemize
It is organized as double linked list.
\end_layout

\begin_layout Itemize
Each record contians the IDs of the two nodes in the relationship (4B each).
\end_layout

\begin_layout Itemize
There is a pointer to the relationship type (4 B).
\end_layout

\begin_layout Itemize
For each node, there is a pointer to the previous and next relationship
 records (4 B x 2 each).
\end_layout

\begin_layout Itemize
Finally, a pointer to the next property (4 B).
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="33">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Relationship
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
inUse
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
firstNode
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
secondNode
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
relType
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
firstPrevRel
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
firstNextRel
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
secPrevRel
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
secNextRel
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
nextProp
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Properties
\series default
: they have a fixed length of 32 B divided in blocks og 8 B.
\end_layout

\begin_deeper
\begin_layout Itemize
It includes the ID of the next property in the properties chain, which is
 thus a single linked list.
\end_layout

\begin_layout Itemize
Each property record holds the property type, a pointer to the property
 index file, holding the property name and a value or a pointer to a dynamic
 structure for long strings or arrays.
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="32">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Property
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
propType
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
propIdxFile
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
value
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
nextProp
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Subsubsection
Caching
\end_layout

\begin_layout Standard
Neo4j uses a cache to divide each store into regions, called 
\series bold
pages
\series default
.
 The cache stores a fixed number of pages per file, which are replaces using
 a Least Frequently Used strategy.
\end_layout

\begin_layout Standard
The cache is optimized for reading, and stores object representationsof
 nodes, relationships, and properties, for fast path traversal.
 In this case, node objects contain properties and references to relationships,
 while relationships contain only their properties.
 This is the opposite of what happens in disk storage, where most informaiton
 is in the relationship records.
\end_layout

\begin_layout Subsection
Cypher
\end_layout

\begin_layout Standard
Cypher is the high level query language used by Neo4j for creating nodes,
 updating/deleting information and querying graphs in a graph database.
\end_layout

\begin_layout Standard
Its functioning is different from that of the relational model.
 In the relational model, we first create the structure of the database,
 and then we store tuples, which must be conformant to the structure.
 The foreign keys are defined at the structural level.
 In Neo4j, nodes and edges are directly created, with their properties,
 labels and types as structural information, but no schema is explicitly
 defined.
 The topology of the graph can be thought as analogous to the foreign key
 in the relational model, but defined at the instance level.
\end_layout

\begin_layout Subsubsection
Nodes
\end_layout

\begin_layout Standard
A node is of the form
\begin_inset Formula 
\[
\left(v\ :l_{1}:...:l_{n}\left\{ P_{1}:v_{1},...,P_{k}:v_{k}\right\} \right)
\]

\end_inset

 where 
\begin_inset Formula $v$
\end_inset

 is the node variable, which identifies the node in an expression, 
\begin_inset Formula $:l_{1}:...:l_{n}$
\end_inset

 is a list of 
\begin_inset Formula $n$
\end_inset

 labels associated with the node, and 
\begin_inset Formula $\left\{ P_{1}:v_{1},...,P_{k}:v_{k}\right\} $
\end_inset

 is a list of 
\begin_inset Formula $k$
\end_inset

 properties associated with the node, and their respective assigned values.
 
\begin_inset Formula $P_{i}$
\end_inset

 is the name of the property, 
\begin_inset Formula $v_{i}$
\end_inset

 is the value.
\end_layout

\begin_layout Standard
To create an empty node:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

CREATE (v)
\end_layout

\begin_layout Plain Layout

RETURN v;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The ID is assigned internally, with a different number each time.
 It can be reused by the system but should not be used in applications:
 it should be considered an internal value to the system.
 RETURN is used to display the node:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado3.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
To create a node with two labels:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

CREATE (v :l1:l2)
\end_layout

\begin_layout Plain Layout

RETURN v;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado4.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
To create a node with one label and 3 properties:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

CREATE (v :l1 {P1:'v1', P2:'v2', P3:['v3_1','v3_2']})
\end_layout

\begin_layout Plain Layout

RETURN v;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado5.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
A 
\series bold
query
\series default
 in Cypher is basically a pattern, which will be fullfilled solving the
 associated pattern-matching problem.
\end_layout

\begin_layout Standard
If we want to add a new label to all nodes previously created:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

MATCH(n)
\end_layout

\begin_layout Plain Layout

SET n :newL
\end_layout

\begin_layout Plain Layout

RETURN n;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado6.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
To delete a label from those nodes with a certain label:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

MATCH(n :matchL)
\end_layout

\begin_layout Plain Layout

REMOVE n :delL
\end_layout

\begin_layout Plain Layout

RETURN n;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A similar thing can be done with properties, which are referred to as node.proper
tyName:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

MATCH(n :matchL)
\end_layout

\begin_layout Plain Layout

REMOVE n.propName1, n.propName2
\end_layout

\begin_layout Plain Layout

RETURN n;
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Edges
\end_layout

\begin_layout Standard
An edge has the form
\begin_inset Formula 
\[
\left(n\right)-\left[e\ :Type\left\{ P_{1}:v_{1},...,P_{k}:v_{k}\right\} \right]->\left(v\right)
\]

\end_inset

 where 
\begin_inset Formula $n$
\end_inset

 is the source node and 
\begin_inset Formula $v$
\end_inset

 is the destination node.
 The edge is defined inside the brackets 
\begin_inset Formula $\left[\right]$
\end_inset

.
 It can also be defined of the form 
\begin_inset Formula $\left(n\right)<-\left[\right]-\left(v\right)$
\end_inset

.
 
\begin_inset Formula $e$
\end_inset

 identifies the edge and 
\begin_inset Formula $Type$
\end_inset

 is a mandatory field prefixed by :.
 Finally, we have again a list of 
\begin_inset Formula $k$
\end_inset

 properties and their values.
\end_layout

\begin_layout Standard
Imagine we have 3 employees and want to create the relationship that one
 of them is the manager of the other two and a date as property.
 We can do that with:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=SQL"
inline false
status open

\begin_layout Plain Layout

MATCH(n1 :Employee {Name:'1'}),(n2 :Employee {Name:'m'}),(n3 :Employee {Name:'2'
})
\end_layout

\begin_layout Plain Layout

CREATE (n1)<-[e1:manager_of {From:'Dec22'}]-(n2)-[e2:manager_of {From:'Jan23'}]-
>(n3)
\end_layout

\begin_layout Plain Layout

RETURN e1,e2;
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Queries
\end_layout

\begin_layout Standard
As we have said, Cypher is a high level query language based on pattern
 matching.
 It queries graphs expressing informational or topological conditions.
\end_layout

\begin_layout Itemize
MATCH: expresses a pattern that Neo4j tries to match.
\end_layout

\begin_layout Itemize
OPTIONAL MATCH: is like an outer join, i.e., if it does not find a match,
 puts null.
\end_layout

\begin_layout Itemize
WHERE: it must go together with a MATCH or OPTIONAL MATCH expression.
 No order can be assumed for the evaluation of the conditions in the clause,
 Neo4j will decide.
\end_layout

\begin_layout Itemize
RETURN: the evaluation produces subgraphs, and any portion of the match
 can be returned.
\end_layout

\begin_layout Itemize
RETURN DISTINCT: eliminates duplicates.
\end_layout

\begin_layout Itemize
ORDER BY: orders the results with some condition.
\end_layout

\begin_layout Itemize
LIMIT: returns only part of the result.
 Unless ORDER BY is used, no assumptions can be made about the discarded
 results.
\end_layout

\begin_layout Itemize
SKIP: skips the first results.
 Unless ORDER BY is used, no assumptions can be made about the discarded
 results.
\end_layout

\begin_layout Standard
In addition:
\end_layout

\begin_layout Enumerate
If we don't need to make reference to a node, we can use () with no variable
 inside.
\end_layout

\begin_layout Enumerate
If we don't need to refer to an edge, we can omit it, like (n1)- ->(n2).
\end_layout

\begin_layout Enumerate
If we don't need to consider the direction of the edge, we can use - -.
\end_layout

\begin_layout Enumerate
If a pattern matches more than one label, we can write the OR condition
 as | inside the pattern.
 For example, (n :l1|:l2) matches nodes with label l1 or label l2.
\end_layout

\begin_layout Enumerate
To express a path of any length, use [*].
 For a fixed length m use [*m].
\end_layout

\begin_layout Enumerate
To indicate boundaries to the length of a path, minimum n and maximum m,
 use [*n..m].
 To only limit one end use [*n..], [*..m].
\end_layout

\begin_layout Example
A page X gets a score computed as the sum of all votes given by the pages
 that references it.
 If a page Z references a page X, Z gives X a normalized vote computed as
 the inverse of the number of pages references by Z.
 To prevent votes of self-referencing pages, if Z references X and X references
 Z, Z gives 0 votes to X.
\end_layout

\begin_layout Example
We are asked to compute the page rank for each web page.
 One possible solution is:
\end_layout

\begin_layout Example
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (p)-->(r)
\end_layout

\begin_layout Plain Layout

WITH p, 1/count(r) AS vote
\end_layout

\begin_layout Plain Layout

MATCH (p)-->(x)
\end_layout

\begin_layout Plain Layout

WHERE NOT ((x)-->(p))
\end_layout

\begin_layout Plain Layout

RETURN x, SUM(vote) AS Rank
\end_layout

\begin_layout Plain Layout

ORDER BY x.url
\end_layout

\end_inset


\end_layout

\begin_layout Example
The first MATCH-WITH computes, for each node, the inverse of the number
 of outgoing edges, and passes this number on to the next clause.
 Now, for each of these p nodes, we look for paths of length 1 where no
 reciprocity exists.
\end_layout

\begin_layout Example
Another solution uses COLLECT:
\end_layout

\begin_layout Example
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MATCH (p)-->(r)
\end_layout

\begin_layout Plain Layout

WITH p, 1/count(r) AS vote
\end_layout

\begin_layout Plain Layout

MATCH (p)-->(x)
\end_layout

\begin_layout Plain Layout

WHERE NOT ((x)-->(p))
\end_layout

\begin_layout Plain Layout

RETURN x.url, COLLECT(p.url), SUM(vote) AS rank
\end_layout

\begin_layout Plain Layout

ORDER BY x.url
\end_layout

\end_inset


\end_layout

\begin_layout Example
In this case, we are using the COLLECT to get the urls that points to x,
 but x does not point to them, in addition to just computing the value.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Temporal Databases
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Section
Time Ontology
\end_layout

\begin_layout Section
Temporal Conceptual Modeling
\end_layout

\begin_layout Section
Manipulating Temporal Databases with SQL-92
\end_layout

\begin_layout Section
Temporal Support in SQL 2011
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Spatial Databases
\end_layout

\begin_layout Section
Georeferences and Coordinate Systems
\end_layout

\begin_layout Section
Conceptual Modelling for Spatial Databases
\end_layout

\begin_layout Section
Logical Modelling for Spatial Databases
\end_layout

\begin_layout Section
SQL/MM
\end_layout

\begin_layout Section
Representative Systems
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintCited"
bibfiles "advDB_bib"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
